<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hui&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="六一">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" class="post-title-link" itemprop="url">Jenkins Blue Ocean</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:42:57 / 修改时间：21:42:02" itemprop="dateCreated datePublished" datetime="2025-09-11T20:42:57+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DevOps/" itemprop="url" rel="index"><span itemprop="name">DevOps</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DevOps/Jenkins/" itemprop="url" rel="index"><span itemprop="name">Jenkins</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Blue-Ocean-插件的主要功能"><a href="#Blue-Ocean-插件的主要功能" class="headerlink" title="Blue Ocean 插件的主要功能"></a>Blue Ocean 插件的主要功能</h3><ol>
<li><p><strong>直观的流水线可视化 (Pipeline Visualization)：</strong></p>
<ul>
<li><strong>图形化流水线显示：</strong> 将复杂的 Jenkins Declarative Pipeline 转换为清晰、易懂的图形界面，展示每个阶段 (Stage) 和步骤 (Step) 的执行顺序和状态。</li>
<li><strong>实时进度更新：</strong> 流水线运行时，实时高亮显示当前正在执行的阶段和步骤，让用户一眼就能看出流水线进行到哪里。</li>
<li><strong>历史执行概览：</strong> 清晰地展示每次流水线执行的历史记录，包括成功、失败、不稳定等状态，以及每次执行的时长。</li>
</ul>
</li>
<li><p><strong>增强的日志查看和调试 (Enhanced Log Viewing &amp; Debugging)：</strong></p>
<ul>
<li><strong>按阶段&#x2F;步骤过滤日志：</strong> 用户可以直接点击流水线图中的某个阶段或步骤，只查看该部分相关的日志，大大简化了问题排查。</li>
<li><strong>高亮错误和警告：</strong> 自动识别并高亮日志中的错误或警告信息，帮助用户快速定位问题根源。</li>
<li><strong>更友好的日志下载：</strong> 提供便捷的日志下载选项。</li>
</ul>
</li>
<li><p><strong>多分支流水线的优化支持 (Optimized Multibranch Pipeline Support)：</strong></p>
<ul>
<li><strong>分支概览：</strong> 提供一个简洁的视图，显示项目下所有分支的最新构建状态。</li>
<li><strong>Pull Request&#x2F;Merge Request 友好：</strong> 特别优化了对 SCM (如 GitHub, GitLab) 的 Pull Request 或 Merge Request 的支持，可以直接看到每个 PR 的 CI 状态和相关流水线。</li>
</ul>
</li>
<li><p><strong>简化的流水线创建和编辑 (Simplified Pipeline Creation &amp; Editing)：</strong></p>
<ul>
<li><strong>引导式创建：</strong> 提供引导式的项目创建流程，帮助用户选择 SCM 源并自动扫描 <code>Jenkinsfile</code>。</li>
<li><strong>Pipeline Editor (Experimental&#x2F;Limited)：</strong> 曾经尝试提供一个图形化的流水线编辑器，允许用户通过拖拽和配置来构建 <code>Jenkinsfile</code>。虽然这个功能在后续版本中被移除或不再是主要卖点（因为直接编写 <code>Jenkinsfile</code> 更符合“配置即代码”的理念），但它代表了 Blue Ocean 简化配置的尝试。</li>
</ul>
</li>
<li><p><strong>改进的作业历史和详情 (Improved Job History &amp; Details)：</strong></p>
<ul>
<li><strong>聚合视图：</strong> 将所有分支和 PR 的构建历史统一展示在项目视图下，便于总览。</li>
<li><strong>快速导航：</strong> 在构建历史中可以快速跳转到特定构建的流水线视图和日志。</li>
</ul>
</li>
<li><p><strong>更好的通知和反馈：</strong></p>
<ul>
<li>虽然不是 Blue Ocean 独有，但其清晰的界面使得集成外部通知（如 Slack, Email）后的反馈更加直观。Blue Ocean 本身也提供了更好的构建状态概览。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Blue-Ocean-插件的典型使用场景"><a href="#Blue-Ocean-插件的典型使用场景" class="headerlink" title="Blue Ocean 插件的典型使用场景"></a>Blue Ocean 插件的典型使用场景</h3><ol>
<li><p><strong>新团队或新手入门 Jenkins：</strong></p>
<ul>
<li><strong>场景：</strong> 团队刚开始使用 Jenkins Pipeline，对 <code>Jenkinsfile</code> 和流水线概念不熟悉。</li>
<li><strong>作用：</strong> Blue Ocean 的直观可视化能够帮助他们快速理解 CI&#x2F;CD 流程的各个阶段如何协同工作，降低学习曲线。</li>
</ul>
</li>
<li><p><strong>复杂流水线的管理和排查：</strong></p>
<ul>
<li><strong>场景：</strong> 您的 CI&#x2F;CD 流水线包含多个阶段（构建、测试、部署、扫描等），每个阶段又包含多个步骤，当构建失败时，很难从纯文本日志中快速定位问题。</li>
<li><strong>作用：</strong> Blue Ocean 的图形化界面能快速指出哪个阶段失败了，点击失败的阶段直接跳转到相关日志，并高亮错误，极大提高了问题排查效率。</li>
</ul>
</li>
<li><p><strong>多分支开发模型的团队 (GitFlow, GitHub Flow)：</strong></p>
<ul>
<li><strong>场景：</strong> 团队使用 GitFlow 或类似的多分支开发策略，有大量的特性分支、修复分支和 Pull Request 存在。需要快速查看每个分支或 PR 的 CI 状态。</li>
<li><strong>作用：</strong> Blue Ocean 提供清晰的分支概览和 Pull Request 视图，让开发者一眼就能看到哪个分支的最新提交通过了 CI，哪个 PR 需要关注。</li>
</ul>
</li>
<li><p><strong>向非技术人员展示 CI&#x2F;CD 流程：</strong></p>
<ul>
<li><strong>场景：</strong> 您需要向产品经理、项目经理或业务方解释您的软件发布流程。</li>
<li><strong>作用：</strong> Blue Ocean 简洁、美观的流水线图解非技术人员也能轻松理解，帮助他们了解软件从代码到生产的每一步。</li>
</ul>
</li>
<li><p><strong>监控和演示 CI&#x2F;CD 流程：</strong></p>
<ul>
<li><strong>场景：</strong> 在团队内部会议、演示或大屏幕监控墙上展示 CI&#x2F;CD 流程的运行情况。</li>
<li><strong>作用：</strong> Blue Ocean 提供的实时更新和图形化显示非常适合作为监控面板或演示工具，展现 CI&#x2F;CD 自动化带来的价值。</li>
</ul>
</li>
<li><p><strong>追求现代化用户体验的团队：</strong></p>
<ul>
<li><strong>场景：</strong> 厌倦了 Jenkins 经典 UI 的老旧界面，希望获得更现代、响应式的用户界面体验。</li>
<li><strong>作用：</strong> Blue Ocean 提供了完全重新设计的 UI，符合现代 Web 应用的设计趋势，提升了日常使用的舒适度。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>尽管 Jenkins 本身提供了强大的 CI&#x2F;CD 功能，但其经典 UI 在视觉呈现和用户体验上有所欠缺。<strong>Blue Ocean 插件的核心价值在于它将 Jenkins Pipeine 的复杂性抽象化，以一种直观、易于理解的方式呈现给用户。</strong>它不仅提升了开发和运维团队的工作效率，也使得整个组织对 CI&#x2F;CD 流程的健康状况有了更清晰的感知。对于任何积极采用 Jenkins Pipeline 进行软件开发的团队来说，Blue Ocean 几乎是一个必不可少的插件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/jenkins-jenkinsfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/jenkins-jenkinsfile/" class="post-title-link" itemprop="url">Jenkins Jenkinsfile</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:40:44 / 修改时间：21:42:19" itemprop="dateCreated datePublished" datetime="2025-09-11T20:40:44+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DevOps/" itemprop="url" rel="index"><span itemprop="name">DevOps</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DevOps/Jenkins/" itemprop="url" rel="index"><span itemprop="name">Jenkins</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Jenkinsfile-的基本类型"><a href="#Jenkinsfile-的基本类型" class="headerlink" title="Jenkinsfile 的基本类型"></a>Jenkinsfile 的基本类型</h3><p>Jenkins Pipeline 目前支持两种语法类型：</p>
<ol>
<li><p><strong>Declarative Pipeline (声明式流水线) - 推荐：</strong></p>
<ul>
<li>结构化、更容易阅读和编写。</li>
<li>强制遵循特定语法，限制了某些 Groovy 结构的使用，但通常更不易出错。</li>
<li>适合大多数 CI&#x2F;CD 场景。</li>
<li>以 <code>pipeline &#123; ... &#125;</code> 块开始。</li>
</ul>
</li>
<li><p><strong>Scripted Pipeline (脚本式流水线) - 更灵活，但复杂：</strong></p>
<ul>
<li>基于传统的 Groovy 脚本。</li>
<li>提供了 Groovy 语言的完整能力，允许更复杂的逻辑和自定义行为。</li>
<li>学习曲线陡峭，调试难度大，更易出错。</li>
<li>以 <code>node &#123; ... &#125;</code> 块开始（或直接是 Groovy 脚本）。</li>
<li>通常用于声明式流水线无法满足的非常特定和高级的场景，或者作为共享库的一部分。</li>
</ul>
</li>
</ol>
<p>除非有特殊需求，<strong>强烈推荐使用 Declarative Pipeline</strong>。以下结构将主要围绕 Declarative Pipeline 展开。</p>
<hr>
<h3 id="Jenkinsfile-Declarative-Pipeline-的基本结构"><a href="#Jenkinsfile-Declarative-Pipeline-的基本结构" class="headerlink" title="Jenkinsfile (Declarative Pipeline) 的基本结构"></a>Jenkinsfile (Declarative Pipeline) 的基本结构</h3><p>一个典型的 Declarative <code>Jenkinsfile</code> 包含以下核心部分：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个声明式 Jenkinsfile 示例</span></span><br><span class="line"></span><br><span class="line">pipeline &#123; <span class="comment">// 1. `pipeline` 块：所有声明式 Pipeline 的根</span></span><br><span class="line">  </span><br><span class="line">    agent any <span class="comment">// 2. `agent` 部分：定义在哪台机器（Agent/Node）上运行流水线</span></span><br><span class="line"></span><br><span class="line">    options &#123; <span class="comment">// 3. `options` 部分：配置整个流水线的选项</span></span><br><span class="line">        timestamps() <span class="comment">// 在控制台输出中显示时间戳</span></span><br><span class="line">        skipDefaultCheckout(<span class="literal">true</span>) <span class="comment">// 跳过默认的 SCM 检出（如果自己处理检出）</span></span><br><span class="line">        <span class="comment">// retry(3) // 失败时重试3次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    environment &#123; <span class="comment">// 4. `environment` 部分：定义环境变量</span></span><br><span class="line">        <span class="comment">// 可以在流水线或特定阶段中访问</span></span><br><span class="line">        DOCKER_IMAGE_NAME = <span class="string">&quot;my-app&quot;</span></span><br><span class="line">        DOCKER_REGISTRY = <span class="string">&quot;your.docker.registry.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tools &#123; <span class="comment">// 5. `tools` 部分：自动安装工具（如 Maven, JDK, Node.js）</span></span><br><span class="line">        <span class="comment">// 确保 Jenkins 管理 -&gt; 全局工具配置 中已配置这些工具</span></span><br><span class="line">        maven <span class="string">&#x27;Maven 3.8.6&#x27;</span> <span class="comment">// Maven 3.8.6 的预定义名称</span></span><br><span class="line">        jdk <span class="string">&#x27;OpenJDK 11&#x27;</span>   <span class="comment">// OpenJDK 11 的预定义名称</span></span><br><span class="line">        nodejs <span class="string">&#x27;node-16&#x27;</span>   <span class="comment">// Node.js 16 的预定义名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123; <span class="comment">// 6. `stages` 部分：定义流水线的阶段集合</span></span><br><span class="line">      </span><br><span class="line">        stage(<span class="string">&#x27;Checkout&#x27;</span>) &#123; <span class="comment">// 7. `stage` 块：定义一个逻辑阶段</span></span><br><span class="line">            steps &#123; <span class="comment">// 8. `steps` 块：定义阶段内的具体步骤</span></span><br><span class="line">                <span class="comment">// `sh` 用于执行 Shell 命令 (Linux/macOS)</span></span><br><span class="line">                <span class="comment">// `bat` 用于执行 Batch 命令 (Windows)</span></span><br><span class="line">                <span class="comment">// `script` 用于执行更复杂的 Groovy 脚本块</span></span><br><span class="line">                <span class="comment">// `git` 用于 SCM 检出</span></span><br><span class="line">              </span><br><span class="line">                script &#123;</span><br><span class="line">                    echo <span class="string">&quot;Checking out Git repository...&quot;</span></span><br><span class="line">                    <span class="comment">// 尽管有 skipDefaultCheckout，这里演示手动检出</span></span><br><span class="line">                    git <span class="attr">branch:</span> <span class="string">&#x27;main&#x27;</span>, <span class="attr">credentialsId:</span> <span class="string">&#x27;your-git-cred-id&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;https://github.com/your-org/your-repo.git&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;Building the application...&quot;</span></span><br><span class="line">                sh <span class="string">&#x27;mvn clean package -DskipTests&#x27;</span> <span class="comment">// 调用 Maven 构建</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;Test&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// `when` 子句：定义阶段执行的条件</span></span><br><span class="line">            when &#123;</span><br><span class="line">                expression &#123; env.BRANCH_NAME == <span class="string">&#x27;main&#x27;</span> || env.BRANCH_NAME.startsWith(<span class="string">&#x27;feature/&#x27;</span>) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;Running unit tests...&quot;</span></span><br><span class="line">                sh <span class="string">&#x27;mvn test&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;Build Docker Image&#x27;</span>) &#123;</span><br><span class="line">            environment &#123; <span class="comment">// 可以在阶段级别定义环境变量，覆盖或新增</span></span><br><span class="line">                IMAGE_TAG = <span class="string">&quot;$&#123;DOCKER_REGISTRY&#125;/$&#123;DOCKER_IMAGE_NAME&#125;:$&#123;env.BUILD_NUMBER&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;Building Docker image: $&#123;IMAGE_TAG&#125;&quot;</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="comment">// withCredentials 块用于安全地使用 Jenkins 凭据</span></span><br><span class="line">                    withCredentials([usernamePassword(<span class="attr">credentialsId:</span> <span class="string">&#x27;docker-registry-credentials&#x27;</span>, <span class="attr">passwordVariable:</span> <span class="string">&#x27;DOCKER_PASSWORD&#x27;</span>, <span class="attr">usernameVariable:</span> <span class="string">&#x27;DOCKER_USERNAME&#x27;</span>)]) &#123;</span><br><span class="line">                        sh <span class="string">&quot;docker login -u $&#123;DOCKER_USERNAME&#125; -p $&#123;DOCKER_PASSWORD&#125; $&#123;DOCKER_REGISTRY&#125;&quot;</span></span><br><span class="line">                        sh <span class="string">&quot;docker build -t $&#123;IMAGE_TAG&#125; .&quot;</span></span><br><span class="line">                        sh <span class="string">&quot;docker push $&#123;IMAGE_TAG&#125;&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;Deploy to Dev&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// `agent` 也可以在阶段级别指定，覆盖顶层定义</span></span><br><span class="line">            agent &#123; label <span class="string">&#x27;kubernetes-kubectl-agent&#x27;</span> &#125; <span class="comment">// 假设需要一个带 kubectl 的 Agent</span></span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;Deploying to development environment...&quot;</span></span><br><span class="line">                <span class="comment">// 确保 kubectl-agent 拥有部署到 K8s 的权限</span></span><br><span class="line">                sh <span class="string">&quot;kubectl apply -f k8s/dev-deployment.yaml --namespace dev --set image.tag=$&#123;env.BUILD_NUMBER&#125;&quot;</span></span><br><span class="line">                sh <span class="string">&quot;kubectl rollout status deployment/my-app-dev -n dev&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;Approve for Prod&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                expression &#123; env.BRANCH_NAME == <span class="string">&#x27;main&#x27;</span> &#125; <span class="comment">// 只有主分支才能触发生产部署</span></span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// `input` 步骤：在流水线中暂停并等待用户确认</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    timeout(<span class="attr">time:</span> <span class="number">1</span>, <span class="attr">unit:</span> <span class="string">&#x27;HOURS&#x27;</span>) &#123; <span class="comment">// 等待审批最多1小时</span></span><br><span class="line">                        input <span class="attr">message:</span> <span class="string">&#x27;Approve deployment to Production?&#x27;</span>, <span class="attr">ok:</span> <span class="string">&#x27;Deploy&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;Deploy to Prod&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                expression &#123; env.BRANCH_NAME == <span class="string">&#x27;main&#x27;</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            agent &#123; label <span class="string">&#x27;kubernetes-prod-agent&#x27;</span> &#125; <span class="comment">// 假设生产环境是用不同的 Agent</span></span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;Deploying to production environment...&quot;</span></span><br><span class="line">                sh <span class="string">&quot;kubectl apply -f k8s/prod-deployment.yaml --namespace prod --set image.tag=$&#123;env.BUILD_NUMBER&#125;&quot;</span></span><br><span class="line">                sh <span class="string">&quot;kubectl rollout status deployment/my-app-prod -n prod&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    post &#123; <span class="comment">// 9. `post` 部分：定义流水线结束后执行的动作 (无论成功失败)</span></span><br><span class="line">        always &#123; <span class="comment">// 总是执行</span></span><br><span class="line">            echo <span class="string">&#x27;Archiving build artifacts...&#x27;</span></span><br><span class="line">            archiveArtifacts <span class="attr">artifacts:</span> <span class="string">&#x27;target/*.jar&#x27;</span>, <span class="attr">fingerprint:</span> <span class="literal">true</span> <span class="comment">// 归档构建产物</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 发送通知</span></span><br><span class="line">            <span class="comment">// mail to: &#x27;devops@example.com&#x27;, subject: &quot;Build $&#123;currentBuild.fullDisplayName&#125; finished&quot;, body: &quot;Status: $&#123;currentBuild.result&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        success &#123; <span class="comment">// 流水线成功时执行</span></span><br><span class="line">            echo <span class="string">&#x27;Pipeline finished successfully!&#x27;</span></span><br><span class="line">            <span class="comment">// slackSend channel: &#x27;#devops-alerts&#x27;, message: &quot;Build $&#123;currentBuild.displayName&#125; SUCCESS!&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        failure &#123; <span class="comment">// 流水线失败时执行</span></span><br><span class="line">            echo <span class="string">&#x27;Pipeline failed!&#x27;</span></span><br><span class="line">            <span class="comment">// slackSend channel: &#x27;#devops-alerts&#x27;, message: &quot;Build $&#123;currentBuild.displayName&#125; FAILED! See $&#123;env.BUILD_URL&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        unstable &#123; <span class="comment">// 流水线不稳定时（例如测试失败但构建成功）执行</span></span><br><span class="line">            echo <span class="string">&#x27;Pipeline is unstable.&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        changed &#123; <span class="comment">// 构建状态发生变化时（从成功到失败，或失败到成功等）</span></span><br><span class="line">            echo <span class="string">&#x27;Build status changed.&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键组成部分解释："><a href="#关键组成部分解释：" class="headerlink" title="关键组成部分解释："></a>关键组成部分解释：</h4><ol>
<li><p>**<code>pipeline &#123; ... &#125;</code>**：</p>
<ul>
<li>外部的根块，所有声明式流水线都必须包含这个块。</li>
</ul>
</li>
<li><p>**<code>agent &#123; ... &#125;</code>**：</p>
<ul>
<li><strong>定义执行流水线的 Jenkins Agent（或节点）。</strong></li>
<li><code>agent any</code>：在任何可用的 Agent 上运行。</li>
<li><code>agent none</code>：不为整个流水线分配 Agent，每个 <code>stage</code> 必须自己指定 <code>agent</code>。</li>
<li><code>agent &#123; label &#39;your-label&#39; &#125;</code>：在具有特定标签的 Agent 上运行。</li>
<li><code>agent &#123; node &#123; label &#39;node-name&#39; &#125; &#125;</code>：在名为 <code>node-name</code> 的特定 Agent 上运行。</li>
<li><code>agent &#123; docker &#123; image &#39;maven:3-alpine&#39; &#125; &#125;</code>：在 Docker 容器中运行（需安装 Docker Pipeline 插件）。</li>
<li><code>agent &#123; kubernetes &#123; ... &#125; &#125;</code>：在 Kubernetes Pod 中运行（需安装 Kubernetes 插件）。</li>
</ul>
</li>
<li><p>**<code>options &#123; ... &#125;</code>**：</p>
<ul>
<li>用于配置流水线的各种选项，如：<ul>
<li><code>timestamps()</code>：在控制台输出中显示时间戳。</li>
<li><code>retry(N)</code>：当流水线失败时，重新尝试 N 次。</li>
<li><code>timeout(time: N, unit: &#39;HOURS&#39;)</code>：设置流水线或阶段的整体超时。</li>
<li><code>skipDefaultCheckout(true)</code>：跳过 Jenkins 默认在开始时执行的 SCM 检出。</li>
<li><code>disableConcurrentBuilds()</code>：阻止相同流水线的并发构建。</li>
</ul>
</li>
</ul>
</li>
<li><p>**<code>environment &#123; ... &#125;</code>**：</p>
<ul>
<li>定义可以在整个流水线中访问的环境变量。</li>
<li>变量可以通过 <code>$&#123;VAR_NAME&#125;</code> 或 <code>env.VAR_NAME</code> 访问。</li>
<li>可以包含 <code>credentials()</code> 这样的凭据绑定，安全地将 Jenkins 凭据暴露为环境变量。</li>
</ul>
</li>
<li><p>**<code>tools &#123; ... &#125;</code>**：</p>
<ul>
<li>自动安装和配置构建工具（如 Maven、JDK、Node.js）。</li>
<li>需要在 Jenkins 的 <code>Manage Jenkins</code> -&gt; <code>Global Tool Configuration</code> 中预先配置这些工具的名称和版本。</li>
</ul>
</li>
<li><p>**<code>stages &#123; ... &#125;</code>**：</p>
<ul>
<li>包含所有 <code>stage</code> 的集合。流水线通常由多个顺序执行的阶段组成。</li>
</ul>
</li>
<li><p>**<code>stage(&#39;Name&#39;) &#123; ... &#125;</code>**：</p>
<ul>
<li>定义一个逻辑上的流水线阶段，例如 <code>Build</code>、<code>Test</code>、<code>Deploy</code>。</li>
<li>每个阶段都包含一个 <code>steps</code> 块。</li>
<li>可以包含自身的 <code>agent</code>、<code>options</code>、<code>environment</code> 和 <code>when</code>。</li>
</ul>
</li>
<li><p>**<code>steps &#123; ... &#125;</code>**：</p>
<ul>
<li>定义在当前 <code>stage</code> 中执行的所有具体操作。</li>
<li>常用的步骤类型：<ul>
<li><code>sh &#39;command&#39;</code>：在 Agent 上执行 Shell 命令。</li>
<li><code>bat &#39;command&#39;</code>：在 Windows Agent 上执行 Batch 命令。</li>
<li><code>script &#123; ... &#125;</code>：在声明式流水线中执行更复杂的 Groovy 脚本逻辑。</li>
<li><code>git branch: &#39;main&#39;, url: &#39;...&#39;</code>：执行 Git 检出。</li>
<li><code>input message: &#39;...&#39;</code>：在流水线执行中暂停，等待用户输入或确认。</li>
<li><code>archiveArtifacts artifacts: &#39;...&#39;</code>：归档构建产物。</li>
<li><code>junit &#39;...&#39;</code>：发布 JUnit 测试报告。</li>
<li><code>slackSend channel: &#39;...&#39;</code>：发送 Slack 消息（需安装插件）。</li>
<li><code>withCredentials([usernamePassword(...)])&#123;...&#125;</code>：安全地使用 Jenkins 凭据。</li>
</ul>
</li>
</ul>
</li>
<li><p>**<code>post &#123; ... &#125;</code>**：</p>
<ul>
<li>定义在流水线或阶段执行完成后运行的动作，无论成功、失败、不稳定或总是执行。</li>
<li>常见的条件：<code>always</code>、<code>success</code>、<code>failure</code>、<code>unstable</code>、<code>changed</code>、<code>fixed</code>。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Jenkinsfile</code> 是实现 Jenkins <strong>Pipeline as Code</strong> 的核心。它将 CI&#x2F;CD 流水线定义显式化、版本化，并与您的项目代码紧密结合，从而提供了更高的可追溯性、标准化和团队协作效率。理解其基本结构和各部分的用途，是您构建和管理现代 CI&#x2F;CD 流程的关键一步。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/shell-trap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/shell-trap/" class="post-title-link" itemprop="url">Linux-trap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:40:44 / 修改时间：21:59:58" itemprop="dateCreated datePublished" datetime="2025-09-11T20:40:44+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/scripts/" itemprop="url" rel="index"><span itemprop="name">scripts</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>——— | :——- | :———————————————————– |<br>| <strong><code>EXIT</code></strong>    | 0        | <strong>伪信号 (Pseudo-Signal)<strong>。这不是一个真正的 OS 信号，而是 Shell 脚本在</strong>任何方式退出时</strong>都会触发的特殊陷阱。<strong>这是进行通用清理工作的最佳选择</strong>。 |<br>| <strong><code>SIGINT</code></strong>  | 2        | **中断信号 (Interrupt)**。通常由用户按下 <code>Ctrl+C</code> 触发。用于处理用户手动中断脚本的场景。 |<br>| <strong><code>SIGTERM</code></strong> | 15       | **终止信号 (Terminate)**。这是标准的、优雅的程序终止信号，例如 <code>kill &lt;pid&gt;</code> 命令默认发送的就是这个信号。服务管理工具（如 <code>systemd</code>）也用它来停止服务。 |<br>| <strong><code>SIGHUP</code></strong>  | 1        | **挂起信号 (Hangup)**。当终端关闭时，该终端启动的进程会收到此信号。常用于让守护进程重新加载配置文件。 |<br>| <strong><code>SIGQUIT</code></strong> | 3        | **退出信号 (Quit)**。通常由用户按下 <code>Ctrl+\</code> 触发，除了终止进程外，还会生成核心转储文件 (core dump)。 |</p>
<p>你可以通过 <code>trap -l</code> 或 <code>kill -l</code> 命令查看系统支持的所有信号列表。</p>
<h3 id="使用方法与实战示例"><a href="#使用方法与实战示例" class="headerlink" title="使用方法与实战示例"></a>使用方法与实战示例</h3><h4 id="示例-1-使用-EXIT-伪信号进行通用清理"><a href="#示例-1-使用-EXIT-伪信号进行通用清理" class="headerlink" title="示例 1: 使用 EXIT 伪信号进行通用清理"></a>示例 1: 使用 <code>EXIT</code> 伪信号进行通用清理</h4><p>这是 <code>trap</code> 最常见、最强大的用法。无论脚本是正常执行完毕、被 <code>Ctrl+C</code> 中断，还是因为其他信号退出，<code>EXIT</code> 陷阱都会被触发。</p>
<p><strong>场景</strong>：一个备份脚本，在执行期间会创建一个临时锁文件，以防止重复执行。无论备份成功还是失败，都必须确保锁文件被删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LOCK_FILE=<span class="string">&quot;/var/run/my_backup.lock&quot;</span></span><br><span class="line">TEMP_DIR=$(<span class="built_in">mktemp</span> -d /tmp/backup.XXXXXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 定义清理函数，逻辑清晰 ---</span></span><br><span class="line"><span class="function"><span class="title">cleanup</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;&gt;&gt;&gt; 正在执行清理操作...&quot;</span></span><br><span class="line">  <span class="comment"># 检查并删除锁文件</span></span><br><span class="line">  <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$LOCK_FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$LOCK_FILE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;锁文件 <span class="variable">$&#123;LOCK_FILE&#125;</span> 已删除。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="comment"># 检查并删除临时目录</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$TEMP_DIR</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$TEMP_DIR</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;临时目录 <span class="variable">$&#123;TEMP_DIR&#125;</span> 已删除。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;&gt;&gt;&gt; 清理完成。&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 设置陷阱 ---</span></span><br><span class="line"><span class="comment"># 无论脚本如何退出（正常结束、Ctrl+C、kill），都调用 cleanup 函数</span></span><br><span class="line"><span class="built_in">trap</span> cleanup EXIT</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 主逻辑 ---</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;开始执行备份任务...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否存在锁文件</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$LOCK_FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;错误: 另一个备份任务正在运行。锁文件存在: <span class="variable">$&#123;LOCK_FILE&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建锁文件</span></span><br><span class="line"><span class="built_in">echo</span> $$ &gt; <span class="string">&quot;<span class="variable">$LOCK_FILE</span>&quot;</span> <span class="comment"># 将当前进程ID写入锁文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;备份数据到临时目录: <span class="variable">$&#123;TEMP_DIR&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># 模拟一个长时间运行的备份操作</span></span><br><span class="line"><span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟备份中途出错</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$SECONDS</span> -gt 5 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;错误：备份过程中发生未知错误！&quot;</span></span><br><span class="line">    <span class="comment"># 此处的 exit 也会触发 trap</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;备份成功完成！&quot;</span></span><br><span class="line"><span class="comment"># 正常退出也会触发 trap</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p><strong>运行与测试</strong>：</p>
<ol>
<li><strong>正常运行</strong>：让脚本执行完毕，你会看到最后的清理信息。</li>
<li><strong>手动中断</strong>：在脚本运行的 10 秒内，按下 <code>Ctrl+C</code>，你会看到脚本立即停止主逻辑，并开始执行 <code>cleanup</code> 函数。</li>
<li><strong>模拟错误</strong>：在脚本中，当 <code>SECONDS</code> 大于 5 时，脚本会因错误 <code>exit 1</code>，但 <code>cleanup</code> 函数依然会被调用。</li>
</ol>
<p>这个模式确保了系统的整洁，是专业运维脚本的标志。</p>
<h4 id="示例-2-捕捉-SIGINT-和-SIGTERM-实现优雅关闭"><a href="#示例-2-捕捉-SIGINT-和-SIGTERM-实现优雅关闭" class="headerlink" title="示例 2: 捕捉 SIGINT 和 SIGTERM 实现优雅关闭"></a>示例 2: 捕捉 <code>SIGINT</code> 和 <code>SIGTERM</code> 实现优雅关闭</h4><p><strong>场景</strong>：一个长时间运行的数据处理脚本，我们希望在收到 <code>Ctrl+C</code> 时，不是立即退出，而是完成当前循环的处理，并给出一个友好的提示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量，用于控制循环</span></span><br><span class="line">KEEP_RUNNING=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 定义信号处理函数 ---</span></span><br><span class="line"><span class="function"><span class="title">handle_shutdown_signal</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> <span class="comment"># 换行，使得输出更美观</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;&gt;&gt;&gt; 检测到关闭信号（SIGINT/SIGTERM）！&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;&gt;&gt;&gt; 将在当前循环结束后安全退出，请稍候...&quot;</span></span><br><span class="line">  <span class="comment"># 修改标志位，让主循环自然退出</span></span><br><span class="line">  KEEP_RUNNING=<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 设置陷阱 ---</span></span><br><span class="line"><span class="comment"># 捕捉 Ctrl+C 和 kill 命令</span></span><br><span class="line"><span class="built_in">trap</span> handle_shutdown_signal SIGINT SIGTERM</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 主循环 ---</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数据处理服务已启动。按 Ctrl+C 可优雅地停止它。&quot;</span></span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> <span class="string">&quot;<span class="variable">$KEEP_RUNNING</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">  i=$((i+<span class="number">1</span>))</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;正在处理第 <span class="variable">$i</span> 批数据...&quot;</span></span><br><span class="line">  <span class="comment"># 模拟复杂的工作</span></span><br><span class="line">  <span class="built_in">sleep</span> 2</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;服务已安全停止。共处理了 <span class="variable">$i</span> 批数据。&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p><strong>运行与测试</strong>：</p>
<ol>
<li>脚本会持续输出 “正在处理第 X 批数据…”。</li>
<li>按下 <code>Ctrl+C</code>，你会看到 <code>handle_shutdown_signal</code> 函数中的提示信息被打印出来。</li>
<li>脚本不会立即停止，而是会等待当前 <code>sleep 2</code> 结束，完成 <code>while</code> 循环的这一次迭代。</li>
<li>由于 <code>KEEP_RUNNING</code> 变为 <code>false</code>，<code>while</code> 循环条件不再满足，循环正常结束，脚本优雅退出。</li>
</ol>
<h3 id="trap-命令的其他用法"><a href="#trap-命令的其他用法" class="headerlink" title="trap 命令的其他用法"></a><code>trap</code> 命令的其他用法</h3><ul>
<li><strong>忽略信号</strong>：<code>trap &#39;&#39; SIGINT</code><ul>
<li>这条命令会让脚本完全忽略 <code>Ctrl+C</code>，按了也没反应。在某些防止用户误操作的场景下有用。</li>
</ul>
</li>
<li><strong>重置信号处理</strong>：<code>trap SIGHUP</code><ul>
<li>省略第一个参数（命令）会恢复信号的默认行为。</li>
</ul>
</li>
<li><strong>查看已设置的陷阱</strong>：<code>trap -p</code><ul>
<li>会以可重用的格式打印出当前设置的所有陷D阱。</li>
</ul>
</li>
</ul>
<p>掌握 <code>trap</code> 命令，意味着你能编写出更健壮、更可靠、更能应对生产环境中各种意外情况的运维脚本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/shell-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">Shell-数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:40:44 / 修改时间：21:57:44" itemprop="dateCreated datePublished" datetime="2025-09-11T20:40:44+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/scripts/" itemprop="url" rel="index"><span itemprop="name">scripts</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="二、关联数组-Associative-Arrays"><a href="#二、关联数组-Associative-Arrays" class="headerlink" title="二、关联数组 (Associative Arrays)"></a>二、关联数组 (Associative Arrays)</h3><p>关联数组使用字符串作为索引（键），非常适合存储键值对数据，类似于 Python 的字典或 Perl 的哈希表。<strong>使用前必须先声明</strong>。</p>
<h4 id="1-定义关联数组"><a href="#1-定义关联数组" class="headerlink" title="1. 定义关联数组"></a>1. 定义关联数组</h4><p><strong>必须使用 <code>declare -A</code> 进行声明。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A service_ports</span><br></pre></td></tr></table></figure>
<p>然后可以进行赋值：</p>
<p><strong>a) 一次性赋值</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service_ports=([http]=80 [https]=443 [mysql]=3306 [ssh]=22)</span><br></pre></td></tr></table></figure>

<p><strong>b) 单个赋值</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service_ports[redis]=6379</span><br><span class="line">service_ports[dns]=53</span><br></pre></td></tr></table></figure>

<h4 id="2-访问和操作关联数组"><a href="#2-访问和操作关联数组" class="headerlink" title="2. 访问和操作关联数组"></a>2. 访问和操作关联数组</h4><p>语法与索引数组非常相似，只是索引变成了字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明并定义</span></span><br><span class="line"><span class="built_in">declare</span> -A user_shells=([root]=<span class="string">&quot;/bin/bash&quot;</span> [nginx]=<span class="string">&quot;/sbin/nologin&quot;</span> [devuser]=<span class="string">&quot;/bin/zsh&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;root 用户的 shell 是: <span class="variable">$&#123;user_shells[root]&#125;</span>&quot;</span>  <span class="comment"># 输出: /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加或修改元素</span></span><br><span class="line">user_shells[devuser]=<span class="string">&quot;/bin/bash&quot;</span>    <span class="comment"># 修改</span></span><br><span class="line">user_shells[ftpuser]=<span class="string">&quot;/bin/false&quot;</span>   <span class="comment"># 添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;所有 Shell: <span class="variable">$&#123;user_shells[@]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有键（索引）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;所有用户: <span class="variable">$&#123;!user_shells[@]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;用户数: <span class="variable">$&#123;#user_shells[@]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line"><span class="built_in">unset</span> user_shells[nginx]</span><br></pre></td></tr></table></figure>

<h4 id="3-遍历关联数组"><a href="#3-遍历关联数组" class="headerlink" title="3. 遍历关联数组"></a>3. 遍历关联数组</h4><p><strong>遍历键</strong>，然后通过键获取值，这是最常见的方式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A host_ips=(</span><br><span class="line">  [web-server]=<span class="string">&quot;192.168.1.10&quot;</span></span><br><span class="line">  [db-server]=<span class="string">&quot;192.168.1.20&quot;</span></span><br><span class="line">  [app-server]=<span class="string">&quot;192.168.1.30&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;主机 IP 地址映射:&quot;</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;!host_ips[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">  ip_addr=<span class="variable">$&#123;host_ips[$host]&#125;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;  - 主机: <span class="variable">$&#123;host&#125;</span>, IP: <span class="variable">$&#123;ip_addr&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="运维场景实战示例"><a href="#运维场景实战示例" class="headerlink" title="运维场景实战示例"></a>运维场景实战示例</h3><p><strong>场景</strong>：批量检查一组服务器上某个服务的状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标服务器列表</span></span><br><span class="line">TARGET_SERVERS=(<span class="string">&quot;10.0.1.5&quot;</span> <span class="string">&quot;10.0.1.6&quot;</span> <span class="string">&quot;10.0.1.8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要检查的服务名称</span></span><br><span class="line">SERVICE_NAME=<span class="string">&quot;nginx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储服务状态的关联数组</span></span><br><span class="line"><span class="built_in">declare</span> -A FAILED_HOSTS</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;开始批量检查服务 [<span class="variable">$&#123;SERVICE_NAME&#125;</span>] 状态...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历服务器列表</span></span><br><span class="line"><span class="keyword">for</span> server <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;TARGET_SERVERS[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">&quot;正在检查 <span class="variable">$&#123;server&#125;</span>... &quot;</span></span><br><span class="line">  <span class="comment"># 使用 ssh 远程执行命令，-o ConnectTimeout 设置超时</span></span><br><span class="line">  <span class="comment"># systemctl is-active 会返回 &quot;active&quot; 或 &quot;inactive/failed&quot; 等</span></span><br><span class="line">  status=$(ssh -o ConnectTimeout=5 <span class="string">&quot;user@<span class="variable">$&#123;server&#125;</span>&quot;</span> <span class="string">&quot;systemctl is-active <span class="variable">$&#123;SERVICE_NAME&#125;</span>&quot;</span> 2&gt;/dev/null)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$status</span>&quot;</span> == <span class="string">&quot;active&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;状态: [OK]&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;状态: [FAILED]&quot;</span></span><br><span class="line">    <span class="comment"># 如果服务异常，记录到失败主机关联数组中</span></span><br><span class="line">    FAILED_HOSTS[<span class="string">&quot;<span class="variable">$server</span>&quot;</span>]=<span class="string">&quot;<span class="variable">$status</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-------------------------------------&quot;</span></span><br><span class="line"><span class="comment"># 检查失败主机的数量</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;#FAILED_HOSTS[@]&#125;</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;发现以下主机的服务状态异常:&quot;</span></span><br><span class="line">  <span class="keyword">for</span> host <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;!FAILED_HOSTS[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  - 主机 <span class="variable">$&#123;host&#125;</span> 的服务状态是: <span class="variable">$&#123;FAILED_HOSTS[$host]&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="built_in">exit</span> 1 <span class="comment"># 以失败状态退出脚本</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;所有主机的服务状态均正常。&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>这个脚本充分利用了索引数组来存储目标列表和关联数组来记录结果，是运维自动化中一个非常典型的数组应用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/shell-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/shell-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/" class="post-title-link" itemprop="url">Shell-条件判断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:40:44 / 修改时间：21:58:34" itemprop="dateCreated datePublished" datetime="2025-09-11T20:40:44+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/scripts/" itemprop="url" rel="index"><span itemprop="name">scripts</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>– | :——————— | :—————————- |<br>| <code>-f</code>   | 判断是否为普通文件     | <code>if [ -f &quot;/var/log/syslog&quot; ]</code> |<br>| <code>-d</code>   | 判断是否为目录         | <code>if [ -d &quot;/etc/nginx&quot; ]</code>      |<br>| <code>-e</code>   | 判断文件或目录是否存在 | <code>if [ -e &quot;/tmp/data.txt&quot; ]</code>   |<br>| <code>-s</code>   | 判断文件是否存在且非空 | <code>if [ -s &quot;access.log&quot; ]</code>      |<br>| <code>-r</code>   | 判断文件是否可读       | <code>if [ -r &quot;/etc/passwd&quot; ]</code>     |<br>| <code>-w</code>   | 判断文件是否可写       | <code>if [ -w &quot;app.lock&quot; ]</code>        |<br>| <code>-x</code>   | 判断文件是否可执行     | <code>if [ -x &quot;/usr/bin/python&quot; ]</code> |</p>
<p><strong>示例：检查 Nginx 配置文件是否存在，否则退出</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NGINX_CONF=<span class="string">&quot;/etc/nginx/nginx.conf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">&quot;<span class="variable">$&#123;NGINX_CONF&#125;</span>&quot;</span> ]; <span class="keyword">then</span> <span class="comment"># ! 表示逻辑 &quot;非&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;错误: Nginx 配置文件 <span class="variable">$&#123;NGINX_CONF&#125;</span> 不存在！&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;配置文件检查通过。&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>b. 字符串判断</strong></p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>str1 = str2</code></td>
<td align="left">字符串是否相等</td>
<td align="left"><code>if [ &quot;$&#123;ACTION&#125;&quot; = &quot;start&quot; ]</code></td>
</tr>
<tr>
<td align="left"><code>str1 != str2</code></td>
<td align="left">字符串是否不相等</td>
<td align="left"><code>if [ &quot;$USER&quot; != &quot;root&quot; ]</code></td>
</tr>
<tr>
<td align="left"><code>-z str</code></td>
<td align="left">字符串长度是否为零（空）</td>
<td align="left"><code>if [ -z &quot;$&#123;ERROR_MSG&#125;&quot; ]</code></td>
</tr>
<tr>
<td align="left"><code>-n str</code></td>
<td align="left">字符串长度是否非零（非空）</td>
<td align="left"><code>if [ -n &quot;$&#123;HOSTNAME&#125;&quot; ]</code></td>
</tr>
</tbody></table>
<p><strong>强烈建议</strong>: 在比较字符串时，<strong>始终用双引号 <code>&quot;&quot;</code> 将变量括起来</strong>，防止变量为空或包含空格时产生语法错误。</p>
<p><strong>示例：判断脚本输入参数</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ACTION=<span class="variable">$1</span> <span class="comment"># 第一个参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;ACTION&#125;</span>&quot;</span> = <span class="string">&quot;start&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;正在启动服务...&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;ACTION&#125;</span>&quot;</span> = <span class="string">&quot;stop&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;正在停止服务...&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;用法: <span class="variable">$0</span> [start|stop]&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><strong>c. 整数判断</strong></p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-eq</code></td>
<td align="left">等于 (equal)</td>
<td align="left"><code>if [ $count -eq 0 ]</code></td>
</tr>
<tr>
<td align="left"><code>-ne</code></td>
<td align="left">不等于 (not equal)</td>
<td align="left"><code>if [ $code -ne 200 ]</code></td>
</tr>
<tr>
<td align="left"><code>-gt</code></td>
<td align="left">大于 (greater than)</td>
<td align="left"><code>if [ $memory_usage -gt 90 ]</code></td>
</tr>
<tr>
<td align="left"><code>-ge</code></td>
<td align="left">大于或等于 (greater than or equal)</td>
<td align="left"><code>if [ $cpu_load -ge 5 ]</code></td>
</tr>
<tr>
<td align="left"><code>-lt</code></td>
<td align="left">小于 (less than)</td>
<td align="left"><code>if [ $disk_free -lt 1024 ]</code></td>
</tr>
<tr>
<td align="left"><code>-le</code></td>
<td align="left">小于或等于 (less than or equal)</td>
<td align="left"><code>if [ $retries -le 3 ]</code></td>
</tr>
</tbody></table>
<p><strong>示例：检查磁盘使用率</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DISK_USAGE=$(<span class="built_in">df</span> -h / | awk <span class="string">&#x27;NR==2 &#123;print $5&#125;&#x27;</span> | sed <span class="string">&#x27;s/%//&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;DISK_USAGE&#125;</span> -gt 90 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;警告: 根分区磁盘使用率已达 <span class="variable">$&#123;DISK_USAGE&#125;</span>%！&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id="3-逻辑组合"><a href="#3-逻辑组合" class="headerlink" title="3. 逻辑组合"></a>3. 逻辑组合</h4><ul>
<li><strong><code>-a</code> (and)</strong>: <code>if [ $USER = &quot;root&quot; -a $UID -eq 0 ]</code> (老式写法)</li>
<li><strong><code>-o</code> (or)</strong>: <code>if [ $HOUR -lt 8 -o $HOUR -gt 18 ]</code> (老式写法)</li>
<li><strong><code>&amp;&amp;</code> (and)</strong>: <code>if [ -f &quot;$FILE&quot; ] &amp;&amp; [ -s &quot;$FILE&quot; ]</code> (推荐，更清晰)</li>
<li><strong><code>||</code> (or)</strong>: <code>if [ &quot;$SERVICE_STATUS&quot; = &quot;failed&quot; ] || [ &quot;$SERVICE_STATUS&quot; = &quot;inactive&quot; ]</code> (推荐)</li>
</ul>
<p><strong>示例：使用 <code>&amp;&amp;</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOG_FILE=<span class="string">&quot;/var/log/app.log&quot;</span></span><br><span class="line"><span class="comment"># 仅当文件存在且可读时，才去搜索错误</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$&#123;LOG_FILE&#125;</span>&quot;</span> ] &amp;&amp; [ -r <span class="string">&quot;<span class="variable">$&#123;LOG_FILE&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  grep -q <span class="string">&quot;ERROR&quot;</span> <span class="string">&quot;<span class="variable">$&#123;LOG_FILE&#125;</span>&quot;</span></span><br><span class="line">  <span class="comment"># $? 是上一条命令的退出状态码，0 表示成功（即找到了）</span></span><br><span class="line">  <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;日志中发现错误！&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id="4-双方括号"><a href="#4-双方括号" class="headerlink" title="4. [[ ... ]] 双方括号"></a>4. <code>[[ ... ]]</code> 双方括号</h4><p><code>[[ ... ]]</code> 是 <code>[ ... ]</code> 的增强版，提供了更高级的功能，并且更安全。**在现代 Shell 脚本中，推荐优先使用 <code>[[ ... ]]</code>**。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>**原生支持 <code>&amp;&amp;</code> 和 <code>||</code>**。</li>
<li><strong>字符串比较时不需要给变量加双引号</strong>，不会因空格等问题出错。</li>
<li><strong>支持通配符匹配 (<code>=~</code>)</strong>: <code>[[ &quot;hello&quot; == h* ]]</code> 结果为真。</li>
<li><strong>支持正则表达式匹配 (<code>=~</code>)</strong>: <code>[[ &quot;abc123xyz&quot; =~ [0-9]+ ]]</code> 结果为真。</li>
</ul>
<p><strong>示例：<code>[[ ... ]]</code> 对比</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 旧式写法</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ACTION</span>&quot;</span> = <span class="string">&quot;start&quot;</span> -o <span class="string">&quot;<span class="variable">$ACTION</span>&quot;</span> = <span class="string">&quot;restart&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 [[ ... ]] 的现代化写法，更易读</span></span><br><span class="line">ACTION=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$ACTION</span> == <span class="string">&quot;start&quot;</span> || <span class="variable">$ACTION</span> == <span class="string">&quot;restart&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;执行启动或重启操作...&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、case-语句"><a href="#二、case-语句" class="headerlink" title="二、case 语句"></a>二、<code>case</code> 语句</h3><p>当一个变量需要和多个<strong>固定的值</strong>进行匹配时，使用 <code>case</code> 语句比写一长串的 <code>if/elif/else</code> 更加清晰和高效。</p>
<h4 id="1-基本语法结构"><a href="#1-基本语法结构" class="headerlink" title="1. 基本语法结构"></a>1. 基本语法结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$variable</span> <span class="keyword">in</span></span><br><span class="line">  pattern1)</span><br><span class="line">    <span class="comment"># 匹配 pattern1 时执行的命令</span></span><br><span class="line">    command_list_1</span><br><span class="line">    ;; <span class="comment"># 双分号表示一个分支的结束</span></span><br><span class="line">  pattern2|pattern3) <span class="comment"># 使用 | 分隔多个模式</span></span><br><span class="line">    <span class="comment"># 匹配 pattern2 或 pattern3 时执行的命令</span></span><br><span class="line">    command_list_2</span><br><span class="line">    ;;</span><br><span class="line">  *.<span class="built_in">log</span>|*.txt) <span class="comment"># 支持通配符</span></span><br><span class="line">    <span class="comment"># 匹配以 .log 或 .txt 结尾的字符串</span></span><br><span class="line">    command_list_3</span><br><span class="line">    ;;</span><br><span class="line">  *) <span class="comment"># 默认分支，类似 else</span></span><br><span class="line">    <span class="comment"># 以上都不匹配时执行的命令</span></span><br><span class="line">    command_list_default</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span> <span class="comment"># 标志 case 语句块结束</span></span><br></pre></td></tr></table></figure>

<h4 id="2-使用场景示例"><a href="#2-使用场景示例" class="headerlink" title="2. 使用场景示例"></a>2. 使用场景示例</h4><p><strong>示例：处理脚本的命令行参数</strong><br>这几乎是 <code>case</code> 语句最经典的应用场景。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $0 是脚本名，$1 是第一个参数</span></span><br><span class="line"><span class="function"><span class="title">print_usage</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;用法: <span class="variable">$0</span> &#123;start|stop|restart|status&#125;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  start)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;启动服务...&quot;</span></span><br><span class="line">    <span class="comment"># systemctl start my_service</span></span><br><span class="line">    ;;</span><br><span class="line">  stop)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;停止服务...&quot;</span></span><br><span class="line">    <span class="comment"># systemctl stop my_service</span></span><br><span class="line">    ;;</span><br><span class="line">  restart)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;重启服务...&quot;</span></span><br><span class="line">    <span class="comment"># systemctl restart my_service</span></span><br><span class="line">    ;;</span><br><span class="line">  status)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;查看服务状态...&quot;</span></span><br><span class="line">    <span class="comment"># systemctl status my_service</span></span><br><span class="line">    ;;</span><br><span class="line">  *) <span class="comment"># 用户输入了未知的参数</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;错误: 无效的参数 &#x27;<span class="variable">$1</span>&#x27;&quot;</span></span><br><span class="line">    print_usage</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<p>这个启动脚本的结构比用一堆 <code>if/elif</code> 要优雅得多。</p>
<p>总而言之，**<code>if</code> 语句<strong>用于处理复杂的、范围性的、多变的条件。而</strong><code>case</code> 语句**则非常适合处理基于一个变量的多个离散值的匹配场景。掌握好它们，你的 Shell 脚本就有了逻辑的灵魂。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/shell-%E6%AD%A3%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/shell-%E6%AD%A3%E5%88%99/" class="post-title-link" itemprop="url">Shell-正则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:40:44 / 修改时间：21:58:58" itemprop="dateCreated datePublished" datetime="2025-09-11T20:40:44+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/scripts/" itemprop="url" rel="index"><span itemprop="name">scripts</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>280</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>———- | :——————————- | :———————————————– |<br>| <strong><code>grep</code></strong>     | <strong>过滤行、提取匹配部分</strong>         | 从大量日志或文本中快速筛选出包含特定模式的行。   |<br>| <strong><code>sed</code></strong>      | <strong>查找与替换</strong>                   | 修改配置文件、格式化文本输出。                   |<br>| <strong><code>awk</code></strong>      | <strong>基于字段的复杂处理和报告生成</strong> | 解析结构化文本（如日志），进行计算和格式化报告。 |<br>| <strong><code>[[ =~ ]]</code></strong> | <strong>脚本内部的逻辑判断和变量解析</strong> | 在 Shell 脚本中验证输入格式、分解字符串。        |</p>
<p>作为运维工程师，这四种方法都是我们工具箱里的必备利器。通常 <code>grep</code> 用于快速定位，<code>sed</code> 和 <code>awk</code> 用于深度加工，而 <code>[[ =~ ]]</code> 则嵌入在我们的自动化脚本中，增强其智能和健壮性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/=%E4%B8%8E:=%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/=%E4%B8%8E:=%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">=与:=区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:09:42" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-短变量声明-Short-Variable-Declaration"><a href="#1-短变量声明-Short-Variable-Declaration" class="headerlink" title="1. := (短变量声明 Short Variable Declaration)"></a>1. <code>:=</code> (短变量声明 Short Variable Declaration)</h3><p><code>:=</code> 是 Go 语言中特有的<strong>短变量声明</strong>运算符。它用于<strong>声明并初始化</strong>一个或多个变量。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>声明并初始化：</strong> 它是 <code>var</code> 关键字的一种更简洁的替代方案，用于同时完成变量的声明和初始化。</li>
<li><strong>类型推断：</strong> 编译器会自动根据等号右侧的值来推断变量的类型。您不需要显式指定类型。</li>
<li><strong>作用域限制：</strong> <code>:=</code> 只能在<strong>函数内部</strong>使用，不能用于声明包级别的变量（全局变量）。</li>
<li><strong>“至少一个新变量”规则：</strong> 在多变量声明中，<code>:=</code> 要求<strong>左侧至少有一个新变量被声明</strong>。如果左侧的所有变量都在当前作用域内已经声明过，那么 <code>:=</code> 会导致编译错误。这是为了防止意外的重声明，同时允许在处理多返回值时简洁地更新现有变量。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var name = &quot;GlobalName&quot; // 错误: := 不能在函数外使用，这里只能用 var name string = &quot;GlobalName&quot;</span></span><br><span class="line"><span class="comment">// 或者 var name = &quot;GlobalName&quot; (会隐式报错，因为Go推荐 := for local vars)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明并初始化一个新变量，类型被推断为 int</span></span><br><span class="line">	count := <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;count: %v (type: %T)\n&quot;</span>, count, count) <span class="comment">// 输出: count: 10 (type: int)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明并初始化多个变量</span></span><br><span class="line">	name, age := <span class="string">&quot;Alice&quot;</span>, <span class="number">30</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;name: %v (type: %T), age: %v (type: %T)\n&quot;</span>, name, name, age, age) <span class="comment">// 输出: name: Alice (type: string), age: 30 (type: int)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接收函数的多返回值，并使用 := 声明新变量</span></span><br><span class="line">	result, err := someFunction() <span class="comment">// result 和 err 都是新声明的变量</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Result:&quot;</span>, result)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// “至少一个新变量”规则示例：</span></span><br><span class="line">	<span class="comment">// 在新的作用域内重新声明 count 是允许的，因为它是一个新的变量。</span></span><br><span class="line">	<span class="comment">// 但在同一作用域内，如果 count 已经存在，则不能再次使用 := 来声明。</span></span><br><span class="line">	<span class="comment">// count := 20 // 编译错误: no new variables on left side of :=</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 但是，如果与一个新变量一起使用，则允许重新赋值现有变量：</span></span><br><span class="line">	price := <span class="number">100</span> <span class="comment">// price 是新变量</span></span><br><span class="line">	<span class="comment">// someOtherNewVar 是新变量, price 是现有变量的重新赋值</span></span><br><span class="line">	someOtherNewVar, price := <span class="string">&quot;apple&quot;</span>, <span class="number">120</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;someOtherNewVar: %v, price: %v\n&quot;</span>, someOtherNewVar, price) <span class="comment">// 输出: someOtherNewVar: apple, price: 120</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 错误示例：没有新变量则报错</span></span><br><span class="line">	<span class="comment">// var existedVar int = 1</span></span><br><span class="line">	<span class="comment">// existedVar := 2 // 编译错误：no new variables on left side of :=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Success&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-赋值运算符-Assignment-Operator"><a href="#2-赋值运算符-Assignment-Operator" class="headerlink" title="2. = (赋值运算符 Assignment Operator)"></a>2. <code>=</code> (赋值运算符 Assignment Operator)</h3><p><code>=</code> 是标准的<strong>赋值运算符</strong>，用于为一个<strong>已经声明过</strong>的变量赋予新的值。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>仅用于赋值：</strong> 它不会声明新的变量。</li>
<li><strong>需要先声明：</strong> 变量必须在使用 <code>=</code> 进行赋值之前，通过 <code>var</code> 或 <code>:=</code> 运算符进行声明。</li>
<li><strong>作用域无限制：</strong> 可以在函数内部和函数外部（包级别）使用。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包级别变量声明 (必须使用 var)</span></span><br><span class="line"><span class="keyword">var</span> globalMessage <span class="type">string</span> = <span class="string">&quot;Hello, Go!&quot;</span></span><br><span class="line"><span class="keyword">var</span> globalCounter <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用 var 关键字声明变量</span></span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">	x = <span class="number">5</span> <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;x: %v (type: %T)\n&quot;</span>, x, x) <span class="comment">// 输出: x: 5 (type: int)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对已声明的变量重新赋值 (可能是通过 := 声明的)</span></span><br><span class="line">	myVar := <span class="string">&quot;initial value&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;myVar (initial):&quot;</span>, myVar) <span class="comment">// 输出: myVar (initial): initial value</span></span><br><span class="line"></span><br><span class="line">	myVar = <span class="string">&quot;new value&quot;</span> <span class="comment">// 重新赋值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;myVar (after assignment):&quot;</span>, myVar) <span class="comment">// 输出: myVar (after assignment): new value</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对包级别变量赋值</span></span><br><span class="line">	globalCounter = <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;globalMessage: %v, globalCounter: %v\n&quot;</span>, globalMessage, globalCounter)</span><br><span class="line">	<span class="comment">// 输出: globalMessage: Hello, Go!, globalCounter: 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心区别总结"><a href="#核心区别总结" class="headerlink" title="核心区别总结"></a>核心区别总结</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>:=</code> (短变量声明)</th>
<th align="left"><code>=</code> (赋值运算符)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>功能</strong></td>
<td align="left"><strong>声明并初始化</strong>变量</td>
<td align="left"><strong>为已声明的变量赋值</strong></td>
</tr>
<tr>
<td align="left"><strong>类型推断</strong></td>
<td align="left">总是进行类型推断</td>
<td align="left">不进行类型推断 (变量类型已在声明时确定)</td>
</tr>
<tr>
<td align="left"><strong>适用范围</strong></td>
<td align="left"><strong>仅限函数内部</strong> (或短语句块如 <code>if</code>, <code>for</code>)</td>
<td align="left">可以在任何地方使用 (包级别、函数内部)，但变量需先声明</td>
</tr>
<tr>
<td align="left"><strong>新变量声明</strong></td>
<td align="left"><strong>必须至少声明一个新变量</strong></td>
<td align="left">不声明新变量</td>
</tr>
<tr>
<td align="left"><strong>语法</strong></td>
<td align="left">简洁，不需要 <code>var</code> 关键字</td>
<td align="left">需要配合 <code>var</code> 关键字进行声明，或用于已声明的变量</td>
</tr>
</tbody></table>
<h3 id="何时使用哪个？"><a href="#何时使用哪个？" class="headerlink" title="何时使用哪个？"></a>何时使用哪个？</h3><ul>
<li><strong>优先使用 <code>:=</code> 简洁性：</strong> 在函数内部，当您需要声明并初始化一个新变量时，<code>:=</code> 是 Go 语言的首选和惯用法。它非常简洁，并且通过类型推断使代码更易读。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大多数局部变量的声明和初始化都用这个</span></span><br><span class="line">data, err := readFromFile(<span class="string">&quot;path/to/file.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>使用 <code>var</code> 和 <code>=</code> 明确性：</strong><ul>
<li><strong>在函数外部声明包级别变量时。</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connections <span class="type">int</span> <span class="comment">// Package-level variable</span></span><br></pre></td></tr></table></figure></li>
<li><strong>当您需要声明一个变量而不立即初始化它时</strong>（它会被初始化为其类型的零值）。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client *http.Client <span class="comment">// client 会是 nil</span></span><br></pre></td></tr></table></figure></li>
<li><strong>当您需要显式地指定变量类型，即使类型推断也能工作</strong>（这在某些情况下可以提高代码清晰度）。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> port <span class="type">uint16</span> = <span class="number">8080</span> <span class="comment">// 确保端口是 uint16 类型</span></span><br></pre></td></tr></table></figure></li>
<li><strong>当您只是为现有变量重新赋值时。</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counter := <span class="number">0</span> <span class="comment">// 声明</span></span><br><span class="line">counter = <span class="number">1</span>  <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/AMQP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/AMQP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">AMQP协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:21:38" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好的，当然。AMQP（Advanced Message Queuing Protocol），即<strong>高级消息队列协议</strong>，是一个网络协议，用于在应用程序或系统之间传递消息。你可以把它理解为消息中间件领域的 “HTTP” 或 “SMTP”。它不是一个具体的软件（像 RabbitMQ），而是一个<strong>开放标准</strong>，定义了消息应该如何产生、传输、路由和消费。</p>
<p>作为一名运维工程师，我们经常接触到 RabbitMQ，而 RabbitMQ 就是 AMQP 协议最著名、最完整的实现者。理解 AMQP 能帮助我们更好地配置、监控和排查与消息队列相关的问题。</p>
<h3 id="AMQP-的核心思想：解耦和异步"><a href="#AMQP-的核心思想：解耦和异步" class="headerlink" title="AMQP 的核心思想：解耦和异步"></a>AMQP 的核心思想：解耦和异步</h3><p>AMQP 的主要目标是解决两个核心问题：</p>
<ol>
<li><strong>解耦 (Decoupling):</strong> 消息的发送方（生产者）和接收方（消费者）不需要知道对方的存在，它们只需要与中间的消息代理（Broker）通信。这使得系统组件可以独立开发、部署和扩展。</li>
<li><strong>异步 (Asynchronicity):</strong> 生产者发送消息后，不需要等待消费者处理完毕。消息会暂存在 Broker 中，消费者可以在自己方便的时候去获取和处理。这大大提高了系统的响应速度和吞吐量。</li>
</ol>
<h3 id="AMQP-协议的核心概念和模型"><a href="#AMQP-协议的核心概念和模型" class="headerlink" title="AMQP 协议的核心概念和模型"></a>AMQP 协议的核心概念和模型</h3><p>为了更好地理解 AMQP，我们可以把它想象成一个<strong>智能化的邮政系统</strong>。</p>
<ol>
<li><p><strong>Publisher (生产者):</strong></p>
<ul>
<li><strong>相当于寄信人。</strong> 负责创建消息并将其发送出去的应用程序。它只关心把信（消息）投递到邮局（Exchange），而不管谁会收到它。</li>
</ul>
</li>
<li><p><strong>Consumer (消费者):</strong></p>
<ul>
<li><strong>相当于收信人。</strong> 负责接收并处理消息的应用程序。它只关心从自己的邮箱（Queue）里取信。</li>
</ul>
</li>
<li><p><strong>Broker &#x2F; Server (消息代理):</strong></p>
<ul>
<li><strong>相当于整个邮政系统。</strong> 这是 AMQP 的核心，通常是一个独立的服务，比如 RabbitMQ Server。它接收来自生产者的消息，并根据规则将其路由给消费者。</li>
</ul>
</li>
<li><p><strong>Exchange (交换机):</strong></p>
<ul>
<li><strong>相当于邮局的分拣中心。</strong> 它是 Broker 内部的组件，负责接收生产者发来的消息，并根据<strong>路由键 (Routing Key)</strong> 和<strong>绑定规则 (Binding)</strong> 将消息分发到一个或多个队列中。它本身不存储消息。</li>
</ul>
</li>
<li><p><strong>Queue (队列):</strong></p>
<ul>
<li><strong>相当于邮箱。</strong> 它是 Broker 内部用于存储消息的缓冲区。消息在被消费者处理之前，会一直存放在队列中。一个队列可以被多个消费者共享（竞争消费），也可以被一个消费者独占。</li>
</ul>
</li>
<li><p><strong>Binding (绑定):</strong></p>
<ul>
<li><strong>相当于订阅关系或投递规则。</strong> 它定义了 Exchange 和 Queue 之间的关系。一个绑定就是告诉 Exchange：“请把符合这种规则的消息发送到这个 Queue 里”。</li>
</ul>
</li>
</ol>
<h3 id="消息的流转过程-The-Message-Flow"><a href="#消息的流转过程-The-Message-Flow" class="headerlink" title="消息的流转过程 (The Message Flow)"></a>消息的流转过程 (The Message Flow)</h3><ol>
<li><strong>建立连接:</strong> 生产者和消费者首先与 Broker 建立 TCP 连接 (Connection)。</li>
<li><strong>创建通道:</strong> 在连接之上创建信道 (Channel)。信道是轻量级的虚拟连接，大多数操作（如发送&#x2F;接收消息）都在信道上进行，这样可以减少 TCP 连接的开销。</li>
<li><strong>生产者发送消息:</strong><ul>
<li>生产者将消息发送给一个指定的 <strong>Exchange</strong>。</li>
<li>发送消息时，通常会附带一个 <strong>Routing Key</strong> (路由键)，就像信封上的地址或邮编。</li>
</ul>
</li>
<li><strong>Exchange 路由消息:</strong><ul>
<li>Exchange 收到消息后，会查找与自己<strong>绑定 (Binding)</strong> 的所有 <strong>Queue</strong>。</li>
<li>它会根据自身的类型和消息的 Routing Key，来决定将消息的副本发送到哪些 Queue。</li>
</ul>
</li>
<li><strong>消息进入队列:</strong> 消息被存入一个或多个符合路由规则的 Queue 中，等待被消费。</li>
<li><strong>消费者接收消息:</strong><ul>
<li>消费者订阅 (subscribe) 一个或多个 Queue。</li>
<li>Broker 将 Queue 中的消息推送给订阅的消费者。</li>
</ul>
</li>
<li><strong>确认 (Acknowledgement, ACK):</strong><ul>
<li>消费者处理完消息后，会向 Broker 发送一个**确认回执 (ACK)**。</li>
<li>Broker 收到 ACK 后，才会将该消息从 Queue 中彻底删除。如果在处理过程中消费者宕机或断开连接而没有发送 ACK，Broker 会认为消息没有被成功处理，并会将其重新投递给其他消费者，这保证了消息的<strong>可靠性</strong>。</li>
</ul>
</li>
</ol>
<h3 id="Exchange-的四种核心类型"><a href="#Exchange-的四种核心类型" class="headerlink" title="Exchange 的四种核心类型"></a>Exchange 的四种核心类型</h3><p>Exchange 的类型决定了它的路由行为，这是 AMQP 灵活性和强大功能的核心。</p>
<ol>
<li><p><strong>Direct Exchange (直接交换机):</strong></p>
<ul>
<li><strong>精确匹配。</strong> 只有当消息的 Routing Key 与 Binding 的 Routing Key <strong>完全一致</strong>时，消息才会被投递到对应的 Queue。非常适合一对一的消息分发。</li>
</ul>
</li>
<li><p><strong>Fanout Exchange (扇出交换机):</strong></p>
<ul>
<li><strong>广播模式。</strong> 它会忽略消息的 Routing Key，将收到的所有消息<strong>广播</strong>给所有与它绑定的 Queue。</li>
</ul>
</li>
<li><p><strong>Topic Exchange (主题交换机):</strong></p>
<ul>
<li><strong>模式匹配。</strong> 这是最灵活的一种。它允许使用通配符进行匹配。</li>
<li><code>*</code> (星号) 可以替代一个单词。</li>
<li><code>#</code> (井号) 可以替代零个或多个单词。</li>
<li>例如：一个 Routing Key 为 <code>log.error.kernel</code> 的消息，可以被 <code>log.error.*</code> 或 <code>log.#</code> 的 Binding 匹配到。</li>
</ul>
</li>
<li><p><strong>Headers Exchange (头交换机):</strong></p>
<ul>
<li><strong>基于消息头的匹配。</strong> 它不依赖 Routing Key，而是根据消息内容中的 <code>headers</code> 属性来进行匹配。性能稍差，使用较少。</li>
</ul>
</li>
</ol>
<h3 id="AMQP-协议的特点总结"><a href="#AMQP-协议的特点总结" class="headerlink" title="AMQP 协议的特点总结"></a>AMQP 协议的特点总结</h3><ul>
<li><strong>可靠性 (Reliability):</strong> 通过事务（Transactions）和确认机制 (ACK)，确保消息至少被成功处理一次 (At-least-once delivery)。</li>
<li><strong>灵活性 (Flexibility):</strong> 多种 Exchange 类型和灵活的路由规则，可以构建出各种复杂的消息拓扑，如发布&#x2F;订阅、路由、远程过程调用 (RPC) 等。</li>
<li><strong>互操作性 (Interoperability):</strong> 作为一个开放标准，理论上任何遵循 AMQP 协议的客户端都可以与任何遵循该协议的 Broker 通信。</li>
<li><strong>安全性 (Security):</strong> 支持通过 SASL 和 TLS&#x2F;SSL 进行认证和数据加密。</li>
</ul>
<p>总而言之，AMQP 是一个功能强大、特性丰富的消息协议，非常适合需要高可靠性和灵活路由的企业级应用场景。虽然它的模型比一些轻量级协议（如 MQTT）要复杂，但这种复杂性也带来了无与伦比的灵活性和可靠性保证。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/ARP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/ARP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">ARP协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:24:31" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好的，我们来详细了解一下 ARP 和 RARP。</p>
<hr>
<h3 id="1-ARP-Address-Resolution-Protocol-地址解析协议"><a href="#1-ARP-Address-Resolution-Protocol-地址解析协议" class="headerlink" title="1. ARP (Address Resolution Protocol) - 地址解析协议"></a>1. ARP (Address Resolution Protocol) - 地址解析协议</h3><p><strong>作用：</strong> 将<strong>网络层（IP 地址）</strong> 地址解析为<strong>数据链路层（MAC 地址）</strong> 的协议。</p>
<p><strong>应用场景：</strong><br>当一个主机想与同一局域网内的另一个主机进行通信时，它知道目标主机的 IP 地址，但数据链路层（如以太网）需要目标主机的 MAC 地址来封装帧。此时就需要 ARP 来完成 IP 到 MAC 的映射。</p>
<p><strong>工作原理（简化流程）：</strong></p>
<ol>
<li><strong>ARP 请求：</strong> 主机 A（已知主机 B 的 IP 地址）希望获取主机 B 的 MAC 地址，它会构建一个 ARP 请求报文，其中包含自己的 IP 地址和 MAC 地址，以及目标主机 B 的 IP 地址。</li>
<li><strong>广播：</strong> 主机 A 将这个 ARP 请求报文封装在一个以太网帧中，并将目的 MAC 地址设置为<strong>广播地址（FFFF.FFFF.FFFF）</strong>，然后发送到局域网中。</li>
<li><strong>接收与响应：</strong><ul>
<li>局域网中的所有主机都会收到这个广播帧。</li>
<li>每个主机都会检查 ARP 请求报文中的目标 IP 地址是否是自己的 IP 地址。</li>
<li>只有目标主机 B 会识别出这个 IP 地址是自己的。</li>
<li>主机 B 会将主机 A 的 IP 地址和 MAC 地址缓存起来（以备后续通信），然后构建一个 ARP 响应报文，其中包含自己的 MAC 地址和 IP 地址。</li>
</ul>
</li>
<li><strong>单播响应：</strong> 主机 B 将 ARP 响应报文封装在一个以太网帧中，并将目的 MAC 地址设置为主机 A 的 MAC 地址（因为主机 B 已经收到了主机 A 的 MAC 地址），然后以<strong>单播</strong>方式发送给主机 A。</li>
<li><strong>缓存：</strong> 主机 A 收到主机 B 的 ARP 响应后，就会将主机 B 的 IP 地址和 MAC 地址映射关系缓存到自己的 ARP 缓存表中，以便后续直接使用，避免重复请求。</li>
</ol>
<p><strong>总结 ARP：</strong> <strong>已知 IP 找 MAC。</strong></p>
<hr>
<h3 id="2-RARP-Reverse-Address-Resolution-Protocol-逆向地址解析协议"><a href="#2-RARP-Reverse-Address-Resolution-Protocol-逆向地址解析协议" class="headerlink" title="2. RARP (Reverse Address Resolution Protocol) - 逆向地址解析协议"></a>2. RARP (Reverse Address Resolution Protocol) - 逆向地址解析协议</h3><p><strong>作用：</strong> 将<strong>数据链路层（MAC 地址）</strong> 地址解析为<strong>网络层（IP 地址）</strong> 的协议。</p>
<p><strong>应用场景：</strong><br>RARP 主要用于无盘工作站。这些工作站在启动时没有自己的 IP 地址，它们只知道自己的 MAC 地址。为了能够连接到网络并获取其他配置信息（如引导文件），它们需要知道自己的 IP 地址。</p>
<p><strong>工作原理（简化流程）：</strong></p>
<ol>
<li><strong>RARP 请求：</strong> 无盘工作站（已知自己的 MAC 地址，但不知道 IP 地址）在启动时会构建一个 RARP 请求报文，其中包含自己的 MAC 地址。</li>
<li><strong>广播：</strong> 工作站将这个 RARP 请求报文封装在一个以太网帧中，并将目的 MAC 地址设置为<strong>广播地址</strong>，发送到局域网中。</li>
<li><strong>RARP 服务器响应：</strong> 局域网中预先配置好的 RARP 服务器会收到这个广播请求。<ul>
<li>RARP 服务器维护着一个 MAC 地址与 IP 地址的映射表。</li>
<li>它会查找请求报文中 MAC 地址对应的 IP 地址。</li>
<li>一旦找到，RARP 服务器就会构建一个 RARP 响应报文，其中包含请求工作站的 IP 地址。</li>
</ul>
</li>
<li><strong>单播响应：</strong> RARP 服务器将 RARP 响应报文封装在一个以太网帧中，以<strong>单播</strong>方式发送给请求工作站。</li>
<li><strong>获取 IP：</strong> 无盘工作站收到 RARP 响应后，就获取到了自己的 IP 地址，然后可以继续进行网络通信和启动引导。</li>
</ol>
<p><strong>总结 RARP：</strong> <strong>已知 MAC 找 IP。</strong></p>
<hr>
<h3 id="ARP-和-RARP-的主要区别："><a href="#ARP-和-RARP-的主要区别：" class="headerlink" title="ARP 和 RARP 的主要区别："></a>ARP 和 RARP 的主要区别：</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">ARP (Address Resolution Protocol)</th>
<th align="left">RARP (Reverse Address Resolution Protocol)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>功能</strong></td>
<td align="left"><strong>IP 地址 → MAC 地址</strong> (正向解析)</td>
<td align="left"><strong>MAC 地址 → IP 地址</strong> (逆向解析)</td>
</tr>
<tr>
<td align="left"><strong>发起者</strong></td>
<td align="left">任何需要通信但缺少目标 MAC 的主机</td>
<td align="left">通常是无盘工作站或启动时无 IP 的设备</td>
</tr>
<tr>
<td align="left"><strong>请求信息</strong></td>
<td align="left">包含自己的 IP&#x2F;MAC，目标 IP</td>
<td align="left">包含自己的 MAC 地址</td>
</tr>
<tr>
<td align="left"><strong>目标对象</strong></td>
<td align="left">网络中的任何主机</td>
<td align="left">网络中预先配置好的 RARP 服务器</td>
</tr>
<tr>
<td align="left"><strong>目的</strong></td>
<td align="left">实现网络层与数据链路层地址的映射，进行通信</td>
<td align="left">帮助设备启动时获取自己的 IP 地址</td>
</tr>
<tr>
<td align="left"><strong>流行度</strong></td>
<td align="left"><strong>非常常用，广泛使用</strong></td>
<td align="left"><strong>基本被 DHCP 替代，很少使用</strong></td>
</tr>
<tr>
<td align="left"><strong>替代者</strong></td>
<td align="left">无</td>
<td align="left">DHCP (Dynamic Host Configuration Protocol)</td>
</tr>
</tbody></table>
<h3 id="为什么-RARP-基本被-DHCP-替代了？"><a href="#为什么-RARP-基本被-DHCP-替代了？" class="headerlink" title="为什么 RARP 基本被 DHCP 替代了？"></a>为什么 RARP 基本被 DHCP 替代了？</h3><p>RARP 有一些局限性：</p>
<ol>
<li><strong>需要专门的 RARP 服务器：</strong> 每段子网都需要有 RARP 服务器来响应请求。</li>
<li><strong>每次启动都需要请求：</strong> 客户端每次启动都要重新请求 IP 地址。</li>
<li><strong>只提供 IP 地址：</strong> RARP 只能提供 IP 地址，不能提供子网掩码、网关、DNS 服务器等其他网络配置信息。</li>
</ol>
<p>而 <strong>DHCP (Dynamic Host Configuration Protocol)</strong> 协议则更为强大和灵活：</p>
<ul>
<li>DHCP 客户端在启动时发送一个 DHCP Discover 广播请求。</li>
<li>DHCP 服务器会响应并提供<strong>完整的网络配置信息</strong>，包括 IP 地址、子网掩码、默认网关、DNS 服务器地址等。</li>
<li>DHCP 支持 IP 地址的动态分配和租约管理，更加高效和易于管理。</li>
</ul>
<p>因此，现在几乎所有的设备都使用 DHCP 来获取 IP 地址和其他网络配置，RARP 已经很少在实际网络中使用了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/APISIX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/APISIX/" class="post-title-link" itemprop="url">APISIX</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：20:42:57" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="APISIX"><a href="#APISIX" class="headerlink" title="APISIX"></a>APISIX</h1><p><a target="_blank" rel="noopener" href="https://apisix.apache.org/">Apache APISIX</a> 是一个基于 <code>OpenResty</code> 和 Etcd 实现的动态、实时、高性能的 API 网关，目前已经是 Apache 顶级项目。提供了丰富的流量管理功能，如负载均衡、动态路由、动态 upstream、A&#x2F;B 测试、金丝雀发布、限速、熔断、防御恶意攻击、认证、监控指标、服务可观测性、服务治理等。可以使用 APISIX 来处理传统的南北流量以及服务之间的东西向流量。</p>
<p>APISIX 基于 Nginx 和 etcd，与传统 API 网关相比，APISIX 具有动态路由和热加载插件功能，避免了配置之后的 reload 操作，同时 APISIX 支持 HTTP(S)、HTTP2、Dubbo、QUIC、MQTT、TCP&#x2F;UDP 等更多的协议。而且还内置了 Dashboard，提供强大而灵活的界面。同样也提供了丰富的插件支持功能，而且还可以让用户自定义插件。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/t2audk.png" alt="APISIX 架构图"></p>
<p>上图是 APISIX 的架构图，整体上分成数据面和控制面两个部分，控制面用来管理路由，主要通过 etcd 来实现配置中心，数据面用来处理客户端请求，通过 APISIX 自身来实现，会不断去 watch etcd 中的 route、upstream 等数据。</p>
<h2 id="APISIX-Ingress"><a href="#APISIX-Ingress" class="headerlink" title="APISIX Ingress"></a>APISIX Ingress</h2><p>同样作为一个 API 网关，APISIX 也支持作为 Kubernetes 的一个 Ingress 控制器进行使用。APISIX Ingress 在架构上分成了两部分，一部分是 APISIX Ingress Controller，作为控制面它将完成配置管理与分发。另一部分 APISIX(代理) 负责承载业务流量。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/4918f9.png" alt="apisix-ingress-controller"></p>
<p>当 Client 发起请求，到达 Apache APISIX 后，会直接把相应的业务流量传输到后端（如 Service Pod），从而完成转发过程。此过程不需要经过 Ingress Controller，这样做可以保证一旦有问题出现，或者是进行变更、扩缩容或者迁移处理等，都不会影响到用户和业务流量。</p>
<p>同时在配置端，用户通过 <code>kubectl apply</code> 创建资源，可将自定义 CRD 配置应用到 K8s 集群，Ingress Controller 会持续 watch 这些资源变更，来将相应配置应用到 Apache APISIX（通过 admin api）。</p>
<p>从上图可以看出 APISIX Ingress 采用了数据面与控制面的分离架构，所以用户可以选择将数据面部署在 K8s 集群内部或外部。但 Ingress Nginx 是将控制面和数据面放在了同一个 Pod 中，如果 Pod 或控制面出现一点闪失，整个 Pod 就会挂掉，进而影响到业务流量。这种架构分离，给用户提供了比较方便的部署选择，同时在业务架构调整场景下，也方便进行相关数据的迁移与使用。</p>
<p>APISIX Ingress 控制器目前支持的核心特性包括：</p>
<ul>
<li>全动态，支持高级路由匹配规则，可与 Apache APISIX 官方 50 多个插件 &amp; 客户自定义插件进行扩展使用</li>
<li>支持 CRD，更容易理解声明式配置</li>
<li>兼容原生 Ingress 资源对象</li>
<li>支持流量切分</li>
<li>服务自动注册发现，无惧扩缩容</li>
<li>更灵活的负载均衡策略，自带健康检查功能</li>
<li>支持 gRPC plaintext 与 TCP 4 层代理</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们这里在 Kubernetes 集群中来使用 APISIX，可以通过 Helm Chart 来进行安装，首先添加官方提供的 Helm Chart 仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ helm repo add apisix https://charts.apiseven.com</span><br><span class="line">➜ helm repo update</span><br></pre></td></tr></table></figure>



<p>由于 APISIX 的 Chart 包中包含 dashboard 和 ingress 控制器的依赖，我们只需要在 values 中启用即可安装 ingress 控制器了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ helm fetch apisix/apisix</span><br><span class="line">➜ tar -xvf apisix-0.7.2.tgz</span><br><span class="line">➜ mkdir -p apisix/ci</span><br></pre></td></tr></table></figure>



<p>在 <code>apisix/ci</code> 目录中新建一个用于安装的 values 文件，内容如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ci/prod.yaml</span></span><br><span class="line"><span class="attr">apisix:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="comment"># 固定在node2节点上</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="string">node2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Cluster</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">9080</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 启用 tls</span></span><br><span class="line">    <span class="attr">servicePort:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">9443</span></span><br><span class="line"></span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 会自动创建3个节点的etcd集群</span></span><br><span class="line">  <span class="attr">replicaCount:</span> <span class="number">1</span> <span class="comment"># 多副本需要修改下模板，这里暂时运行一个etcd pod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dashboard:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingress-controller:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">apisix:</span></span><br><span class="line">      <span class="attr">serviceName:</span> <span class="string">apisix-admin</span></span><br><span class="line">      <span class="attr">serviceNamespace:</span> <span class="string">apisix</span> <span class="comment"># 指定命名空间，如果不是 ingress-apisix 需要重新指定</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>经测试官方的 Helm Chart 包对 etcd 多节点集群支持不是很好，我测试跑 3 个节点会出问题，另外对外部的 etcd tls 集群兼容度也不好，比如 dashboard 的 Chart 需要自己修改模板去支持 tls，所以这里我们测试先改成 1 个副本的 etcd 集群。</p>
</blockquote>
<p>APISIX 需要依赖 etcd，默认情况下 Helm Chart 会自动安装一个 3 副本的 etcd 集群，需要提供一个默认的 StorageClass（存储章节会详细讲解），如果你已经有默认的存储类则可以忽略下面的步骤，这里我们安装一个 nfs 的 provisioner，用下面的命令可以安装一个默认的 StorageClass：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/</span><br><span class="line">➜ helm upgrade --install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \</span><br><span class="line">--set nfs.server=192.168.31.31 \</span><br><span class="line">--set nfs.path=/var/lib/k8s/data \</span><br><span class="line">--set image.repository=cnych/nfs-subdir-external-provisioner \</span><br><span class="line">--set storageClass.defaultClass=true -n kube-system</span><br></pre></td></tr></table></figure>



<p>安装完成后会自动创建一个 StorageClass：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get sc</span><br><span class="line">NAME                   PROVISIONER                                     RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE</span><br><span class="line">nfs-client (default)   cluster.local/nfs-subdir-external-provisioner   Delete          Immediate              true                   35s</span><br></pre></td></tr></table></figure>



<p>然后直接执行下面的命令进行一键安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜ helm upgrade --install apisix ./apisix -f ./apisix/ci/prod.yaml -n apisix</span><br><span class="line">Release &quot;apisix&quot; does not exist. Installing it now.</span><br><span class="line">NAME: apisix</span><br><span class="line">LAST DEPLOYED: Thu Dec 30 16:28:38 2021</span><br><span class="line">NAMESPACE: apisix</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">NOTES:</span><br><span class="line">1. Get the application URL by running these commands:</span><br><span class="line">  export NODE_PORT=$(kubectl get --namespace apisix -o jsonpath=&quot;&#123;.spec.ports[0].nodePort&#125;&quot; services apisix-gateway)</span><br><span class="line">  export NODE_IP=$(kubectl get nodes --namespace apisix -o jsonpath=&quot;&#123;.items[0].status.addresses[0].address&#125;&quot;)</span><br><span class="line">  echo http://$NODE_IP:$NODE_PORT</span><br></pre></td></tr></table></figure>



<p>正常就可以成功部署 apisix 了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods -n apisix</span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">apisix-dashboard-b69d5c768-r6tqk             1/1     Running   0          85m</span><br><span class="line">apisix-etcd-0                                1/1     Running   0          90m</span><br><span class="line">apisix-fb8cdb569-wz9gq                       1/1     Running   0          87m</span><br><span class="line">apisix-ingress-controller-7d5bbf5dd5-r6khq   1/1     Running   0          85m</span><br><span class="line">➜ kubectl get svc -n apisix</span><br><span class="line">NAME                        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">apisix-admin                ClusterIP   10.97.108.252    &lt;none&gt;        9180/TCP                     24h</span><br><span class="line">apisix-dashboard            ClusterIP   10.108.202.136   &lt;none&gt;        80/TCP                       24h</span><br><span class="line">apisix-etcd                 ClusterIP   10.107.150.100   &lt;none&gt;        2379/TCP,2380/TCP            24h</span><br><span class="line">apisix-etcd-headless        ClusterIP   None             &lt;none&gt;        2379/TCP,2380/TCP            24h</span><br><span class="line">apisix-gateway              NodePort    10.97.214.188    &lt;none&gt;        80:32200/TCP,443:31417/TCP   24h</span><br><span class="line">apisix-ingress-controller   ClusterIP   10.103.176.26    &lt;none&gt;        80/TCP                       24h</span><br></pre></td></tr></table></figure>



<h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><p>现在我们可以为 Dashboard 创建一个路由规则，新建一个如下所示的 <code>ApisixRoute</code> 资源对象即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">apisix</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">apisix.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/*&#x27;</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">apisix-dashboard</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<p>创建后 <code>apisix-ingress-controller</code> 会将上面的资源对象通过 admin api 映射成 APISIX 中的配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get apisixroute -n apisixNAME        HOSTS                    URIS     AGE</span><br><span class="line">dashboard   [&quot;apisix.qikqiak.com&quot;]   [&quot;/*&quot;]   75m</span><br></pre></td></tr></table></figure>



<p>所以其实我们的访问入口是 APISIX，而 <code>apisix-ingress-controller</code> 只是一个用于监听 crds，然后将 crds 翻译成 APISIX 的配置的工具而已，现在就可以通过 <code>apisix-gateway</code> 的 NodePort 端口去访问我们的 dashboard 了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/ernkst.png" alt="dashboard"></p>
<p>当然如果不想在访问的时候域名后面带上端口，在云端环境可以直接将 <code>apisix-gateway</code> 这个 Service 设置成 LoadBalancer 模式，在本地测试的时候可以使用 <code>kubectl port-forward</code> 将服务暴露在节点的 80 端口上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node2 节点暴露 apisix-gateway 服务</span></span><br><span class="line">➜ kubectl port-forward --address 0.0.0.0 svc/apisix-gateway 80:80 443:443 -n apisix</span><br></pre></td></tr></table></figure>



<p>默认登录用户名和密码都是 admin，登录后在<code>路由</code>菜单下正常可以看到上面我们创建的这个 dashboard 的路由信息：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/wiec1f.png" alt="dashboard route"></p>
<p>点击<code>更多</code>下面的<code>查看</code>就可以看到在 APISIX 下面真正的路由配置信息：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/3ynwm1.png" alt="apisix config"></p>
<p>所以我们要使用 APISIX，也一定要理解其中的路由 Route 这个概念，路由（Route）是请求的入口点，它定义了客户端请求与服务之间的匹配规则，路由可以与服务（Service）、上游（Upstream）关联，一个服务可对应一组路由，一个路由可以对应一个上游对象（一组后端服务节点），因此，每个匹配到路由的请求将被网关代理到路由绑定的上游服务中。</p>
<p>理解了路由后自然就知道了我们还需要一个上游 Upstream 进行关联，这个概念和 Nginx 中的 Upstream 基本是一致的，在<code>上游</code>菜单下可以看到我们上面创建的 dashboard 对应的上游服务：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/836sgi.png" alt="Upstream"></p>
<p>其实就是将 Kubernetes 中的 Endpoints 映射成 APISIX 中的 Upstream，然后我们可以自己在 APISIX 这边进行负载。</p>
<p>APISIX 提供的 Dashboard 功能还是非常全面的，我们甚至都可以直接在页面上进行所有的配置，包括插件这些，非常方便。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/8v1lj2.png" alt="插件"></p>
<p>当然还有很多其他高级的功能，比如流量切分、请求认证等等，这些高级功能在 crds 中去使用则更加方便了，当然也是支持原生的 Ingress 资源对象的，关于 APISIX 的更多用法，后续再进行说明。</p>
<h2 id="URL-Rewrite"><a href="#URL-Rewrite" class="headerlink" title="URL Rewrite"></a>URL Rewrite</h2><p>同样我们来介绍下如何使用 APISIX 来实现 URL Rewrite 操作，同样还是以前面测试用过的 Nexus 应用为例进行说明，通过 <code>ApisixRoute</code> 对象来配置服务路由，对应的资源清单如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nexus.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nexus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nexus</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">cnych/nexus:3.20.1</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8081</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nexusport</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nexus</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/*&#x27;</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>直接创建上面的资源对象即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl apply -f nexus.yaml</span><br><span class="line">➜ kubectl get apisixroute</span><br><span class="line">NAME    HOSTS                   URIS     AGE</span><br><span class="line">nexus   [&quot;ops.qikqiak.com&quot;]   [&quot;/*&quot;]   39s</span><br><span class="line">➜ kubectl get pods -l app=nexus</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nexus-6f78b79d4c-b79r4   1/1     Running   0          48s</span><br><span class="line">➜ kubectl get svc -l app=nexus</span><br><span class="line">NAME    TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">nexus   ClusterIP   10.102.53.243   &lt;none&gt;        8081/TCP   58s</span><br></pre></td></tr></table></figure>



<p>部署完成后，我们根据 <code>ApisixRoute</code> 对象中的配置，只需要将域名 <code>ops.qikqiak.com</code> 解析到 node2 节点（上面通过 port-forward 暴露了 80 端口）即可访问：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/v6w782.png" alt="nexus"></p>
<p>同样如果现在需要通过一个子路径来访问 Nexus 应用的话又应该怎么来实现呢？比如通过 <code>http://ops.qikqiak.com/nexus</code> 来访问我们的应用，首先我们肯定需要修改 <code>ApisixRoute</code> 对象中匹配的 paths 路径，将其修改为 <code>/nexus</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>更新后我们可以通过 <code>http://ops.qikqiak.com/nexus</code> 访问应用：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/v3hn0k.png" alt="nexus 404"></p>
<p>仔细分析发现很多静态资源 404 了，这是因为现在我们只匹配了 <code>/nexus</code> 的请求，而我们的静态资源是 <code>/static</code> 路径开头的，当然就匹配不到了，所以就出现了 404，所以我们只需要加上这个 <code>/static</code> 路径的匹配就可以了，同样更新 ApisixRoute 对象，新增 <code>/static/*</code> 路径支持：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>更新后发现虽然静态资源可以正常访问了，但是当我们访问 <code>http://ops.qikqiak.com/nexus</code> 的时候依然会出现 404 错误。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/j0doah.png" alt="nexus 404"></p>
<p>这是因为我们这里是将 <code>/nexus</code> 路径的请求直接路由到后端服务去了，而后端服务没有对该路径做任何处理，所以也就是 404 的响应了，在之前 ingress-nginx 或者 traefik 中我们是通过 url 重写来实现的，而在 APISIX 中同样可以实现这个处理，相当于在请求在真正到达上游服务之前将请求的 url 重写到根目录就可以了，这里我们需要用到 <a target="_blank" rel="noopener" href="https://apisix.apache.org/zh/docs/apisix/plugins/proxy-rewrite">proxy-rewrite</a> 这个插件（需要确保在安装的时候已经包含了该插件），<code>proxy-rewrite</code> 是上游代理信息重写插件，支持对 scheme、uri、host 等信息的重写，该插件可配置的属性如下表所示：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/vk8n41.png" alt="proxy-rewrite 属性"></p>
<p>我们现在的需求是希望将所有 <code>/nexus</code> 下面的请求都重写到根路径 <code>/</code> 下面去，所以我们应该使用 <code>regex_uri</code> 属性，转发到上游的新 uri 地址, 使用正则表达式匹配来自客户端的 uri，当匹配成功后使用模板替换转发到上游的 uri, 未匹配成功时将客户端请求的 uri 转发至上游，重新修改后的 <code>ApisixRoute</code> 对象如下所示，新增 <code>plugins</code> 属性来配置插件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-rewrite</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^/nexus(/|$)(.*)&#x27;</span>, <span class="string">&#x27;/$2&#x27;</span>]</span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>这里我们启用一个 <code>proxy-rewrite</code> 插件，并且将所有 <code>/nexus</code> 路径的请求都重写到了 <code>/</code> 跟路径下，重新更新后再次访问 <code>http://ops.qikqiak.com/nexus</code> 应该就可以正常访问了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/9fwt92.png" alt="nexus"></p>
<p>只有最后一个小问题了，从浏览器网络请求中可以看出我们没有去匹配 <code>/service</code> 这个路径的请求，只需要配置上该路径即可，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/service/*&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-rewrite</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^/nexus(/|$)(.*)&#x27;</span>, <span class="string">&#x27;/$2&#x27;</span>]</span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>现在重新访问子路径就完成正常了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/et3x9n.png" alt="子路径"></p>
<h2 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h2><p>现在当我们访问 <code>http://ops.qikqiak.com/nexus</code> 或者 <code>http://ops.qikqiak.com/nexus/</code> 的时候都可以得到正常的结果，一般来说我们可能希望能够统一访问路径，比如访问 <code>/nexus</code> 子路径的时候可以自动跳转到 <code>/nexus/</code> 以 Splash 结尾的路径上去。同样要实现该需求我们只需要使用一个名为 <code>redirect</code> 的插件即可，该插件是 URI 重定向插件，可配置的属性如下所示：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20220107174345.png" alt="redirect 插件"></p>
<p>要实现我们的需求直接使用 <code>regex_uri</code> 这个属性即可，只需要去匹配 <code>/nexus</code> 的请求，然后进行跳转即可，更新 <code>ApisixRoute</code> 对象：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/service/*&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-rewrite</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^/nexus(/|$)(.*)&#x27;</span>, <span class="string">&#x27;/$2&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^(/nexus)$&#x27;</span>, <span class="string">&#x27;$1/&#x27;</span>]</span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>我们新启用了一个 <code>redirect</code> 插件，并配置 <code>regex_uri: [&quot;^(/nexus)$&quot;, &quot;$1/&quot;]</code>，这样当访问 <code>/nexus</code> 的时候会自动跳转到 <code>/nexus/</code> 路径下面去。</p>
<p>同样如果我们想要重定向到 https，只需要在该插件下面设置 <code>config.http_to_https=true</code> 即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ... 其他部分省略</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">http_to_https:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h2 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h2><p>通过使用上面的 <code>redirect</code> 插件配置 <code>http_to_https</code> 可以将请求重定向到 https 上去，但是我们现在并没有对我们的 <code>ops.qikqiak.com</code> 配置 https 证书，这里我们就需要使用 <code>ApisixTls</code> 对象来进行证书管理。</p>
<p>我们先使用 <code>openssl</code> 创建一个自签名的证书，当然你有正规 CA 机构购买的证书的话直接将证书下载下来使用即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj &quot;/CN=ops.qikqiak.com&quot;</span><br></pre></td></tr></table></figure>



<p>然后通过 Secret 对象来引用上面创建的证书文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要注意证书文件名称必须是 tls.crt 和 tls.key</span></span><br><span class="line">➜ kubectl create secret tls ops-tls --cert=tls.crt --key=tls.key</span><br></pre></td></tr></table></figure>



<p>然后就可以创建一个 <code>ApisixTls</code> 资源对象，引用上面的 Secret 即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixTls</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ops-tls</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">  <span class="attr">secret:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ops-tls</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>



<p>同时 APISIX TLS 还可以配置 <code>spec.client</code>，用于进行 mTLS 双向认证的配置。上面的资源对象创建完成后，即可访问 https 服务了（chrome 浏览器默认会限制不安全的证书，只需要在页面上输入 <code>thisisunsafe</code> 即可访问了）：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/tgrf70.png" alt="https"></p>
<p>而且当访问 http 的时候也会自动跳转到 https 上面去，此外我们还可以结合 cert-manager 来实现自动化的 https。</p>
<h2 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h2><p>身份认证在日常生活当中是非常常见的一项功能，大家平时基本都会接触到。比如用支付宝消费时的人脸识别确认、公司上班下班时的指纹&#x2F;面部打卡以及网站上进行账号密码登录操作等，其实都是身份认证的场景体现。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/nrmvoy.png" alt="auth"></p>
<p>如上图，Jack 通过账号密码请求服务端应用，服务端应用中需要有一个专门用做身份认证的模块来处理这部分的逻辑。请求处理完毕子后，如果使用 JWT Token 认证方式，服务器会反馈一个 Token 去标识这个用户为 Jack。如果登录过程中账号密码输入错误，就会导致身份认证失败。</p>
<p>但是每个应用服务模块去开发一个单独的身份认证模块，用来支持身份认证的一套流程处理，当服务量多了之后，就会发现这些模块的开发工作量都是非常巨大且重复的。这个时候，我们可以通过把这部分的开发逻辑放置到 Apache APISIX 的网关层来实现统一，减少开发量。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/xtuxsn.png" alt="apisix auth"></p>
<p>如上图所示，用户或应用方直接去请求 Apache APISIX，然后 Apache APISIX 通过识别并认证通过后，会将鉴别的身份信息传递到上游应用服务，之后上游应用服务就可以从请求头中读到这部分信息，然后进行后续的逻辑处理。</p>
<p>Apache APISIX 作为一个 API 网关，目前已开启与各种插件功能的适配合作，插件库也比较丰富。目前已经可与大量身份认证相关的插件进行搭配处理，如下图所示。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/rdea2v.png" alt="API 网关认证插件"></p>
<p>基础认证插件比如 <code>Key-Auth</code>、<code>Basic-Auth</code>，他们是通过账号密码的方式进行认证。复杂一些的认证插件如 <code>Hmac-Auth</code>、<code>JWT-Auth</code>，如 <code>Hmac-Auth</code> 通过对请求信息做一些加密，生成一个签名，当 API 调用方将这个签名携带到 Apache APISIX，Apache APISIX 会以相同的算法计算签名，只有当签名方和应用调用方认证相同时才予以通过。其他则是一些通用认证协议和联合第三方组件进行合作的认证协议，例如 <code>OpenID-Connect</code> 身份认证机制，以及 <code>LDAP</code> 认证等。</p>
<p>Apache APISIX 还可以针对每一个 Consumer （即调用方应用）去做不同级别的插件配置。如下图所示，我们创建了两个消费者 Consumer A、Consumer B，我们将 Consumer A 应用到应用 1，则后续应用 1 的访问将会开启 Consumer A 的这部分插件，例如 IP 黑白名单，限制并发数量等。将 Consumer B 应用到应用 2 ，由于开启了 http-log 插件，则应用 2 的访问日志将会通过 HTTP 的方式发送到日志系统进行收集。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/vy9bkn.png" alt="配置灵活"></p>
<p>总体说来 APISIX 的认证系统功能非常强大，我们非常有必要掌握。</p>
<h3 id="basic-auth"><a href="#basic-auth" class="headerlink" title="basic-auth"></a>basic-auth</h3><p>首先我们来了解下最简单的基本认证在 APISIX 中是如何使用的。<code>basic-auth</code> 是一个认证插件，它需要与 Consumer 一起配合才能工作。添加 Basic Auth 到一个 Service 或 Route，然后 Consumer 将其用户名和密码添加到请求头中以验证其请求。</p>
<p>首先我们需要在 APISIX Consumer 消费者中增加 basic auth 认证配置，为其指定用户名和密码，我们这里在 APISIX Ingress 中，可以通过 <code>ApisixConsumer</code> 资源对象进行配置，比如这里我们为前面的 nexus 实例应用添加一个基本认证，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nexus-basic-auth.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixConsumer</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexusBauth</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">authParameter:</span></span><br><span class="line">    <span class="attr">basicAuth:</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">admin321</span></span><br></pre></td></tr></table></figure>



<p><code>ApisixConsumer</code> 资源对象中只需要配置 <code>authParameter</code> 认证参数即可，目前只支持 <code>BasicAuth</code> 与 <code>KeyAuth</code> 两种认证类型，在 basicAuth 下面可以通过 value 可直接去配置相关的 username 和 password，也可以直接使用 Secret 资源对象进行配置，比起明文配置会更安全一些。</p>
<p>然后在 <code>ApisixRoute</code> 中添加 authentication，将其开启并指定认证类型即可，就可以实现使用 Consumer 去完成相关配置认证，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/service/*&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-rewrite</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^/nexus(/|$)(.*)&#x27;</span>, <span class="string">&#x27;/$2&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^(/nexus)$&#x27;</span>, <span class="string">&#x27;$1/&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">http_to_https:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br><span class="line">      <span class="attr">authentication:</span> <span class="comment"># 开启 basic auth 认证</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">basicAuth</span></span><br></pre></td></tr></table></figure>



<p>直接更新上面的资源即可开启 basic auth 认证了，在 Dashboard 上也可以看到创建了一个 Consumer：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20220111160306.png" alt="consumer"></p>
<p>然后我们可以进行如下的测试来进行验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缺少 Authorization header</span></span><br><span class="line">➜ curl -i http://ops.qikqiak.com/nexus/</span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">Date: Tue, 11 Jan 2022 07:44:49 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">WWW-Authenticate: Basic realm=&#x27;.&#x27;</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line">&#123;&quot;message&quot;:&quot;Missing authorization in request&quot;&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户名不存在</span></span><br><span class="line">➜ curl -i -ubar:bar http://ops.qikqiak.com/nexus/</span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">Date: Tue, 11 Jan 2022 07:45:07 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line">&#123;&quot;message&quot;:&quot;Invalid user key in authorization&quot;&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">成功请求</span></span><br><span class="line">➜ curl -uadmin:admin321 http://ops.qikqiak.com/nexus/</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h3 id="consumer-restriction"><a href="#consumer-restriction" class="headerlink" title="consumer-restriction"></a>consumer-restriction</h3><p>不过这里大家可能会有一个疑问，在 Route 上面我们并没有去指定具体的一个 Consumer，然后就可以进行 Basic Auth 认证了，那如果我们有多个 Consumer 都定义了 Basic Auth 岂不是都会生效的？确实是这样的，这就是 APISIX 的实现方式，所有的 Consumer 对启用对应插件的 Route 都会生效的，如果我们只想 Consumer A 应用在 Route A、Consumer B 应用在 Route B 上面的话呢？要实现这个功能就需要用到另外一个插件：<a target="_blank" rel="noopener" href="https://apisix.apache.org/zh/docs/apisix/plugins/consumer-restriction/">consumer-restriction</a>。</p>
<p><code>consumer-restriction</code> 插件可以根据选择的不同对象做相应的访问限制，该插件可配置的属性如下表所示：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/9jz6xt.png" alt="consumer restriction"></p>
<p>其中的 type 字段是个枚举类型，它可以是 <code>consumer_name</code> 或 <code>service_id</code>，分别代表以下含义：</p>
<ul>
<li><code>consumer_name</code>：把 consumer 的 username 列入白名单或黑名单（支持单个或多个 consumer）来限制对服务或路由的访问。</li>
<li><code>service_id</code>：把 service 的 id 列入白名单或黑名单（支持一个或多个 service）来限制 service 的访问，需要结合授权插件一起使用。</li>
</ul>
<p>比如现在我们有两个 Consumer：jack1 和 jack2，这两个 Consumer 都配置了 Basic Auth 认证，配置如下所示：</p>
<p>Conumer <code>jack1</code> 的认证配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ curl http://192.168.31.46/apisix/admin/consumers -H &#x27;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#x27; -X PUT -i -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;: &quot;jack1&quot;,</span><br><span class="line">    &quot;plugins&quot;: &#123;</span><br><span class="line">        &quot;basic-auth&quot;: &#123;</span><br><span class="line">            &quot;username&quot;:&quot;jack2019&quot;,</span><br><span class="line">            &quot;password&quot;: &quot;123456&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>Conumer <code>jack2</code> 的认证配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ curl http://192.168.31.46/apisix/admin/consumers -H &#x27;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#x27; -X PUT -i -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;: &quot;jack2&quot;,</span><br><span class="line">    &quot;plugins&quot;: &#123;</span><br><span class="line">        &quot;basic-auth&quot;: &#123;</span><br><span class="line">            &quot;username&quot;:&quot;jack2020&quot;,</span><br><span class="line">            &quot;password&quot;: &quot;123456&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>现在我们只想给一个 Route 路由对象启用 jack1 这个 Consumer 的认证配置，则除了启用 <code>basic-auth</code> 插件之外，还需要在 <code>consumer-restriction</code> 插件中配置一个 <code>whitelist</code> 白名单（当然配置黑名单也是可以的），如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜ curl http://192.168.31.46/apisix/admin/routes/1 -H &#x27;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#x27; -X PUT -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;uri&quot;: &quot;/index.html&quot;,</span><br><span class="line">    &quot;upstream&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;roundrobin&quot;,</span><br><span class="line">        &quot;nodes&quot;: &#123;</span><br><span class="line">            &quot;127.0.0.1:1980&quot;: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;plugins&quot;: &#123;</span><br><span class="line">        &quot;basic-auth&quot;: &#123;&#125;,</span><br><span class="line">        &quot;consumer-restriction&quot;: &#123;</span><br><span class="line">            &quot;whitelist&quot;: [</span><br><span class="line">                &quot;jack1&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>然后我们使用 jack1 去访问我们的路由进行验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -u jack2019:123456 http://127.0.0.1:9080/index.html -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>正常使用 jack2 访问就会认证失败了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -u jack2020:123456 http://127.0.0.1:9080/index.html -i</span><br><span class="line">HTTP/1.1 403 Forbidden</span><br><span class="line">...</span><br><span class="line">&#123;&quot;message&quot;:&quot;The consumer_name is forbidden.&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>所以当你只想让一个 Route 对象关联指定的 Consumer 的时候，记得使用 <code>consumer-restriction</code> 插件。</p>
<h3 id="jwt-auth"><a href="#jwt-auth" class="headerlink" title="jwt-auth"></a>jwt-auth</h3><p>在平时的应用中可能使用 jwt 认证的场景是最多的，同样在 APISIX 中也有提供 <code>jwt-auth</code> 的插件，它同样需要与 Consumer 一起配合才能工作，我们只需要添加 JWT Auth 到一个 Service 或 Route，然后 Consumer 将其密钥添加到查询字符串参数、请求头或 cookie 中以验证其请求即可。</p>
<p>由于目前 <code>ApisixConsumer</code> 还不支持 <code>jwt-auth</code> 配置，所以需要我们去 APISIX 手动创建一个 Consumer，可以通过 APISIX 的 API 进行创建，当然也可以直接通过 Dashboard 页面操作。在 Dashboard 消费者页面点击创建消费者：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/9z7ow8.png" alt="创建消费者"></p>
<p>点击<strong>下一步</strong>进入插件配置页面，这里我们需要启用 <code>jwt-auth</code> 这个插件：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/d2aie8.png" alt="启用jwt-auth"></p>
<p>在插件配置页面配置 <code>jwt-auth</code> 相关属性，可参考插件文档 <a target="_blank" rel="noopener" href="https://apisix.apache.org/zh/docs/apisix/plugins/jwt-auth/">https://apisix.apache.org/zh/docs/apisix/plugins/jwt-auth/</a>:</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/2p2o90.png" alt="配置jwt-auth"></p>
<p>可配置的属性如下表所示：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20220111184501.png" alt="jwt 属性"></p>
<p>然后提交即可创建完成 Consumer，然后我们只需要在需要的 Service 或者 Route 上开启 <code>jwt-auth</code> 即可，比如同样还是针对上面的 nexus 应用，我们只需要在 <code>ApisixRoute</code> 对象中启用一个 <code>jwt-auth</code> 插件即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/service/*&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jwt-auth</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">http_to_https:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^(/nexus)$&#x27;</span>, <span class="string">&#x27;$1/&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-rewrite</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^/nexus(/|$)(.*)&#x27;</span>, <span class="string">&#x27;/$2&#x27;</span>]</span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>需要注意的是 <code>authentication</code> 属性也不支持 <code>jwt-auth</code>，所以这里我们通过 <code>plugins</code> 进行启用，重新更新上面的对象后我们同样来测试验证下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://ops.qikqiak.com/nexus/</span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">Date: Tue, 11 Jan 2022 08:54:30 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line">&#123;&quot;message&quot;:&quot;Missing JWT token in request&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>要正常访问我们的服务就需要先进行登录获取 <code>jwt-auth</code> 的 token，通过 APISIX 的 <code>apisix/plugin/jwt/sign</code> 可以获取：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://192.168.31.46/apisix/plugin/jwt/sign\?key\=user-key</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 11 Jan 2022 09:01:29 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJ1c2VyLWtleSIsImV4cCI6MTY0MTk3ODA4OX0.rdzMxM4QAKI444c3SC3u3ZqfW9rKnsqrdorLHCGqrQg</span><br></pre></td></tr></table></figure>



<p>要注意上面我们在获取 token 的时候需要传递创建消费者的标识 key，因为可能有多个不同的 Consumer 消费者，然后我们将上面获得的 token 放入到 Header 头中进行访问：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://ops.qikqiak.com/nexus/ -H &#x27;Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJ1c2VyLWtleSIsImV4cCI6MTY0MTk3ODA4OX0.rdzMxM4QAKI444c3SC3u3ZqfW9rKnsqrdorLHCGqrQg&#x27;</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 8802</span><br><span class="line">Connection: keep-alive</span><br><span class="line">......</span><br><span class="line">Expires: 0</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>可以看到可以正常访问。同样也可以放到请求参数中验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://ops.qikqiak.com/nexus/?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJ1c2VyLWtleSIsImV4cCI6MTY0MTk3ODA4OX0.rdzMxM4QAKI444c3SC3u3ZqfW9rKnsqrdorLHCGqrQg</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>此外还可以放到 cookie 中进行验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://ops.qikqiak.com/nexus/ --cookie jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJ1c2VyLWtleSIsImV4cCI6MTY0MTk3ODA4OX0.rdzMxM4QAKI444c3SC3u3ZqfW9rKnsqrdorLHCGqrQg</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h2 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h2><p>除了 APISIX 官方内置的插件之外，我们也可以根据自己的需求去自定义插件，要自定义插件需要使用到 APISIX 提供的 Runner，目前已经支持 Java、Go 和 Python 语言的 Runner，这个 Runner 相当于是 APISIX 和自定义插件之间的桥梁，比如 <code>apache-apisix-python-runner</code> 这个项目通过 Python Runner 可以把 Python 直接应用到 APISIX 的插件开发中，整体架构如下所示：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/sr199a.png" alt="Apache APISIX work flow"></p>
<p>左边是 APISIX 的工作流程，右边的 <code>Plugin Runner</code> 是各语言的插件运行器，当在 APISIX 中配置一个 Plugin Runner 时，APISIX 会启动一个子进程运行 Plugin Runner，该子进程与 APISIX 进程属于同一个用户，当我们重启或重新加载 APISIX 时，Plugin Runner 也将被重启。</p>
<p>如果你为一个给定的路由配置了 <code>ext-plugin-*</code> 插件，请求命中该路由时将触发 APISIX 通过 <code>Unix Socket</code> 向 Plugin Runner 发起 RPC 调用。调用分为两个阶段：</p>
<ul>
<li><code>ext-plugin-pre-req</code>：在执行 APISIX 内置插件之前</li>
<li><code>ext-plugin-post-req</code>：在执行 APISIX 内置插件之后</li>
</ul>
<p>接下来我们就以 Python 为例来说明如何自定义插件，首先获取 <code>apache-apisix-python-runner</code> 项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ git clone https://github.com/apache/apisix-python-plugin-runner.git</span><br><span class="line">➜ cd apisix-python-plugin-runner</span><br><span class="line">➜ git checkout 0.1.0  # 切换刀0.1.0版本</span><br></pre></td></tr></table></figure>



<p>如果是开发模式，则我们可以直接使用下面的命令启动 Python Runner：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ APISIX_LISTEN_ADDRESS=unix:/tmp/runner.sock python3 apisix/main.py start</span><br></pre></td></tr></table></figure>



<p>启动后需要在 APISIX 配置文件中新增外部插件配置，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ vim /path/to/apisix/conf/config.yaml</span><br><span class="line">apisix:</span><br><span class="line">  admin_key:</span><br><span class="line">    - name: &quot;admin&quot;</span><br><span class="line">      key: edd1c9f034335f136f87ad84b625c8f1</span><br><span class="line">      role: admin</span><br><span class="line"></span><br><span class="line">ext-plugin:</span><br><span class="line">  path_for_test: /tmp/runner.sock</span><br></pre></td></tr></table></figure>



<p>通过 <code>ext-plugin.path_for_test</code> 指定 Python Runner 的 unix socket 文件路径即可，如果是生产环境则可以通过 <code>ext-plugin.cmd</code> 来指定 Runner 的启动命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ext-plugin:</span><br><span class="line">  cmd: [ &quot;python3&quot;, &quot;/path/to/apisix-python-plugin-runner/apisix/main.py&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure>



<p>我们这里的 APISIX 是运行 Kubernetes 集群中的，所以要在 APISIX 的 Pod 中去执行 Python Runner 的代码，我们自然需要将我们的 Python 代码放到 APISIX 的容器中去，然后安装自定义插件的相关依赖，直接在 APISIX 配置文件中添加上面的配置即可，所以我们这里基于 APISIX 的镜像来重新定制包含插件的镜像，在 <code>apisix-python-plugin-runner</code> 项目根目录下新增如下所示的 Dockerfile 文件：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> apache/apisix:<span class="number">2.10</span>.<span class="number">0</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /apisix-python-plugin-runner</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --update python3 py3-pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cd</span> /apisix-python-plugin-runner &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 -m pip install --upgrade pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 -m pip install -r requirements.txt --ignore-installed &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 setup.py install --force</span></span><br></pre></td></tr></table></figure>



<p>基于上面 Dockerfile 构建一个新的镜像，推送到 Docker Hub：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ docker build -t cnych/apisix:py3-plugin-2.10.0-alpine .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送到DockerHub</span></span><br><span class="line">➜ docker push cnych/apisix:py3-plugin-2.10.0-alpine</span><br></pre></td></tr></table></figure>



<p>接下来我们需要使用上面构建的镜像来安装 APISIX，我们这里使用的是 Helm Chart 进行安装的，所以需要通过 Values 文件进行覆盖，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ci/prod.yaml</span></span><br><span class="line"><span class="attr">apisix:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">cnych/apisix</span></span><br><span class="line">    <span class="attr">tag:</span> <span class="string">py3-plugin-2.10.0-alpine</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>



<p>由于官方的 Helm Chart 没有提供对 <code>ext-plugin</code> 配置的支持，所以需要我们手动修改模板文件 <code>templates/configmap.yaml</code>，在 <code>apisix</code> 属性同级目录下面新增 <code>ext-plugin</code> 相关配置，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.extPlugins.enabled</span> &#125;&#125;</span><br><span class="line"><span class="attr">ext-plugin:</span></span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.extPlugins.pathForTest</span> &#125;&#125;</span><br><span class="line">  <span class="attr">path_for_test:</span> &#123;&#123; <span class="string">.Values.extPlugins.pathForTest</span> &#125;&#125;</span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.extPlugins.cmds</span> &#125;&#125;</span><br><span class="line">  <span class="attr">cmd:</span></span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">range</span> <span class="string">$cmd</span> <span class="string">:=</span> <span class="string">.Values.extPlugins.cmds</span> &#125;&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;&#123; <span class="string">$cmd</span> &#125;&#125;</span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">nginx_config:</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">root</span>  <span class="comment"># fix 执行 python runner没权限的问题</span></span><br></pre></td></tr></table></figure>



<p>然后在定制的 Values 文件中添加如下所示的配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ci/prod.yaml</span></span><br><span class="line"><span class="attr">extPlugins:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cmds:</span> [<span class="string">&#x27;python3&#x27;</span>, <span class="string">&#x27;/apisix-python-plugin-runner/apisix/main.py&#x27;</span>, <span class="string">&#x27;start&#x27;</span>]</span><br></pre></td></tr></table></figure>



<p>接着就可以重新部署 APISIX 了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ helm upgrade --install apisix ./apisix -f ./apisix/ci/prod.yaml -n apisix</span><br></pre></td></tr></table></figure>



<p>部署完成后在 APISIX 的 Pod 中可以看到会启动一个 Python Runner 的子进程：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/tg916o.png" alt="apisix top"></p>
<p>在插件目录 <code>/apisix-python-plugin-runner/apisix/plugins</code> 中的 <code>.py</code> 文件都会被自动加载，上面示例中有两个插件 <code>stop.py</code> 和 <code>rewrite.py</code>，我们以 <code>stop.py</code> 为例进行说明，该插件代码如下所示：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apisix.runner.plugin.base <span class="keyword">import</span> Base</span><br><span class="line"><span class="keyword">from</span> apisix.runner.http.request <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> apisix.runner.http.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stop</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Stop, <span class="variable language_">self</span>).__init__(<span class="variable language_">self</span>.__class__.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">self, request: Request, response: Response</span>):</span><br><span class="line">        <span class="comment"># 可以通过 `self.config` 获取配置信息，如果插件配置为JSON将自动转换为字典结构</span></span><br><span class="line">        <span class="comment"># print(self.config)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置响应 Header 头</span></span><br><span class="line">        response.headers[<span class="string">&quot;X-Resp-A6-Runner&quot;</span>] = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        <span class="comment"># 设置响应body</span></span><br><span class="line">        response.body = <span class="string">&quot;Hello, Python Runner of APISIX&quot;</span></span><br><span class="line">        <span class="comment"># 设置响应状态码</span></span><br><span class="line">        response.status_code = <span class="number">201</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过调用 `self.stop()` 中断请求流程，此时将立即响应请求给客户端</span></span><br><span class="line">        <span class="comment"># 如果未显示调用 `self.stop()` 或 显示调用 `self.rewrite()`将继续将请求</span></span><br><span class="line">        <span class="comment"># 默认为 `self.rewrite()`</span></span><br><span class="line">        <span class="variable language_">self</span>.stop()</span><br></pre></td></tr></table></figure>



<p>实现插件首先必须要继承 <code>Base</code> 类，必须实现 <code>filter</code> 函数，插件执行核心业务逻辑就是在 <code>filter</code> 函数中，该函数只包含 <code>Request</code> 和 <code>Response</code> 类对象作为参数，<code>Request</code> 对象参数可以获取请求信息，<code>Response</code> 对象参数可以设置响应信息 ，<code>self.config</code> 可以获取插件配置信息，在 <code>filter</code> 函数中调用 <code>self.stop()</code> 时将马上中断请求，响应数据，调用 <code>self.rewrite()</code> 时，将会继续请求。</p>
<p>然后我们在前面的 Nexus 应用中新增一个路由来测试我们上面的 <code>stop</code> 插件，在 <code>ApisixRoute</code> 对象中新增一个路由规则，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ext</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/extPlugin&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ext-plugin-pre-req</span> <span class="comment"># 启用ext-plugin-pre-req插件</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">conf:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;stop&#x27;</span> <span class="comment"># 使用 stop 这个自定义插件</span></span><br><span class="line">                <span class="attr">value:</span> <span class="string">&#x27;&#123;&quot;body&quot;:&quot;hello&quot;&#125;&#x27;</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>直接创建上面的路由即可，核心配置是启用 <code>ext-plugin-pre-req</code> 插件（前提是在配置文件中已经启用该插件，在 Helm Chart 的 Values 中添加上），然后在 <code>config</code> 下面使用 <code>conf</code> 属性进行配置，<code>conf</code> 为数组格式可以同时设置多个插件，插件配置对象中 <code>name</code> 为插件名称，该名称需要与插件代码文件和对象名称一致，<code>value</code> 为插件配置，可以为 JSON 字符串。</p>
<p>创建后同样在 Dashboard 中也可以看到 APISIX 中的路由配置格式：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/z8tq8g.png" alt="apisix ext plugin"></p>
<p>接着我们可以来访问 <code>http://ops.qikqiak.com/extPlugin</code> 这个路径来验证我们的自定义插件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://ops.qikqiak.com/extPlugin</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Thu, 13 Jan 2022 07:04:50 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">accept: */*</span><br><span class="line">user-agent: curl/7.64.1</span><br><span class="line">host: ops.qikqiak.com</span><br><span class="line">X-Resp-A6-Runner: Python</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line">Hello, Python Runner of APISIX</span><br></pre></td></tr></table></figure>



<p>访问请求结果中有一个 <code>X-Resp-A6-Runner: Python</code> 头信息，返回的 body 数据为 <code>Hello, Python Runner of APISIX</code>，和我们在插件中的定义是符合的。到这里就完成了使用 Python 进行 APISIX 自定义插件，我们有任何的业务逻辑需要处理直接去定义一个对应的插件即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
