<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hui&#39;s Blog">
<meta property="og:url" content="http://example.com/page/25/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="六一">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/25/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%96%B0%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%20CubeFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%96%B0%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%20CubeFS/" class="post-title-link" itemprop="url">新一代云原生存储系统 CubeFS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:18:53" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">集群管理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="新一代云原生存储系统-CubeFS"><a href="#新一代云原生存储系统-CubeFS" class="headerlink" title="新一代云原生存储系统 CubeFS"></a>新一代云原生存储系统 CubeFS</h1><p><a target="_blank" rel="noopener" href="https://cubefs.io/zh/">CubeFS</a>是一种新一代云原生存储系统，支持 S3、HDFS 和 POSIX 等访问协议，支持多副本与纠删码两种存储引擎，为用户提供多租户、 多 AZ 部署以及跨区域复制等多种特性。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/44u60m.png" alt="CubeFS"></p>
<p>CubeFS 作为一个云原生的分布式存储平台，提供了多种访问协议，因此其应用场景也非常广泛，下面简单介绍几种比较典型的应用场景</p>
<ul>
<li>大数据分析：兼容 HDFS 协议，为 Hadoop 生态（如 Spark、Hive）提供统一存储底座，为计算引擎提供无限的存储空间以及大带宽的数据存储能力。</li>
<li>深度训练&#x2F;机器学习：作为分布式并行文件系统，支撑 AI 训练、模型存储及分发、IO 加速等需求。</li>
<li>容器共享存储：容器集群可以将容器镜像的配置文件或初始化加载数据存储在 CubeFS 上，在容器批量加载时实时读取。多 Pod 间通过 CubeFS 共享持久化数据，在 Pod 故障时可以进行快速故障切换。</li>
<li>数据库&amp;中间件：为数据库应用如 MySQL、ElasticSearch、ClickHouse 提供高并发、低时延云盘服务，实现彻底的存算分离。</li>
<li>在线服务：为在线业务(如广告、点击流、搜索)或终端用户的图、文、音视频等内容提供高可靠、低成本的对象存储服务。</li>
<li>传统 NAS 上云：替换线下传统本地存储及 NAS，助力 IT 业务上云。</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><code>CubeFS</code> 具有众多特性，包括：</p>
<p><strong>多协议</strong></p>
<p>兼容 S3、POSIX、HDFS 等多种访问协议，协议间访问可互通</p>
<ul>
<li>POSIX 兼容：兼容 POSIX 接口，让上层应用的开发变得极其简单，就跟使用本地文件系统一样便捷。此外，CubeFS 在实现时放松了对 POSIX 语义的一致性要求来兼顾文件和元文件操作的性能。</li>
<li>对象存储兼容：兼容 AWS 的 S3 对象存储协议，用户可以使用原生的 Amazon S3 SDK 管理 CubeFS 中的资源。</li>
<li>Hadoop 协议兼容：兼容 Hadoop FileSystem 接口协议，用户可以使用 CubeFS 来替换 HDFS，做到上层业务无感。</li>
</ul>
<p><strong>双引擎</strong></p>
<p>支持多副本及纠删码两种引擎，用户可以根据业务场景灵活选择</p>
<ul>
<li>多副本存储引擎：副本之间的数据为镜像关系，通过强一致的复制协议来保证副本之间的数据一致性，用户可以根据应用场景灵活的配置不同副本数。</li>
<li>纠删码存储引擎：纠删码引擎具备高可靠、高可用、低成本、支持超大规模(EB)的特性，根据不同 AZ 模型可以灵活选择纠删码模式。</li>
</ul>
<p><strong>多租户</strong></p>
<p>支持多租户管理，提供细粒度的租户隔离策略</p>
<p><strong>可扩展</strong></p>
<p>可以轻松构建 PB 或者 EB 级规模的分布式存储服务，各模块可水平扩展</p>
<p><strong>高性能</strong></p>
<p>支持多级缓存，针对小文件特定优化，支持多种高性能的复制协议</p>
<ul>
<li>元数据管理：元数据集群为内存元数据存储，在设计上使用两个 B-Tree（inodeBTree 与 dentryBTree）来管理索引，进而提升元数据访问性能；</li>
<li>强一致副本协议 ：CubeFS 根据文件写入方式的不同采用不同的复制协议来保证副本间的数据一致性。（如果文件按照顺序写入，则会使用主备复制协议来优化 IO 吞吐量；如果是随机写入覆盖现有文件内容时，则是采用一种基于 Multi-Raft 的复制协议，来确保数据的强一致性）；</li>
<li>多级缓存：纠删码卷支持多级缓存加速能力，针对热点数据，提供更高数据访问性能：</li>
<li>本地缓存：可以在 Client 机器上同机部署 BlockCache 组件，将本地磁盘作为本地缓存. 可以不经过网络直接读取本地 Cache, 但容量受本地磁盘限制；</li>
<li>全局缓存：使用副本组件 DataNode 搭建的分布式全局 Cache, 比如可以通过部署客户端同机房的 SSD 磁盘的 DataNode 作为全局 cache, 相对于本地 cache, 需要经过网络, 但是容量更大, 可动态扩缩容,副本数可调。</li>
</ul>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/gi2c8s.png" alt="img"></p>
<p><strong>云原生</strong></p>
<p>基于 CSI 插件可以快速地在 Kubernetes 上使用 CubeFS。</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>整体上 CubeFS 由元数据子系统（Metadata Subsystem）、数据子系统（Data Subsystem）和资源管理节点（Master）以及对象网关（Object Subsystem）组成，可以通过 POSIX&#x2F;HDFS&#x2F;S3 接口访问存储数据。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/s2rcaw.png" alt="img"></p>
<p><strong>资源管理节点</strong></p>
<p>由多个 Master 节点组成，负责异步处理不同类型的任务，如管理数据分片与元数据分片（包括创建、删除、更新以及一致性检查等），检查数据节点或者元数据节点的健康状态，维护管理卷信息等</p>
<blockquote>
<p>Master 节点可以有多个，节点之间通过 Raft 算法保证元数据的一致性，并且持久化到 <code>RocksDB</code> 中。</p>
</blockquote>
<p><strong>元数据子系统</strong></p>
<p>由多个 Meta Node 节点组成，多个元数据分片（Meta Partition）和 Raft 实例（基于 Multi-Raft 复制协议）组成，每个元数据分片表示一个 Inode 范围元数据，其中包含两棵内存 B-Tree 树：inode BTree 与 dentry BTree。</p>
<blockquote>
<p>元数据实例最少需要 3 个，支持水平扩容。</p>
</blockquote>
<p><strong>数据子系统</strong></p>
<p>分为副本子系统和纠删码子系统，两种子系统可同时存在，也都可单独存在：</p>
<ul>
<li>副本子系统由 DataNode 组成，每个节点管理一组数据分片，多个节点的数据分片构成一个副本组；</li>
<li>纠删码子系统（Blobstore）主要由 BlobNode 模块组成，每个节点管理一组数据块，多个节点的数据块构成一个纠删码条带。</li>
</ul>
<blockquote>
<p>数据节点支持水平扩容。</p>
</blockquote>
<p><strong>对象子系统</strong></p>
<p>由对象节点（ObjectNode）组成，提供了兼容标准 S3 语义的访问协议，可以通过 Amazon S3 SDK 或者是 s3cmd 等工具访问存储资源。</p>
<p><strong>卷</strong></p>
<p>逻辑上的概念，由多个元数据和数据分片组成，从客户端的角度看，卷可以被看作是可被容器访问的文件系统实例。从对象存储的角度来看，一个卷对应着一个 bucket。一个卷可以在多个容器中挂载，使得文件可以被不同客户端同时访问。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>CubeFS 的安装方式有很多，包括 Docker、YUM 等等，由于我们这里直接直接在 Kubernetes 上使用，因此我们可以通过 Helm 来安装 CubeFS，各组件会直接使用宿主机网络，使用 <code>hostPath</code> 将磁盘映射到容器中。</p>
<p>在 Kubernetes 集群中部署 CubeFS 可以按照下图所示的架构进行部署：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/zo97cs.png" alt="img"></p>
<p>CubeFS 目前由这四部分组成：</p>
<ul>
<li><code>Master</code>：资源管理节点，负责维护整个集群的元信息，部署为 StatefulSet 资源。</li>
<li><code>DataNode</code>：数据存储节点，需要挂载大量磁盘负责文件数据的实际存储，部署为 DaemonSet 资源。</li>
<li><code>MetaNode</code>：元数据节点，负责存储所有的文件元信息，部署为 DaemonSet 资源。</li>
<li><code>ObjectNode</code>：负责提供转换 S3 协议提供对象存储的能力，无状态服务，部署为 Deployment 资源。</li>
</ul>
<p>在部署之前，我们需要拥有一个至少有 3 个节点（最好 4 个以上，可以容灾）的 Kubernetes 集群，且集群版本需要大于等于 1.15。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME     STATUS   ROLES           AGE   VERSION</span><br><span class="line">master   Ready    control-plane   46d   v1.28.7</span><br><span class="line">node1    Ready    &lt;none&gt;          46d   v1.28.7</span><br><span class="line">node2    Ready    &lt;none&gt;          46d   v1.28.7</span><br></pre></td></tr></table></figure>

<p>首先我们需要给节点打上各自的标签，标明这台机器要在 CubeFS 集群中承担的角色：</p>
<blockquote>
<p>由于我们这里只有 3 个节点，所以需要这些节点承担一些共同的角色。</p>
</blockquote>
<ul>
<li><code>Master</code> 节点，至少三个，建议为奇数个:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node master component.cubefs.io/master=enabled</span><br><span class="line">kubectl label node node1 component.cubefs.io/master=enabled</span><br><span class="line">kubectl label node node2 component.cubefs.io/master=enabled</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MetaNode</code> 元数据节点，至少 3 个，奇偶无所谓:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node master component.cubefs.io/metanode=enabled</span><br><span class="line">kubectl label node node1 component.cubefs.io/metanode=enabled</span><br><span class="line">kubectl label node node2 component.cubefs.io/metanode=enabled</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Datanode</code> 数据节点，至少 3 个，奇偶无所谓:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node master component.cubefs.io/datanode=enabled</span><br><span class="line">kubectl label node node1 component.cubefs.io/datanode=enabled</span><br><span class="line">kubectl label node node2 component.cubefs.io/datanode=enabled</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ObjectNode</code> 对象存储节点，可以按需进行标记，不需要对象存储功能的话也可以不部署这个组件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node node1 component.cubefs.io/objectnode=enabled</span><br><span class="line">kubectl label node node2 component.cubefs.io/objectnode=enabled</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CSI</code> 组件，用于在 Kubernetes 中使用 CubeFS，需要在所有节点上部署：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node node1 component.cubefs.io/csi=enabled</span><br><span class="line">kubectl label node node2 component.cubefs.io/csi=enabled</span><br></pre></td></tr></table></figure>

<p>CubeFS 安装时会根据这些标签通过 <code>nodeSelector</code> 进行匹配，然后在机器创建起对应的 Pod。</p>
<p>接下来我们就可以通过 Helm 来安装 CubeFS 了，首先我们需要将 CubeFS 的 Helm Chart 下载到本地：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/cubefs/cubefs-helm</span><br><span class="line"><span class="built_in">cd</span> cubefs-helm</span><br></pre></td></tr></table></figure>

<p>然后根据自身环境定制 values 文件，比如下面是一个简单的 values 文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cubefs-values.yaml</span></span><br><span class="line"><span class="attr">component:</span></span><br><span class="line">  <span class="attr">master:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">datanode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">metanode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">objectnode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">client:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">csi:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">monitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">ingress:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="comment"># 3.3.0 版本之前会出现 /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21&#x27; not found 错误</span></span><br><span class="line">  <span class="attr">server:</span> <span class="string">cubefs/cfs-server:v3.3.0</span></span><br><span class="line">  <span class="attr">client:</span> <span class="string">cubefs/cfs-client:v3.3.0</span></span><br><span class="line">  <span class="attr">csi_driver:</span> <span class="string">cnych/cubefs-cfs-csi-driver:3.2.0.150.0</span></span><br><span class="line">  <span class="attr">csi_provisioner:</span> <span class="string">cnych/csi-provisioner:v2.2.2</span></span><br><span class="line">  <span class="attr">csi_attacher:</span> <span class="string">cnych/csi-attacher:v3.4.0</span></span><br><span class="line">  <span class="attr">csi_resizer:</span> <span class="string">cnych/csi-resizer:v1.3.0</span></span><br><span class="line">  <span class="attr">driver_registrar:</span> <span class="string">cnych/csi-node-driver-registrar:v2.5.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">master:</span></span><br><span class="line">  <span class="comment"># The replicas of master component, at least 3, recommend to be an odd number</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;node-role.kubernetes.io/control-plane&quot;</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metanode:</span></span><br><span class="line">  <span class="attr">total_mem:</span> <span class="string">&quot;4000000000&quot;</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;node-role.kubernetes.io/control-plane&quot;</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">datanode:</span></span><br><span class="line">  <span class="comment"># DataNode 要使用的磁盘，可以挂载多块</span></span><br><span class="line">  <span class="comment"># 格式: 挂载点:保留的空间</span></span><br><span class="line">  <span class="comment"># 保留的空间: 单位字节，当磁盘剩余空间小于该值时将不会再在该磁盘上写入数据</span></span><br><span class="line">  <span class="attr">disks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/data0:10000000000</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;node-role.kubernetes.io/control-plane&quot;</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">csi:</span></span><br><span class="line">  <span class="attr">driverName:</span> <span class="string">csi.cubefs.com</span></span><br><span class="line">  <span class="attr">logLevel:</span> <span class="string">error</span></span><br><span class="line">  <span class="attr">kubeletPath:</span> <span class="string">/var/lib/kubelet</span></span><br><span class="line">  <span class="attr">controller:</span></span><br><span class="line">    <span class="attr">tolerations:</span> []</span><br><span class="line">    <span class="attr">nodeSelector:</span></span><br><span class="line">      <span class="attr">component.cubefs.io/csi:</span> <span class="string">&quot;enabled&quot;</span></span><br><span class="line">  <span class="attr">node:</span></span><br><span class="line">    <span class="attr">tolerations:</span> []</span><br><span class="line">    <span class="attr">nodeSelector:</span></span><br><span class="line">      <span class="attr">component.cubefs.io/csi:</span> <span class="string">&quot;enabled&quot;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">storageClass:</span></span><br><span class="line">    <span class="attr">setToDefault:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">reclaimPolicy:</span> <span class="string">&quot;Delete&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CSI 客户端配置</span></span><br><span class="line"><span class="attr">provisioner:</span></span><br><span class="line">  <span class="comment"># Kubelet 的主目录</span></span><br><span class="line">  <span class="attr">kubelet_path:</span> <span class="string">/var/lib/kubelet</span></span><br></pre></td></tr></table></figure>

<p>然后使用如下命令进行 CubeFS 部署：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade --install cubefs -n cubefs-system ./cubefs-helm/cubefs -f cubefs-values.yaml --create-namespace</span><br></pre></td></tr></table></figure>

<p>部署完成后可以使用命令 <code>kubectl get pods -n cubefs-system</code> 等待所有组件状态变为 Running 即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -n cubefs-system</span><br><span class="line">NAME                                  READY   STATUS     RESTARTS   AGE</span><br><span class="line">cfs-csi-controller-66cdbb664f-pqkp6   4/4     Running    0          28m</span><br><span class="line">cfs-csi-node-966t9                    2/2     Running    0          25m</span><br><span class="line">cfs-csi-node-9f4ts                    2/2     Running    0          25m</span><br><span class="line">datanode-4zfhc                        1/1     Running    0          28m</span><br><span class="line">datanode-blc8w                        1/1     Running    0          28m</span><br><span class="line">datanode-ldj72                        1/1     Running    0          28m</span><br><span class="line">master-0                              1/1     Running    0          28m</span><br><span class="line">master-1                              1/1     Running    0          23m</span><br><span class="line">master-2                              1/1     Running    0          23m</span><br><span class="line">metanode-5csgt                        1/1     Running    0          7m31s</span><br><span class="line">metanode-jvqnl                        1/1     Running    0          7m31s</span><br><span class="line">metanode-vpjtj                        1/1     Running    0          7m31s</span><br></pre></td></tr></table></figure>

<p>各个组件的关键日志会在容器标准输出中输出。</p>
<p>此外还会自动创建一个 <code>StorageClass</code> 对象，可以通过 <code>kubectl get sc</code> 查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get sc</span><br><span class="line">NAME         PROVISIONER                                   RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class="line">cfs-sc       csi.cubefs.com                                Delete          Immediate           <span class="literal">true</span>                   29m</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在我们有了一个可用的 StorageClass 对象了，接下来可以创建一个 PVC 对象来测试 CubeFS 的存储功能。如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cubefs-pvc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cubefs-pvc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">cfs-sc</span></span><br></pre></td></tr></table></figure>

<p>上面的 PVC 对象中我们通过 <code>storageClassName</code> 指定了使用的 StorageClass 名称，这里是 <code>cfs-sc</code>，这个名称需要和我们之前创建的 StorageClass 名称一致，这样就会根据 <code>cubefs-sc</code> 中定义的参数来创建存储卷。当我们在编写 pvc yaml 主要注意一下参数：</p>
<ul>
<li><code>metadata.name</code>：pvc 的名称，可以按需修改，同一个 namespace 下 pvc 名称是唯一的，不允许有两个相同的名称。</li>
<li><code>metadata.namespace</code>：pvc 所在的命名空间，按需修改</li>
<li><code>spec.resources.request.storage</code>：pvc 容量大小。</li>
<li><code>storageClassName</code>：这是 storage class 的名称。如果想知道当前集群有哪些 storageclass，可以通过命令 <code>kubectl get sc</code> 来查看。</li>
</ul>
<p>这里直接应用这个 yaml 文件即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f cubefs-pvc.yaml</span><br></pre></td></tr></table></figure>

<p>执行命令完成后，可以通过命令 <code>kubectl get pvc -n 命名空间</code> 来查看对应 pvc 的状态，Pending 代表正在等待，Bound 代表创建成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME         STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">cubefs-pvc   Bound    pvc-53cc95b7-8a05-43f8-8903-f1c6f7b11c05   5Gi        RWO            cfs-sc         3s</span><br></pre></td></tr></table></figure>

<p>如果 PVC 的状态一直处于 Pending，可以通过命令查看原因：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pvc -n 命名空间 PVC 名称</span><br></pre></td></tr></table></figure>

<p>如果报错消息不明显或者看不出错误，则可以使用 <code>kubectl logs</code> 相关命令先查看 csi controller pod 里面的 <code>csi-provisioner</code> 容器的报错信息，<code>csi-provisioner</code> 是 k8s 与 csi driver 的中间桥梁，很多信息都可以在这里的日志查看。</p>
<p>如果 <code>csi-provisioner</code> 的日志还看不出具体问题，则使用 <code>kubectl exec</code> 相关命令查看 csi controller pod 里面的 cfs-driver 容器的日志，它的日志放在容器里面的 <code>/cfs/logs</code> 下。</p>
<p>这里不能使用 Kubectl logs 相关命令是因为 cfs-driver 的日志并不是打印到标准输出，而其它几个类似 <code>csi-provisioner</code> 的 sidecar 容器的日志是打印到标准输出的，所以可以使用 <code>kubectl logs</code> 相关命令查看。</p>
<p>有了 PVC 则接下来就可以在应用中挂载到指定目录了，比如我们这里有一个如下所示的示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cfs-csi-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cfs-csi-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">cfs-csi-demo-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">cfs-csi-demo-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">component.cubefs.io/csi:</span> <span class="string">enabled</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cfs-csi-demo</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.9</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">&quot;IfNotPresent&quot;</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">&quot;http-server&quot;</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span></span><br><span class="line">              <span class="attr">mountPropagation:</span> <span class="string">HostToContainer</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mypvc</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mypvc</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">cubefs-pvc</span></span><br></pre></td></tr></table></figure>

<p>上面的资源清单中我们将一个名称为 <code>cubefs-pvc</code> 的 PVC 挂载到 <code>cfs-csi-demo</code> 容器里面的 <code>/usr/share/nginx/html</code> 下。</p>
<p>同样直接创建这个资源清单即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f cfs-csi-demo.yaml</span><br></pre></td></tr></table></figure>

<p>创建完成后可以通过 <code>kubectl get pods</code> 查看 Pod 的状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -owide</span><br><span class="line">NAME                                      READY   STATUS    RESTARTS       AGE   IP           NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">cfs-csi-demo-5d456c8d97-sjsvw             1/1     Running   0              78s   10.0.1.85    node1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以直接通过往 <code>/usr/share/nginx/html</code> 目录写入文件来测试 CubeFS 的存储功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> -it cfs-csi-demo-5d456c8d97-sjsvw -- /bin/bash</span><br><span class="line">root@cfs-csi-demo-5d456c8d97-sjsvw:/# <span class="built_in">echo</span> <span class="string">&quot;Hello, CubeFS&quot;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line">root@cfs-csi-demo-5d456c8d97-sjsvw:/#</span><br></pre></td></tr></table></figure>

<p>然后我们可以将这个 Pod 删除重建，然后查看是否还有这个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pod cfs-csi-demo-5d456c8d97-sjsvw</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                                      READY   STATUS    RESTARTS       AGE</span><br><span class="line">cfs-csi-demo-5d456c8d97-c245z             1/1     Running   0              3m22s</span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it cfs-csi-demo-5d456c8d97-c245z -- <span class="built_in">ls</span> /usr/share/nginx/html</span><br><span class="line">index.html</span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it cfs-csi-demo-5d456c8d97-c245z -- <span class="built_in">cat</span> /usr/share/nginx/html/index.html</span><br><span class="line">Hello, CubeFS</span><br></pre></td></tr></table></figure>

<p>如果能够看到 <code>Hello, CubeFS</code> 则说明 CubeFS 的存储功能正常。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" class="post-title-link" itemprop="url">服务发现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:12:43" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>由于我们这里每个节点上面都运行了 <code>node-exporter</code> 程序，当然我们也可以手动的把所有节点用静态的方式配置到 Prometheus 中去，但是以后要新增或者去掉节点的时候就还得手动去配置，那么有没有一种方式可以让 Prometheus 去自动发现我们节点的 <code>node-exporter</code> 程序，并且按节点进行分组呢？这就是 Prometheus 里面非常重要的<strong>服务发现</strong>功能了。</p>
<h2 id="节点发现"><a href="#节点发现" class="headerlink" title="节点发现"></a>节点发现</h2><p>在 Kubernetes 下，Promethues 通过与 Kubernetes API 集成，主要支持 5 中服务发现模式，分别是：<code>Node</code>、<code>Service</code>、<code>Pod</code>、<code>Endpoints</code>、<code>Ingress</code>。</p>
<p>我们通过 kubectl 命令可以很方便的获取到当前集群中的所有节点信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES                  AGE   VERSION</span><br><span class="line">master1   Ready    control-plane,master   55d   v1.22.2</span><br><span class="line">node1     Ready    &lt;none&gt;                 55d   v1.22.2</span><br><span class="line">node2     Ready    &lt;none&gt;                 55d   v1.22.2</span><br></pre></td></tr></table></figure>

<p>但是要让 Prometheus 也能够获取到当前集群中的所有节点信息的话，我们就需要利用 Node 的服务发现模式，同样的，在 <code>prometheus.yml</code> 文件中配置如下的 job 任务即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;nodes&#x27;</span></span><br><span class="line">  <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">node</span></span><br></pre></td></tr></table></figure>

<p>通过指定 <code>kubernetes_sd_configs</code> 的模式为<code>node</code>，Prometheus 就会自动从 Kubernetes 中发现所有的 node 节点并作为当前 job 监控的目标实例，发现的节点 <code>/metrics</code> 接口是默认的 kubelet 的 HTTP 接口。</p>
<p>prometheus 的 ConfigMap 更新完成后，同样的我们执行 reload 操作，让配置生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl apply -f kubectl apply -f https://p8s.io/docs/k8s/manifests/prometheus/config-4.yaml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">隔一会儿执行reload操作</span></span><br><span class="line">☸ ➜ curl -X POST &quot;http://10.244.2.46:9090/-/reload&quot;</span><br></pre></td></tr></table></figure>

<p>配置生效后，我们再去 prometheus 的 dashboard 中查看 Targets 是否能够正常抓取数据：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/iyw0wf.png" alt="prometheus webui nodes"></p>
<p>我们可以看到上面的 <code>nodes</code> 这个 job 任务已经自动发现了我们 3 个 node 节点，但是在获取数据的时候失败了，出现了类似于下面的错误信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server returned HTTP status 400 Bad Request</span><br></pre></td></tr></table></figure>

<p>这个是因为 prometheus 去发现 Node 模式的服务的时候，访问的端口默认是 10250，而默认是需要认证的 https 协议才有权访问的，但实际上我们并不是希望让去访问 10250 端口的 <code>/metrics</code> 接口，而是 <code>node-exporter</code> 绑定到节点的 9100 端口，所以我们应该将这里的 <code>10250</code> 替换成 <code>9100</code>，但是应该怎样替换呢？</p>
<h2 id="relabel"><a href="#relabel" class="headerlink" title="relabel"></a>relabel</h2><p>这里我们就需要使用到 Prometheus 提供的 <code>relabel_configs</code> 中的 <code>replace</code> 能力了，<code>relabel</code> 可以在 Prometheus 采集数据之前，通过 Target 实例的 <code>Metadata</code> 信息，动态重新写入 Label 的值。除此之外，我们还能根据 Target 实例的 <code>Metadata</code> 信息选择是否采集或者忽略该 Target 实例。比如我们这里就可以去匹配 <code>__address__</code> 这个 Label 标签，然后替换掉其中的端口，如果你不知道有哪些 Label 标签可以操作的话，可以切换到 Service Discovery 页面找到 <code>nodes</code> 任务，下面的 <code>Discovered Labels</code> 就是我们可以操作的标签：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20211220155107.png" alt="prometheus webui relabel before"></p>
<p>现在我们来替换掉端口，修改 ConfigMap：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;nodes&#x27;</span></span><br><span class="line">  <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">node</span></span><br><span class="line">  <span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>]</span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&#x27;(.*):10250&#x27;</span></span><br><span class="line">      <span class="attr">replacement:</span> <span class="string">&#x27;$&#123;1&#125;:9100&#x27;</span></span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">      <span class="attr">action:</span> <span class="string">replace</span></span><br></pre></td></tr></table></figure>

<p>这里就是一个正则表达式，去匹配 <code>__address__</code> 这个标签，然后将 host 部分保留下来，port 替换成了 9100，现在我们重新更新配置文件，执行 reload 操作，然后再去看 Prometheus 的 Dashboard 的 Targets 路径下面 nodes 这个 job 任务是否正常了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/uf3ei6.png" alt="prometheus webui sd nodes"></p>
<p>我们可以看到现在已经正常了，但是还有一个问题就是我们采集的指标数据 Label 标签就只有一个节点的 hostname，这对于我们在进行监控分组分类查询的时候带来了很多不方便的地方，要是我们能够将集群中 Node 节点的 Label 标签也能获取到就很好了。这里我们可以通过 <code>labelmap</code> 这个属性来将 Kubernetes 的 Label 标签添加为 Prometheus 的指标数据的标签：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-nodes&#x27;</span></span><br><span class="line">  <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">node</span></span><br><span class="line">  <span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>]</span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&#x27;(.*):10250&#x27;</span></span><br><span class="line">      <span class="attr">replacement:</span> <span class="string">&#x27;$&#123;1&#125;:9100&#x27;</span></span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">      <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">__meta_kubernetes_node_label_(.+)</span></span><br></pre></td></tr></table></figure>

<p>添加了一个 action 为 <code>labelmap</code>，正则表达式是 <code>__meta_kubernetes_node_label_(.+)</code> 的配置，这里的意思就是表达式中匹配都的数据也添加到指标数据的 Label 标签中去。</p>
<p>重新配置后的监控目标标签就多了很多了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/apttah.png" alt="nodes labelmap"></p>
<p>对于 <code>kubernetes_sd_configs</code> 下面可用的元信息标签如下：</p>
<ul>
<li><code>__meta_kubernetes_node_name</code>：节点对象的名称</li>
<li><code>_meta_kubernetes_node_label</code>：节点对象中的每个标签</li>
<li><code>_meta_kubernetes_node_annotation</code>：来自节点对象的每个注释</li>
<li><code>_meta_kubernetes_node_address</code>：每个节点地址类型的第一个地址（如果存在）</li>
</ul>
<p>关于 kubernets_sd_configs 更多信息可以查看官方文档：<a target="_blank" rel="noopener" href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#">kubernetes_sd_config</a></p>
<p>另外由于 kubelet 也自带了一些监控指标数据，就上面我们提到的 10250 端口，所以我们这里也把 kubelet 的监控任务也一并配置上：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubelet&#x27;</span></span><br><span class="line">  <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">node</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">  <span class="attr">tls_config:</span></span><br><span class="line">    <span class="attr">ca_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span></span><br><span class="line">    <span class="attr">insecure_skip_verify:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">bearer_token_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/token</span></span><br><span class="line">  <span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">__meta_kubernetes_node_label_(.+)</span></span><br></pre></td></tr></table></figure>

<p>但是这里需要特别注意的是这里必须使用 <code>https</code> 协议访问，这样就必然需要提供证书，我们这里是通过配置 <code>insecure_skip_verify: true</code> 来跳过了证书校验，但是除此之外，要访问集群的资源，还必须要有对应的权限才可以，也就是对应的 ServiceAccount 棒的 权限允许才可以，我们这里部署的 prometheus 关联的 ServiceAccount 对象前面我们已经提到过了，这里我们只需要将 Pod 中自动注入的 <code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</code> 和 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 文件配置上，就可以获取到对应的权限了。</p>
<p>现在我们再去更新下配置文件，执行 reload 操作，让配置生效，然后访问 Prometheus 的 Dashboard 查看 Targets 路径：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/fiicax.png" alt="prometheus webui sd kubelet"></p>
<p>现在可以看到我们上面添加的 <code>kubelet</code> 和 <code>nodes</code> 这两个 job 任务都已经配置成功了，而且二者的 Labels 标签都和集群的 node 节点标签保持一致了。</p>
<p>现在我们就可以切换到 Graph 路径下面查看采集的一些指标数据了，比如查询 node_load1 指标：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/3sov2b.png" alt="prometheus webui node load1"></p>
<p>我们可以看到将 3 个节点对应的 <code>node_load1</code> 指标数据都查询出来了，同样的，我们还可以使用 <code>PromQL</code> 语句来进行更复杂的一些聚合查询操作，还可以根据我们的 Labels 标签对指标数据进行聚合。</p>
<p>到这里我们就把 Kubernetes 集群节点使用 Prometheus 监控起来了，接下来我们再来和大家学习下怎样监控 Pod 或者 Service 之类的资源对象。</p>
<p><a target="_blank" rel="noopener" href="https://docs.youdianzhishi.com/prometheus/k8s/nodes/">
</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%A7%A3%E6%9E%90%20HTTP%20%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%A7%A3%E6%9E%90%20HTTP%20%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">服务端解析 HTTP 请求数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:12:34" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>服务端解析 HTTP 请求数据是一个多步的、结构化的过程，它依赖于 HTTP 请求的严格格式定义。理解这个过程，有助于我们更好地进行网络编程和故障排查。</p>
<p>HTTP 请求通常由以下几个部分组成：</p>
<ol>
<li><strong>请求行 (Request Line)</strong></li>
<li><strong>请求头 (Request Headers)</strong></li>
<li><strong>空行 (Empty Line)</strong></li>
<li><strong>请求体 (Request Body)</strong> (可选，通常用于 POST&#x2F;PUT 请求)</li>
</ol>
<p>服务端（通常是 Web 服务器如 Nginx, Apache, Tomcat, Node.js Express，或自定义的网络应用）在底层接收到客户端发送的原始字节流后，会按照这些部分的定义逐步解析。</p>
<hr>
<h3 id="服务端解析-HTTP-请求数据的步骤："><a href="#服务端解析-HTTP-请求数据的步骤：" class="headerlink" title="服务端解析 HTTP 请求数据的步骤："></a>服务端解析 HTTP 请求数据的步骤：</h3><h4 id="步骤-1：建立-TCP-连接并接收原始字节流"><a href="#步骤-1：建立-TCP-连接并接收原始字节流" class="headerlink" title="步骤 1：建立 TCP 连接并接收原始字节流"></a>步骤 1：建立 TCP 连接并接收原始字节流</h4><ul>
<li><strong>底层网络通信：</strong> 客户端通过 TCP&#x2F;IP 协议向服务器的指定端口（HTTP 默认 80，HTTPS 默认 443）发起连接。</li>
<li><strong>服务器监听：</strong> 服务器程序（如 Apache, Nginx 或 Node.js 应用）在这些端口上监听传入连接。</li>
<li><strong>数据接收：</strong> 一旦 TCP 连接建立，服务器开始从这个连接中接收客户端发送过来的原始字节流。</li>
</ul>
<h4 id="步骤-2：解析请求行-Request-Line"><a href="#步骤-2：解析请求行-Request-Line" class="headerlink" title="步骤 2：解析请求行 (Request Line)"></a>步骤 2：解析请求行 (Request Line)</h4><ul>
<li><p><strong>识别行结束符：</strong> 服务器首先会读取第一行数据，直到遇到回车换行符 (<code>CRLF</code>，即 <code>\r\n</code>)。</p>
</li>
<li><p><strong>分割请求行：</strong> 这一行（请求行）通常包含三个部分，由空格分隔：</p>
<ol>
<li><strong>请求方法 (Method)：</strong> 解析第一个单词，识别是 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>HEAD</code>、<code>OPTIONS</code> 等。</li>
<li><strong>请求目标 (Request Target&#x2F;Path)：</strong> 解析第二个单词，这是客户端请求的资源路径（URI&#x2F;URL），可能包含查询字符串（<code>?param=value</code>）。<ul>
<li><strong>路径解析：</strong> 将路径分割为基础路径和查询字符串部分。</li>
<li><strong>查询字符串解析：</strong> 如果存在，会将键值对（<code>param=value&amp;param2=value2</code>）解析成易于访问的数据结构（例如，在编程语言中通常是键值对映射或字典）。</li>
</ul>
</li>
<li><strong>HTTP 协议版本 (HTTP Version)：</strong> 解析第三个单词，识别请求使用的 HTTP 协议版本（如 <code>HTTP/1.1</code>, <code>HTTP/2.0</code>）。</li>
</ol>
</li>
<li><p><strong>示例请求行：</strong><br><code>GET /index.html?name=John&amp;age=30 HTTP/1.1</code></p>
</li>
</ul>
<h4 id="步骤-3：解析请求头-Request-Headers"><a href="#步骤-3：解析请求头-Request-Headers" class="headerlink" title="步骤 3：解析请求头 (Request Headers)"></a>步骤 3：解析请求头 (Request Headers)</h4><ul>
<li><strong>循环读取：</strong> 服务器会继续一行一行地读取数据。每行代表一个请求头，直到遇到一个空行。</li>
<li><strong>识别头结束符：</strong> 每读取一行，直到遇到 <code>CRLF</code>。</li>
<li><strong>分割键值对：</strong> 每个请求头都由 <code>Header-Name: Header-Value</code> 的格式组成。服务器会：<ol>
<li>查找第一个冒号 (<code>:</code> )。</li>
<li>冒号之前的部分是**头名称 (Header Name)**。</li>
<li>冒号之后的部分是**头值 (Header Value)**（可能会去除前导空格）。</li>
</ol>
</li>
<li><strong>存储头信息：</strong> 解析后的头名称和头值会存储在服务器内部的一个数据结构中（例如，一个哈希表或字典），以便后续处理。</li>
<li><strong>常见请求头示例：</strong><ul>
<li><code>Host: www.example.com</code></li>
<li><code>User-Agent: Mozilla/5.0 (...)</code></li>
<li><code>Accept: text/html,application/xhtml+xml</code></li>
<li><code>Content-Type: application/x-www-form-urlencoded</code> (如果存在请求体)</li>
<li><code>Content-Length: 123</code> (如果存在请求体)</li>
<li><code>Cookie: sessionid=abcd123; user=test</code></li>
</ul>
</li>
</ul>
<h4 id="步骤-4：识别空行-Empty-Line"><a href="#步骤-4：识别空行-Empty-Line" class="headerlink" title="步骤 4：识别空行 (Empty Line)"></a>步骤 4：识别空行 (Empty Line)</h4><ul>
<li><strong>标记请求头结束：</strong> 服务器通过检测到一个单独的 <code>CRLF</code>（即一行中只有回车换行符，没有任何其他字符）来判断请求头部分已经结束。这是请求头和请求体之间的分隔符。</li>
</ul>
<h4 id="步骤-5：解析请求体-Request-Body"><a href="#步骤-5：解析请求体-Request-Body" class="headerlink" title="步骤 5：解析请求体 (Request Body)"></a>步骤 5：解析请求体 (Request Body)</h4><ul>
<li><strong>条件判断：</strong> 只有当请求方法是 <code>POST</code>、<code>PUT</code> 或其他需要提交数据的方法时，并且请求头中包含 <code>Content-Length</code> 或 <code>Transfer-Encoding: chunked</code> 时，服务器才会期望接收请求体。</li>
<li><strong>读取长度：</strong><ul>
<li><strong>Content-Length：</strong> 如果存在 <code>Content-Length</code> 头，服务器会根据其值（一个数字，表示字节数）从连接中精确地读取指定数量的字节。</li>
<li><strong>Transfer-Encoding: chunked：</strong> 如果是分块传输编码，服务器会按照分块的格式解析：读取每块的大小，然后读取该大小的数据，直到遇到一个零大小的块标记传输结束。</li>
</ul>
</li>
<li><strong>解析Content-Type：</strong> 请求体中的数据格式由 <code>Content-Type</code> 请求头指定。服务器需要根据这个头来决定如何解析请求体数据。常见的 <code>Content-Type</code> 及其解析方式：<ul>
<li><code>application/x-www-form-urlencoded</code>：这是传统的 HTML 表单提交格式。数据是 <code>key1=value1&amp;key2=value2</code> 形式的字符串，需要进行 URL 解码，并解析成键值对。</li>
<li><code>multipart/form-data</code>：用于文件上传，以及包含多个数据部分的表单。服务器会解析多部分（<code>Boundary</code>）分隔符，并从每个部分中提取字段名、文件名和数据。</li>
<li><code>application/json</code>：请求体是一个 JSON 字符串。服务器会使用 JSON 解析器将其解析成对应的编程语言数据结构（如对象、字典）。</li>
<li><code>text/plain</code>：纯文本。</li>
<li><code>application/xml</code>：XML 数据，需要 XML 解析器。</li>
<li>其他二进制数据：如图片、视频等，通常直接作为原始字节流处理。</li>
</ul>
</li>
</ul>
<h4 id="步骤-6：封装请求对象并路由"><a href="#步骤-6：封装请求对象并路由" class="headerlink" title="步骤 6：封装请求对象并路由"></a>步骤 6：封装请求对象并路由</h4><ul>
<li><strong>构建内部请求对象：</strong> 解析完成后，服务器会将所有解析出来的信息（方法、路径、查询参数、请求头、请求体数据）封装到一个内部的“请求对象”（Request Object）中。</li>
<li><strong>路由到处理程序：</strong> Web 服务器或框架会根据请求方法和路径，将这个请求对象路由到对应的应用程序处理程序（例如，某个 MVC 框架中的控制器方法，或某个 Node.js Express 路由句柄）。</li>
<li><strong>业务逻辑处理：</strong> 应用程序处理程序可以读取和使用这个请求对象中的数据，执行业务逻辑（如数据库查询、用户认证、数据保存等）。</li>
</ul>
<hr>
<p><strong>示例流程（以 Node.js Express 为例的简化概念）：</strong></p>
<p>当一个 Express 应用接收到请求：</p>
<ol>
<li>底层 Node.js <code>http</code> 模块接收到原始字节流。</li>
<li><code>http</code> 模块解析请求行（<code>req.method</code>, <code>req.url</code>）和请求头（<code>req.headers</code>）。查询字符串被解析到 <code>req.query</code>。</li>
<li>如果存在请求体，<code>http</code> 模块会流式地接收请求体数据。</li>
<li>Express 或其使用的中间件（如 <code>body-parser</code>）会根据 <code>Content-Type</code> 头部来进一步解析请求体数据：<ul>
<li>如果是 <code>application/json</code>，<code>body-parser</code> 会将请求体解析成 JavaScript 对象，并赋值给 <code>req.body</code>。</li>
<li>如果是 <code>application/x-www-form-urlencoded</code>，<code>body-parser</code> 也会将其解析成对象，赋值给 <code>req.body</code>。</li>
<li>如果是 <code>multipart/form-data</code>，通常需要像 <code>multer</code> 这样的第三方库来处理文件上传，解析结果也会被放置在 <code>req.body</code> 或 <code>req.files</code> 中。</li>
</ul>
</li>
<li>最终，在你的路由处理器中，你可以直接访问 <code>req.method</code>, <code>req.url</code>, <code>req.query</code>, <code>req.headers</code>, <code>req.body</code> 等属性来获取解析后的请求数据。</li>
</ol>
<p>这个过程是所有 Web 服务的基础，理解它有助于我们更深入地理解网络通信。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%A0%88%E4%B8%8E%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%A0%88%E4%B8%8E%E5%A0%86/" class="post-title-link" itemprop="url">栈与堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:20:07" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><strong>栈（Stack）</strong> 就像是你办公桌上的一摞文件。你总是把新文件放在最上面，要找文件时也从最上面拿。处理完一份文件，就把它从桌上拿走。这摞文件有高度限制，放太多了就会倒塌（栈溢出）。它是为你当前正在处理的任务（函数）服务的。</li>
<li><strong>堆（Heap）</strong> 就像是公司的大型档案仓库。里面的文件（数据）可以很大，存放时间可以很长，不是按照特定顺序摆放的。你需要一个档案管理员（内存管理器&#x2F;垃圾回收器）去帮你找到文件（分配内存）和销毁过期的文件（回收内存）。它为整个程序共享的、生命周期不确定的数据服务。</li>
</ul>
<hr>
<h3 id="核心区别对比表"><a href="#核心区别对比表" class="headerlink" title="核心区别对比表"></a>核心区别对比表</h3><table>
<thead>
<tr>
<th align="left">特征</th>
<th align="left">栈 (Stack)</th>
<th align="left">堆 (Heap)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>管理方式</strong></td>
<td align="left">由<strong>编译器</strong>自动管理，无需程序员干预。</td>
<td align="left">由<strong>程序员</strong>（在C&#x2F;C++中）或<strong>语言的运行时</strong>（如Go的GC）来管理。</td>
</tr>
<tr>
<td align="left"><strong>分配&#x2F;回收速度</strong></td>
<td align="left"><strong>极快</strong>。仅涉及栈指针的移动，是简单的CPU指令。</td>
<td align="left"><strong>较慢</strong>。需要通过算法（如first-fit, best-fit）查找合适的内存块，可能涉及系统调用。</td>
</tr>
<tr>
<td align="left"><strong>大小</strong></td>
<td align="left"><strong>固定且较小</strong>。通常为几 KB 到几 MB，由操作系统或线程&#x2F;goroutine创建时决定。</td>
<td align="left"><strong>灵活且较大</strong>。系统可用虚拟内存的总和，通常可达 GB 级别。</td>
</tr>
<tr>
<td align="left"><strong>数据结构</strong></td>
<td align="left">**后进先出 (LIFO)**。与函数调用&#x2F;返回的顺序一致。</td>
<td align="left"><strong>无特定结构</strong>。一个大的内存池，像一棵树或链表来组织空闲块。</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left"><strong>短暂且确定</strong>。与函数调用的生命周期绑定，函数返回时自动销毁。</td>
<td align="left"><strong>长短不一</strong>。从分配开始，直到被显式回收或垃圾回收器清理为止。</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">存储局部变量、函数参数、返回地址。</td>
<td align="left">存储动态分配的对象、全局变量、生命周期需要跨越函数调用的数据。</td>
</tr>
<tr>
<td align="left"><strong>主要风险</strong></td>
<td align="left">**栈溢出 (Stack Overflow)**。递归过深或局部变量过大。</td>
<td align="left"><strong>内存泄漏、内存碎片化、GC暂停</strong>（对于自动管理语言）。</td>
</tr>
<tr>
<td align="left"><strong>归属</strong></td>
<td align="left"><strong>每个线程&#x2F;Goroutine都有自己独立的栈。</strong></td>
<td align="left"><strong>整个进程中的所有线程&#x2F;Goroutine共享同一个堆。</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h3><h4 id="1-栈-Stack-的工作原理"><a href="#1-栈-Stack-的工作原理" class="headerlink" title="1. 栈 (Stack) 的工作原理"></a>1. 栈 (Stack) 的工作原理</h4><p>栈的核心是**“函数调用栈” (Call Stack)<strong>。当你的程序执行时，每调用一个函数，就会在栈顶创建一个</strong>栈帧 (Stack Frame)**。</p>
<p><strong>一个栈帧通常包含：</strong></p>
<ol>
<li><strong>函数参数 (Arguments)：</strong> 调用者传递给函数的参数。</li>
<li><strong>返回地址 (Return Address)：</strong> 函数执行完毕后，程序应该回到哪里继续执行。</li>
<li><strong>局部变量 (Local Variables)：</strong> 在函数内部声明的变量。</li>
</ol>
<p><strong>工作流程（LIFO）：</strong></p>
<ul>
<li><strong>函数调用 (Push)：</strong> 当 <code>main</code> 函数调用 <code>functionA</code> 时，系统会为 <code>functionA</code> 创建一个栈帧并将其<strong>压入 (push)</strong> 栈顶。当 <code>functionA</code> 再调用 <code>functionB</code> 时，同样会为 <code>functionB</code> 创建栈帧并压入栈顶。此时栈顶是 <code>functionB</code> 的栈帧。</li>
<li><strong>函数返回 (Pop)：</strong> 当 <code>functionB</code> 执行完毕并返回时，它的栈帧会从栈顶被**弹出 (pop)**，内存被立即回收。程序控制权返回到 <code>functionA</code>。当 <code>functionA</code> 返回时，它的栈帧也被弹出。</li>
<li><strong>栈指针 (Stack Pointer)：</strong> 这是一个特殊的 CPU 寄存器，始终指向当前栈顶的位置。压入和弹出操作实际上就是增加或减少这个指针的值，所以速度极快。</li>
</ul>
<p><strong>优点：</strong> 简单、高效、自动管理，不会产生内存碎片。<br><strong>缺点：</strong> 大小受限，不灵活。</p>
<h4 id="2-堆-Heap-的工作原理"><a href="#2-堆-Heap-的工作原理" class="headerlink" title="2. 堆 (Heap) 的工作原理"></a>2. 堆 (Heap) 的工作原理</h4><p>堆是一块巨大的、非连续的内存区域，专门用于<strong>动态内存分配</strong>——即在程序运行时根据需要请求任意大小的内存。</p>
<p><strong>工作流程：</strong></p>
<ol>
<li><p><strong>分配 (Allocation)：</strong></p>
<ul>
<li>当程序需要一块内存时（例如在Go中使用 <code>make</code> 创建切片，或因“逃逸分析”需要将变量放到堆上），它会向语言的<strong>内存管理器 (Memory Allocator)</strong> 发出请求，指明需要的大小。</li>
<li>内存管理器会在堆中维护一个记录了所有空闲内存块的列表（或树等更复杂的数据结构）。</li>
<li>它会根据某种算法（如首次适应、最佳适应）在这个列表中查找一个足够大的空闲块。</li>
<li>找到后，可能会将这块内存分割（如果它比请求的大），然后将分配好的内存块的地址（指针）返回给程序。</li>
<li>这个过程比栈的指针移动要复杂得多，因此速度较慢。</li>
</ul>
</li>
<li><p><strong>回收 (Deallocation)：</strong></p>
<ul>
<li><strong>手动管理 (如 C&#x2F;C++)：</strong> 程序员必须显式调用 <code>free()</code> 来告诉内存管理器“这块内存我不用了”。如果忘记调用，就会发生**内存泄漏 (Memory Leak)**。</li>
<li><strong>自动管理 (如 Go, Java, Python)：</strong> 语言的<strong>垃圾回收器 (Garbage Collector, GC)</strong> 会周期性地运行。它会扫描程序的堆和栈，找出哪些内存块是“可达的”（即仍然有指针指向它们），哪些是“不可达的”。然后，它会自动回收所有不可达内存块，将其重新标记为空闲，以便后续分配。</li>
</ul>
</li>
</ol>
<p><strong>优点：</strong> 灵活，可以分配大块内存，生命周期由程序逻辑决定。<br><strong>缺点：</strong> 分配&#x2F;回收开销大，可能产生<strong>内存碎片</strong>（小的、不连续的空闲内存块，导致无法分配大的连续内存），GC 会带来一定的性能开销（例如 STW - Stop-The-World 暂停）。</p>
<h3 id="Go-语言中的实践"><a href="#Go-语言中的实践" class="headerlink" title="Go 语言中的实践"></a>Go 语言中的实践</h3><p>在 Go 中，你作为开发者通常<strong>不需要直接关心</strong>一个变量是分配在栈上还是堆上。Go 编译器通过<strong>逃逸分析</strong>自动为你做出了最优决策。</p>
<ul>
<li><strong>不逃逸 -&gt; 栈分配：</strong> 如果一个变量只在函数内部使用，它的生命周期明确，编译器会将其分配在对应 Goroutine 的栈上，以获得最高性能。</li>
<li><strong>逃逸 -&gt; 堆分配：</strong> 如果一个变量的生命周期超出了函数的范围（例如被返回指针、被闭包引用），编译器会将其分配在堆上，由 GC 来管理其生命周期。</li>
</ul>
<p><strong>示例代码回顾：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数返回一个局部变量的指针，导致 user 变量逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createUser</span><span class="params">()</span></span> *User &#123;</span><br><span class="line">    <span class="comment">// &quot;user&quot; 在函数内定义，但它的指针被返回了</span></span><br><span class="line">    <span class="comment">// 编译器分析后发现它需要活得比 createUser() 更久</span></span><br><span class="line">    <span class="comment">// 因此，user 这个实例会被分配在堆上</span></span><br><span class="line">	user := User&#123;Name: <span class="string">&quot;Alice&quot;</span>&#125; </span><br><span class="line">	<span class="keyword">return</span> &amp;user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数中的变量不会逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateSum</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// a 和 b 的生命周期完全局限在函数内部</span></span><br><span class="line">    <span class="comment">// 它们会被安全地分配在栈上</span></span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	b := <span class="number">20</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解堆和栈的区别，能帮助你写出更高效、内存占用更合理的代码，并能更好地定位和解决性能问题，例如诊断 GC 压力过大的原因。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/" class="post-title-link" itemprop="url">服务质量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:12:53" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E8%B0%83%E5%BA%A6%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">调度器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h1><p><code>QoS</code> 是 <code>Quality of Service</code> 的缩写，即服务质量，为了实现资源被有效调度和分配的同时提高资源利用率，Kubernetes 针对不同服务质量的预期，通过 QoS 来对 pod 进行服务质量管理，对于一个 pod 来说，服务质量体现在两个具体的指标：CPU 和内存。当节点上内存资源紧张时，Kubernetes 会根据预先设置的不同 QoS 类别进行相应处理。</p>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>如果未做过节点 nodeSelector、亲和性（node affinity）或 pod 亲和、反亲和性等高级调度策略设置，我们没有办法指定服务部署到指定节点上，这样就可能会造成 CPU 或内存等密集型的 pod 同时分配到相同节点上，造成资源竞争。另一方面，如果未对资源进行限制，一些关键的服务可能会因为资源竞争因 OOM 等原因被 kill 掉，或者被限制 CPU 使用。</p>
<p>我们知道对于每一个资源，container 可以指定具体的资源需求（requests）和限制（limits），requests 申请范围是0到节点的最大配置，而 limits 申请范围是 requests 到无限，即 <code>0 &lt;= requests &lt;= Node Allocatable</code>, <code>requests &lt;= limits &lt;= Infinity</code>。</p>
<p>对于 CPU，如果 pod 中服务使用的 CPU 超过设置的 limits，pod 不会被 kill 掉但会被限制，因为 CPU 是可压缩资源，如果没有设置 limits，pod 可以使用全部空闲的 CPU 资源。</p>
<p>对于内存，当一个 pod 使用内存超过了设置的 limits，pod 中容器的进程会被 kernel 因 OOM kill 掉，当 container 因为 OOM 被 kill 掉时，系统倾向于在其原所在的机器上重启该 container 或本机或其他重新创建一个 pod。</p>
<h2 id="QoS-分类"><a href="#QoS-分类" class="headerlink" title="QoS 分类"></a>QoS 分类</h2><p>Kubelet 提供 QoS 服务质量管理，支持系统级别的 OOM 控制。在 Kubernetes 中，QoS 主要分为 <code>Guaranteed</code>、<code>Burstable</code> 和 <code>Best-Effort</code> 三类，优先级从高到低。</p>
<p>QoS 分类并不是通过一个配置项来直接配置的，而是通过配置 CPU&#x2F;内存的 limits 与 requests 值的大小来确认服务质量等级的，我们通过使用 <code>kubectl get pod xxx -o yaml</code> 可以看到 pod 的配置输出中有 <code>qosClass</code> 一项，该配置的作用是为了给资源调度提供策略支持，调度算法根据不同的服务质量等级可以确定将 pod 调度到哪些节点上。</p>
<h3 id="Guaranteed-有保证的"><a href="#Guaranteed-有保证的" class="headerlink" title="Guaranteed(有保证的)"></a>Guaranteed(有保证的)</h3><p>系统用完了全部内存，且没有其他类型的容器可以被 kill 时，该类型的 pods 会被 kill 掉，也就是说最后才会被考虑 kill 掉，属于该级别的 pod 有以下两种情况：</p>
<ul>
<li>pod 中的所有容器都且仅设置了 CPU 和内存的 limits</li>
<li>pod 中的所有容器都设置了 CPU 和内存的 requests 和 limits ，且单个容器内的 <code>requests==limits</code>（requests不等于0）</li>
</ul>
<p>pod 中的所有容器都且仅设置了 limits：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">10m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bar</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">100Mi</span></span><br></pre></td></tr></table></figure>



<p>因为如果一个容器只指明 limit 而未设定 requests，则 requests 的值等于 limit 值，所以上面 pod 的 QoS 级别属于 Guaranteed。</p>
<p>另外一个就是 pod 中的所有容器都明确设置了 requests 和 limits，且单个容器内的 <code>requests==limits</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">10m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">10m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bar</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">100Mi</span></span><br></pre></td></tr></table></figure>



<p>容器 foo 和 bar 内 resources 的 requests 和 limits 均相等，该 pod 的 QoS 级别属于 Guaranteed。</p>
<h3 id="Burstable-不稳定的"><a href="#Burstable-不稳定的" class="headerlink" title="Burstable(不稳定的)"></a>Burstable(不稳定的)</h3><p>系统用完了全部内存，且没有 Best-Effort 类型的容器可以被 kill 时，该类型的 pods 会被 kill 掉。pod 中只要有一个容器的 requests 和 limits 的设置不相同，该 pod 的 QoS 即为 Burstable。</p>
<p>比如容器 foo 指定了 resource，而容器 bar 未指定：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">10m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">10m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bar</span></span><br></pre></td></tr></table></figure>



<p>或者容器 foo 设置了内存 limits，而容器 bar 设置了 CPU limits：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bar</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br></pre></td></tr></table></figure>



<p>上面两种情况定义的 pod 都属于 Burstable 类别的 QoS。另外需要注意若容器指定了 requests 而未指定 limits，则 limits 的值等于节点资源的最大值；若容器指定了 limits 而未指定 requests，则 requests 的值等于 limits。</p>
<h3 id="Best-Effort-尽最大努力"><a href="#Best-Effort-尽最大努力" class="headerlink" title="Best-Effort(尽最大努力)"></a>Best-Effort(尽最大努力)</h3><p>系统用完了全部内存时，该类型 pods 会最先被 kill 掉。如果 pod 中所有容器的 resources 均未设置 requests 与 limits，那么该 pod 的 QoS 即为 Best-Effort。</p>
<p>比如容器 foo 和容器 bar 均未设置 requests 和 limits：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bar</span></span><br><span class="line">    <span class="attr">resources:</span></span><br></pre></td></tr></table></figure>



<h2 id="QoS-解析"><a href="#QoS-解析" class="headerlink" title="QoS 解析"></a>QoS 解析</h2><p>首先我们要明确在调度时调度器只会根据 requests 值进行调度。当系统 OOM 上时对于处理不同 OOMScore 的进程表现不同，OOMScore 是针对 memory 的，当宿主上 memory 不足时系统会优先 kill 掉 OOMScore 值高的进程，可以使用 <code>cat /proc/$PID/oom_score</code> 命令查看进程的 OOMScore。OOMScore 的取值范围为 <code>[-1000, 1000]</code>，Guaranteed 类型的 pod 的默认值为 -998，Burstable pod 的值为 <code>2~999</code>，BestEffort pod 的值为 1000，也就是说当系统 OOM 时，首先会 kill 掉 BestEffort pod 的进程，若系统依然处于 OOM 状态，然后才会 kill 掉 Burstable pod，最后是 Guaranteed pod。</p>
<p>Kubernetes 是通过 cgroup 给 pod 设置 QoS 级别的，kubelet 中有一个 <code>--cgroups-per-qos</code> 参数（默认启用），启用后 kubelet 会为不同 QoS 创建对应的 level cgroups，在 Qos level cgroups 下也会为 pod 下的容器创建对应的 level cgroups，从 <code>Qos –&gt; pod –&gt; container</code>，层层限制每个 level cgroups 的资源使用量。由于我们这里使用的是 containerd 这种容器运行时，则 cgroup 的路径与之前的 docker 不太一样：</p>
<ul>
<li>Guaranteed 类型的 cgroup level 会直接创建在 <code>RootCgroup/system.slice/containerd.service/kubepods-pod&lt;uid&gt;.slice:cri-containerd:&lt;container-id&gt;</code> 下</li>
<li>Burstable 的创建在 <code>RootCgroup/system.slice/containerd.service/kubepods-burstable-pod&lt;uid&gt;.slice:cri-containerd:&lt;container-id&gt;</code> 下</li>
<li>BestEffort 类型的创建在 <code>RootCgroup/system.slice/containerd.service/kubepods-besteffort-pod&lt;uid&gt;.slice:cri-containerd:&lt;container-id&gt;</code> 下</li>
</ul>
<p>我们可以通过 <code>mount | grep cgroup</code> 命令查看 RootCgroup：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ mount | grep cgroup</span><br><span class="line">tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br></pre></td></tr></table></figure>



<p>在 cgroup 的每个子系统下都会创建 QoS level cgroups， 此外在对应的 QoS level cgroups 还会为 pod 创建 Pod level cgroups。比如我们创建一个如下所示的 Pod：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># qos-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">qos-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">250m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">2Gi</span></span><br></pre></td></tr></table></figure>



<p>直接创建上面的资源对象即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl apply -f qos-demo.yaml</span><br><span class="line">➜ kubectl get pods qos-demo -o wide</span><br><span class="line">NAME       READY   STATUS    RESTARTS   AGE     IP            NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">qos-demo   1/1     Running   0          2m49s   10.244.1.29   node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">➜ kubectl get pods qos-demo -o yaml |grep uid</span><br><span class="line">  uid: 489a19f2-8d75-474c-988f-5854b61b839f</span><br><span class="line">➜ kubectl get pods qos-demo -o yaml |grep qosClass</span><br><span class="line">  qosClass: Burstable</span><br></pre></td></tr></table></figure>



<p>由于该 pod 的设置的资源 requests !&#x3D; limits，所以其属于 Burstable 类别的 pod，kubelet 会在其所属 QoS 下创建 <code>RootCgroup/system.slice/containerd.service/kubepods-burstable-pod&lt;uid&gt;.slice:cri-containerd:&lt;container-id&gt;</code> 这个 cgroup level，比如我们查看内存这个子系统的 cgroup：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还有一个 pause 容器的 cgroup level</span></span><br><span class="line">➜ ls /sys/fs/cgroup/memory/system.slice/containerd.service/kubepods-burstable-pod489a19f2_8d75_474c_988f_5854b61b839f.slice:cri-containerd:4782243ba3260125513af20689fcea31b52eae1cbabeafeb1f7a52bcdcd5b44b</span><br><span class="line">cgroup.clone_children           memory.kmem.tcp.max_usage_in_bytes  memory.oom_control</span><br><span class="line">cgroup.event_control            memory.kmem.tcp.usage_in_bytes      memory.pressure_level</span><br><span class="line">cgroup.procs                    memory.kmem.usage_in_bytes          memory.soft_limit_in_bytes</span><br><span class="line">memory.failcnt                  memory.limit_in_bytes               memory.stat</span><br><span class="line">memory.force_empty              memory.max_usage_in_bytes           memory.swappiness</span><br><span class="line">memory.kmem.failcnt             memory.memsw.failcnt                memory.usage_in_bytes</span><br><span class="line">memory.kmem.limit_in_bytes      memory.memsw.limit_in_bytes         memory.use_hierarchy</span><br><span class="line">memory.kmem.max_usage_in_bytes  memory.memsw.max_usage_in_bytes     notify_on_release</span><br><span class="line">memory.kmem.slabinfo            memory.memsw.usage_in_bytes         tasks</span><br><span class="line">memory.kmem.tcp.failcnt         memory.move_charge_at_immigrate</span><br><span class="line">memory.kmem.tcp.limit_in_bytes  memory.numa_stat</span><br></pre></td></tr></table></figure>



<p>上面创建的应用容器进程 ID 会被写入到上面的 tasks 文件中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜ cat tasks</span><br><span class="line">64133</span><br><span class="line">64170</span><br><span class="line">64171</span><br><span class="line">64172</span><br><span class="line">64173</span><br><span class="line">➜ ps -aux |grep nginx</span><br><span class="line">root      64133  0.0  0.0   8840  3488 ?        Ss   15:56   0:00 nginx: master process nginx -g daemon off;</span><br><span class="line">101       64170  0.0  0.0   9228  1532 ?        S    15:56   0:00 nginx: worker process</span><br><span class="line">101       64171  0.0  0.0   9228  1532 ?        S    15:56   0:00 nginx: worker process</span><br><span class="line">101       64172  0.0  0.0   9228  1532 ?        S    15:56   0:00 nginx: worker process</span><br><span class="line">101       64173  0.0  0.0   9228  1532 ?        S    15:56   0:00 nginx: worker process</span><br></pre></td></tr></table></figure>



<p>这样我们的容器进程就会受到该 cgroup 的限制了，在 pod 的资源清单中我们设置了 memory 的 limits 值为 2Gi，kubelet 则会将该限制值写入到 <code>memory.limit_in_bytes</code> 中去：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ cat memory.limit_in_bytes</span><br><span class="line">2147483648 # 2147483648 / 1024 / 1024 / 1024 = 2</span><br></pre></td></tr></table></figure>



<p>同样对于 cpu 资源一样可以在对应的子系统中找到创建的对应 cgroup：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜ ls /sys/fs/cgroup/cpu/system.slice/containerd.service/kubepods-burstable-pod489a19f2_8d75_474c_988f_5854b61b839f.slice:cri-containerd:4782243ba3260125513af20689fcea31b52eae1cbabeafeb1f7a52bcdcd5b44b</span><br><span class="line">cgroup.clone_children  cpuacct.stat          cpu.cfs_period_us  cpu.rt_runtime_us  notify_on_release</span><br><span class="line">cgroup.event_control   cpuacct.usage         cpu.cfs_quota_us   cpu.shares         tasks</span><br><span class="line">cgroup.procs           cpuacct.usage_percpu  cpu.rt_period_us   cpu.stat</span><br><span class="line">➜ cat tasks</span><br><span class="line">64133</span><br><span class="line">64170</span><br><span class="line">64171</span><br><span class="line">64172</span><br><span class="line">64173</span><br><span class="line">➜ cat cpu.cfs_quota_us</span><br><span class="line">50000  # 500m</span><br></pre></td></tr></table></figure>



<p>最后关于 QoS 还有一点建议，如果资源充足，可将 QoS pods 类型均设置为 Guaranteed。用计算资源换业务性能和稳定性，减少排查问题时间和成本。如果想更好的提高资源利用率，业务服务可以设置为 Guaranteed，而其他服务根据重要程度可分别设置为 Burstable 或 Best-Effort。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%A3%80%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%A3%80%E6%B5%8B/" class="post-title-link" itemprop="url">检测</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:14:24" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/Query-PromQL/" itemprop="url" rel="index"><span itemprop="name">Query PromQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h1><p>本节我们将学习如何来检查我们的实例数据抓取健康状况。</p>
<h2 id="检查抓取实例"><a href="#检查抓取实例" class="headerlink" title="检查抓取实例"></a>检查抓取实例</h2><p>每当 Prometheus 抓取一个目标时，它都会存储一个合成的样本，其中包含指标名称 <code>up</code> 和被抓取实例的 <code>job</code> 和 <code>instance</code> 标签，如果抓取成功，则样本的值被设置为 1，如果抓取失败，则设置为 0，所以我们可以通过如下所示的查询来获取当前哪些实例处于正常或挂掉的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up&#123;job=&quot;demo&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>正常三个演示服务实例都处于正常状态，所以应该都为<strong>1</strong>。如果我们将第一个实例停掉，重新查询则第一个实例结果为<strong>0</strong>：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/f863uf.png" alt="up"></p>
<p>如果只希望显示 <code>down</code> 掉的实例，可以通过过滤<strong>0</strong>值来获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up&#123;job=&quot;demo&quot;&#125; == 0</span><br></pre></td></tr></table></figure>

<p><img data-src="https://mudutestmenu.mudu.tv/upload/4z61du.png" alt="down"></p>
<p>或者获取挂掉实例的总数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count by(job) (up&#123;job=&quot;demo&quot;&#125; == 0)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://picdn.youdianzhishi.com/images/20210922111212.png" alt="count"></p>
<p>一般情况下这种类型的查询会用于指标抓取健康状态报警。</p>
<blockquote>
<p>注意：因为 <code>count()</code> 是一个聚合运算符，它期望有一组维度的时间序列作为其输入，并且可以根据 <code>by</code> 或 <code>without</code> 子句将输出序列分组。任何输出组只能基于现有的输入序列，如果根本没有输入序列，就不会产生输出。</p>
</blockquote>
<h2 id="检查序列数据"><a href="#检查序列数据" class="headerlink" title="检查序列数据"></a>检查序列数据</h2><p>在某些情况下，只查看序列的样本值是不够的，有时还需要检测是否存在某些序列，上面我们用 <code>up&#123;job=&quot;demo&quot;&#125; == 0</code> 语句来查询所有无法抓取的演示服务实例，但是只有已经被抓取的目标才会被加上 <code>up</code> 指标，如果 Prometheus 都没有抓取到任何的演示服务目标应该怎么办呢？比如它的抓取配置出问题了，服务发现可能返回也为空，或者由于 Prometheus 自身出了某些问题。</p>
<p>在这种情况下，<code>absent()</code> 函数就非常有用了，<code>absent()</code> 将一个瞬时向量作为其输入，当输入包含序列时，将返回一个空结果，不包含时将返回单个输出序列，而且样本值为<strong>1</strong>。</p>
<p>例如，查询语句 <code>absent(up&#123;job=&quot;demo&quot;&#125;)</code> 将得到一个空的输出结果，如果测试一个没有被抓取的 job 是否存在的时候，将得到样本值<strong>1</strong>。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20210922114313.png" alt="non-existent"></p>
<p>这可以帮助我们检测序列是否存在的情况。此外还有一个 <code>absent()</code> 的变种，叫做 <code>absent_over_time()</code>，它接受一个区间向量，告诉你在该输入向量的整个时间范围内是否有样本。</p>
<blockquote>
<p><strong>练习：</strong></p>
<p>1.构建一个查询，检测指标 <code>demo_api_request_duration_seconds_count</code> 是否具有 <code>PUT</code> 的 method 标签的序列。</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">absent(demo_api_request_duration_seconds_count&#123;method=&quot;PUT&quot;&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>2.构建一个查询，当过去一小时内任务 <code>non-existent</code> 没有记录 up 指标时，该查询输出一个系列。</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">absent_over_time(up&#123;job=&quot;non-existent&quot;&#125;[1h])</span><br></pre></td></tr></table></figure>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">容器运行时概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:13:18" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">容器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在学习 Containerd 之前我们有必要对 Docker 的发展历史做一个简单的回顾，因为这里面牵涉到的组件实战是有点多，有很多我们会经常听到，但是不清楚这些组件到底是干什么用的，比如 <code>libcontainer</code>、<code>runc</code>、<code>containerd</code>、<code>CRI</code>、<code>OCI</code> 等等。</p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>从 Docker 1.11 版本开始，Docker 容器运行就不是简单通过 Docker Daemon 来启动了，而是通过集成 containerd、runc 等多个组件来完成的。虽然 Docker Daemon 守护进程模块在不停的重构，但是基本功能和定位没有太大的变化，一直都是 CS 架构，守护进程负责和 Docker Client 端交互，并管理 Docker 镜像和容器。现在的架构中组件 containerd 就会负责集群节点上容器的生命周期管理，并向上为 Docker Daemon 提供 gRPC 接口。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/11qjro.png" alt="docker 架构"></p>
<p>当我们要创建一个容器的时候，现在 Docker Daemon 并不能直接帮我们创建了，而是请求 <code>containerd</code> 来创建一个容器，containerd 收到请求后，也并不会直接去操作容器，而是创建一个叫做 <code>containerd-shim</code> 的进程，让这个进程去操作容器，我们指定容器进程是需要一个父进程来做状态收集、维持 stdin 等 fd 打开等工作的，假如这个父进程就是 containerd，那如果 containerd 挂掉的话，整个宿主机上所有的容器都得退出了，而引入 <code>containerd-shim</code> 这个垫片就可以来规避这个问题了。</p>
<p>然后创建容器需要做一些 namespaces 和 cgroups 的配置，以及挂载 root 文件系统等操作，这些操作其实已经有了标准的规范，那就是 OCI（开放容器标准），<code>runc</code> 就是它的一个参考实现（Docker 被逼无耐将 <code>libcontainer</code> 捐献出来改名为 <code>runc</code> 的），这个标准其实就是一个文档，主要规定了容器镜像的结构、以及容器需要接收哪些操作指令，比如 create、start、stop、delete 等这些命令。<code>runc</code> 就可以按照这个 OCI 文档来创建一个符合规范的容器，既然是标准肯定就有其他 OCI 实现，比如 Kata、gVisor 这些容器运行时都是符合 OCI 标准的。</p>
<p>所以真正启动容器是通过 <code>containerd-shim</code> 去调用 <code>runc</code> 来启动容器的，<code>runc</code> 启动完容器后本身会直接退出，<code>containerd-shim</code> 则会成为容器进程的父进程, 负责收集容器进程的状态, 上报给 containerd, 并在容器中 pid 为 1 的进程退出后接管容器中的子进程进行清理, 确保不会出现僵尸进程。</p>
<p>而 Docker 将容器操作都迁移到 <code>containerd</code> 中去是因为当前做 Swarm，想要进军 PaaS 市场，做了这个架构切分，让 Docker Daemon 专门去负责上层的封装编排，当然后面的结果我们知道 Swarm 在 Kubernetes 面前是惨败，然后 Docker 公司就把 <code>containerd</code> 项目捐献给了 CNCF 基金会，这个也是现在的 Docker 架构。</p>
<h2 id="CRI"><a href="#CRI" class="headerlink" title="CRI"></a>CRI</h2><p>我们知道 Kubernetes 提供了一个 CRI 的容器运行时接口，那么这个 CRI 到底是什么呢？这个其实也和 Docker 的发展密切相关的。</p>
<p>在 Kubernetes 早期的时候，当时 Docker 实在是太火了，Kubernetes 当然会先选择支持 Docker，而且是通过硬编码的方式直接调用 Docker API，后面随着 Docker 的不断发展以及 Google 的主导，出现了更多容器运行时，Kubernetes 为了支持更多更精简的容器运行时，Google 就和红帽主导推出了 CRI 标准，用于将 Kubernetes 平台和特定的容器运行时（当然主要是为了干掉 Docker）解耦。</p>
<p><code>CRI</code>（Container Runtime Interface 容器运行时接口）本质上就是 Kubernetes 定义的一组与容器运行时进行交互的接口，所以只要实现了这套接口的容器运行时都可以对接到 Kubernetes 平台上来。不过 Kubernetes 推出 CRI 这套标准的时候还没有现在的统治地位，所以有一些容器运行时可能不会自身就去实现 CRI 接口，于是就有了 <code>shim（垫片）</code>， 一个 shim 的职责就是作为适配器将各种容器运行时本身的接口适配到 Kubernetes 的 CRI 接口上，其中 <code>dockershim</code> 就是 Kubernetes 对接 Docker 到 CRI 接口上的一个垫片实现。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/ru6fpg.png" alt="cri shim"></p>
<p>Kubelet 通过 gRPC 框架与容器运行时或 shim 进行通信，其中 kubelet 作为客户端，CRI shim（也可能是容器运行时本身）作为服务器。</p>
<p>CRI 定义的 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/kubelet/api/v1alpha1/runtime/api.proto">API</a> 主要包括两个 gRPC 服务，<code>ImageService</code> 和 <code>RuntimeService</code>，<code>ImageService</code> 服务主要是拉取镜像、查看和删除镜像等操作，<code>RuntimeService</code> 则是用来管理 Pod 和容器的生命周期，以及与容器交互的调用（exec&#x2F;attach&#x2F;port-forward）等操作，可以通过 kubelet 中的标志 <code>--container-runtime-endpoint</code> 和 <code>--image-service-endpoint</code> 来配置这两个服务的套接字。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/7rjypb.png" alt="kubelet cri"></p>
<p>不过这里同样也有一个例外，那就是 Docker，由于 Docker 当时的江湖地位很高，Kubernetes 是直接内置了 <code>dockershim</code> 在 kubelet 中的，所以如果你使用的是 Docker 这种容器运行时的话是不需要单独去安装配置适配器之类的，当然这个举动似乎也麻痹了 Docker 公司。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/lickfd.png" alt="dockershim"></p>
<p>现在如果我们使用的是 Docker 的话，当我们在 Kubernetes 中创建一个 Pod 的时候，首先就是 kubelet 通过 CRI 接口调用 <code>dockershim</code>，请求创建一个容器，kubelet 可以视作一个简单的 CRI Client, 而 dockershim 就是接收请求的 Server，不过他们都是在 kubelet 内置的。</p>
<p><code>dockershim</code> 收到请求后, 转化成 Docker Daemon 能识别的请求, 发到 Docker Daemon 上请求创建一个容器，请求到了 Docker Daemon 后续就是 Docker 创建容器的流程了，去调用 <code>containerd</code>，然后创建 <code>containerd-shim</code> 进程，通过该进程去调用 <code>runc</code> 去真正创建容器。</p>
<p>其实我们仔细观察也不难发现使用 Docker 的话其实是调用链比较长的，真正容器相关的操作其实 containerd 就完全足够了，Docker 太过于复杂笨重了，当然 Docker 深受欢迎的很大一个原因就是提供了很多对用户操作比较友好的功能，但是对于 Kubernetes 来说压根不需要这些功能，因为都是通过接口去操作容器的，所以自然也就可以将容器运行时切换到 containerd 来。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/kg5bla.png" alt="切换到containerd"></p>
<p>切换到 containerd 可以消除掉中间环节，操作体验也和以前一样，但是由于直接用容器运行时调度容器，所以它们对 Docker 来说是不可见的。 因此，你以前用来检查这些容器的 Docker 工具就不能使用了。</p>
<p>你不能再使用 <code>docker ps</code> 或 <code>docker inspect</code> 命令来获取容器信息。由于不能列出容器，因此也不能获取日志、停止容器，甚至不能通过 <code>docker exec</code> 在容器中执行命令。</p>
<p>当然我们仍然可以下载镜像，或者用 <code>docker build</code> 命令构建镜像，但用 Docker 构建、下载的镜像，对于容器运行时和 Kubernetes，均不可见。为了在 Kubernetes 中使用，需要把镜像推送到镜像仓库中去。</p>
<p>从上图可以看出在 containerd 1.0 中，对 CRI 的适配是通过一个单独的 <code>CRI-Containerd</code> 进程来完成的，这是因为最开始 containerd 还会去适配其他的系统（比如 swarm），所以没有直接实现 CRI，所以这个对接工作就交给 <code>CRI-Containerd</code> 这个 shim 了。</p>
<p>然后到了 containerd 1.1 版本后就去掉了 <code>CRI-Containerd</code> 这个 shim，直接把适配逻辑作为插件的方式集成到了 containerd 主进程中，现在这样的调用就更加简洁了。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/i491d2.png" alt="containerd cri"></p>
<p>与此同时 Kubernetes 社区也做了一个专门用于 Kubernetes 的 CRI 运行时 <a target="_blank" rel="noopener" href="https://cri-o.io/">CRI-O</a>，直接兼容 CRI 和 OCI 规范。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/hdjrcp.png" alt="cri-o"></p>
<p>这个方案和 containerd 的方案显然比默认的 dockershim 简洁很多，不过由于大部分用户都比较习惯使用 Docker，所以大家还是更喜欢使用 <code>dockershim</code> 方案。</p>
<p>但是随着 CRI 方案的发展，以及其他容器运行时对 CRI 的支持越来越完善，Kubernetes 社区在 2020 年 7 月份就开始着手移除 dockershim 方案了：<a target="_blank" rel="noopener" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim%EF%BC%8C%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%A7%BB%E9%99%A4%E8%AE%A1%E5%88%92%E6%98%AF%E5%9C%A8">https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim，现在的移除计划是在</a> 1.20 版本中将 kubelet 中内置的 dockershim 代码分离，将内置的 dockershim 标记为<code>维护模式</code>，当然这个时候仍然还可以使用 dockershim，目标是在 1.23&#x2F;1.24 版本发布没有 dockershim 的版本（代码还在，但是要默认支持开箱即用的 docker 需要自己构建 kubelet，会在某个宽限期过后从 kubelet 中删除内置的 dockershim 代码）。</p>
<p>那么这是否就意味这 Kubernetes 不再支持 Docker 了呢？当然不是的，这只是废弃了内置的 <code>dockershim</code> 功能而已，Docker 和其他容器运行时将一视同仁，不会单独对待内置支持，如果我们还想直接使用 Docker 这种容器运行时应该怎么办呢？可以将 dockershim 的功能单独提取出来独立维护一个 <code>cri-dockerd</code> 即可，就类似于 containerd 1.0 版本中提供的 <code>CRI-Containerd</code>，当然还有一种办法就是 Docker 官方社区将 CRI 接口内置到 Dockerd 中去实现。</p>
<p>但是我们也清楚 Dockerd 也是去直接调用的 Containerd，而 containerd 1.1 版本后就内置实现了 CRI，所以 Docker 也没必要再去单独实现 CRI 了，当 Kubernetes 不再内置支持开箱即用的 Docker 的以后，最好的方式当然也就是直接使用 Containerd 这种容器运行时，而且该容器运行时也已经经过了生产环境实践的，接下来我们就来学习下 Containerd 的使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">消息队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:18:31" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="核心构成"><a href="#核心构成" class="headerlink" title="核心构成"></a>核心构成</h3><p>一个典型的消息队列系统主要由以下几部分组成：</p>
<ol>
<li><strong>消息（Message）：</strong> 传输的数据单元，通常是结构化的二进制数据、JSON 或 XML。</li>
<li><strong>生产者（Producer）：</strong> 消息的发送方，负责创建消息并将消息发送到消息队列。</li>
<li><strong>消费者（Consumer）：</strong> 消息的接收方，负责从消息队列中获取消息并进行处理。</li>
<li><strong>消息队列（Queue&#x2F;Broker）：</strong> 消息存储和转发的核心组件。它接收生产者发送的消息，将消息持久化存储，并管理消息的投递和确认。大型 MQ 系统通常由一个或多个 Broker 组成集群。</li>
<li><strong>主题&#x2F;队列（Topic&#x2F;Queue）：</strong> 消息的逻辑分类。<ul>
<li><strong>Queue（队列式）：</strong> 一条消息通常只能被一个消费者组中的一个消费者消费（点对点模式）。</li>
<li><strong>Topic（主题式）：</strong> 一条消息可以被多个消费者组（订阅者）的消费者同时消费（发布&#x2F;订阅模式）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li><strong>生产者发送消息：</strong> 生产者将业务数据（消息）封装后，发送到指定的消息队列（Broker 的某个 Topic 或 Queue）。</li>
<li><strong>消息存储：</strong> 消息队列接收到消息后，将消息持久化存储起来，并根据消息的 Topic 或 Queue 进行分类和排队。</li>
<li><strong>消费者拉取&#x2F;推送消息：</strong> 消费者程序连接到消息队列，可以是主动拉取（Pull 模式），也可以是消息队列主动推送（Push 模式）。</li>
<li><strong>消费者处理消息：</strong> 消费者获取到消息后，执行相应的业务逻辑。</li>
<li><strong>消息确认（Ack）：</strong> 消费者成功处理消息后，向消息队列发送确认信号（ACK）。消息队列收到确认后，会将该消息从队列中删除或标记为已消费。如果消费者处理失败或未发送确认，消息队列会根据配置进行重试投递。</li>
</ol>
<hr>
<h3 id="为什么需要消息队列？（核心优势）"><a href="#为什么需要消息队列？（核心优势）" class="headerlink" title="为什么需要消息队列？（核心优势）"></a>为什么需要消息队列？（核心优势）</h3><p>消息队列在后端系统设计中扮演着至关重要的角色，它的引入带来了以下几个关键优势：</p>
<ol>
<li><p><strong>解耦（Decoupling）：</strong></p>
<ul>
<li>发送方和接收方不再直接通信，而是通过消息队列进行间接通信。</li>
<li>生产者无需知道消费者是否存在、数量以及位置，只管将消息发出去。</li>
<li>消费者也无需知道消息来自哪个生产者。</li>
<li>这种松散耦合使得系统更容易扩展、维护和修改，任何一方的改动都不会直接影响另一方。</li>
</ul>
</li>
<li><p><strong>异步通信（Asynchronous Communication）：</strong></p>
<ul>
<li>生产者发送消息后，无需等待消费者处理完毕即可返回，可以立即进行其他任务。</li>
<li>大大提高了系统的响应速度和吞吐量。例如，用户下单后，订单服务立即返回成功，而短信发送、积分计算、库存扣减等异步任务可以稍后由消息队列驱动。</li>
</ul>
</li>
<li><p><strong>流量削峰填谷（Load Leveling &#x2F; Throttling）：</strong></p>
<ul>
<li>在高并发场景下，消息队列可以作为流量的“缓冲池”。</li>
<li>当瞬时请求量远超系统处理能力时，消息队列将多余的请求缓存起来，系统可以按照自己的节奏逐步消费，避免服务被“冲垮”。</li>
<li>例如，秒杀活动中，短时间的巨量订单请求可以先进入消息队列，然后由后端服务缓慢消化。</li>
</ul>
</li>
<li><p><strong>高可用与冗余（High Availability &amp; Redundancy）：</strong></p>
<ul>
<li>消息队列通常具备消息持久化能力。即使消费者服务宕机，消息也会保留在队列中，待消费者恢复后继续处理，保证数据不丢失。</li>
<li>消费者故障也不会影响生产者持续发送消息。</li>
</ul>
</li>
<li><p><strong>弹性伸缩（Scalability）：</strong></p>
<ul>
<li>当业务量增加时，可以通过增加消费者实例来提高消息处理能力，消费者之间可以并行处理消息。</li>
<li>当业务量减少时，可以相应减少消费者实例，降低资源消耗。</li>
</ul>
</li>
<li><p><strong>最终一致性（Eventual Consistency）：</strong></p>
<ul>
<li>在分布式事务场景（如 RocketMQ 的事务消息），消息队列可以作为协调者，帮助实现多个服务之间的数据最终一致性。</li>
</ul>
</li>
<li><p><strong>广播（Broadcasting）：</strong></p>
<ul>
<li>通过主题订阅模式，一条消息可以被多个不同的消费者（订阅者）同时消费，实现消息的广播功能，例如数据变更通知、日志统一收集分发等。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><ul>
<li><strong>异步通知与事件驱动：</strong> 用户下单后发送通知、邮件、短信等。</li>
<li><strong>日志收集与分析：</strong> 各服务将日志发送到 MQ，统一由日志处理服务消费并存储到大数据平台。</li>
<li><strong>任务解耦与分布式任务调度：</strong> 将耗时长的任务放入 MQ，由专门的任务处理服务消费。</li>
<li><strong>数据同步与最终一致性：</strong> 跨系统数据变更同步，如库存扣减、积分赠送。</li>
<li><strong>高并发限流与削峰：</strong> 秒杀系统、大数据导入导出。</li>
</ul>
<hr>
<h3 id="主流消息队列产品"><a href="#主流消息队列产品" class="headerlink" title="主流消息队列产品"></a>主流消息队列产品</h3><ul>
<li><strong>Apache Kafka：</strong> 高吞吐量、低延迟的分布式流处理平台，常用于大数据领域和实时数据管道。</li>
<li><strong>Apache RocketMQ：</strong> 阿里开源的分布式消息和流平台，专注于金融互联网领域，支持事务消息、顺序消息等。</li>
<li><strong>RabbitMQ：</strong> 基于 AMQP 协议，功能丰富，支持多种消息模式，适用于复杂的企业级应用。</li>
<li><strong>Apache ActiveMQ：</strong> 使用广泛的开源消息中间件，支持多种协议和平台。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>消息队列是现代分布式、微服务架构中不可或缺的组件。它通过实现系统间的解耦和异步通信，解决了一系列复杂的挑战，从而提升了系统的性能、可用性、可伸缩性和可维护性。在设计和实现后端系统时，合理地引入消息队列将是提高系统鲁棒性和效率的关键一步。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%B8%8D%E4%B8%A2%E5%A4%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%B8%8D%E4%B8%A2%E5%A4%B1/" class="post-title-link" itemprop="url">消息队列保证消息在分布式系统中不丢失</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:18:40" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>您好！保证消息在分布式系统中不丢失是后端开发中一个至关重要的课题，也是衡量一个消息队列系统可靠性的核心指标。作为后端开发专家，我深知这一挑战的复杂性，因为它涉及到消息流动的整个生命周期：从生产者发送，到消息队列存储，再到消费者处理。</p>
<p>要实现“消息不丢失”，我们通常需要采用<strong>端到端（End-to-End）</strong>的防护措施，在消息生产、消息存储和消息消费的每个环节都做好保障。</p>
<hr>
<h3 id="一、-生产者侧：确保消息成功发送到消息队列"><a href="#一、-生产者侧：确保消息成功发送到消息队列" class="headerlink" title="一、 生产者侧：确保消息成功发送到消息队列"></a>一、 生产者侧：确保消息成功发送到消息队列</h3><p>消息的第一站就是从生产者发出，如果在这里就丢了，后续的任何保证都无从谈起。</p>
<ol>
<li><p><strong>可靠的消息发送机制：</strong></p>
<ul>
<li><strong>同步发送 (Sync Send)：</strong> 生产者发送消息后，等待消息队列（Broker）的确认响应（ACK）。如果收到 ACK，表示消息已成功写入Broker；如果未收到或收到失败响应，生产者可以进行重试（配置重试次数和间隔）。这是最常用的保证机制。</li>
<li><strong>异步发送 + 回调 (Async Send + Callback)：</strong> 生产者发送消息后立即返回，但会提供一个回调函数。当Broker返回响应时，通过回调函数通知生产者发送结果。生产者在回调函数中判断发送成功或失败，失败时执行重试逻辑。</li>
<li><strong>消息的持久化与重发（本地消息表&#x2F;事务消息）：</strong> 针对生产者在发送消息前或发送消息的过程中宕机导致消息丢失的极端情况。<ul>
<li><strong>本地消息表方案：</strong> 生产者在发送消息前，先将消息内容和状态写入本地数据库，并开启本地事务。本地事务成功提交后，再发送消息到MQ。如果发送失败，通过定时任务扫描本地消息表，重发未发送成功的消息。</li>
<li><strong>分布式事务消息（如 RocketMQ 的事务消息）：</strong> 这是一种更优雅的方案。生产者先发送一条“半消息”到 Broker，然后执行本地事务。根据本地事务的结果，向 Broker 发送 Commit 或 Rollback 指令。即使生产者在发送 Commit&#x2F;Rollback 前宕机，Broker 也会通过事务回查机制来询问生产者的本地事务状态，从而决定消息的最终是提交还是回滚。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>网络和连接稳定性：</strong> 确保生产者与 Broker 之间的网络连接稳定，客户端 SDK 通常会内置连接管理和自动重连机制。</p>
</li>
</ol>
<hr>
<h3 id="二、-消息队列（Broker）侧：确保消息可靠存储与传递"><a href="#二、-消息队列（Broker）侧：确保消息可靠存储与传递" class="headerlink" title="二、 消息队列（Broker）侧：确保消息可靠存储与传递"></a>二、 消息队列（Broker）侧：确保消息可靠存储与传递</h3><p>Broker 是消息的“中转站”和“保管员”，它的可靠性至关重要。</p>
<ol>
<li><p><strong>消息持久化（Message Persistence）：</strong></p>
<ul>
<li><strong>消息写入磁盘：</strong> 消息到达 Broker 后，必须立即写入到持久化存储（如磁盘文件，通常是日志文件或 Commit Log）而不是只停留在内存中。这样即使 Broker 宕机，重启后也能从磁盘恢复消息。</li>
<li><strong>刷盘机制（Flush Disk）：</strong> 消息写入操作系统缓存后，需要及时强制刷入磁盘（<code>fsync</code> 或 <code>AIO</code>）。<ul>
<li><strong>同步刷盘（Sync Flush）：</strong> 消息提交到 Broker 后，只有当消息真正写入磁盘后，Broker 才返回成功响应给生产者。可靠性最高，但性能较低。</li>
<li><strong>异步刷盘（Async Flush）：</strong> 消息写入操作系统缓存后，Broker 立即返回成功响应给生产者，然后异步地将消息刷入磁盘。性能高，但若Broker在消息未刷盘前宕机，可能会丢失少量消息。在对消息丢失容忍度极低但对性能要求很高的情况下，通常会结合下面的主从同步复制。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>高可用与冗余（High Availability &amp; Redundancy）：</strong></p>
<ul>
<li><strong>集群部署：</strong> Broker 通常以集群模式部署，避免单点故障。</li>
<li><strong>主从复制&#x2F;多副本机制：</strong><ul>
<li><strong>同步复制（Synchronous Replication）：</strong> 主节点收到消息后，必须等待至少一个从节点成功复制并写入磁盘后，才向生产者返回成功。这是保证消息不丢失的<strong>最强机制</strong>，即使主节点宕机，消息也能在从节点找到。例如 RocketMQ 的 <code>SYNC_MASTER</code> 模式，Kafka 的 <code>acks=all</code> 级别。</li>
<li><strong>异步复制（Asynchronous Replication）：</strong> 主节点收到消息并写入磁盘后，立即向生产者返回成功，然后异步地复制给从节点。性能更高，但如果在消息未同步到从节点前主节点宕机，可能会丢失少量消息。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>消息的排队和索引：</strong> MQ 内部的队列结构和高效的索引机制，确保消息能被正确存储、查找和发送给消费者。</p>
</li>
</ol>
<hr>
<h3 id="三、-消费者侧：确保消息成功处理并确认"><a href="#三、-消费者侧：确保消息成功处理并确认" class="headerlink" title="三、 消费者侧：确保消息成功处理并确认"></a>三、 消费者侧：确保消息成功处理并确认</h3><p>即使消息安全送达消费者，如果在消费者处理过程中或确认过程中出现问题，消息也可能“丢失”在业务逻辑层面。</p>
<ol>
<li><p><strong>消费者消息确认（Acknowledgement &#x2F; ACK）：</strong></p>
<ul>
<li><strong>手动 ACK：</strong> 这是保证消息不丢失的关键。消费者接收到消息后，先执行业务逻辑。只有当业务逻辑<strong>成功完成</strong>后，才向 Broker 发送确认（ACK）信号。</li>
<li><strong>自动 ACK 的风险：</strong> 如果使用自动 ACK（收到消息即 ACK），那么在自动 ACK 之后，消费者处理业务逻辑失败或宕机，消息将不会被重试，从而丢失。因此，生产环境一般不推荐使用自动 ACK。</li>
<li><strong>NACK&#x2F;重试机制：</strong> 如果消费者处理消息失败（例如，业务逻辑异常、数据库连接中断），不发送 ACK，或者发送 NACK 信号。Broker 会认为该消息未被成功处理，并在一定时间后进行重试投递（配置最大重试次数和重试间隔）。</li>
</ul>
</li>
<li><p><strong>消费者幂等性（Idempotency）：</strong></p>
<ul>
<li>由于消息队列提供的是“<strong>至少一次（At Least Once）</strong>”的投递保证（因为重试机制的存在，可能会导致消息重复投递），因此消费者必须设计为幂等的。</li>
<li><strong>幂等性</strong>意味着：多次执行同一个操作，产生的结果与执行一次操作的结果相同，不会产生副作用。</li>
<li><strong>实现方式：</strong><ul>
<li><strong>唯一 ID 校验：</strong> 给每条消息生成唯一的消息 ID 或业务 ID，消费者处理前先根据此 ID 查询是否已处理过。</li>
<li><strong>状态机：</strong> 对于有状态的操作，记录当前状态，避免重复操作。</li>
<li><strong>数据库唯一约束：</strong> 利用数据库的唯一索引或主键约束，插入重复数据时报错。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>死信队列（Dead Letter Queue, DLQ）：</strong></p>
<ul>
<li>当消息经过多次重试仍然无法被消费者成功处理时（例如，消息本身格式错误、业务逻辑存在 Bug 导致反复失败），为了不阻碍后续消息的消费，这些消息会被移到特殊的“死信队列”。</li>
<li>死信队列中的消息不会再被普通消费者消费，等待开发人员后续进行分析、修复问题并手动处理或重新投递。这是对消息的<strong>最后一道防线</strong>，确保“难以处理”的消息不会被悄悄丢弃。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四、-总结：多层防护与权衡"><a href="#四、-总结：多层防护与权衡" class="headerlink" title="四、 总结：多层防护与权衡"></a>四、 总结：多层防护与权衡</h3><p>保证消息不丢失是一个系统工程，涉及生产、传输和消费的每个环节。没有银弹，需要结合多种策略共同作用：</p>
<ul>
<li><strong>生产者：</strong> 确保成功发送（同步&#x2F;异步ACK，重试，事务消息&#x2F;本地消息表）。</li>
<li><strong>消息队列：</strong> 确保可靠存储（持久化，同步刷盘，主从同步复制集群）。</li>
<li><strong>消费者：</strong> 确保成功处理（手动ACK，处理完再ACK，幂等性处理，死信队列）。</li>
</ul>
<p>在实际应用中，我们需要在<strong>消息的可靠性、系统的性能和资源的成本</strong>之间进行权衡。例如，同步刷盘和同步复制能提供最高的可靠性，但会显著降低消息吞吐量和增加延迟。因此，需要根据业务对消息丢失的容忍度来选择合适的策略和配置。</p>
<p>作为后端开发人员，我们必须深入理解这些机制，并结合业务场景做出明智的设计决策。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F/" class="post-title-link" itemprop="url">消息队列如何保证有序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:18:42" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>您好！保证消息的<strong>有序性（Ordering）</strong>在分布式系统中是一个非常复杂但又至关重要的问题。它意味着消息在生产、传输和消费的整个过程中，都必须按照其发送时的相对顺序进行处理。</p>
<p>在实际场景中，我们通常追求的是<strong>局部有序性</strong>，而不是严格的<strong>全局有序性</strong>。</p>
<ul>
<li><strong>全局有序性：</strong> 整个系统中所有消息都严格按照其生产时间顺序被消费，这在分布式环境中几乎无法实现，而且性能开销巨大。</li>
<li><strong>局部有序性（更常见）：</strong> 针对某个特定维度（例如，同一个订单的所有操作、同一个用户的所有事件）的消息，需要保证它们的消费顺序与生产顺序一致。不同维度之间的消息顺序则不要求。</li>
</ul>
<p>要保证消息的有序性，需要从消息流动的<strong>三大环节（生产者、消息队列、消费者）</strong>进行设计和控制。</p>
<hr>
<h3 id="一、-生产端（Producer）：确保消息按序发送到指定分区"><a href="#一、-生产端（Producer）：确保消息按序发送到指定分区" class="headerlink" title="一、 生产端（Producer）：确保消息按序发送到指定分区"></a>一、 生产端（Producer）：确保消息按序发送到指定分区</h3><p>这是保证有序性的第一步，也是最关键的一步。</p>
<ol>
<li><p><strong>串行发送：</strong> 如果需要保证某个特定维度（如订单ID、用户ID）的消息有序，生产者必须确保与该维度相关的所有消息都是<strong>串行地发送</strong>到消息队列的。避免多线程并发发送同一维度的消息。</p>
</li>
<li><p><strong>消息路由到同一分区&#x2F;队列：</strong></p>
<ul>
<li>这是核心。大多数主流消息队列（如 Kafka、RocketMQ）都<strong>只保证单个分区（Partition）或队列（Queue）内的消息是有序的</strong>。</li>
<li>因此，生产者需要使用<strong>相同的业务键（如订单ID、用户ID）</strong>作为 <code>Message Key</code> 或 <code>Sharding Key</code>，通过散列（Hash）算法或其他路由策略，确保：<strong>所有属于同一个业务维度（例如同一个订单）的消息，都发送到消息队列的同一个物理分区或队列中。</strong></li>
<li>例如，订单ID为 <code>ORDER_001</code> 的所有消息，无论是“创建”、“支付”、“发货”还是“取消”，都必须被发送到 <code>TopicA</code> 的 <code>Partition 0</code>。而 <code>ORDER_002</code> 的所有消息则发送到 <code>Partition 1</code>。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码示例</span></span><br><span class="line">Producer<span class="selector-class">.send</span>(message_body, message_key=<span class="string">&quot;ORDER_001&quot;</span>) <span class="comment">// 确保同一key的消息被路由到同一分区</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="二、-消息队列（Broker）端：保证分区内部有序存储"><a href="#二、-消息队列（Broker）端：保证分区内部有序存储" class="headerlink" title="二、 消息队列（Broker）端：保证分区内部有序存储"></a>二、 消息队列（Broker）端：保证分区内部有序存储</h3><p>这部分是消息队列系统自身的设计保证。</p>
<ol>
<li><strong>分区内有序存储：</strong> 主流的消息队列系统（如 Apache Kafka、Apache RocketMQ）都内建了机制来保证：<strong>只要消息被正确地发送到一个分区的 leader 副本，并且被成功写入，那么它们在该分区内部的存储顺序就和接收顺序是严格一致的。</strong></li>
<li><strong>主从复制：</strong> 对于多副本（主从）机制，通常会要求从副本严格按照主副本的写入顺序进行复制，以保证数据一致性和有序性。只有当消息在主副本和从副本都按序写入并确认后，才认为消息写入成功。</li>
</ol>
<hr>
<h3 id="三、-消费端（Consumer）：确保消息按序处理"><a href="#三、-消费端（Consumer）：确保消息按序处理" class="headerlink" title="三、 消费端（Consumer）：确保消息按序处理"></a>三、 消费端（Consumer）：确保消息按序处理</h3><p>即使消息在 Broker 层面是有序的，但如果在消费者端处理不当，有序性仍可能被破坏。</p>
<ol>
<li><p><strong>单线程消费单个分区&#x2F;队列：</strong></p>
<ul>
<li>这是保证消费者端有序性的<strong>最主要方式</strong>。消费者从一个分区&#x2F;队列拉取消息后，必须使用<strong>单线程</strong>按拉取到的顺序进行处理。</li>
<li>如果消费者内部使用多线程并行处理从同一个分区拉取的消息，尽管消息到达的顺序是正确的，但并行处理可能导致处理完成的顺序混乱。</li>
<li><strong>消费组与分区</strong>：在一个消费组内，一个分区通常只能被该消费组中的一个消费者实例所消费。这样做的目的是避免多个消费者实例竞争同一个分区内的消息，从而破坏分区内部的有序性。如果消费者需要线性扩展，可以在不同的消费组订阅同一个 Topic，或者增加 Topic 的分区数量。</li>
</ul>
</li>
<li><p><strong>避免重试导致的乱序：</strong></p>
<ul>
<li>消息队列的重试机制是为了保证消息不丢失（“至少一次”投递），但它可能导致消息乱序。例如，消息 A 失败重试，消息 B 成功处理。等 A 重试成功时，B 已经处理完了。</li>
<li><strong>处理策略：</strong><ul>
<li><strong>严格顺序消息模式：</strong> 某些 MQ（如 RocketMQ）提供专门的“顺序消息”模式，在这种模式下，如果一个消息处理失败，后续消息会被阻塞，直到失败消息处理成功或进入死信队列。这虽然保证了严格顺序，但可能导致消息积压。</li>
<li><strong>业务层面的顺序保障（幂等性与版本号）：</strong> 为了容忍消息可能存在重复和乱序（尤其在重试场景），消费者必须设计为<strong>幂等</strong>的。此外，可以在消息中加入版本号或时间戳，消费者在处理时校验版本号，确保处理的是最新的或正确的版本。对于旧版本消息可以直接跳过或更新。</li>
<li><strong>死信队列 &#x2F; 延迟队列：</strong> 对于处理失败但不希望阻塞后续消息的场景，可以将失败的消息放入死信队列。或者，将消息放入一个<strong>延迟队列</strong>，待其依赖的前续消息处理完毕后再重新投递。这需要业务逻辑有能力处理消息的“跳跃”和未来的“回溯”。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>批量消费的考量：</strong></p>
<ul>
<li>虽然批量消费能够提高吞吐量，但如果批量内的消息有顺序要求，则需要确保批次内消息的顺序。一般来说，从一个分区拉取的一个批次内的消息，Broker 会保证其顺序。但消费者处理批次内的消息时需注意。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结与权衡"><a href="#总结与权衡" class="headerlink" title="总结与权衡"></a>总结与权衡</h3><p>保证消息的有序性会增加系统的复杂性和降低吞吐量，因为：</p>
<ul>
<li>它限制了并行度：同一顺序维度的消息无法并行处理。</li>
<li>它可能增加消息积压风险：一个消息处理失败可能阻塞后续消息。</li>
</ul>
<p>因此，在设计系统时，<strong>需要仔细评估业务是否真的需要严格的局部有序性</strong>。在大多数场景中，通过：</p>
<ol>
<li><strong>生产者将相关消息路由到同一分区&#x2F;队列。</strong></li>
<li><strong>消费者以单线程消费该分区&#x2F;队列。</strong></li>
<li><strong>消费者实现幂等性并结合版本校验。</strong></li>
</ol>
<p>通常就能满足业务对局部有序性的需求。对于极致的全局有序性需求，则需要考虑更重量级的分布式事务解决方案或特定的流处理框架。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/24/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/26/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
