<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hui&#39;s Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="六一">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">DHCP 协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:28:38" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="DHCP-协议的工作原理及应用场景"><a href="#DHCP-协议的工作原理及应用场景" class="headerlink" title="DHCP 协议的工作原理及应用场景"></a>DHCP 协议的工作原理及应用场景</h3><h4 id="什么是-DHCP-协议？"><a href="#什么是-DHCP-协议？" class="headerlink" title="什么是 DHCP 协议？"></a>什么是 DHCP 协议？</h4><p>DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 是一种网络协议，用于自动化管理和分配网络中的 IP 地址以及其他相关配置信息（如子网掩码、默认网关、DNS 服务器地址等）。它的核心思想是取代手动配置每台设备的网络参数，实现即插即用，大大简化了大型网络的管理。</p>
<h4 id="DHCP-协议的工作原理-DORA-过程"><a href="#DHCP-协议的工作原理-DORA-过程" class="headerlink" title="DHCP 协议的工作原理 (DORA 过程)"></a>DHCP 协议的工作原理 (DORA 过程)</h4><p>DHCP 协议通常通过四步过程（称为 DORA 过程）来完成 IP 地址分配：</p>
<ol>
<li><p><strong>Discover (发现)</strong></p>
<ul>
<li><strong>客户端行为：</strong> 当一台新设备（或一台没有配置 IP 地址的设备）连接到网络时，它不知道网络中是否有 DHCP 服务器，也不知道自己的 IP 地址。因此，它会广播一个 DHCP Discover 消息到局域网内的所有设备（使用目的 IP 地址 255.255.255.255，源 IP 地址 0.0.0.0）。</li>
<li><strong>目的：</strong> 寻找网络中的 DHCP 服务器。</li>
</ul>
</li>
<li><p><strong>Offer (提供)</strong></p>
<ul>
<li><strong>服务器行为：</strong> 网络中的 DHCP 服务器收到 DHCP Discover 消息后，会从其可用的 IP 地址池中选择一个合适的 IP 地址，以及其他网络配置信息（如子网掩码、默认网关、DNS 服务器地址、租约时间等），然后以单播或广播形式（取决于客户端的Discover报文配置）向客户端发送一个 DHCP Offer 消息。</li>
<li><strong>目的：</strong> 向客户端提供一个可用的 IP 地址和其他配置。</li>
</ul>
</li>
<li><p><strong>Request (请求)</strong></p>
<ul>
<li><strong>客户端行为：</strong> 客户端收到一个或多个 DHCP Offer 消息后（如果网络中有多个DHCP服务器），会选择其中一个 Offer（通常是第一个收到的，或者根据其他策略），然后向所有 DHCP 服务器广播一个 DHCP Request 消息。这个请求中包含了它选择了哪个 DHCP 服务器的 Offer，以及请求的 IP 地址。</li>
<li><strong>目的：</strong> 客户端确认选择某个 DHCP 服务器提供的 IP 地址。通过广播，其他DHCP服务器会知道该客户端选择了哪个服务器的IP，并将其提供的IP地址收回池中。</li>
</ul>
</li>
<li><p><strong>Acknowledge (确认)</strong></p>
<ul>
<li><strong>服务器行为：</strong> 被选中的 DHCP 服务器收到 DHCP Request 消息后，会确认该 IP 地址仍然可用，然后向客户端发送一个 DHCP ACK (Acknowledge) 消息。这个消息包含了客户端最终将使用的 IP 地址、租约期限以及其他所有配置信息。</li>
<li><strong>目的：</strong> DHCP 服务器最终确认 IP 地址分配，客户端获取配置信息。</li>
</ul>
</li>
</ol>
<p><strong>IP 地址续租：</strong><br>当 IP 地址的租约即将到期时，客户端会再次发送 DHCP Request 消息来请求续租。如果服务器同意，则发送 DHCP ACK 消息确认续租；如果服务器不同意，或者 IP 地址已被其他客户端使用，服务器会发送 DHCP NAK (Negative Acknowledge) 消息，客户端需要重新启动 DORA 过程来获取新的 IP 地址。</p>
<hr>
<h4 id="DHCP-协议的应用场景"><a href="#DHCP-协议的应用场景" class="headerlink" title="DHCP 协议的应用场景"></a>DHCP 协议的应用场景</h4><p>DHCP 协议的广泛应用基于其自动化、集中管理和资源优化的优势。</p>
<ol>
<li><p><strong>家庭网络 (Home Networks)：</strong></p>
<ul>
<li><strong>路由器作为 DHCP 服务器：</strong> 家庭无线路由器通常内置 DHCP 服务器功能。当你的手机、笔记本电脑、智能电视等设备连接到 Wi-Fi 时，它们会自动从路由器获取 IP 地址，无需手动配置。这使得新设备加入网络非常方便。</li>
</ul>
</li>
<li><p><strong>企业网络 (Enterprise Networks)：</strong></p>
<ul>
<li><strong>大规模部署：</strong> 在大型公司、学校、医院等机构中，有成百上千甚至上万台设备需要连接网络。手动配置每台设备的 IP 地址几乎是不可能的工作。DHCP 服务器能够高效地为所有员工电脑、访客设备、打印机、IP 电话等分配 IP 地址，大大减轻了网络管理员的工作负担。</li>
<li><strong>移动办公：</strong> 员工的笔记本电脑在不同部门、不同办公区之间移动时，每次连接不同的子网都可以通过 DHCP 自动获取新的 IP 地址配置。</li>
<li><strong>IP 地址重用：</strong> 当设备离线后，其 IP 地址租约到期并被释放回 IP 地址池，可以分配给其他新上线设备，提高了 IP 地址资源的利用率。</li>
</ul>
</li>
<li><p><strong>公共 Wi-Fi 热点 (Public Wi-Fi Hotspots)：</strong></p>
<ul>
<li>机场、咖啡馆、酒店、商场等提供的免费 Wi-Fi 服务，都依赖 DHCP 为接入的用户设备自动分配 IP 地址，实现了“即插即用”的便捷性。</li>
</ul>
</li>
<li><p><strong>数据中心&#x2F;云计算环境 (Data Centers&#x2F;Cloud Environments)：</strong></p>
<ul>
<li><strong>虚拟机和容器的动态分配：</strong> 在虚拟化和云计算环境中，新的虚拟机或容器可能频繁地创建、迁移和销毁。DHCP 可以自动化地为这些动态资源分配 IP 地址，确保它们能够快速地启动并加入网络。</li>
<li><strong>弹性伸缩：</strong> 当应用程序需要更多服务器实例时，新启动的服务器通过 DHCP 快速获取网络配置。</li>
</ul>
</li>
<li><p><strong>物联网 (IoT - Internet of Things)：</strong></p>
<ul>
<li>智能家居设备、传感器、摄像头等 IoT 设备数量庞大，且通常资源有限，不适合手动配置。DHCP 提供了一种简单有效的方式来管理和配置这些设备的网络连接。</li>
</ul>
</li>
<li><p><strong>服务器&#x2F;特定设备的 IP 地址保留：</strong></p>
<ul>
<li>尽管 DHCP 主要用于动态分配，但它也支持“IP 地址保留”或“静态映射”功能。这意味着你可以为某个设备的 MAC 地址绑定一个固定的 IP 地址，保证它每次通过 DHCP 获取的都是同一个 IP 地址，这对于需要固定 IP 的服务器、打印机或网络设备非常有用，同时仍然利用了 DHCP 的集中管理优势。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>DHCP 协议通过自动化 IP 地址分配和网络配置，极大地简化了网络管理，提高了网络的易用性和可扩展性。它是现代网络中不可或缺的基础服务。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Crane/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Crane/" class="post-title-link" itemprop="url">Crane</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:26:45" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>49k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>45 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Crane"><a href="#Crane" class="headerlink" title="Crane"></a>Crane</h1><p><a target="_blank" rel="noopener" href="https://gocrane.io/">Crane</a> 是一个基于 FinOps 的云资源分析与成本优化平台，它的愿景是在保证客户应用运行质量的前提下实现极致的降本。Crane 已经在腾讯内部自研业务实现了大规模落地，部署数百个 Kubernetes 集群、管控 CPU 核数达百万，在降本增效方面取得了阶段性成果。以腾讯某部门集群优化为例，通过使用 FinOps Crane，该部门在保障业务稳定的情况下，资源利用率提升了 3 倍；腾讯另一自研业务落地 Crane 后，在一个月内实现了总 CPU 规模 40 万核的节省量，相当于成本节约超 1000 万元&#x2F;月。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666249414588.png" alt="FinOps"></p>
<blockquote>
<p>FinOps 是将 DevOps、财务和业务整合在一起的变革，其目标在于优化一个组织在云计算上的支出的财务规范和技术解决方案，即根据支出的历史记录和来自预期负载的信息，FinOps 可以在需要时预分配资源或估算成本。FinOps 可以称为“财务运维” ，或者更直白地称为“成本优化”，是将财务问责制引入云的 IT 支持，进行调整以优化质量和支出。</p>
</blockquote>
<p><code>Crane</code> 会通过下面 3 个方面来开启成本优化之旅：</p>
<ul>
<li>成本展示: Kubernetes 资源( Deployments, StatefulSets )的多维度聚合与展示。</li>
<li>成本分析: 周期性的分析集群资源的状态并提供优化建议。</li>
<li>成本优化: 通过丰富的优化工具更新配置达成降本的目标。</li>
</ul>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666249357026.jpg" alt="Crane整体架构"></p>
<p><strong>成本可视化和优化评估</strong></p>
<ul>
<li>提供一组 Exporter 计算集群云资源的计费和账单数据并存储到你的监控系统，比如 Prometheus。</li>
<li>多维度的成本洞察，优化评估。通过 Cloud Provider 支持多云计费。</li>
</ul>
<p><strong>推荐框架</strong></p>
<ul>
<li>提供了一个可扩展的推荐框架以支持多种云资源的分析，内置了多种推荐器：<code>资源推荐</code>、<code>副本推荐</code>、<code>闲置资源推荐</code>。</li>
</ul>
<p><strong>基于预测的水平弹性器</strong></p>
<ul>
<li><code>EffectiveHorizontalPodAutoscaler</code> 支持预测驱动的弹性。它基于社区 HPA 做底层的弹性控制，支持更丰富的弹性触发策略（预测、观测、周期），让弹性更加高效，并保障了服务的质量。</li>
</ul>
<p><strong>负载感知的调度器</strong></p>
<ul>
<li>动态调度器根据实际的节点利用率构建了一个简单但高效的模型，并过滤掉那些负载高的节点来平衡集群。</li>
</ul>
<p><strong>基于 QOS 的混部</strong></p>
<ul>
<li><code>QOS</code> 相关能力保证了运行在 Kubernetes 上的 Pod 的稳定性。具有多维指标条件下的干扰检测和主动回避能力，支持精确操作和自定义指标接入；具有预测算法增强的弹性资源超卖能力，复用和限制集群内的空闲资源；具备增强的旁路 cpuset 管理能力，在绑核的同时提升资源利用效率。</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Crane 的整体架构如下图所示：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666249962271.jpg" alt="架构"></p>
<p><strong>Craned</strong>：Craned 是 Crane 的最核心组件，它管理了 CRDs 的生命周期以及 API，Craned 通过 Deployment 方式部署且由两个容器组成：</p>
<ul>
<li>Craned: 运行了 Operators 用来管理 CRDs，向 Dashboard 提供 WebApi，Predictors 提供了 TimeSeries API</li>
<li>Dashboard: 基于 TDesign’s Starter 脚手架研发的前端项目，提供了易于上手的产品功能</li>
</ul>
<p><strong>Fadvisor</strong>：<code>Fadvisor</code> 提供一组 Exporter 计算集群云资源的计费和账单数据并存储到你的监控系统，比如 Prometheus。Fadvisor 通过 Cloud Provider 支持了多云计费的 API。</p>
<p><strong>Metric Adapter</strong>：<code>Metric Adapter</code> 实现了一个 Custom Metric Apiserver，Metric Adapter 读取 CRDs 信息并提供基于 Custom&#x2F;External Metric API 的 HPA Metric 的数据。</p>
<p><strong>Crane Agent</strong>：Crane Agent 通过 DaemonSet 部署在集群的节点上。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们这里使用 Helm 的方式来进行安装，首先需要安装 Prometheus 和 Grafana（如果您已经在环境中部署了 Prometheus 和 Grafana，可以跳过该步骤）。</p>
<p><code>Crane</code> 使用 Prometheus 获取集群工作负载对资源的使用情况，可以使用如下所示命令安装 Prometheus：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo add prometheus-community https://finops-helm.pkg.coding.net/gocrane/prometheus-community</span><br><span class="line">$ helm upgrade --install prometheus -n crane-system \</span><br><span class="line">    --<span class="built_in">set</span> pushgateway.enabled=<span class="literal">false</span> \</span><br><span class="line">    --<span class="built_in">set</span> alertmanager.enabled=<span class="literal">false</span> \</span><br><span class="line">    --<span class="built_in">set</span> server.persistentVolume.enabled=<span class="literal">false</span> \</span><br><span class="line">    -f https://gitee.com/finops/helm-charts/raw/main/integration/prometheus/override_values.yaml \</span><br><span class="line">    --create-namespace  prometheus-community/prometheus</span><br></pre></td></tr></table></figure>



<p>由于 Crane 的 <code>Fadvisor</code> 会使用 Grafana 来展示成本预估，所以我们也需要安装 Grafana：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo add grafana https://finops-helm.pkg.coding.net/gocrane/grafana</span><br><span class="line">$ helm upgrade --install grafana \</span><br><span class="line">    -f https://gitee.com/finops/helm-charts/raw/main/integration/grafana/override_values.yaml \</span><br><span class="line">    -n crane-system \</span><br><span class="line">    --create-namespace grafana/grafana</span><br></pre></td></tr></table></figure>



<p>上面我们指定的 values 文件中配置了 Prometheus 数据源以及一些相关的 Dashboard，直接安装后即可使用。</p>
<p>然后接下来安装 crane 与 fadvisor，同样直接使用 Helm Chart 安装即可，如下命令所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo add crane https://finops-helm.pkg.coding.net/gocrane/gocrane</span><br><span class="line">$ helm upgrade --install crane -n crane-system --create-namespace crane/crane</span><br><span class="line">$ helm upgrade --install fadvisor -n crane-system --create-namespace crane/fadvisor</span><br></pre></td></tr></table></figure>



<p>安装后可以查看 Pod 列表了解应用状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -n crane-system</span><br><span class="line">NAME                                             READY   STATUS             RESTARTS         AGE</span><br><span class="line">crane-agent-8jrs5                                0/1     CrashLoopBackOff   71 (2m26s ago)   3h23m</span><br><span class="line">crane-agent-t2rpz                                0/1     CrashLoopBackOff   71 (65s ago)     3h23m</span><br><span class="line">craned-776c7b6c75-gx8cp                          2/2     Running            0                3h28m</span><br><span class="line">fadvisor-56fcc547b6-zvf6r                        1/1     Running            0                158m</span><br><span class="line">grafana-5cd57f9f6b-d7nk5                         1/1     Running            0                3h32m</span><br><span class="line">metric-adapter-887f6548d-qcbb8                   1/1     Running            0                3h28m</span><br><span class="line">prometheus-kube-state-metrics-5f6f856ffb-4lrrr   1/1     Running            0                3h34m</span><br><span class="line">prometheus-node-exporter-97vmz                   1/1     Running            0                3h27m</span><br><span class="line">prometheus-node-exporter-m2gr9                   1/1     Running            0                3h27m</span><br><span class="line">prometheus-server-7744f66fb4-lw2sz               2/2     Running            0                3h34m</span><br></pre></td></tr></table></figure>



<p>需要注意我们这里 crane-agent 启动失败了，这是因为我的 K8s 集群使用的是 containerd 这种容器运行时，需要明确声明指定使用的运行时 endpoint：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit ds crane-agent -n crane-system</span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - args:</span><br><span class="line">        - --v=2</span><br><span class="line">        - --runtime-endpoint=/run/containerd/containerd.sock  <span class="comment"># 指定有containerd的sock文件</span></span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - /crane-agent</span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure>



<p>此外还需要更新 crane-agent 的 rbac 权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit clusterrole crane-agent</span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line">- apiGroups:</span><br><span class="line">  - ensurance.crane.io</span><br><span class="line">  resources:</span><br><span class="line">  - podqosensurancepolicies</span><br><span class="line">  - nodeqoss  <span class="comment"># 增加 nodeqoss 和 podqoss 资源的权限</span></span><br><span class="line">  - podqoss</span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure>



<p>然后我们可以再创建一个 Ingress 对象来暴露 crane 的 dashboard 服务：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-crane-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">crane-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">crane.k8s.local</span> <span class="comment"># change to your domain</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">craned</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure>



<p>直接应用该 ingress 资源对象即可，当然前提是你已经安装了 ingress-nginx：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -n ingress-nginx</span><br><span class="line">NAME                                            READY   STATUS    RESTARTS      AGE</span><br><span class="line">ingress-nginx-controller-7647c44fb9-6gcsf       1/1     Running   8 (44m ago)   21d</span><br><span class="line">ingress-nginx-defaultbackend-7fc5bfd66c-gqmmj   1/1     Running   8 (44m ago)   21d</span><br><span class="line">$ kubectl get ingress -n crane-system</span><br><span class="line">NAME                      CLASS   HOSTS             ADDRESS        PORTS   AGE</span><br><span class="line">ingress-crane-dashboard   nginx   crane.k8s.local   192.168.0.52   80      11s</span><br></pre></td></tr></table></figure>



<p>将 <code>crane.k8s.local</code> 映射到 <code>192.168.0.52</code> 后就可以访问 crane 的 dashboard 了：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666251698513.png" alt="crane dashboard"></p>
<p>第一次访问 dashboard 的时候需要添加一个 K8s 集群，添加<code>添加集群</code>按钮开始添加，填入正确的 <code>CRNE Endpoint</code> 地址即可。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666251839866.png" alt="添加集群"></p>
<p>然后切换到<code>集群总览</code>可以查看到当前集群的一些成本相关数据，由于目前数据还不足，所以会有一些空的图表。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666256619382.png" alt="集群总览"></p>
<p>在成本分布页面可以按照维度成本、集群成本和利用率指标以及命名空间成本来展示成本的分布情况。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666260576817.jpg" alt="成本分布"></p>
<h2 id="智能推荐"><a href="#智能推荐" class="headerlink" title="智能推荐"></a>智能推荐</h2><p>在 dasbhoard 中开箱后就可以看到相关的成本数据，是因为在添加集群的时候我们安装了推荐的规则。</p>
<p>推荐框架会自动分析集群的各种资源的运行情况并给出优化建议。<code>Crane</code> 的推荐模块会定期检测发现集群资源配置的问题，并给出优化建议。智能推荐提供了多种 Recommender 来实现面向不同资源的优化推荐。</p>
<p>在<code>成本分析&gt;推荐规则</code>页面可以看到我们安装的两个推荐规则。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666252873850.jpg" alt="推荐规则"></p>
<p>这些推荐规则实际上是安装在 K8s 集群上的 <code>RecommendationRule CRD</code> 对象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get RecommendationRule</span><br><span class="line">NAME             RUNINTERVAL   AGE</span><br><span class="line">idlenodes-rule   24h           16m</span><br><span class="line">workloads-rule   24h           16m</span><br></pre></td></tr></table></figure>



<p><code>workloads-rule</code> 这个推荐规则的资源对象如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">analysis.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RecommendationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">workloads-rule</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">analysis.crane.io/recommendation-rule-preinstall:</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">resourceSelectors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">      <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line">      <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">  <span class="attr">namespaceSelector:</span></span><br><span class="line">    <span class="attr">any:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">runInterval:</span> <span class="string">24h</span></span><br><span class="line">  <span class="attr">recommenders:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Replicas</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Resource</span></span><br></pre></td></tr></table></figure>



<p><code>RecommendationRule</code> 是一个全部范围内的对象，该推荐规则会对所有命名空间中的 Deployments 和 StatefulSets 做资源推荐和副本数推荐。相关规范属性如下所示：</p>
<ul>
<li>每隔 24 小时运行一次分析推荐，<code>runInterval</code> 格式为时间间隔，比如: 1h，1m，设置为空表示只运行一次。</li>
<li>待分析的资源通过配置 <code>resourceSelectors</code> 数组设置，每个 <code>resourceSelector</code> 通过 <code>kind</code>、<code>apiVersion</code>、<code>name</code> 选择 K8s 中的资源，当不指定 name 时表示在 <code>namespaceSelector</code> 基础上的所有资源。</li>
<li><code>namespaceSelector</code> 定义了待分析资源的命名空间，<code>any: true</code> 表示选择所有命名空间。</li>
<li><code>recommenders</code> 定义了待分析的资源需要通过哪些 <code>Recommender</code> 进行分析。目前支持两种 <code>Recommender</code>：<ul>
<li>资源推荐(Resource): 通过 VPA 算法分析应用的真实用量推荐更合适的资源配置</li>
<li>副本数推荐(Replicas): 通过 HPA 算法分析应用的真实用量推荐更合适的副本数量</li>
</ul>
</li>
</ul>
<p><strong>资源推荐</strong></p>
<p>Kubernetes 用户在创建应用资源时常常是基于经验值来设置 request 和 limit，通过资源推荐的算法分析应用的真实用量推荐更合适的资源配置，你可以参考并采纳它提升集群的资源利用率。该推荐算法模型采用了 VPA 的滑动窗口（Moving Window）算法进行推荐：</p>
<ul>
<li>通过监控数据，获取 Workload 过去一周（可配置）的 CPU 和内存的历史用量。</li>
<li>算法考虑数据的时效性，较新的数据采样点会拥有更高的权重。</li>
<li>CPU 推荐值基于用户设置的目标百分位值计算，内存推荐值基于历史数据的最大值。</li>
</ul>
<p><strong>副本数推荐</strong></p>
<p>Kubernetes 用户在创建应用资源时常常是基于经验值来设置副本数。通过副本数推荐的算法分析应用的真实用量推荐更合适的副本配置，同样可以参考并采纳它提升集群的资源利用率。其实现的基本算法是基于工作负载历史 CPU 负载，找到过去七天内每小时负载最低的 CPU 用量，计算按 50%（可配置）利用率和工作负载 CPU Request 应配置的副本数。</p>
<p>当我们部署 crane 的时候会在同一个命名空间中创建一个名为 <code>recommendation-configuration</code> 的 ConfigMap 对象，包含一个 yaml 格式的 <code>RecommendationConfiguration</code>，该配置订阅了 <code>recommender</code> 的配置，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">cm</span> <span class="string">recommendation-configuration</span> <span class="string">-n</span> <span class="string">crane-system</span> <span class="string">-oyaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">config.yaml:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">    apiVersion: analysis.crane.io/v1alpha1</span></span><br><span class="line"><span class="string">    kind: RecommendationConfiguration</span></span><br><span class="line"><span class="string">    recommenders:</span></span><br><span class="line"><span class="string">      - name: Replicas  # 副本数推荐</span></span><br><span class="line"><span class="string">        acceptedResources:</span></span><br><span class="line"><span class="string">          - kind: Deployment</span></span><br><span class="line"><span class="string">            apiVersion: apps/v1</span></span><br><span class="line"><span class="string">          - kind: StatefulSet</span></span><br><span class="line"><span class="string">            apiVersion: apps/v1</span></span><br><span class="line"><span class="string">      - name: Resource  # 资源推荐</span></span><br><span class="line"><span class="string">        acceptedResources:</span></span><br><span class="line"><span class="string">          - kind: Deployment</span></span><br><span class="line"><span class="string">            apiVersion: apps/v1</span></span><br><span class="line"><span class="string">          - kind: StatefulSet</span></span><br><span class="line"><span class="string">            apiVersion: apps/v1</span></span><br><span class="line"><span class="string"></span><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">recommendation-configuration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">crane-system</span></span><br></pre></td></tr></table></figure>



<p>需要注意的是资源类型和 recommenders 需要可以匹配，比如 Resource 推荐默认只支持 Deployments 和 StatefulSets。</p>
<p>同样的也可以再查看一次闲置节点推荐规则的资源对象，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">recommendationrule</span> <span class="string">idlenodes-rule</span> <span class="string">-oyaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">analysis.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RecommendationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">analysis.crane.io/recommendation-rule-preinstall:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">idlenodes-rule</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">namespaceSelector:</span></span><br><span class="line">    <span class="attr">any:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">recommenders:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">IdleNode</span></span><br><span class="line">  <span class="attr">resourceSelectors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line">  <span class="attr">runInterval:</span> <span class="string">24h</span></span><br></pre></td></tr></table></figure>



<p>创建 <code>RecommendationRule</code> 配置后，RecommendationRule 控制器会根据配置定期运行推荐任务，给出优化建议生成 <code>Recommendation</code> 对象，然后我们可以根据优化建议 <code>Recommendation</code> 调整资源配置。</p>
<p>比如我们这里集群中已经生成了多个优化建议 <code>Recommendation</code> 对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get recommendations</span><br><span class="line">NAME                            TYPE       TARGETKIND    TARGETNAMESPACE   TARGETNAME       STRATEGY   PERIODSECONDS   ADOPTIONTYPE          AGE</span><br><span class="line">workloads-rule-resource-8whzs   Resource   StatefulSet   default           nacos            Once                       StatusAndAnnotation   34m</span><br><span class="line">workloads-rule-resource-hx4cp   Resource   StatefulSet   default           redis-replicas   Once                       StatusAndAnnotation   34m</span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure>



<p>可以随便查看任意一个优化建议对象。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">recommend</span> <span class="string">workloads-rule-resource-g7nwp</span> <span class="string">-n</span> <span class="string">crane-system</span> <span class="string">-oyaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">analysis.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Recommendation</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">workloads-rule-resource-g7nwp</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">crane-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">adoptionType:</span> <span class="string">StatusAndAnnotation</span></span><br><span class="line">  <span class="attr">completionStrategy:</span></span><br><span class="line">    <span class="attr">completionStrategyType:</span> <span class="string">Once</span></span><br><span class="line">  <span class="attr">targetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fadvisor</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">crane-system</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">Patch</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-10-20T07:43:49Z&quot;</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">Recommendation</span> <span class="string">is</span> <span class="string">ready</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">RecommendationReady</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Ready</span></span><br><span class="line">  <span class="attr">currentInfo:</span> <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;template&quot;:&#123;&quot;spec&quot;:&#123;&quot;containers&quot;:[&#123;&quot;name&quot;:&quot;fadvisor&quot;,&quot;resources&quot;:&#123;&quot;requests&quot;:&#123;&quot;cpu&quot;:&quot;0&quot;,&quot;memory&quot;:&quot;0&quot;&#125;&#125;&#125;]&#125;&#125;&#125;&#125;&#x27;</span></span><br><span class="line">  <span class="attr">lastUpdateTime:</span> <span class="string">&quot;2022-10-20T07:43:49Z&quot;</span></span><br><span class="line">  <span class="attr">recommendedInfo:</span> <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;template&quot;:&#123;&quot;spec&quot;:&#123;&quot;containers&quot;:[&#123;&quot;name&quot;:&quot;fadvisor&quot;,&quot;resources&quot;:&#123;&quot;requests&quot;:&#123;&quot;cpu&quot;:&quot;114m&quot;,&quot;memory&quot;:&quot;120586239&quot;&#125;&#125;&#125;]&#125;&#125;&#125;&#125;&#x27;</span></span><br><span class="line">  <span class="attr">recommendedValue:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    resourceRequest:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - containerName: fadvisor</span></span><br><span class="line"><span class="string">        target:</span></span><br><span class="line"><span class="string">          cpu: 114m</span></span><br><span class="line"><span class="string">          memory: &quot;120586239&quot;</span></span><br><span class="line"><span class="string"></span>  <span class="attr">targetRef:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>在 dashboard 的<code>资源推荐</code>页面也能查看到优化建议列表。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666253982497.jpg" alt="资源推荐"></p>
<p>在页面中可以看到当前资源(容器&#x2F;CPU&#x2F;Memory)与推荐的资源数据，点击<code>采纳建议</code>即可获取优化的执行命令。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666254060338.png" alt="查看优化命令"></p>
<p>执行命令即可完成优化，其实就是修改资源对象的 <code>resources</code> 资源数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchData=`kubectl get recommend workloads-rule-resource-g7nwp -n crane-system -o jsonpath=<span class="string">&#x27;&#123;.status.recommendedInfo&#125;&#x27;</span>`;kubectl patch Deployment fadvisor -n crane-system --patch <span class="string">&quot;<span class="variable">$&#123;patchData&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>



<p>对于闲置节点推荐，由于节点的下线在不同平台上的步骤不同，用户可以根据自身需求进行节点的下线或者缩容。</p>
<p>应用在监控系统（比如 Prometheus）中的历史数据越久，推荐结果就越准确，建议生产上超过两周时间。对新建应用的预测往往不准。</p>
<h3 id="自定义推荐"><a href="#自定义推荐" class="headerlink" title="自定义推荐"></a>自定义推荐</h3><p>Recommendation Framework 提供了一套可扩展的 Recommender 框架并支持了内置的 Recommender，用户可以实现一个自定义的 Recommender，或者修改一个已有的 Recommender。</p>
<p>和 K8s 调度框架类似，Recommender 接口定义了一次推荐需要实现的<strong>四个阶段和八个扩展点</strong>，这些扩展点会在推荐过程中按顺序被调用。这些扩展点中的一些可以改变推荐决策，而另一些仅用来提供信息。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/2um5u9.jpg" alt="推荐框架架构"></p>
<p>Recommender 接口定义如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Recommender <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="type">string</span></span><br><span class="line">    framework.Filter</span><br><span class="line">    framework.PrePrepare</span><br><span class="line">    framework.Prepare</span><br><span class="line">    framework.PostPrepare</span><br><span class="line">    framework.PreRecommend</span><br><span class="line">    framework.Recommend</span><br><span class="line">    framework.PostRecommend</span><br><span class="line">    framework.Observe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Phase: Filter</span></span><br><span class="line"><span class="keyword">type</span> Filter <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Filter 将过滤无法通过目标推荐器推荐的资源</span></span><br><span class="line">    Filter(ctx *RecommendationContext) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Phase: Prepare</span></span><br><span class="line"><span class="keyword">type</span> PrePrepare <span class="keyword">interface</span> &#123;</span><br><span class="line">    CheckDataProviders(ctx *RecommendationContext) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Prepare <span class="keyword">interface</span> &#123;</span><br><span class="line">    CollectData(ctx *RecommendationContext) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PostPrepare <span class="keyword">interface</span> &#123;</span><br><span class="line">    PostProcessing(ctx *RecommendationContext) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PreRecommend <span class="keyword">interface</span> &#123;</span><br><span class="line">    PreRecommend(ctx *RecommendationContext) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Phase: Recommend</span></span><br><span class="line"><span class="keyword">type</span> Recommend <span class="keyword">interface</span> &#123;</span><br><span class="line">    Recommend(ctx *RecommendationContext) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PostRecommend <span class="keyword">interface</span> &#123;</span><br><span class="line">    Policy(ctx *RecommendationContext) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Phase: Observe</span></span><br><span class="line"><span class="keyword">type</span> Observe <span class="keyword">interface</span> &#123;</span><br><span class="line">    Observe(ctx *RecommendationContext) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>整个推荐过程分成了四个阶段：<code>Filter</code>、<code>Prepare</code>、<code>Recommend</code>、<code>Observe</code>，阶段的输入是需要分析的 Kubernetes 资源，输出是推荐的优化建议。接口中的 <code>RecommendationContext</code> 保存了一次推荐过程中的上下文，包括推荐目标、RecommendationConfiguration 等信息，我们可以根据自身需求增加更多的内容。</p>
<ul>
<li><strong>Filter</strong>：Filter 阶段用于预处理推荐数据，通常，在预处理时需判断推荐目标是否和 Recommender 匹配，比如资源推荐默认只支持处理 Deployment 和 StatefulSet。除此之外，还可以判断推荐目标状态是否适合推荐，比如是否删除中，是否刚创建等。当返回 error 会终止此次推荐。</li>
<li><strong>Prepare</strong>：Prepare 阶段用于数据准备，请求外部监控系统并将时序数据保存在上下文中。<ul>
<li><code>PrePrepare</code> 扩展点用于检测监控系统的链接情况</li>
<li><code>Prepare</code> 扩展点用于查询时序数据</li>
<li><code>PostPrepare</code> 扩展点用于对时序数据的数据处理，比如：应用冷启动的异常数据，部分数据的缺失，数据聚合，异常数据清理等。</li>
</ul>
</li>
<li><strong>Recommend</strong>：Recommend 阶段用于基于时序数据和资源配置进行优化建议，优化建议的类型取决于推荐的类型。比如，如果是资源推荐，那么输出就是 K8s workload 的资源配置。<ul>
<li><code>Recommend</code> 扩展点用于采用 Crane 的算法模块对数据进行分析计算</li>
<li><code>PostRecommend</code> 扩展点对分析结果进行最后处理</li>
</ul>
</li>
<li><code>Observe</code>：Observe 阶段用于推荐结果的可观测。比如，在资源推荐时，将优化建议的信息通过 Metric 保存到监控系统，再通过 Dashboard 观测优化建议带来的收益。</li>
</ul>
<p>比如资源推荐就实现了 Recommender 接口，主要做了下面 3 个阶段的处理：</p>
<ul>
<li>Filter 阶段：过滤没有 Pod 的工作负载</li>
<li>Recommend 推荐：采用 VPA 的滑动窗口算法分别计算每个容器的 CPU 和内存并给出对应的推荐值</li>
<li>Observe 推荐：将推荐资源配置记录到 <code>crane_analytics_replicas_recommendation</code> 指标</li>
</ul>
<p>除了核心的智能推荐功能之外，Crane 还有很多高级特性，比如可以根据实际的节点利用率的动态调度器、基于流量预测的弹性 HPA 等等。</p>
<h2 id="智能调度器"><a href="#智能调度器" class="headerlink" title="智能调度器"></a>智能调度器</h2><p><code>Crane</code> 除了提供了智能推荐功能之外，还提供了一个调度器插件 <code>Crane-scheduler</code> 可以实现智能调度和完成拓扑感知调度与资源分配的工作。</p>
<h3 id="动态调度器"><a href="#动态调度器" class="headerlink" title="动态调度器"></a>动态调度器</h3><p>K8s 的原生调度器只能通过资源的 requests 值来调度 pod，这很容易造成一系列负载不均的问题：</p>
<ul>
<li>对于某些节点，实际负载与资源请求相差不大，这会导致很大概率出现稳定性问题。</li>
<li>对于其他节点来说，实际负载远小于资源请求，这将导致资源的巨大浪费。</li>
</ul>
<p>为了解决这些问题，动态调度器根据实际的节点利用率构建了一个简单但高效的模型，并过滤掉那些负载高的节点来平衡集群。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666261847798.jpg" alt="动态调度器架构"></p>
<p>动态调度器依赖于 prometheus 和 node-exporter 收集汇总指标数据，它由两个组件组成：</p>
<ul>
<li><code>Node-annotator</code> 定期从 Prometheus 拉取数据，并以 annotations 的形式在节点上用时间戳标记它们。</li>
<li><code>Dynamic plugin</code> 直接从节点的 annotations 中读取负载数据，过滤并基于简单的算法对候选节点进行评分。</li>
</ul>
<p>动态调度器提供了一个默认值调度策略，配置文件如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># policy.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">scheduler.policy.crane.io/v1alpha1</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">DynamicSchedulerPolicy</span></span><br><span class="line"> <span class="attr">spec:</span></span><br><span class="line">   <span class="attr">syncPolicy:</span></span><br><span class="line">     <span class="comment">##cpu usage</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cpu_usage_avg_5m</span></span><br><span class="line">       <span class="attr">period:</span> <span class="string">3m</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cpu_usage_max_avg_1h</span></span><br><span class="line">       <span class="attr">period:</span> <span class="string">15m</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cpu_usage_max_avg_1d</span></span><br><span class="line">       <span class="attr">period:</span> <span class="string">3h</span></span><br><span class="line">     <span class="comment">##memory usage</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mem_usage_avg_5m</span></span><br><span class="line">       <span class="attr">period:</span> <span class="string">3m</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mem_usage_max_avg_1h</span></span><br><span class="line">       <span class="attr">period:</span> <span class="string">15m</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mem_usage_max_avg_1d</span></span><br><span class="line">       <span class="attr">period:</span> <span class="string">3h</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">predicate:</span></span><br><span class="line">     <span class="comment">##cpu usage</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cpu_usage_avg_5m</span></span><br><span class="line">       <span class="attr">maxLimitPecent:</span> <span class="number">0.65</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cpu_usage_max_avg_1h</span></span><br><span class="line">       <span class="attr">maxLimitPecent:</span> <span class="number">0.75</span></span><br><span class="line">     <span class="comment">##memory usage</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mem_usage_avg_5m</span></span><br><span class="line">       <span class="attr">maxLimitPecent:</span> <span class="number">0.65</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mem_usage_max_avg_1h</span></span><br><span class="line">       <span class="attr">maxLimitPecent:</span> <span class="number">0.75</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">priority:</span></span><br><span class="line">     <span class="comment">##cpu usage</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cpu_usage_avg_5m</span></span><br><span class="line">       <span class="attr">weight:</span> <span class="number">0.2</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cpu_usage_max_avg_1h</span></span><br><span class="line">       <span class="attr">weight:</span> <span class="number">0.3</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cpu_usage_max_avg_1d</span></span><br><span class="line">       <span class="attr">weight:</span> <span class="number">0.5</span></span><br><span class="line">     <span class="comment">##memory usage</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mem_usage_avg_5m</span></span><br><span class="line">       <span class="attr">weight:</span> <span class="number">0.2</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mem_usage_max_avg_1h</span></span><br><span class="line">       <span class="attr">weight:</span> <span class="number">0.3</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mem_usage_max_avg_1d</span></span><br><span class="line">       <span class="attr">weight:</span> <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">hotValue:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">timeRange:</span> <span class="string">5m</span></span><br><span class="line">       <span class="attr">count:</span> <span class="number">5</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">timeRange:</span> <span class="string">1m</span></span><br><span class="line">       <span class="attr">count:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>我们可以根据实际需求自定义该策略配置，默认策略依赖于以下指标：</p>
<ul>
<li>cpu_usage_avg_5m</li>
<li>cpu_usage_max_avg_1h</li>
<li>cpu_usage_max_avg_1d</li>
<li>mem_usage_avg_5m</li>
<li>mem_usage_max_avg_1h</li>
<li>mem_usage_max_avg_1d</li>
</ul>
<p>这几个指标我们这里是通过记录规则创建的，可以查看 Prometheus 的配置文件来了解详细信息：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">cm</span> <span class="string">-n</span> <span class="string">crane-system</span> <span class="string">prometheus-server</span> <span class="string">-oyaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">alerting_rules.yml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;&#125;</span></span><br><span class="line"><span class="string"></span>  <span class="attr">alerts:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;&#125;</span></span><br><span class="line"><span class="string"></span>  <span class="attr">allow-snippet-annotations:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">  <span class="attr">prometheus.yml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    global:</span></span><br><span class="line"><span class="string">      evaluation_interval: 1m</span></span><br><span class="line"><span class="string">      scrape_interval: 1m</span></span><br><span class="line"><span class="string">      scrape_timeout: 10s</span></span><br><span class="line"><span class="string">    rule_files:</span></span><br><span class="line"><span class="string">    - /etc/config/recording_rules.yml</span></span><br><span class="line"><span class="string">    - /etc/config/alerting_rules.yml</span></span><br><span class="line"><span class="string">    - /etc/config/rules</span></span><br><span class="line"><span class="string">    - /etc/config/alerts</span></span><br><span class="line"><span class="string">    scrape_configs:</span></span><br><span class="line"><span class="string">    - job_name: prometheus</span></span><br><span class="line"><span class="string">      static_configs:</span></span><br><span class="line"><span class="string">      - targets:</span></span><br><span class="line"><span class="string">        - localhost:9090</span></span><br><span class="line"><span class="string">    # ......</span></span><br><span class="line"><span class="string"></span>  <span class="attr">recording_rules.yml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    groups:</span></span><br><span class="line"><span class="string">    - interval: 3600s</span></span><br><span class="line"><span class="string">      name: costs.rules</span></span><br><span class="line"><span class="string">      rules:</span></span><br><span class="line"><span class="string">    #   ......</span></span><br><span class="line"><span class="string">    - interval: 30s</span></span><br><span class="line"><span class="string">      name: scheduler.rules.30s</span></span><br><span class="line"><span class="string">      rules:</span></span><br><span class="line"><span class="string">      - expr: 100 - (avg by (instance) (irate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[90s]))</span></span><br><span class="line"><span class="string">          * 100)</span></span><br><span class="line"><span class="string">        record: cpu_usage_active</span></span><br><span class="line"><span class="string">      - expr: 100*(1-node_memory_MemAvailable_bytes/node_memory_MemTotal_bytes)</span></span><br><span class="line"><span class="string">        record: mem_usage_active</span></span><br><span class="line"><span class="string">    - interval: 1m</span></span><br><span class="line"><span class="string">      name: scheduler.rules.1m</span></span><br><span class="line"><span class="string">      rules:</span></span><br><span class="line"><span class="string">      - expr: avg_over_time(cpu_usage_active[5m])</span></span><br><span class="line"><span class="string">        record: cpu_usage_avg_5m</span></span><br><span class="line"><span class="string">      - expr: avg_over_time(mem_usage_active[5m])</span></span><br><span class="line"><span class="string">        record: mem_usage_avg_5m</span></span><br><span class="line"><span class="string">    - interval: 5m</span></span><br><span class="line"><span class="string">      name: scheduler.rules.5m</span></span><br><span class="line"><span class="string">      rules:</span></span><br><span class="line"><span class="string">      - expr: max_over_time(cpu_usage_avg_5m[1h])</span></span><br><span class="line"><span class="string">        record: cpu_usage_max_avg_1h</span></span><br><span class="line"><span class="string">      - expr: max_over_time(cpu_usage_avg_5m[1d])</span></span><br><span class="line"><span class="string">        record: cpu_usage_max_avg_1d</span></span><br><span class="line"><span class="string">      - expr: max_over_time(mem_usage_avg_5m[1h])</span></span><br><span class="line"><span class="string">        record: mem_usage_max_avg_1h</span></span><br><span class="line"><span class="string">      - expr: max_over_time(mem_usage_avg_5m[1d])</span></span><br><span class="line"><span class="string">        record: mem_usage_max_avg_1d</span></span><br><span class="line"><span class="string"></span>  <span class="attr">rules:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">crane-system</span></span><br></pre></td></tr></table></figure>



<p>在调度的 Filter 阶段，如果该节点的实际使用率大于上述任一指标的阈值，则该节点将被过滤。而在 Score 阶段，最终得分是这些指标值的加权和。</p>
<p>在生产集群中，可能会频繁出现调度热点，因为创建 Pod 后节点的负载不能立即增加。因此，我们定义了一个额外的指标，名为 <code>hotValue</code>，表示节点最近几次的调度频率，并且节点的最终优先级是最终得分减去 hotValue。</p>
<p>我们可以在 K8s 集群中安装 <code>Crane-scheduler</code> 作为第二个调度器来进行验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo add crane https://finops-helm.pkg.coding.net/gocrane/gocrane</span><br><span class="line">$ helm upgrade --install scheduler -n crane-system --create-namespace --<span class="built_in">set</span> global.prometheusAddr=<span class="string">&quot;http://prometheus-server.crane-system.svc.cluster.local:8080&quot;</span> crane/scheduler</span><br></pre></td></tr></table></figure>



<p>安装后会创建一个名为 <code>scheduler-config</code> 的 ConfigMap 对象，里面包含的就是调度器的配置文件，我们会在配置中启用 Dynamic 动态调度插件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">cm</span> <span class="string">-n</span> <span class="string">crane-system</span> <span class="string">scheduler-config</span> <span class="string">-oyaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">scheduler-config.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    apiVersion: kubescheduler.config.k8s.io/v1beta2</span></span><br><span class="line"><span class="string">    kind: KubeSchedulerConfiguration</span></span><br><span class="line"><span class="string">    leaderElection:</span></span><br><span class="line"><span class="string">      leaderElect: false</span></span><br><span class="line"><span class="string">    profiles:</span></span><br><span class="line"><span class="string">    - schedulerName: crane-scheduler</span></span><br><span class="line"><span class="string">      plugins:</span></span><br><span class="line"><span class="string">        filter:</span></span><br><span class="line"><span class="string">          enabled:</span></span><br><span class="line"><span class="string">          - name: Dynamic</span></span><br><span class="line"><span class="string">        score:</span></span><br><span class="line"><span class="string">          enabled:</span></span><br><span class="line"><span class="string">          - name: Dynamic</span></span><br><span class="line"><span class="string">            weight: 3</span></span><br><span class="line"><span class="string">      pluginConfig:</span></span><br><span class="line"><span class="string">      - name: Dynamic</span></span><br><span class="line"><span class="string">        args:</span></span><br><span class="line"><span class="string">          policyConfigPath: /etc/kubernetes/policy.yaml</span></span><br><span class="line"><span class="string"></span><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">scheduler-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">crane-system</span></span><br></pre></td></tr></table></figure>



<p>安装完成后我们可以任意创建一个 Pod，并通过设置 <code>schedulerName: crane-scheduler</code> 属性明确指定使用该调度器进行调度，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cpu-stress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">cpu-stress</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">cpu-stress</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">crane-scheduler</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node.kubernetes.io/network-unavailable</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">          <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">stress</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">docker.io/gocrane/stress:latest</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&#x27;stress&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;1&#x27;</span>]</span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">&#x27;1Gi&#x27;</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">&#x27;1Gi&#x27;</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>



<p>直接创建上面的资源对象，正常创建的 Pod 就会通过 <code>Crane Scheduler</code> 调度器进行调度了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From             Message</span><br><span class="line">  ----    ------     ----  ----             -------</span><br><span class="line">  Normal  Scheduled  22s   crane-scheduler  Successfully assigned default/cpu-stress-cc8656b6c-hsqdg to node2</span><br><span class="line">  Normal  Pulling    22s   kubelet          Pulling image <span class="string">&quot;docker.io/gocrane/stress:latest&quot;</span></span><br></pre></td></tr></table></figure>



<p>如果想默认使用该动态调度器，则可以使用该调度器去替换掉默认的调度器即可。</p>
<h3 id="使用拓扑感知调度对-Pod-进行精细化调度"><a href="#使用拓扑感知调度对-Pod-进行精细化调度" class="headerlink" title="使用拓扑感知调度对 Pod 进行精细化调度"></a>使用拓扑感知调度对 Pod 进行精细化调度</h3><p>Crane-Scheduler 和 Crane-Agent 配合工作可以完成拓扑感知调度与资源分配的工作。Crane-Agent 从节点采集资源拓扑，包括 NUMA、Socket、设备等信息，汇总到 <code>NodeResourceTopology</code> 这个自定义资源对象中。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666938840993.jpg" alt="CPU 拓扑感知"></p>
<p>Crane-Scheduler 在调度时会参考节点的 <code>NodeResourceTopology</code> 对象获取到节点详细的资源拓扑结构，在调度到节点的同时还会为 Pod 分配拓扑资源，并将结果写到 Pod 的 annotations 中。Crane-Agent 在节点上 Watch 到 Pod 被调度后，从 Pod 的 annotations 中获取到拓扑分配结果，并按照用户给定的 CPU 绑定策略进行 CPUSet 的细粒度分配。</p>
<p>Crane 中提供了四种 CPU 分配策略，分别如下：</p>
<ul>
<li><code>none</code>：该策略不进行特别的 CPUSet 分配，Pod 会使用节点 CPU 共享池。</li>
<li><code>exclusive</code>：该策略对应 kubelet 的 static 策略，Pod 会独占 CPU 核心，其他任何 Pod 都无法使用。</li>
<li><code>numa</code>：该策略会指定 NUMA Node，Pod 会使用该 NUMA Node 上的 CPU 共享池。</li>
<li><code>immovable</code>：该策略会将 Pod 固定在某些 CPU 核心上，但这些核心属于共享池，其他 Pod 仍可使用。</li>
</ul>
<p>首先需要在 Crane-Agent 启动参数中添加 <code>--feature-gates=NodeResourceTopology=true,CraneCPUManager=true</code> 开启拓扑感知调度特性。然后安装下面的步骤修改 K8s 集群默认的调度器。</p>
<ol>
<li>备份 <code>/etc/kubernetes/manifests/kube-scheduler.yaml</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /etc/kubernetes/manifests/kube-scheduler.yaml /etc/kubernetes/</span><br></pre></td></tr></table></figure>



<ol>
<li>通过修改 kube-scheduler 的配置文件（<code>scheduler-config.yaml</code> ) 启用动态调度插件并配置插件参数：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubescheduler.config.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeSchedulerConfiguration</span></span><br><span class="line"><span class="attr">leaderElection:</span></span><br><span class="line">  <span class="attr">leaderElect:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">clientConnection:</span></span><br><span class="line">  <span class="attr">kubeconfig:</span> <span class="string">&#x27;REPLACE_ME_WITH_KUBE_CONFIG_PATH&#x27;</span></span><br><span class="line"><span class="attr">profiles:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">    <span class="attr">plugins:</span></span><br><span class="line">      <span class="attr">preFilter:</span></span><br><span class="line">        <span class="attr">enabled:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NodeResourceTopologyMatch</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NodeResourceTopologyMatch</span></span><br><span class="line">      <span class="attr">score:</span></span><br><span class="line">        <span class="attr">enabled:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NodeResourceTopologyMatch</span></span><br><span class="line">            <span class="attr">weight:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">reserve:</span></span><br><span class="line">        <span class="attr">enabled:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NodeResourceTopologyMatch</span></span><br><span class="line">      <span class="attr">preBind:</span></span><br><span class="line">        <span class="attr">enabled:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NodeResourceTopologyMatch</span></span><br></pre></td></tr></table></figure>



<ol>
<li>添加 RBAC 规则</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:kube-scheduler:plugins</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">topology.crane.io</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:kube-scheduler:plugins</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:kube-scheduler:plugins</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">system:kube-scheduler</span></span><br></pre></td></tr></table></figure>



<ol>
<li>修改 <code>kube-scheduler.yaml</code> 并用 Crane-scheduler 的镜像替换 kube-scheduler 镜像</li>
</ol>
<p>正确安装组件后，每个节点均会生成 <code>NodeResourceTopology</code> 对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nrt</span><br><span class="line">NAME    CRANE CPU MANAGER POLICY   CRANE TOPOLOGY MANAGER POLICY   AGE</span><br><span class="line">node1   Static                     SingleNUMANodePodLevel          35d</span><br></pre></td></tr></table></figure>



<p>可以看出集群中节点 <code>node1</code> 已生成对应的 NRT 对象，此时 Crane 的 CPU Manager Policy 为 <code>Static</code>，节点默认的 Topology Manager Policy 为 <code>SingleNUMANodePodLevel</code>，代表节点不允许跨 NUMA 分配资源。</p>
<p>使用以下实例进行调度测试：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">topology.crane.io/topology-awareness:</span> <span class="string">&#x27;true&#x27;</span> <span class="comment"># 添加注解，表示Pod需要感知CPU拓扑，资源分配不允许跨NUMA。若不指定，则拓扑策略默认继承节点上的topology.crane.io/topology-awareness标签</span></span><br><span class="line">        <span class="attr">topology.crane.io/cpu-policy:</span> <span class="string">&#x27;exclusive&#x27;</span> <span class="comment"># 添加注解，表示Pod的CPU分配策略为exclusive策略。</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&#x27;2&#x27;</span> <span class="comment"># 需要limits.cpu值，如果要开启绑核，则该值必须等于requests.cpu。</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">2Gi</span></span><br></pre></td></tr></table></figure>



<p>应用后可以从 annotations 中查看 Pod 的拓扑分配结果，发现 Pod 在 NUMA Node0 上被分配了 2 个 CPU 核心。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -o custom-columns=name:metadata.name,topology-result:metadata.annotations.<span class="string">&quot;topology\.crane\.io/topology-result&quot;</span></span><br><span class="line">name                                topology-result</span><br><span class="line">nginx-deployment-754d99dcdf-mtcdp   [&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;node0&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;Node&quot;</span>,<span class="string">&quot;resources&quot;</span>:&#123;<span class="string">&quot;capacity&quot;</span>:&#123;<span class="string">&quot;cpu&quot;</span>:<span class="string">&quot;2&quot;</span>&#125;&#125;&#125;]</span><br></pre></td></tr></table></figure>



<h2 id="实现基于流量预测的弹性"><a href="#实现基于流量预测的弹性" class="headerlink" title="实现基于流量预测的弹性"></a>实现基于流量预测的弹性</h2><p>Kubernetes HPA 支持了丰富的弹性扩展能力，Kubernetes 平台开发者部署服务实现自定义 Metric 的服务，Kubernetes 用户配置多项内置的资源指标或者自定义 Metric 指标实现自定义水平弹性。</p>
<p><code>EffectiveHorizontalPodAutoscaler</code>（简称 <code>EHPA</code>）是 Crane 提供的弹性伸缩产品，它基于社区 HPA 做底层的弹性控制，支持更丰富的弹性触发策略（预测，观测，周期），让弹性更加高效，并保障了服务的质量。</p>
<ul>
<li>提前扩容，保证服务质量：通过算法预测未来的流量洪峰提前扩容，避免扩容不及时导致的雪崩和服务稳定性故障。</li>
<li>减少无效缩容：通过预测未来可减少不必要的缩容，稳定工作负载的资源使用率，消除突刺误判。</li>
<li>支持 Cron 配置：支持 Cron-based 弹性配置，应对大促等异常流量洪峰。</li>
<li>兼容社区：使用社区 HPA 作为弹性控制的执行层，能力完全兼容社区。</li>
</ul>
<p>Effective HPA 兼容社区的 Kubernetes HPA 的能力，提供了更智能的弹性策略，比如基于预测的弹性和基于 Cron 周期的弹性等。</p>
<h3 id="基于自定义指标的容器弹性伸缩"><a href="#基于自定义指标的容器弹性伸缩" class="headerlink" title="基于自定义指标的容器弹性伸缩"></a>基于自定义指标的容器弹性伸缩</h3><p>在了解如何使用 EHPA 之前，我们有必要来详细了解下 K8s 中的 HPA 对象。通过此伸缩组件，Kubernetes 集群可以利用监控指标（CPU 使用率等）自动扩容或者缩容服务中的 Pod 数量，当业务需求增加时，HPA 将自动增加服务的 Pod 数量，提高系统稳定性，而当业务需求下降时，HPA 将自动减少服务的 Pod 数量，减少对集群资源的请求量，甚至还可以配合 Cluster Autoscaler 实现集群规模的自动伸缩，节省 IT 成本。</p>
<p>不过目前默认的 HPA 对象只能支持根据 CPU 和内存的阈值检测扩缩容，但也可以通过 custom metric api 来调用 Prometheus 实现自定义 metric，这样就可以实现更加灵活的监控指标实现弹性伸缩了。</p>
<p>默认情况下，HPA 会通过 <code>metrics.k8s.io</code> 这个接口服务来获取 Pod 的 CPU、内存指标，CPU 和内存这两者属于核心指标，<code>metrics.k8s.io</code> 服务对应的后端服务一般是 metrics-server，所以在使用 HPA 的时候需要安装该应用。</p>
<p>如果 HPA 要通过非 CPU、内存的其他指标来伸缩容器，我们则需要部署一套监控系统如 Prometheus，让 Prometheus 采集各种指标，但是 Prometheus 采集到的 metrics 指标并不能直接给 K8s 使用，因为两者数据格式是不兼容的，因此需要使用到另外一个组件 <code>prometheus-adapter</code>，该组件可以将 Prometheus 的 metrics 指标数据格式转换成 K8s API 接口能识别的格式，另外我们还需要在 K8s 注册一个服务（即 <code>custom.metrics.k8s.io</code>），以便 HPA 能通过 <code>/apis/</code> 进行访问。</p>
<p>需要注意的是 Crane 提供了一个 <code>metric-adapter</code> 组件，该组件和 <code>prometheus-adapter</code> 都基于 <code>custom-metric-apiserver</code> 实现了 Custom Metric 和 External Metric 的 <code>ApiService</code>，在安装 Crane 时会将对应的 <code>ApiService</code> 安装为 Crane 的 <code>metric-adapter</code>，所以它会和 <code>prometheus-adapter</code> 冲突，因为 Prometheus 是当下最流行的开源监控系统，所以我们更愿意使用它来获取用户的自定义指标，那么我们就需要去安装 <code>prometheus-adapter</code>，但是在安装之前需要删除 Crane 提供的 <code>ApiService</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前集群 ApiService</span></span><br><span class="line">$ kubectl get apiservice |grep crane-system</span><br><span class="line">v1beta1.custom.metrics.k8s.io          crane-system/metric-adapter                    True                      3h51m</span><br><span class="line">v1beta1.external.metrics.k8s.io        crane-system/metric-adapter                    True                      3h51m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 crane 安装的 ApiService</span></span><br><span class="line">$ kubectl delete apiservice v1beta1.custom.metrics.k8s.io</span><br><span class="line">$ kubectl delete apiservice v1beta1.external.metrics.k8s.io</span><br></pre></td></tr></table></figure>



<p>然后通过 Helm Chart 来安装 Prometheus Adapter：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo add prometheus-community https://prometheus-community.github.io/helm-charts</span><br><span class="line">$ helm repo update</span><br><span class="line"><span class="comment"># 指定有 prometheus 地址</span></span><br><span class="line">$ helm upgrade --install prometheus-adapter -n crane-system prometheus-community/prometheus-adapter --<span class="built_in">set</span> image.repository=cnych/prometheus-adapter,prometheus.url=http://prometheus-server.crane-system.svc,prometheus.port=8080</span><br></pre></td></tr></table></figure>



<p>当 <code>prometheus-adapter</code> 安装成功后我们再将 ApiService 改回 Crane 的 <code>metric-adapter</code>，应用下面的资源清单即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">APIService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">v1beta1.custom.metrics.k8s.io</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">metric-adapter</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">crane-system</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">custom.metrics.k8s.io</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">v1beta1</span></span><br><span class="line">  <span class="attr">insecureSkipTLSVerify:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">groupPriorityMinimum:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">versionPriority:</span> <span class="number">100</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">APIService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">v1beta1.external.metrics.k8s.io</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">metric-adapter</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">crane-system</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">external.metrics.k8s.io</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">v1beta1</span></span><br><span class="line">  <span class="attr">insecureSkipTLSVerify:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">groupPriorityMinimum:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">versionPriority:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>



<p>应用了上面的对象后，ApiService 改回了 Crane 的 <code>metric-adapter</code>，那么就不能使用 <code>prometheus-adapter</code> 的自定义 Metrics 功能，我们可以通过 Crane 的 <code>metric-adapter</code> 提供的 <code>RemoteAdapter</code> 功能将请求转发给 <code>prometheus-adapter</code>。</p>
<p>修改 <code>metric-adapter</code> 的配置，将 <code>prometheus-adapter</code> 的 Service 配置成 Crane Metric Adapter 的 <code>RemoteAdapter</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit deploy metric-adapter -n crane-system</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: metric-adapter</span><br><span class="line">  namespace: crane-system</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - args:</span><br><span class="line">        <span class="comment"># 添加外部 Adapter 配置</span></span><br><span class="line">        - --remote-adapter=<span class="literal">true</span></span><br><span class="line">        - --remote-adapter-service-namespace=crane-system</span><br><span class="line">        - --remote-adapter-service-name=prometheus-adapter</span><br><span class="line">        - --remote-adapter-service-port=443</span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure>



<p>这是因为 Kubernetes <strong>限制一个 ApiService 只能配置一个后端服务</strong>，为了在一个集群内使用 Crane 提供的 Metric 和 <code>prometheus-adapter</code> 提供的 Metric，Crane 支持了 <code>RemoteAdapter</code> 来解决该问题：</p>
<ul>
<li>Crane Metric-Adapter 支持配置一个 Kubernetes Service 作为一个远程 Adapter</li>
<li>Crane Metric-Adapter 处理请求时会先检查是否是 Crane 提供的 Local Metric，如果不是，则转发给远程 Adapter</li>
</ul>
<p>下面我们来部署一个示例应用，用来测试自定义指标的容器弹性伸缩。如下所示的应用暴露了 Metric 展示每秒收到的 http 请求数量。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sample-app.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sample-app</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">sample-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">sample-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">sample-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luxas/autoscale-demo:v0.1.2</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">metrics-provider</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">sample-app</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sample-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">sample-app</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>



<p>当应用部署完成后，我们可以通过命令检查 <code>http_requests_total</code> 指标数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://$(kubectl get service sample-app -o jsonpath=<span class="string">&#x27;&#123; .spec.clusterIP &#125;&#x27;</span>)/metrics</span><br><span class="line"><span class="comment"># HELP http_requests_total The amount of requests served by the server in total</span></span><br><span class="line"><span class="comment"># TYPE http_requests_total counter</span></span><br><span class="line">http_requests_total 1</span><br></pre></td></tr></table></figure>



<p>然后我们需要在 Prometheus 中配置抓取 <code>sample-app</code> 的指标，我们这里使用如下所示命令添加抓取配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit cm -n crane-system prometheus-server</span><br><span class="line"><span class="comment"># 添加抓取 sample-app 配置</span></span><br><span class="line">- job_name: sample-app</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: pod</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - action: keep</span><br><span class="line">    regex: default;sample-app-(.+)</span><br><span class="line">    source_labels:</span><br><span class="line">    - __meta_kubernetes_namespace</span><br><span class="line">    - __meta_kubernetes_pod_name</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_pod_label_(.+)</span><br><span class="line">  - action: replace</span><br><span class="line">    source_labels:</span><br><span class="line">    - __meta_kubernetes_namespace</span><br><span class="line">    target_label: namespace</span><br><span class="line">  - source_labels: [__meta_kubernetes_pod_name]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: pod</span><br></pre></td></tr></table></figure>



<p>配置生效后我们可以在 Prometheus Dashboard 中查询对应的指标：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666422933054.png" alt="查询指标"></p>
<p>为了让 HPA 能够用到 Prometheus 采集到的指标，<code>prometheus-adapter</code> 通过使用 promql 语句来获取指标，然后修改数据格式，并把重新组装的指标和值通过自己的接口暴露。而 HPA 会通过 <code>/apis/custom.metrics.k8s.io/</code> 代理到 <code>prometheus-adapter</code> 的 service 上来获取这些指标。</p>
<p>如果把 Prometheus 的所有指标到获取一遍并重新组装，那 adapter 的效率必然十分低下，因此 adapter 将需要读取的指标设计成可配置，让用户通过 ConfigMap 来决定读取 Prometheus 的哪些监控指标。</p>
<p>我们这里使用 Helm Chart 方式安装的 <code>prometheus-adapter</code>，其默认的 Rule 配置如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get cm -n crane-system prometheus-adapter -oyaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  config.yaml: |</span><br><span class="line">    rules:</span><br><span class="line">    - seriesQuery: <span class="string">&#x27;&#123;__name__=~&quot;^container_.*&quot;,container!=&quot;POD&quot;,namespace!=&quot;&quot;,pod!=&quot;&quot;&#125;&#x27;</span></span><br><span class="line">      seriesFilters: []</span><br><span class="line">      resources:</span><br><span class="line">        overrides:</span><br><span class="line">          namespace:</span><br><span class="line">            resource: namespace</span><br><span class="line">          pod:</span><br><span class="line">            resource: pod</span><br><span class="line">      name:</span><br><span class="line">        matches: ^container_(.*)_seconds_total$</span><br><span class="line">        as: <span class="string">&quot;&quot;</span></span><br><span class="line">      metricsQuery: <span class="built_in">sum</span>(rate(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;,container!=<span class="string">&quot;POD&quot;</span>&#125;[5m]))</span><br><span class="line">        by (&lt;&lt;.GroupBy&gt;&gt;)</span><br><span class="line">    - seriesQuery: <span class="string">&#x27;&#123;__name__=~&quot;^container_.*&quot;,container!=&quot;POD&quot;,namespace!=&quot;&quot;,pod!=&quot;&quot;&#125;&#x27;</span></span><br><span class="line">      seriesFilters:</span><br><span class="line">      - isNot: ^container_.*_seconds_total$</span><br><span class="line">      resources:</span><br><span class="line">        overrides:</span><br><span class="line">          namespace:</span><br><span class="line">            resource: namespace</span><br><span class="line">          pod:</span><br><span class="line">            resource: pod</span><br><span class="line">      name:</span><br><span class="line">        matches: ^container_(.*)_total$</span><br><span class="line">        as: <span class="string">&quot;&quot;</span></span><br><span class="line">      metricsQuery: <span class="built_in">sum</span>(rate(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;,container!=<span class="string">&quot;POD&quot;</span>&#125;[5m]))</span><br><span class="line">        by (&lt;&lt;.GroupBy&gt;&gt;)</span><br><span class="line">    - seriesQuery: <span class="string">&#x27;&#123;__name__=~&quot;^container_.*&quot;,container!=&quot;POD&quot;,namespace!=&quot;&quot;,pod!=&quot;&quot;&#125;&#x27;</span></span><br><span class="line">      seriesFilters:</span><br><span class="line">      - isNot: ^container_.*_total$</span><br><span class="line">      resources:</span><br><span class="line">        overrides:</span><br><span class="line">          namespace:</span><br><span class="line">            resource: namespace</span><br><span class="line">          pod:</span><br><span class="line">            resource: pod</span><br><span class="line">      name:</span><br><span class="line">        matches: ^container_(.*)$</span><br><span class="line">        as: <span class="string">&quot;&quot;</span></span><br><span class="line">      metricsQuery: <span class="built_in">sum</span>(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;,container!=<span class="string">&quot;POD&quot;</span>&#125;) by (&lt;&lt;.GroupBy&gt;&gt;)</span><br><span class="line">    - seriesQuery: <span class="string">&#x27;&#123;namespace!=&quot;&quot;,__name__!~&quot;^container_.*&quot;&#125;&#x27;</span></span><br><span class="line">      seriesFilters:</span><br><span class="line">      - isNot: .*_total$</span><br><span class="line">      resources:</span><br><span class="line">        template: &lt;&lt;.Resource&gt;&gt;</span><br><span class="line">      name:</span><br><span class="line">        matches: <span class="string">&quot;&quot;</span></span><br><span class="line">        as: <span class="string">&quot;&quot;</span></span><br><span class="line">      metricsQuery: <span class="built_in">sum</span>(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;&#125;) by (&lt;&lt;.GroupBy&gt;&gt;)</span><br><span class="line">    - seriesQuery: <span class="string">&#x27;&#123;namespace!=&quot;&quot;,__name__!~&quot;^container_.*&quot;&#125;&#x27;</span></span><br><span class="line">      seriesFilters:</span><br><span class="line">      - isNot: .*_seconds_total</span><br><span class="line">      resources:</span><br><span class="line">        template: &lt;&lt;.Resource&gt;&gt;</span><br><span class="line">      name:</span><br><span class="line">        matches: ^(.*)_total$</span><br><span class="line">        as: <span class="string">&quot;&quot;</span></span><br><span class="line">      metricsQuery: <span class="built_in">sum</span>(rate(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;&#125;[5m])) by (&lt;&lt;.GroupBy&gt;&gt;)</span><br><span class="line">    - seriesQuery: <span class="string">&#x27;&#123;namespace!=&quot;&quot;,__name__!~&quot;^container_.*&quot;&#125;&#x27;</span></span><br><span class="line">      seriesFilters: []</span><br><span class="line">      resources:</span><br><span class="line">        template: &lt;&lt;.Resource&gt;&gt;</span><br><span class="line">      name:</span><br><span class="line">        matches: ^(.*)_seconds_total$</span><br><span class="line">        as: <span class="string">&quot;&quot;</span></span><br><span class="line">      metricsQuery: <span class="built_in">sum</span>(rate(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;&#125;[5m])) by (&lt;&lt;.GroupBy&gt;&gt;)</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-adapter</span><br><span class="line">  namespace: crane-system</span><br></pre></td></tr></table></figure>



<p>Prometheus adapter 的配置文件格式如上所示，它分为两个部分，第一个是 <code>rules</code>，用于 custom metrics，另一个是 <code>resourceRules</code>，用于 metrics，如果你只用 Prometheus adapter 做 HPA，那么 <code>resourceRules</code> 就可以省略。</p>
<p>我们可以看到 <code>rules</code> 规则下面有很多的查询语句，这些查询语句的作用就是尽可能多的获取指标，从而让这些指标都可以用于 HPA。也就是说通过 <code>prometheus-adapter</code> 可以将 Prometheus 中的任何一个指标都用于 HPA，但是前提是你得通过查询语句将它拿到（包括指标名称和其对应的值）。也就是说，如果你只需要使用一个指标做 HPA，那么你完全就可以只写一条查询，而不像上面使用了好多个查询。</p>
<p>整体上每个规则大致可以分为 4 个部分：</p>
<ul>
<li><code>Discovery</code>：它指定 Adapter 应该如何找到该规则的所有 Prometheus 指标</li>
<li><code>Association</code>：指定 Adapter 应该如何确定和特定的指标关联的 Kubernetes 资源</li>
<li><code>Naming</code>：指定 Adapter 应该如何在自定义指标 API 中暴露指标</li>
<li><code>Querying</code>：指定如何将对一个获多个 Kubernetes 对象上的特定指标的请求转换为对 Prometheus 的查询</li>
</ul>
<p><strong>Discovery</strong></p>
<p>指定待转换的 Prometheus 指标，你可以通过 <code>seriesFilters</code> 精确过滤指标，<code>seriesQuery</code> 可以根据标签进行查找(如下)，也可以直接指定 metric name 查找。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seriesQuery:</span> <span class="string">http_requests_total&#123;namespace!=&quot;&quot;,pod!=&quot;&quot;&#125;</span></span><br><span class="line"><span class="attr">seriesFilters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">isNot:</span> <span class="string">&#x27;^container_.*_seconds_total&#x27;</span></span><br></pre></td></tr></table></figure>



<p>其中 <code>seriesFilters</code> 为非必填项，用来过滤指标：</p>
<ul>
<li><code>is：&lt;regex&gt;</code>：匹配包含该正则表达式的指标。</li>
<li><code>isNot：&lt;regex&gt;</code>：匹配不包含该正则表达式的指标。</li>
</ul>
<p><strong>Association</strong></p>
<p>设置 Prometheus 指标标签与 Kubernetes 中的资源映射关系，Kubernetes Resources 可以通过 <code>kubectl api-resources</code> 命令查看。<code>overrides</code> 会将 Prometheus metric label 与一个 Kubernetes resource(下例为 deployment)关联。需要注意的是该 label 必须是一个真实的 Kubernetes resource，如 metric 的 pod 标签可以映射为 Kubernetes 的 pod resource，但不能将 container_image 映射为 Kubernetes 的 pod resource，映射错误会导致无法通过 custom metrics API 获取正确的值，这也表示 metric 中必须存在一个真实的 resource 名称，将其映射为 Kubernetes resource。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># microservice 标签对应于 apps.deployment 资源</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">overrides:</span></span><br><span class="line">    <span class="comment"># 此处 resource 为 Kubernetes 的 API Resource，可通过 kubectl api-resources -o wide 查看。</span></span><br><span class="line">    <span class="attr">microservice:</span> &#123; <span class="attr">group:</span> <span class="string">&#x27;apps&#x27;</span>, <span class="attr">resource:</span> <span class="string">&#x27;deployment&#x27;</span> &#125;</span><br><span class="line">    <span class="comment"># 此处 key(microservice)对应 Prometheus 数据中的 LabelName，请确认 Prometheus 指标数据中有此 LabelName。</span></span><br></pre></td></tr></table></figure>



<p><strong>Naming</strong></p>
<p>将 Prometheus 指标名称转换为自定义指标 API 中的指标的过程，它由 <code>name</code> 字段控制。命名通过指定一种模式来控制的，以从 Prometheus 名称中提取 API 名称，并可能对该提取的值进行转换。</p>
<p>模式在 <code>matches</code> 字段中指定，并且只是一个正则表达式。如果未指定，则默认为 <code>.*</code>。转换由 <code>as</code> 字段指定，可以使用 <code>matches</code> 字段中定义的任何捕获组，如果 <code>matches</code> 字段不包含捕获组，则 <code>as</code> 字段默认为 <code>$0</code>，如果它包含单个捕获组，则 <code>as</code> 字段默认为 <code>$1</code>，<code>as</code> 为空就是使用默认值的意思。例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将任意名称 `＜name＞_total` 转换为 `＜name＞_per_second`</span></span><br><span class="line"><span class="comment"># e.g. http_requests_total 变成 http_requests_per_second</span></span><br><span class="line"><span class="attr">name:</span></span><br><span class="line">  <span class="attr">matches:</span> <span class="string">&#x27;^(.*)_total$&#x27;</span></span><br><span class="line">  <span class="attr">as:</span> <span class="string">&#x27;$&#123;1&#125;_per_second&#x27;</span></span><br></pre></td></tr></table></figure>



<p><strong>Querying</strong></p>
<p>处理调用 custom metrics API 获取到的 metrics 的 value，该值最终提供给 HPA 进行扩缩容，它由 <code>metricsQuery</code> 字段控制。<code>metricsQuery</code> 字段使用 Go template 将 URL 请求转变为 Prometheus 的请求，它会提取 custom metrics API 请求中的字段，并将其划分为 metric name、group-resource 以及 group-resource 中的一个或多个 objects，对应如下字段：</p>
<ul>
<li><code>Series</code>: metric 名称</li>
<li><code>LabelMatchers</code>: 以逗号分割的 objects，当前表示特定 group-resource 加上命名空间的 label(如果该 group-resource 是 namespaced 的)</li>
<li><code>GroupBy</code>：以逗号分割的 label 的集合，当前表示 <code>LabelMatchers</code> 中的 group-resource label</li>
</ul>
<p>假设有一个如下所示的 <code>http_requests_per_second</code> 指标：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_requests_per_second&#123;pod=<span class="string">&quot;pod1&quot;</span>,service=<span class="string">&quot;nginx1&quot;</span>,namespace=<span class="string">&quot;somens&quot;</span>&#125;</span><br><span class="line">http_requests_per_second&#123;pod=<span class="string">&quot;pod2&quot;</span>,service=<span class="string">&quot;nginx2&quot;</span>,namespace=<span class="string">&quot;somens&quot;</span>&#125;</span><br></pre></td></tr></table></figure>



<p>当调用 <code>kubectl get --raw &quot;/apis/&#123;APIService-name&#125;/v1beta1/namespaces/somens/pods/*/http_request_per_second&quot;</code> 时，<code>metricsQuery</code> 字段的模板的实际内容如下：</p>
<ul>
<li>Series: “http_requests_total”</li>
<li>LabelMatchers: “pod&#x3D;~&quot;pod1|pod2”, namespace&#x3D;”somens”</li>
<li>GroupBy:pod</li>
</ul>
<p>我们这里使用的 sample-app 应用的指标名叫 <code>http_requests_total</code>，通过上面的规则后会将 <code>http_requests_total</code> 转换成 Pods 类型的 Custom Metric，可以获得类似于 <code>pods/http_requests</code> 这样的数据。</p>
<p>执行以下命令，通过 Custom Metrics 指标查询方式，查看 HPA 可用指标详情。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get --raw <span class="string">&quot;/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/*/http_requests&quot;</span> | jq .</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;MetricValueList&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;custom.metrics.k8s.io/v1beta1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;selfLink&quot;</span>: <span class="string">&quot;/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/%2A/http_requests&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;items&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;describedObject&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Pod&quot;</span>,</span><br><span class="line">        <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;sample-app-6876d5585b-wv8fl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;/v1&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;metricName&quot;</span>: <span class="string">&quot;http_requests&quot;</span>,</span><br><span class="line">      <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;2022-10-27T11:19:05Z&quot;</span>,</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: <span class="string">&quot;18m&quot;</span>,</span><br><span class="line">      <span class="string">&quot;selector&quot;</span>: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后我们可以创建一个如下所示的 HPA 对象：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sample-app-hpa.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sample-app-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># HPA的伸缩对象描述，HPA 会动态修改该对象的 Pod 数量。</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sample-app</span></span><br><span class="line">  <span class="comment"># HPA 的最小 Pod 数量和最大 Pod 数量。</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="comment"># 监控的指标数组，支持多种类型的指标共存。</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">      <span class="attr">pods:</span></span><br><span class="line">        <span class="comment">#使用指标：pods/http_requests。</span></span><br><span class="line">        <span class="attr">metricName:</span> <span class="string">http_requests</span></span><br><span class="line">        <span class="comment"># AverageValue 类型的目标值，Pods 指标类型下只支持 AverageValue 类型的目标值。</span></span><br><span class="line">        <span class="attr">targetAverageValue:</span> <span class="string">500m</span> <span class="comment"># 当出现了小数点，K8s 又需要高精度时，会使用单位 m 或k。例如1001m=1.001，1k=1000。</span></span><br></pre></td></tr></table></figure>



<p>直接应用该资源对象即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f sample-app-hpa.yaml</span><br><span class="line">horizontalpodautoscaler.autoscaling/sample-app-hpa created</span><br><span class="line">$ kubectl get hpa</span><br><span class="line">NAME             REFERENCE               TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">sample-app-hpa   Deployment/sample-app   16m/50m   1         10        1          25s</span><br></pre></td></tr></table></figure>



<p>然后针对 <code>sample-app</code> 服务做压力测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc sample-app</span><br><span class="line">NAME         TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">sample-app   NodePort   10.104.163.144   &lt;none&gt;        80:31941/TCP   3h59m</span><br><span class="line">$ ab -c 50 -n 2000 http://192.168.0.106:31941/</span><br></pre></td></tr></table></figure>



<p>然后查看 HPA 的状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get hpa</span><br><span class="line">NAME             REFERENCE               TARGETS     MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">sample-app-hpa   Deployment/sample-app   8001m/50m   1         10        4          7m58s</span><br><span class="line">$ kubectl describe hpa sample-app-hpa</span><br><span class="line">Name:                       sample-app-hpa</span><br><span class="line">Namespace:                  default</span><br><span class="line">Labels:                     &lt;none&gt;</span><br><span class="line">Annotations:                &lt;none&gt;</span><br><span class="line">CreationTimestamp:          Thu, 27 Oct 2022 19:24:16 +0800</span><br><span class="line">Reference:                  Deployment/sample-app</span><br><span class="line">Metrics:                    ( current / target )</span><br><span class="line">  <span class="string">&quot;http_requests&quot;</span> on pods:  2093m / 50m</span><br><span class="line">Min replicas:               1</span><br><span class="line">Max replicas:               10</span><br><span class="line">Deployment pods:            10 current / 10 desired</span><br><span class="line">Conditions:</span><br><span class="line">  Type            Status  Reason            Message</span><br><span class="line">  ----            ------  ------            -------</span><br><span class="line">  AbleToScale     True    ReadyForNewScale  recommended size matches current size</span><br><span class="line">  ScalingActive   True    ValidMetricFound  the HPA was able to successfully calculate a replica count from pods metric http_requests</span><br><span class="line">  ScalingLimited  True    TooManyReplicas   the desired replica count is more than the maximum replica count</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                       Message</span><br><span class="line">  ----    ------             ----  ----                       -------</span><br><span class="line">  Normal  SuccessfulRescale  105s  horizontal-pod-autoscaler  New size: 4; reason: pods metric http_requests above target</span><br><span class="line">  Normal  SuccessfulRescale  90s   horizontal-pod-autoscaler  New size: 8; reason: pods metric http_requests above target</span><br><span class="line">  Normal  SuccessfulRescale  75s   horizontal-pod-autoscaler  New size: 10; reason: pods metric http_requests above target</span><br></pre></td></tr></table></figure>



<p>可以看到基于我们自定义的指标实现容器的弹性已经成功了。</p>
<h3 id="基于流量预测的容器弹性伸缩"><a href="#基于流量预测的容器弹性伸缩" class="headerlink" title="基于流量预测的容器弹性伸缩"></a>基于流量预测的容器弹性伸缩</h3><p>接下来我们再来测试下基于流量预测的容器弹性伸缩，这就需要用到 Crane 的 EHPA 对象了。我们可以使用上面的 <code>pods/http_requests</code> 自定义指标来实现弹性功能。</p>
<p>许多业务在时间序列上天然存在周期性的，尤其是对于那些直接或间接为“人”服务的业务。这种周期性是由人们日常活动的规律性决定的。例如，人们习惯于中午和晚上点外卖；早晚总有交通高峰；即使是搜索等模式不那么明显的服务，夜间的请求量也远低于白天时间。对于这类业务相关的应用来说，从过去几天的历史数据中推断出次日的指标，或者从上周一的数据中推断出下周一的访问量是很自然的想法。通过预测未来 24 小时内的指标或流量模式，我们可以更好地管理我们的应用程序实例，稳定我们的系统，同时降低成本。EHPA 对象可以使用 DSP 算法来预测应用未来的时间序列数据，DSP 是一种预测时间序列的算法，它基于 FFT（快速傅里叶变换），擅长预测一些具有季节性和周期的时间序列。</p>
<p>接下来我们创建一个如下所示的 EHPA 资源对象，并开启预测功能：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sample-app-ehpa.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">EffectiveHorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sample-app-ehpa</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="comment"># metric-query.autoscaling.crane.io 是固定的前缀</span></span><br><span class="line">    <span class="comment"># 后面是 prefix.Metrics，前缀支持 pods、resource、external 类型</span></span><br><span class="line">    <span class="attr">metric-query.autoscaling.crane.io/pods.http_requests:</span> <span class="string">&#x27;sum(rate(http_requests_total[5m])) by (pod)&#x27;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># ScaleTargetRef 是对需要缩放的工作负载的引用</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sample-app</span></span><br><span class="line">  <span class="comment"># minReplicas 是可以缩小到的缩放目标的最小副本数</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># maxReplicas 是可以扩大到的缩放目标的最大副本数</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="comment"># scaleStrategy 表示缩放目标的策略，值可以是 Auto 或 Manual</span></span><br><span class="line">  <span class="attr">scaleStrategy:</span> <span class="string">Auto</span></span><br><span class="line">  <span class="comment"># metrics 包含用于计算所需副本数的规范。</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="comment"># 在使用预测算法预测时，你可能会担心预测数据不准带来一定的风险，EHPA 在计算副本数时，不仅会按预测数据计算，同时也会考虑实际监控数据来兜底，提升弹性的安全性，所以可以定义下面的 Resource 监控数据来兜底</span></span><br><span class="line">    <span class="comment"># - type: Resource</span></span><br><span class="line">    <span class="comment">#   resource:</span></span><br><span class="line">    <span class="comment">#     name: cpu</span></span><br><span class="line">    <span class="comment">#     target:</span></span><br><span class="line">    <span class="comment">#       type: Utilization</span></span><br><span class="line">    <span class="comment">#       averageUtilization: 50</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">      <span class="attr">pods:</span></span><br><span class="line">        <span class="attr">metric:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">http_requests</span> <span class="comment"># 和上面注解中的 metric-query.autoscaling.crane.io/pods.(.*) 必须一致</span></span><br><span class="line">        <span class="attr">target:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">          <span class="attr">averageValue:</span> <span class="string">500m</span> <span class="comment"># 当出现了小数点，K8s 又需要高精度时，会使用单位 m 或k。例如1001m=1.001，1k=1000。</span></span><br><span class="line">  <span class="comment"># prediction 定义了预测资源的配置，如果未指定，则默认不启用预测功能</span></span><br><span class="line">  <span class="attr">prediction:</span></span><br><span class="line">    <span class="attr">predictionWindowSeconds:</span> <span class="number">3600</span> <span class="comment"># PredictionWindowSeconds 是预测未来指标的时间窗口</span></span><br><span class="line">    <span class="attr">predictionAlgorithm:</span></span><br><span class="line">      <span class="attr">algorithmType:</span> <span class="string">dsp</span> <span class="comment"># 指定dsp为预测算法</span></span><br><span class="line">      <span class="attr">dsp:</span></span><br><span class="line">        <span class="attr">sampleInterval:</span> <span class="string">&#x27;60s&#x27;</span> <span class="comment"># 监控数据的采样间隔为1分钟</span></span><br><span class="line">        <span class="attr">historyLength:</span> <span class="string">&#x27;7d&#x27;</span> <span class="comment"># 拉取过去7天的监控指标作为预测的依据</span></span><br></pre></td></tr></table></figure>



<p>在上面的资源对象中添加了一个 <code>metric-query.autoscaling.crane.io/pods.http_requests: &quot;sum(rate(http_requests_total[5m])) by (pod)&quot;</code> 的注解，这样就可以开启自定义指标的预测功能了，该注解的前缀 <code>metric-query.autoscaling.crane.io/</code> 是固定不变的，后面的 <code>pods.http_requests</code> 需要根据我们指定的指标类型而定，注意的是我们这里是指定 Pods 类型的指标，所以这里的注解 key 后面是 <code>pods.http_requests</code>，后面的 <code>http_requests</code> 就是配置的指标名称。</p>
<p>相应的在规范中定义了 <code>spec.prediction</code> 属性，用来指定预测资源的配置，其中的 <code>predictionWindowSeconds</code> 属性用来指定预测未来指标的时间窗口，<code>predictionAlgorithm</code> 属性用来指定预测的算法，比如我们这里配置的 <code>algorithmType: dsp</code> 表示使用 DSP（Digital Signal Processing）算法进行预测，该算法使用在数字信号处理领域中常用的的离散傅里叶变换、自相关函数等手段来识别、预测周期性的时间序列，关于该算法的实现原理可以查看官方文档 <code>https://gocrane.io/zh-cn/docs/tutorials/timeseriees-forecasting-by-dsp/</code> 的相关介绍，或者查看源码以了解背后原理，相关代码位于 <code>pkg/prediction/dsp</code> 目录下。此外在 <code>prediction.predictionAlgorithm.dsp</code> 下面还可以配置 dsp 算法的相关参数，比如我们这里配置的 <code>sampleInterval: &quot;60s&quot;</code> 表示监控数据的采样间隔为 1 分钟，<code>historyLength: &quot;7d&quot;</code> 表示拉取过去 7 天的监控指标作为预测的依据，此外还可以配置预测方式等。</p>
<p>然后核心的配置就是 <code>spec.metrics</code> 了，用来指定计算所需副本数的规范，我们这里指定了基于 <code>Pods</code> 指标的计算方式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">  <span class="attr">pods:</span></span><br><span class="line">    <span class="attr">metric:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http_requests</span></span><br><span class="line">    <span class="attr">target:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">      <span class="attr">averageValue:</span> <span class="string">500m</span></span><br></pre></td></tr></table></figure>



<p>上面的配置表示当 <code>pods/http_requests</code> 的自定义指标平均值达到 500m 后就可以触发 HPA 缩放，这里有一个点需要注意自定义指标的 <code>pods.metric.name</code> 的值必须和 annotations 注解 <code>metric-query.autoscaling.crane.io/&lt;metric name&gt;</code> 指标名保持一致。</p>
<p>EHPA 对象水平弹性的执行流程如下所示：</p>
<ul>
<li><code>EffectiveHPAController</code> 创建 <code>HorizontalPodAutoscaler</code> 和 <code>TimeSeriesPrediction</code> 对象</li>
<li><code>PredictionCore</code> 从 Prometheus 获取历史 metric 通过预测算法计算，将结果记录到 <code>TimeSeriesPrediction</code></li>
<li><code>HPAController</code> 通过 metric client 从 KubeApiServer 读取 metric 数据</li>
<li><code>KubeApiServer</code> 将请求路由到 Crane 的 Metric-Adapter。</li>
<li><code>HPAController</code> 计算所有的 Metric 返回的结果得到最终的弹性副本推荐。</li>
<li><code>HPAController</code> 调用 scale API 对目标应用扩&#x2F;缩容。</li>
</ul>
<p>整体流程如下所示：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666921205654.jpg" alt="ehpa 流程"></p>
<p>直接应用上面的 EPHA 对象即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f sample-app-ehpa.yaml</span><br><span class="line">effectivehorizontalpodautoscaler.autoscaling.crane.io/sample-app-ehpa created</span><br><span class="line">$ kubectl get ehpa</span><br><span class="line">NAME              STRATEGY   MINPODS   MAXPODS   SPECIFICPODS   REPLICAS   AGE</span><br><span class="line">sample-app-ehpa   Auto       1         10                       1          17s</span><br></pre></td></tr></table></figure>



<p>由于我们开启了自动预测功能，所以 EPHA 对象创建后会创建一个对应的 <code>TimeSeriesPrediction</code> 对象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get tsp</span><br><span class="line">NAME                   TARGETREFNAME   TARGETREFKIND   PREDICTIONWINDOWSECONDS   AGE</span><br><span class="line">ehpa-sample-app-ehpa   sample-app      Deployment      3600                      3m50s</span><br><span class="line">$ kubectl get tsp ehpa-sample-app-ehpa -oyaml</span><br><span class="line">apiVersion: prediction.crane.io/v1alpha1</span><br><span class="line">kind: TimeSeriesPrediction</span><br><span class="line">metadata:</span><br><span class="line">  name: ehpa-sample-app-ehpa</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  predictionMetrics:</span><br><span class="line">  - algorithm:</span><br><span class="line">      algorithmType: dsp</span><br><span class="line">      dsp:</span><br><span class="line">        estimators: &#123;&#125;</span><br><span class="line">        historyLength: 7d</span><br><span class="line">        sampleInterval: 60s</span><br><span class="line">    expressionQuery:</span><br><span class="line">      expression: <span class="built_in">sum</span>(rate(http_requests_total[5m])) by (pod)</span><br><span class="line">    resourceIdentifier: pods.http_requests</span><br><span class="line">    <span class="built_in">type</span>: ExpressionQuery</span><br><span class="line">  predictionWindowSeconds: 3600</span><br><span class="line">  targetRef:</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: sample-app</span><br><span class="line">    namespace: default</span><br><span class="line">status:</span><br><span class="line">  conditions:</span><br><span class="line">  - lastTransitionTime: <span class="string">&quot;2022-10-29T06:50:46Z&quot;</span></span><br><span class="line">    message: not all metric predicted</span><br><span class="line">    reason: PredictPartial</span><br><span class="line">    status: <span class="string">&quot;False&quot;</span></span><br><span class="line">    <span class="built_in">type</span>: Ready</span><br><span class="line">  predictionMetrics:</span><br><span class="line">  - ready: <span class="literal">false</span></span><br><span class="line">    resourceIdentifier: pods.http_requests</span><br></pre></td></tr></table></figure>



<p>在 status 中可以看到包含 <code>not all metric predicted</code> 这样的信息，这是因为应用运行时间较短，可能会出现无法预测的情况。同样也会自动创建一个对应的 HPA 对象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get hpa</span><br><span class="line">NAME                   REFERENCE               TARGETS    MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">ehpa-sample-app-ehpa   Deployment/sample-app   16m/500m   1         10        1          69m</span><br></pre></td></tr></table></figure>



<p>然后我们可以重新使用 <code>ab</code> 命令对 sample-app 做一次压力测试，正常也可以触发该应用的弹性扩容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get hpa</span><br><span class="line">NAME                   REFERENCE               TARGETS      MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">ehpa-sample-app-ehpa   Deployment/sample-app   7291m/500m   1         10        10         71m</span><br><span class="line">$ kubectl describe hpa ehpa-sample-app-ehpa</span><br><span class="line">Name:                       ehpa-sample-app-ehpa</span><br><span class="line">Namespace:                  default</span><br><span class="line">Labels:                     app.kubernetes.io/managed-by=effective-hpa-controller</span><br><span class="line">                            app.kubernetes.io/name=ehpa-sample-app-ehpa</span><br><span class="line">                            app.kubernetes.io/part-of=sample-app-ehpa</span><br><span class="line">                            autoscaling.crane.io/effective-hpa-uid=8fad0b0b-8a53-433e-b483-9f2ff61aaa58</span><br><span class="line">Annotations:                &lt;none&gt;</span><br><span class="line">CreationTimestamp:          Thu, 27 Oct 2022 21:01:13 +0800</span><br><span class="line">Reference:                  Deployment/sample-app</span><br><span class="line">Metrics:                    ( current / target )</span><br><span class="line">  <span class="string">&quot;http_requests&quot;</span> on pods:  8350m / 500m</span><br><span class="line">Min replicas:               1</span><br><span class="line">Max replicas:               10</span><br><span class="line">Deployment pods:            10 current / 10 desired</span><br><span class="line">Conditions:</span><br><span class="line">  Type            Status  Reason            Message</span><br><span class="line">  ----            ------  ------            -------</span><br><span class="line">  AbleToScale     True    ReadyForNewScale  recommended size matches current size</span><br><span class="line">  ScalingActive   True    ValidMetricFound  the HPA was able to successfully calculate a replica count from pods metric http_requests</span><br><span class="line">  ScalingLimited  True    TooManyReplicas   the desired replica count is more than the maximum replica count</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                       Message</span><br><span class="line">  ----    ------             ----  ----                       -------</span><br><span class="line">  Normal  SuccessfulRescale  57s   horizontal-pod-autoscaler  New size: 4; reason: pods metric http_requests above target</span><br><span class="line">  Normal  SuccessfulRescale  42s   horizontal-pod-autoscaler  New size: 8; reason: pods metric http_requests above target</span><br><span class="line">  Normal  SuccessfulRescale  27s   horizontal-pod-autoscaler  New size: 10; reason: pods metric http_requests above target</span><br></pre></td></tr></table></figure>



<p>我们可以使用如下所示命令来查看 EHPA 自动生成的 HPA 对象的资源清单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get hpa.v2beta2.autoscaling ehpa-sample-app-ehpa -oyaml</span><br><span class="line">apiVersion: autoscaling/v2beta2</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: ehpa-sample-app-ehpa</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  maxReplicas: 10</span><br><span class="line">  metrics:</span><br><span class="line">  - pods:</span><br><span class="line">      metric:</span><br><span class="line">        name: http_requests</span><br><span class="line">      target:</span><br><span class="line">        averageValue: 500m</span><br><span class="line">        <span class="built_in">type</span>: AverageValue</span><br><span class="line">    <span class="built_in">type</span>: Pods</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: sample-app</span><br><span class="line">status:</span><br><span class="line">  conditions:</span><br><span class="line">  - lastTransitionTime: <span class="string">&quot;2022-10-27T13:01:28Z&quot;</span></span><br><span class="line">    message: recent recommendations were higher than current one, applying the highest</span><br><span class="line">      recent recommendation</span><br><span class="line">    reason: ScaleDownStabilized</span><br><span class="line">    status: <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="built_in">type</span>: AbleToScale</span><br><span class="line">  - lastTransitionTime: <span class="string">&quot;2022-10-27T13:01:28Z&quot;</span></span><br><span class="line">    message: the HPA was able to successfully calculate a replica count from pods</span><br><span class="line">      metric http_requests</span><br><span class="line">    reason: ValidMetricFound</span><br><span class="line">    status: <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="built_in">type</span>: ScalingActive</span><br><span class="line">  - lastTransitionTime: <span class="string">&quot;2022-10-27T14:11:24Z&quot;</span></span><br><span class="line">    message: the desired replica count is more than the maximum replica count</span><br><span class="line">    reason: TooManyReplicas</span><br><span class="line">    status: <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="built_in">type</span>: ScalingLimited</span><br><span class="line">  currentMetrics:</span><br><span class="line">  - pods:</span><br><span class="line">      current:</span><br><span class="line">        averageValue: 15m</span><br><span class="line">      metric:</span><br><span class="line">        name: http_requests</span><br><span class="line">    <span class="built_in">type</span>: Pods</span><br><span class="line">  currentReplicas: 10</span><br><span class="line">  desiredReplicas: 10</span><br><span class="line">  lastScaleTime: <span class="string">&quot;2022-10-27T14:11:54Z&quot;</span></span><br></pre></td></tr></table></figure>



<p>可以观测到已经创建出基于自定义指标预测的 Metric: <code>http_requests</code>，由于生产环境的复杂性，基于多指标的弹性（CPU&#x2F;Memory&#x2F;自定义指标）往往是生产应用的常见选择，因此 Effective HPA 通过预测算法覆盖了多指标的弹性，达到了帮助更多业务在生产环境落地水平弹性的成效。</p>
<p>除此之外 EHPA 对象还支持基于 cron 的自动缩放，除了基于监控指标，有时节假日和工作日的工作负载流量存在差异，简单的预测算法可能效果不佳。然后可以通过设置周末 cron 来支持更大数量的副本来弥补预测的不足。对于一些非 web 流量的应用，比如一些应用不需要在周末使用，可以把工作负载的副本数减少到 1，也可以配置 cron 来降低你的服务成本。</p>
<h2 id="QOS-增强与混部"><a href="#QOS-增强与混部" class="headerlink" title="QOS 增强与混部"></a>QOS 增强与混部</h2><p>除了上面介绍的主要功能之外，crane 还具有很多 QOS 增强功能，QOS 相关能力保证了运行在 Kubernetes 上的 Pod 的稳定性。</p>
<h3 id="干扰检测和主动回避"><a href="#干扰检测和主动回避" class="headerlink" title="干扰检测和主动回避"></a>干扰检测和主动回避</h3><p><img data-src="https://picdn.youdianzhishi.com/images/1666938915729.jpg" alt="干扰检测和主动回避"></p>
<p>干扰检测和主动回避功能主要涉及到以下几个 CRD 对象：</p>
<ul>
<li><code>AvoidanceAction</code>：定义了检测到干扰后需要执行的操作，包含了 <code>Disable Scheduling</code>、<code>throttle</code>、<code>eviction</code> 等操作，并且定义了其相关的一些参数。</li>
<li><code>NodeQOS</code>：定义了指标采集方式和参数，水位线指标相关参数，以及指标异常时关联的回避操作，同时通过 label selector 将上面的内容关联到指定的节点。</li>
<li><code>PodQOS</code>：定义了指定 pod 可以被执行的 <code>AvoidanceAction</code>，通常和 <code>NodeQOS</code> 搭配起来，从节点和 pod 的维度共同限制执行动作的范围，<code>PodQOS</code> 支持的 seletor 包含 label selector、还支持筛选特定 QOSClass(“BestEffort”、“Guaranteed”等)、特定 Priority、特定 Namespace 的 pod，并且之间采用<strong>与</strong>的方式关联。</li>
</ul>
<p><strong>Disable Scheduling</strong></p>
<p>定义如下所示几个 <code>AvoidanceAction</code>、<code>PodQOS</code> 和 <code>NodeQOS</code> 资源对象。当节点 CPU 使用率触发回避阈值时，将该节点设置为禁用调度。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">ensurance.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">AvoidanceAction</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">system</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">disablescheduling</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">disable</span> <span class="string">schedule</span> <span class="string">new</span> <span class="string">pods</span> <span class="string">to</span> <span class="string">the</span> <span class="string">node</span></span><br><span class="line">  <span class="attr">coolDownSeconds:</span> <span class="number">300</span> <span class="comment"># 节点从禁止调度状态到正常状态的最小等待时间</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">ensurance.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NodeQOS</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#x27;watermark1&#x27;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">&#x27;system&#x27;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeQualityProbe:</span></span><br><span class="line">    <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">nodeLocalGet:</span></span><br><span class="line">      <span class="attr">localCacheTTLSeconds:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;cpu-usage&#x27;</span></span><br><span class="line">      <span class="attr">avoidanceThreshold:</span> <span class="number">2</span> <span class="comment"># 当达到阈值并持续多次，那么我们认为规则被触发</span></span><br><span class="line">      <span class="attr">restoreThreshold:</span> <span class="number">2</span> <span class="comment"># 当阈值未达到并继续多次, 那么我们认为规则已恢复</span></span><br><span class="line">      <span class="attr">actionName:</span> <span class="string">&#x27;disablescheduling&#x27;</span> <span class="comment"># 关联到 AvoidanceAction 名称</span></span><br><span class="line">      <span class="attr">strategy:</span> <span class="string">&#x27;None&#x27;</span> <span class="comment"># 动作的策略，你可以将其设置为“Preview”以不实际执行</span></span><br><span class="line">      <span class="attr">metricRule:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&#x27;cpu_total_usage&#x27;</span> <span class="comment"># 指标名称</span></span><br><span class="line">        <span class="attr">value:</span> <span class="number">4000</span> <span class="comment"># 指标的阈值</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">ensurance.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodQOS</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">all-elastic-pods</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">allowedActions:</span> <span class="comment"># 被该PodQOS关联的pod允许被执行的action为eviction</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">eviction</span></span><br><span class="line">  <span class="attr">labelSelector:</span> <span class="comment"># 通过label selector关联具有preemptible_job: “true&quot;的pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">preemptible_job:</span> <span class="string">&#x27;true&#x27;</span></span><br></pre></td></tr></table></figure>



<p><strong>Throttle</strong></p>
<p>定义 <code>AvoidanceAction</code> 和 <code>NodeQOS</code>。当节点 CPU 使用率触发回避阈值时，将执行节点的 Throttle Action。示例 YAML 如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">ensurance.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">AvoidanceAction</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">throttle</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">coolDownSeconds:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">throttle:</span></span><br><span class="line">    <span class="attr">cpuThrottle:</span></span><br><span class="line">      <span class="attr">minCPURatio:</span> <span class="number">10</span> <span class="comment"># CPU 配额的最小比例，如果 pod 被限制低于这个比例，就会被设置为这个</span></span><br><span class="line">      <span class="attr">stepCPURatio:</span> <span class="number">10</span> <span class="comment"># 该配置设置给Throttle Action。它将在每个触发的回避动作中减少这个 CPU 配额占比。它会在每个恢复动作中增加这个 CPU 配额占比</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">&#x27;throttle low priority pods&#x27;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">ensurance.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NodeQOS</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#x27;watermark2&#x27;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">&#x27;system&#x27;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeQualityProbe:</span></span><br><span class="line">    <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">nodeLocalGet:</span></span><br><span class="line">      <span class="attr">localCacheTTLSeconds:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;cpu-usage&#x27;</span></span><br><span class="line">      <span class="attr">avoidanceThreshold:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">restoredThreshold:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">actionName:</span> <span class="string">&#x27;throttle&#x27;</span></span><br><span class="line">      <span class="attr">strategy:</span> <span class="string">&#x27;None&#x27;</span></span><br><span class="line">      <span class="attr">metricRule:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&#x27;cpu_total_usage&#x27;</span></span><br><span class="line">        <span class="attr">value:</span> <span class="number">6000</span></span><br></pre></td></tr></table></figure>



<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">ensurance.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodQOS</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">all-be-pods</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">allowedActions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">throttle</span></span><br><span class="line">  <span class="attr">scopeSelector:</span></span><br><span class="line">    <span class="attr">matchExpressions:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">        <span class="attr">scopeName:</span> <span class="string">QOSClass</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">BestEffort</span></span><br></pre></td></tr></table></figure>



<p><strong>Eviction</strong></p>
<p>下面的 YAML 是另一种情况，当节点 CPU 使用率触发阈值时，节点上的低优先级 pod 将被驱逐。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">ensurance.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">AvoidanceAction</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eviction</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">coolDownSeconds:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">eviction:</span></span><br><span class="line">    <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span> <span class="comment"># pod 需要优雅终止的持续时间（以秒为单位）</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">&#x27;evict low priority pods&#x27;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">ensurance.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NodeQOS</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#x27;watermark3&#x27;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">&#x27;system&#x27;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeQualityProbe:</span></span><br><span class="line">    <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">nodeLocalGet:</span></span><br><span class="line">      <span class="attr">localCacheTTLSeconds:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;cpu-usage&#x27;</span></span><br><span class="line">      <span class="attr">avoidanceThreshold:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">restoreThreshold:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">actionName:</span> <span class="string">&#x27;eviction&#x27;</span></span><br><span class="line">      <span class="attr">strategy:</span> <span class="string">&#x27;Preview&#x27;</span> <span class="comment"># 回避动作策略。当设置为Preview时，将不会被实际执行</span></span><br><span class="line">      <span class="attr">metricRule:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&#x27;cpu_total_usage&#x27;</span></span><br><span class="line">        <span class="attr">value:</span> <span class="number">6000</span></span><br></pre></td></tr></table></figure>



<p><strong>支持的水位线指标</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>cpu_total_usage</td>
<td>node cpu usage</td>
</tr>
<tr>
<td>cpu_total_utilization</td>
<td>node cpu utilization percent</td>
</tr>
<tr>
<td>memory_total_usage</td>
<td>node mem usage</td>
</tr>
<tr>
<td>memory_total_utilization</td>
<td>node mem utilization percent</td>
</tr>
</tbody></table>
<p><strong>灵活的异常规则配置与可自定义的主动回避规则</strong></p>
<p>针对异常规则的配置，Crane 支持静态阈值，基于 OPA 的灵活定义和多种算法支持，用户也可以根据接口自行定义自己的异常判断逻辑，实现灵活配置，具有较好的扩展能力；</p>
<p>针对主动回避规则，可以为业务设置优先级和 QoS 质量保障，在资源紧张时对低优业务进行抢占和压制，通过 NodeQOS 和 PodQOS 的配合，保障节点和业务的稳定性。 PodQOS 定义了可以选择 pod 被执行的具体 AvoidanceAction，同时支持具有如指定 QOSClass,priority 或具体 label 等丰富的 pod 关联方式，通过这两种方式，即可实现丰富和精确的回避策略，精准操作 workload，避免误伤。</p>
<p>比如可以结合弹性资源回收，只允许离线作业被执行驱逐等操作，避免主动回避操作对于高优先级业务的影响，误驱逐了重要业务，从而在资源紧张时将低优或者使用扩展资源的 pod 优先回收，保证了节点上的核心业务的稳定。</p>
<p>如下面的例子，为打有 <code>preemptible_job: &quot;true&quot;</code> 标签的 Pod 和 BestEffor pod 配置可驱逐。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">ensurance.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodQOS</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">all-elastic-pods</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">allowedActions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">eviction</span></span><br><span class="line">  <span class="attr">labelSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">preemptible_job:</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">ensurance.crane.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodQOS</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">all-be-pods</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">allowedActions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">eviction</span></span><br><span class="line">  <span class="attr">scopeSelector:</span></span><br><span class="line">    <span class="attr">matchExpressions:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">        <span class="attr">scopeName:</span> <span class="string">QOSClass</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">BestEffort</span></span><br></pre></td></tr></table></figure>



<p><strong>与弹性资源搭配使用</strong></p>
<p>为了避免主动回避操作对于高优先级业务的影响，比如误驱逐了重要业务，建议使用 <code>PodQOS</code> 关联使用了弹性资源的 workload，这样在执行动作的时候只会影响这些使用了空闲资源的 workload，保证了节点上的核心业务的稳定。</p>
<p><strong>自定义指标接入干扰检测框架</strong></p>
<ul>
<li><ol>
<li>提供了丰富的 pod 排序策略可以供自定义指标任意搭配组合，一个合适的 pod 排序策略组合，能够更快地将指标调整到水位线以下，也可以方便地实现自己的排序策略</li>
</ol>
</li>
<li><ol>
<li>能够避免过度操作，以 NodeQOS 中的指标值作为水位，操作到刚好低于水位线，能避免对低优先级服务的过度影响</li>
</ol>
</li>
<li><ol>
<li>一次操作过程兼顾多条不同指标的水位线，尽量短的时间内完成整个过程，避免对高优业务和整机的影响</li>
</ol>
</li>
<li><ol>
<li>在回避过程中考虑到实时指标暂时无法获取以及部分指标在 pod 被执行操作后无法量化的问题；由于低于水位线时会存在 restore 的反向过程，考虑到了避免指标在水位线附近来回摇摆的情况</li>
</ol>
</li>
</ul>
<p>用户按照规范完善自定义指标的一些属性和实现，即可在无需关心具体细节的情况下，复用以上能力和整个干扰检测主动回避过程，可以便捷扩展。</p>
<p>通过便捷的自定义指标复用流程的能力，用户可以定义一些各维度的指标用来保证集群的稳定，比如将弹性资源的总体使用量作为指标，即可实现无侵入的“离线资源大框”；比如将高优业务的关键指标作为指标，即可时刻保障高优业务的稳定运行。</p>
<h3 id="预测算法增强的动态资源超卖"><a href="#预测算法增强的动态资源超卖" class="headerlink" title="预测算法增强的动态资源超卖"></a>预测算法增强的动态资源超卖</h3><p>为了提高稳定性，通常用户在部署应用的时候会设置高于实际使用量的 Request 值，造成资源的浪费，为了提高节点的资源利用率，用户会搭配部署一些 BestEffort 的应用，利用闲置资源，实现超卖。但是这些应用由于缺乏资源 limit 和 request 的约束和相关信息，调度器依旧可能将这些 pod 调度到负载较高的节点上去，这与我们的初衷是不符的，所以最好能依据节点的空闲资源量进行调度。</p>
<p>crane 通过如下两种方式收集了节点的空闲资源量，综合后作为节点的空闲资源量，增强了资源评估的准确性：</p>
<p>这里以 cpu 为例，同时也支持内存的空闲资源回收和计算。</p>
<ol>
<li>通过本地收集的 cpu 用量信息 <code>nodeCpuCannotBeReclaimed := nodeCpuUsageTotal + exclusiveCPUIdle - extResContainerCpuUsageTotal</code><ul>
<li><code>exclusiveCPUIdle</code> 是指被 cpu manager policy 为 exclusive 的 pod 占用的 cpu 的空闲量，虽然这部分资源是空闲的，但是因为独占的原因，是无法被复用的，因此加上被算作已使用量</li>
<li><code>extResContainerCpuUsageTotal</code> 是指被作为动态资源使用的 cpu 用量，需要减去以免被二次计算</li>
</ul>
</li>
<li>创建节点 cpu 使用量的 TSP，默认情况下自动创建，会根据历史预测节点 CPU 用量</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">spec:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    predictionMetrics:</span></span><br><span class="line"><span class="string">    - algorithm:</span></span><br><span class="line"><span class="string">        algorithmType: dsp</span></span><br><span class="line"><span class="string">        dsp:</span></span><br><span class="line"><span class="string">          estimators:</span></span><br><span class="line"><span class="string">            fft:</span></span><br><span class="line"><span class="string">            - highFrequencyThreshold: &quot;0.05&quot;</span></span><br><span class="line"><span class="string">              lowAmplitudeThreshold: &quot;1.0&quot;</span></span><br><span class="line"><span class="string">              marginFraction: &quot;0.2&quot;</span></span><br><span class="line"><span class="string">              maxNumOfSpectrumItems: 20</span></span><br><span class="line"><span class="string">              minNumOfSpectrumItems: 10</span></span><br><span class="line"><span class="string">          historyLength: 3d</span></span><br><span class="line"><span class="string">          sampleInterval: 60s</span></span><br><span class="line"><span class="string">      resourceIdentifier: cpu</span></span><br><span class="line"><span class="string">      type: ExpressionQuery</span></span><br><span class="line"><span class="string">      expressionQuery:</span></span><br><span class="line"><span class="string">        expression: &#x27;sum(count(node_cpu_seconds_total&#123;mode=&quot;idle&quot;,instance=~&quot;(&#123;&#123;.metadata.name&#125;&#125;)(:\\d+)?&quot;&#125;) by (mode, cpu)) - sum(irate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;,instance=~&quot;(&#123;&#123;.metadata.name&#125;&#125;)(:\\d+)?&quot;&#125;[5m]))&#x27;</span></span><br><span class="line"><span class="string">    predictionWindowSeconds: 3600</span></span><br><span class="line"><span class="string"></span><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">noderesource-tsp-template</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>



<p>结合预测算法和当前实际用量推算节点的剩余可用资源，并将其作为拓展资源赋予节点，pod 可标明使用该扩展资源作为离线作业将空闲资源利用起来，以提升节点的资源利用率。</p>
<p>在部署 pod 时 limit 和 request 使用 <code>gocrane.io/&lt;$ResourceName&gt;：&lt;$value&gt;</code> 即可，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">extended-resource-demo-ctr</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">gocrane.io/cpu:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">          <span class="attr">gocrane.io/memory:</span> <span class="string">&#x27;2000Mi&#x27;</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">gocrane.io/cpu:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">          <span class="attr">gocrane.io/memory:</span> <span class="string">&#x27;2000Mi&#x27;</span></span><br></pre></td></tr></table></figure>



<p><strong>弹性资源限制功能</strong></p>
<p>原生的 BestEffort 应用缺乏资源用量的公平保证，Crane 保证使用动态资源的 BestEffort pod 其 cpu 使用量被限制在其允许使用的合理范围内，agent 保证使用扩展资源的 pod 实际用量也不会超过其声明限制，同时在 cpu 竞争时也能按照各自声明量公平竞争；同时使用弹性资源的 pod 也会受到水位线功能的管理。</p>
<p>同样在部署 pod 时 limit 和 request 使用<code>gocrane.io/&lt;$ResourceName&gt;：&lt;$value&gt;</code>即可</p>
<p><strong>适配场景</strong></p>
<p>为了提升节点的负载，可以将一些离线作业或者重要性较低的作业通过使用弹性资源的方式调度部署到集群中，这类作业会使用空闲的弹性资源，搭配 QOS 的水位线保障，在节点出现负载较高的时候，也会优先被驱逐和压制，在保证高优先级业务稳定的前提下提升节点利用率。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2022 年，腾讯云原生 FinOps Crane 项目组，结合行业及产业的发展趋势，联动中国产业互联网发展联盟、中国信通院、中国电子节能技术协会、FinOps 基金会及中国内外众多生态合作伙伴，开展及推动技术标准、国内联盟、国际开源、双碳升级等多维度的成果落地，输出了系列白皮书和标准指南，旨在助力企业和生态更良性发展和应用先进技术，达成降本增效，节能减排目标方向。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1666922649467.png" alt="Crane 能力全景图"></p>
<p>我们可以自己在 Kubernetes 集群中安装 crane 来获取这些相关功能，此外这些能力也都会在腾讯云 TKE 的原生节点产品 <code>Housekeeper</code> 中提供，新推出的 TKE Housekeeper 是腾讯云推出的全新 K8s 运维范式，可以帮助企业像管理 Workload 一样声明式管理 Node 节点，高效解决节点维护、资源规划等各种各样的运维问题。</p>
<p>毫无疑问，Crane 已经是 Kubernetes 集群中用于云资源分析和经济的最佳 FinOps 平台了。目前，腾讯云 Crane 已进入 CNCF LandScape，这意味着 Crane 已成为云原生领域的重要项目。面向未来，腾讯云还将持续反馈开源社区、共建开源生态，帮助更多企业通过云原生全面释放生产力，加速实现数字化和绿色化双转型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/DaemonSet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/DaemonSet/" class="post-title-link" itemprop="url">DaemonSet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:27:00" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E6%8E%A7%E5%88%B6%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">控制器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DaemonSet-控制器"><a href="#DaemonSet-控制器" class="headerlink" title="DaemonSet 控制器"></a>DaemonSet 控制器</h1><p>通过该控制器的名称我们可以看出它的用法：<code>Daemon</code>，就是用来部署守护进程的，<code>DaemonSet</code>用于在每个 Kubernetes 节点中将守护进程的副本作为后台进程运行，说白了就是在每个节点部署一个 Pod 副本，当节点加入到 Kubernetes 集群中，Pod 会被调度到该节点上运行，当节点从集群只能够被移除后，该节点上的这个 Pod 也会被移除，当然，如果我们删除 DaemonSet，所有和这个对象相关的 Pods 都会被删除。那么在哪种情况下我们会需要用到这种业务场景呢？其实这种场景还是比较普通的，比如：</p>
<ul>
<li>集群存储守护程序，如 glusterd、ceph 要部署在每个节点上以提供持久性存储；</li>
<li>节点监控守护进程，如 Prometheus 监控集群，可以在每个节点上运行一个 <code>node-exporter</code> 进程来收集监控节点的信息；</li>
<li>日志收集守护程序，如 fluentd 或 logstash，在每个节点上运行以收集容器的日志</li>
<li>节点网络插件，比如 flannel、calico，在每个节点上运行为 Pod 提供网络服务。</li>
</ul>
<p>这里需要特别说明的一个就是关于 DaemonSet 运行的 Pod 的调度问题，正常情况下，Pod 运行在哪个节点上是由 Kubernetes 的调度器策略来决定的，然而，由 DaemonSet 控制器创建的 Pod 实际上提前已经确定了在哪个节点上了（Pod 创建时指定了<code>.spec.nodeName</code>），所以：</p>
<ul>
<li><code>DaemonSet</code> 并不关心一个节点的 <code>unshedulable</code> 字段，这个我们会在后面的调度章节和大家讲解的。</li>
<li><code>DaemonSet</code> 可以创建 Pod，即使调度器还没有启动。</li>
</ul>
<p>下面我们直接使用一个示例来演示下，在每个节点上部署一个 Nginx Pod：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx-ds.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ds</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>然后直接创建即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f nginx-ds.yaml</span><br><span class="line">daemonset.apps/nginx-ds created</span><br></pre></td></tr></table></figure>

<p>创建完成后，我们查看 Pod 的状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES                  AGE   VERSION</span><br><span class="line">master1   Ready    control-plane,master   18d   v1.22.2</span><br><span class="line">node1     Ready    &lt;none&gt;                 18d   v1.22.2</span><br><span class="line">node2     Ready    &lt;none&gt;                 18d   v1.22.2</span><br><span class="line">➜  ~ kubectl get pods -l k8s-app=nginx -o wide</span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE   IP             NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-ds-5b2m7   1/1     Running   0          15s   10.244.2.165   node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-ds-jfr89   1/1     Running   0          15s   10.244.1.170   node1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>我们观察可以发现除了 master1 节点之外的 2 个节点上都有一个相应的 Pod 运行，因为 master1 节点上默认被打上了<code>污点</code>，所以默认情况下不能调度普通的 Pod 上去，后面讲解调度器的时候会和大家学习如何调度上去。</p>
<p>基本上我们可以用下图来描述 DaemonSet 的拓扑图：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/qm9exj.jpg" alt="DaemonSet"></p>
<p>集群中的 Pod 和 Node 是<strong>一一</strong>对应 d 的，而 DaemonSet 会管理全部机器上的 Pod 副本，负责对它们进行更新和删除。</p>
<p>那么，DaemonSet 控制器是如何保证每个 Node 上有且只有一个被管理的 Pod 呢？</p>
<ul>
<li>首先控制器从 Etcd 获取到所有的 Node 列表，然后遍历所有的 Node。</li>
<li>根据资源对象定义是否有调度相关的配置，然后分别检查 Node 是否符合要求。</li>
<li>在可运行 Pod 的节点上检查是否已有对应的 Pod，如果没有，则在这个 Node 上创建该 Pod；如果有，并且数量大于 1，那就把多余的 Pod 从这个节点上删除；如果有且只有一个 Pod，那就说明是正常情况。</li>
</ul>
<p>实际上当我们学习了资源调度后，我们也可以自己用 Deployment 来实现 DaemonSet 的效果，这里我们明白 DaemonSet 如何使用的即可，当然该资源对象也有对应的更新策略，有 <code>OnDelete</code> 和 <code>RollingUpdate</code> 两种方式，默认是滚动更新。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Deployment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Deployment/" class="post-title-link" itemprop="url">Deployment</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:27:52" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E6%8E%A7%E5%88%B6%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">控制器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Deployment-控制器"><a href="#Deployment-控制器" class="headerlink" title="Deployment 控制器"></a>Deployment 控制器</h1><p>前面我们学习了 ReplicaSet 控制器，了解到该控制器是用来维护集群中运行的 Pod 数量的，但是往往在实际操作的时候，我们反而不会去直接使用 RS，而是会使用更上层的控制器，比如我们今天要学习的主角 Deployment，Deployment 一个非常重要的功能就是实现了 Pod 的滚动更新，比如我们应用更新了，我们只需要更新我们的容器镜像，然后修改 Deployment 里面的 Pod 模板镜像，那么 Deployment 就会用<strong>滚动更新（Rolling Update）</strong>的方式来升级现在的 Pod，这个能力是非常重要的，因为对于线上的服务我们需要做到不中断服务，所以滚动更新就成了必须的一个功能。而 Deployment 这个能力的实现，依赖的就是上节课我们学习的 ReplicaSet 这个资源对象，实际上我们可以通俗的理解就是<strong>每个 Deployment 就对应集群中的一次部署</strong>，这样就更好理解了。</p>
<h2 id="Deployment-概述"><a href="#Deployment-概述" class="headerlink" title="Deployment 概述"></a>Deployment 概述</h2><p>Deployment 资源对象的格式和 ReplicaSet 几乎一致，如下资源对象就是一个常见的 Deployment 资源类型：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx-deploy.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 期望的 Pod 副本数量，默认值为1</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># Label Selector，必须匹配 Pod 模板中的标签</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># Pod 模板</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>我们这里只是将类型替换成了 Deployment，我们可以先来创建下这个资源对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f nginx-deploy.yaml</span><br><span class="line">deployment.apps/nginx-deploy created</span><br><span class="line">➜  ~ kubectl get deployment</span><br><span class="line">NAME           READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deploy   3/3     3            3           58s</span><br></pre></td></tr></table></figure>

<p>创建完成后，查看 Pod 状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get pods -l app=nginx</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deploy-85ff79dd56-7r76h   1/1     Running   0          41s</span><br><span class="line">nginx-deploy-85ff79dd56-d5gjs   1/1     Running   0          41s</span><br><span class="line">nginx-deploy-85ff79dd56-txc4h   1/1     Running   0          41s</span><br></pre></td></tr></table></figure>

<p>到这里我们发现和之前的 RS 对象是否没有什么两样，都是根据<code>spec.replicas</code>来维持的副本数量，我们随意查看一个 Pod 的描述信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl describe pod nginx-deploy-85ff79dd56-txc4h</span><br><span class="line">Name:               nginx-deploy-85ff79dd56-txc4h</span><br><span class="line">Namespace:          default</span><br><span class="line">Priority:           0</span><br><span class="line">PriorityClassName:  &lt;none&gt;</span><br><span class="line">Node:               node1/10.151.30.22</span><br><span class="line">Start Time:         Sat, 16 Nov 2019 16:01:25 +0800</span><br><span class="line">Labels:             app=nginx</span><br><span class="line">                    pod-template-hash=85ff79dd56</span><br><span class="line">Annotations:        podpreset.admission.kubernetes.io/podpreset-time-preset: 2062768</span><br><span class="line">Status:             Running</span><br><span class="line">IP:                 10.244.1.166</span><br><span class="line">Controlled By:      ReplicaSet/nginx-deploy-85ff79dd56</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age        From                 Message</span><br><span class="line">  ----    ------     ----       ----                 -------</span><br><span class="line">  Normal  Scheduled  &lt;unknown&gt;  default-scheduler    Successfully assigned default/nginx-deploy-85ff79dd56-txc4h to node1</span><br><span class="line">  Normal  Pulling    2m         kubelet, node1  Pulling image &quot;nginx&quot;</span><br><span class="line">  Normal  Pulled     117s       kubelet, node1  Successfully pulled image &quot;nginx&quot;</span><br><span class="line">  Normal  Created    117s       kubelet, node1  Created container nginx</span><br><span class="line">  Normal  Started    116s       kubelet, node1  Started container nginx</span><br></pre></td></tr></table></figure>

<p>我们仔细查看其中有这样一个信息 <code>Controlled By: ReplicaSet/nginx-deploy-85ff79dd56</code>，什么意思？是不是表示当前我们这个 Pod 的控制器是一个 ReplicaSet 对象啊，我们不是创建的一个 Deployment 吗？为什么 Pod 会被 RS 所控制呢？那我们再去看下这个对应的 RS 对象的详细信息如何呢：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl describe rs nginx-deploy-85ff79dd56</span><br><span class="line">Name:           nginx-deploy-85ff79dd56</span><br><span class="line">Namespace:      default</span><br><span class="line">Selector:       app=nginx,pod-template-hash=85ff79dd56</span><br><span class="line">Labels:         app=nginx</span><br><span class="line">                pod-template-hash=85ff79dd56</span><br><span class="line">Annotations:    deployment.kubernetes.io/desired-replicas: 3</span><br><span class="line">                deployment.kubernetes.io/max-replicas: 4</span><br><span class="line">                deployment.kubernetes.io/revision: 1</span><br><span class="line">Controlled By:  Deployment/nginx-deploy</span><br><span class="line">Replicas:       3 current / 3 desired</span><br><span class="line">Pods Status:    3 Running / 0 Waiting / 0 Succeeded / 0 Failed</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason            Age    From                   Message</span><br><span class="line">  ----    ------            ----   ----                   -------</span><br><span class="line">  Normal  SuccessfulCreate  4m52s  replicaset-controller  Created pod: nginx-deploy-85ff79dd56-7r76h</span><br><span class="line">  Normal  SuccessfulCreate  4m52s  replicaset-controller  Created pod: nginx-deploy-85ff79dd56-d5gjs</span><br><span class="line">  Normal  SuccessfulCreate  4m52s  replicaset-controller  Created pod: nginx-deploy-85ff79dd56-txc4h</span><br></pre></td></tr></table></figure>

<p>其中有这样的一个信息：<code>Controlled By: Deployment/nginx-deploy</code>，明白了吧？意思就是我们的 Pod 依赖的控制器 RS 实际上被我们的 Deployment 控制着呢，我们可以用下图来说明 Pod、ReplicaSet、Deployment 三者之间的关系：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/fhuquv.jpg" alt="Deployment"></p>
<p>通过上图我们可以很清楚的看到，定义了 3 个副本的 Deployment 与 ReplicaSet 和 Pod 的关系，就是一层一层进行控制的。ReplicaSet 作用和之前一样还是来保证 Pod 的个数始终保存指定的数量，所以 Deployment 中的容器 <code>restartPolicy=Always</code> 是唯一的就是这个原因，因为容器必须始终保证自己处于 Running 状态，ReplicaSet 才可以去明确调整 Pod 的个数。而 Deployment 是通过管理 ReplicaSet 的数量和属性来实现<code>水平扩展/收缩</code>以及<code>滚动更新</code>两个功能的。</p>
<h2 id="水平伸缩"><a href="#水平伸缩" class="headerlink" title="水平伸缩"></a>水平伸缩</h2><p><code>水平扩展/收缩</code>的功能比较简单，因为 ReplicaSet 就可以实现，所以 Deployment 控制器只需要去修改它缩控制的 ReplicaSet 的 Pod 副本数量就可以了。比如现在我们把 Pod 的副本调整到 4 个，那么 Deployment 所对应的 ReplicaSet 就会自动创建一个新的 Pod 出来，这样就水平扩展了，我们可以使用一个新的命令 <code>kubectl scale</code> 命令来完成这个操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl scale deployment nginx-deploy --replicas=4</span><br><span class="line">deployment.apps/nginx-deployment scaled</span><br></pre></td></tr></table></figure>

<p>扩展完成后可以查看当前的 RS 对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get rs</span><br><span class="line">NAME                      DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-85ff79dd56   4         4         3       40m</span><br></pre></td></tr></table></figure>

<p>可以看到期望的 Pod 数量已经变成 4 了，只是 Pod 还没准备完成，所以 READY 状态数量还是 3，同样查看 RS 的详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl describe rs nginx-deploy-85ff79dd56</span><br><span class="line">Name:           nginx-deploy-85ff79dd56</span><br><span class="line">Namespace:      default</span><br><span class="line">Selector:       app=nginx,pod-template-hash=85ff79dd56</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason            Age   From                   Message</span><br><span class="line">  ----    ------            ----  ----                   -------</span><br><span class="line">  Normal  SuccessfulCreate  40m   replicaset-controller  Created pod: nginx-deploy-85ff79dd56-7r76h</span><br><span class="line">  Normal  SuccessfulCreate  40m   replicaset-controller  Created pod: nginx-deploy-85ff79dd56-d5gjs</span><br><span class="line">  Normal  SuccessfulCreate  40m   replicaset-controller  Created pod: nginx-deploy-85ff79dd56-txc4h</span><br><span class="line">  Normal  SuccessfulCreate  17s   replicaset-controller  Created pod: nginx-deploy-85ff79dd56-tph9g</span><br></pre></td></tr></table></figure>

<p>可以看到 ReplicaSet 控制器增加了一个新的 Pod，同样的 Deployment 资源对象的事件中也可以看到完成了扩容的操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl describe deploy nginx-deploy</span><br><span class="line">Name:                   nginx-deploy</span><br><span class="line">Namespace:              default</span><br><span class="line">......</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   nginx-deploy-85ff79dd56 (4/4 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age    From                   Message</span><br><span class="line">  ----    ------             ----   ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  43m    deployment-controller  Scaled up replica set nginx-deploy-85ff79dd56 to 3</span><br><span class="line">  Normal  ScalingReplicaSet  3m16s  deployment-controller  Scaled up replica set nginx-deploy-85ff79dd56 to 4</span><br></pre></td></tr></table></figure>

<h2 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h2><p>如果只是<code>水平扩展/收缩</code>这两个功能，就完全没必要设计 Deployment 这个资源对象了，Deployment 最突出的一个功能是支持<code>滚动更新</code>，比如现在我们需要把应用容器更改为 <code>nginx:1.7.9</code> 版本，修改后的资源清单文件如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">minReadySeconds:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 指定更新策略：RollingUpdate和Recreate</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>后前面相比较，除了更改了镜像之外，我们还指定了更新策略：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">strategy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">rollingUpdate:</span></span><br><span class="line">    <span class="attr">maxSurge:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>minReadySeconds</code>：表示 Kubernetes 在等待设置的时间后才进行升级，如果没有设置该值，Kubernetes 会假设该容器启动起来后就提供服务了，如果没有设置该值，在某些极端情况下可能会造成服务不正常运行，默认值就是 0。</li>
<li><code>type=RollingUpdate</code>：表示设置更新策略为滚动更新，可以设置为<code>Recreate</code>和<code>RollingUpdate</code>两个值，<code>Recreate</code>表示全部重新创建，默认值就是<code>RollingUpdate</code>。</li>
<li><code>maxSurge</code>：表示升级过程中最多可以比原先设置多出的 Pod 数量，例如：<code>maxSurage=1，replicas=5</code>，就表示 Kubernetes 会先启动一个新的 Pod，然后才删掉一个旧的 Pod，整个升级过程中最多会有<code>5+1</code>个 Pod。</li>
<li><code>maxUnavaible</code>：表示升级过程中最多有多少个 Pod 处于无法提供服务的状态，当<code>maxSurge</code>不为 0 时，该值也不能为 0，例如：<code>maxUnavaible=1</code>，则表示 Kubernetes 整个升级过程中最多会有 1 个 Pod 处于无法服务的状态。</li>
</ul>
<p>现在我们来直接更新上面的 Deployment 资源对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-deploy.yaml</span><br></pre></td></tr></table></figure>

<p><strong>record 参数</strong></p>
<p>我们可以添加了一个额外的 <code>--record</code> 参数来记录下我们的每次操作所执行的命令，以方便后面查看。</p>
<p>更新后，我们可以执行下面的 <code>kubectl rollout status</code> 命令来查看我们此次滚动更新的状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl rollout status deployment/nginx-deploy</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 2 out of 3 new replicas have been updated...</span><br></pre></td></tr></table></figure>

<p>从上面的信息可以看出我们的滚动更新已经有两个 Pod 已经更新完成了，在滚动更新过程中，我们还可以执行如下的命令来暂停更新：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl rollout pause deployment/nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy paused</span><br></pre></td></tr></table></figure>

<p>这个时候我们的滚动更新就暂停了，此时我们可以查看下 Deployment 的详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl describe deploy nginx-deploy</span><br><span class="line">Name:                   nginx-deploy</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Sat, 16 Nov 2019 16:01:24 +0800</span><br><span class="line">Labels:                 &lt;none&gt;</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: 2</span><br><span class="line">                        kubectl.kubernetes.io/last-applied-configuration:</span><br><span class="line">                          &#123;&quot;apiVersion&quot;:&quot;apps/v1&quot;,&quot;kind&quot;:&quot;Deployment&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;name&quot;:&quot;nginx-deploy&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;spec&quot;:&#123;&quot;minReadySec...</span><br><span class="line">Selector:               app=nginx</span><br><span class="line">Replicas:               3 desired | 2 updated | 4 total | 4 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        5</span><br><span class="line">RollingUpdateStrategy:  1 max unavailable, 1 max surge</span><br><span class="line">......</span><br><span class="line">OldReplicaSets:  nginx-deploy-85ff79dd56 (2/2 replicas created)</span><br><span class="line">NewReplicaSet:   nginx-deploy-5b7b9ccb95 (2/2 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age    From                   Message</span><br><span class="line">  ----    ------             ----   ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  26m    deployment-controller  Scaled up replica set nginx-deploy-85ff79dd56 to 4</span><br><span class="line">  Normal  ScalingReplicaSet  3m44s  deployment-controller  Scaled down replica set nginx-deploy-85ff79dd56 to 3</span><br><span class="line">  Normal  ScalingReplicaSet  3m44s  deployment-controller  Scaled up replica set nginx-deploy-5b7b9ccb95 to 1</span><br><span class="line">  Normal  ScalingReplicaSet  3m44s  deployment-controller  Scaled down replica set nginx-deploy-85ff79dd56 to 2</span><br><span class="line">  Normal  ScalingReplicaSet  3m44s  deployment-controller  Scaled up replica set nginx-deploy-5b7b9ccb95 to 2</span><br></pre></td></tr></table></figure>



<p><img data-src="https://mudutestmenu.mudu.tv/upload/mxgnl0.jpg" alt="Deployment RollingUpdate"></p>
<p>我们仔细观察 Events 事件区域的变化，上面我们用 <code>kubectl scale</code> 命令将 Pod 副本调整到了 4，现在我们更新的时候是不是声明又变成 3 了，所以 Deployment 控制器首先是将之前控制的 <code>nginx-deploy-85ff79dd56</code> 这个 RS 资源对象进行缩容操作，然后滚动更新开始了，可以发现 Deployment 为一个新的 <code>nginx-deploy-5b7b9ccb95</code> RS 资源对象首先新建了一个新的 Pod，然后将之前的 RS 对象缩容到 2 了，再然后新的 RS 对象扩容到 2，后面由于我们暂停滚动升级了，所以没有后续的事件了，大家有看明白这个过程吧？这个过程就是滚动更新的过程，启动一个新的 Pod，杀掉一个旧的 Pod，然后再启动一个新的 Pod，这样滚动更新下去，直到全都变成新的 Pod，这个时候系统中应该存在 4 个 Pod，因为我们设置的策略<code>maxSurge=1</code>，所以在升级过程中是允许的，而且是两个新的 Pod，两个旧的 Pod：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get pods -l app=nginx</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deploy-5b7b9ccb95-k6pkh   1/1     Running   0          11m</span><br><span class="line">nginx-deploy-5b7b9ccb95-l6lmx   1/1     Running   0          11m</span><br><span class="line">nginx-deploy-85ff79dd56-7r76h   1/1     Running   0          75m</span><br><span class="line">nginx-deploy-85ff79dd56-txc4h   1/1     Running   0          75m</span><br></pre></td></tr></table></figure>

<p>查看 Deployment 的状态也可以看到当前的 Pod 状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get deployment</span><br><span class="line">NAME           READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deploy   4/3     2            4           75m</span><br></pre></td></tr></table></figure>

<p>这个时候我们可以使用<code>kubectl rollout resume</code>来恢复我们的滚动更新：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl rollout resume deployment/nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy resumed</span><br><span class="line">➜  ~ kubectl rollout status deployment/nginx-deploy</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 2 of 3 updated replicas are available...</span><br><span class="line">deployment &quot;nginx-deploy&quot; successfully rolled out</span><br></pre></td></tr></table></figure>

<p>看到上面的信息证明我们的滚动更新已经成功了，同样可以查看下资源状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get pod -l app=nginx</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deploy-5b7b9ccb95-gmq7v   1/1     Running   0          115s</span><br><span class="line">nginx-deploy-5b7b9ccb95-k6pkh   1/1     Running   0          15m</span><br><span class="line">nginx-deploy-5b7b9ccb95-l6lmx   1/1     Running   0          15m</span><br><span class="line">➜  ~ kubectl get deployment</span><br><span class="line">NAME           READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deploy   3/3     3            3           79m</span><br></pre></td></tr></table></figure>

<p>这个时候我们查看 ReplicaSet 对象，可以发现会出现两个：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get rs -l app=nginx</span><br><span class="line">NAME                      DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-5b7b9ccb95   3         3         3       18m</span><br><span class="line">nginx-deploy-85ff79dd56   0         0         0       81m</span><br></pre></td></tr></table></figure>

<p>从上面可以看出滚动更新之前我们使用的 RS 资源对象的 Pod 副本数已经变成 0 了，而滚动更新后的 RS 资源对象变成了 3 个副本，我们可以导出之前的 RS 对象查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get rs nginx-deploy-85ff79dd56 -o yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    deployment.kubernetes.io/desired-replicas: &quot;3&quot;</span><br><span class="line">    deployment.kubernetes.io/max-replicas: &quot;4&quot;</span><br><span class="line">    deployment.kubernetes.io/revision: &quot;1&quot;</span><br><span class="line">  creationTimestamp: &quot;2019-11-16T08:01:24Z&quot;</span><br><span class="line">  generation: 5</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">    pod-template-hash: 85ff79dd56</span><br><span class="line">  name: nginx-deploy-85ff79dd56</span><br><span class="line">  namespace: default</span><br><span class="line">  ownerReferences:</span><br><span class="line">  - apiVersion: apps/v1</span><br><span class="line">    blockOwnerDeletion: true</span><br><span class="line">    controller: true</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: nginx-deploy</span><br><span class="line">    uid: b0fc5614-ef58-496c-9111-740353bd90d4</span><br><span class="line">  resourceVersion: &quot;2140545&quot;</span><br><span class="line">  selfLink: /apis/apps/v1/namespaces/default/replicasets/nginx-deploy-85ff79dd56</span><br><span class="line">  uid: 8eca2998-3610-4f80-9c21-5482ba579892</span><br><span class="line">spec:</span><br><span class="line">  replicas: 0</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">      pod-template-hash: 85ff79dd56</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">        pod-template-hash: 85ff79dd56</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          protocol: TCP</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">        terminationMessagePath: /dev/termination-log</span><br><span class="line">        terminationMessagePolicy: File</span><br><span class="line">      dnsPolicy: ClusterFirst</span><br><span class="line">      restartPolicy: Always</span><br><span class="line">      schedulerName: default-scheduler</span><br><span class="line">      securityContext: &#123;&#125;</span><br><span class="line">      terminationGracePeriodSeconds: 30</span><br><span class="line">status:</span><br><span class="line">  observedGeneration: 5</span><br><span class="line">  replicas: 0</span><br></pre></td></tr></table></figure>

<p>我们仔细观察这个资源对象里面的描述信息除了副本数变成了 <code>replicas=0</code> 之外，和更新之前没有什么区别吧？大家看到这里想到了什么？有了这个 RS 的记录存在，是不是我们就可以回滚了啊？而且还可以回滚到前面的任意一个版本，这个版本是如何定义的呢？我们可以通过命令 <code>rollout history</code> 来获取：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl rollout history deployment nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         &lt;none&gt;</span><br><span class="line">2         &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>其实 <code>rollout history</code> 中记录的 <code>revision</code> 是和 <code>ReplicaSets</code> 一一对应。如果我们手动删除某个 <code>ReplicaSet</code>，对应的<code>rollout history</code>就会被删除，也就是说你无法回滚到这个<code>revison</code>了，同样我们还可以查看一个<code>revison</code>的详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl rollout history deployment nginx-deploy --revision=1</span><br><span class="line">deployment.apps/nginx-deploy with revision #1</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:       app=nginx</span><br><span class="line">        pod-template-hash=85ff79dd56</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:      nginx</span><br><span class="line">    Port:       80/TCP</span><br><span class="line">    Host Port:  0/TCP</span><br><span class="line">    Environment:        &lt;none&gt;</span><br><span class="line">    Mounts:     &lt;none&gt;</span><br><span class="line">  Volumes:      &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>假如现在要直接回退到当前版本的前一个版本，我们可以直接使用如下命令进行操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl rollout undo deployment nginx-deploy</span><br></pre></td></tr></table></figure>

<p>当然也可以回退到指定的<code>revision</code>版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl rollout undo deployment nginx-deploy --to-revision=1</span><br><span class="line">deployment &quot;nginx-deploy&quot; rolled back</span><br></pre></td></tr></table></figure>

<p>回滚的过程中我们同样可以查看回滚状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl rollout status deployment/nginx-deploy</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 1 old replicas are pending termination...</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 1 old replicas are pending termination...</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 1 old replicas are pending termination...</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 2 of 3 updated replicas are available...</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 2 of 3 updated replicas are available...</span><br><span class="line">deployment &quot;nginx-deploy&quot; successfully rolled out</span><br></pre></td></tr></table></figure>

<p>这个时候查看对应的 RS 资源对象可以看到 Pod 副本已经回到之前的 RS 里面去了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get rs -l app=nginx</span><br><span class="line">NAME                      DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-5b7b9ccb95   0         0         0       31m</span><br><span class="line">nginx-deploy-85ff79dd56   3         3         3       95m</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是回滚的操作滚动的<code>revision</code>始终是递增的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl rollout history deployment nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">2         &lt;none&gt;</span><br><span class="line">3         &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p><strong>保留旧版本</strong></p>
<p>在很早之前的 Kubernetes 版本中，默认情况下会为我们暴露下所有滚动升级的历史记录，也就是 ReplicaSet 对象，但一般情况下没必要保留所有的版本，毕竟会存在 etcd 中，我们可以通过配置 <code>spec.revisionHistoryLimit</code> 属性来设置保留的历史记录数量，不过新版本中该值默认为 10，如果希望多保存几个版本可以设置该字段。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Descheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Descheduler/" class="post-title-link" itemprop="url">Descheduler</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:27:59" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E8%B0%83%E5%BA%A6%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">调度器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Descheduler"><a href="#Descheduler" class="headerlink" title="Descheduler"></a>Descheduler</h1><p>从 kube-scheduler 的角度来看，它是通过一系列算法计算出最佳节点运行 Pod，当出现新的 Pod 进行调度时，调度程序会根据其当时对 Kubernetes 集群的资源描述做出最佳调度决定，但是 Kubernetes 集群是非常动态的，由于整个集群范围内的变化，比如一个节点为了维护，我们先执行了驱逐操作，这个节点上的所有 Pod 会被驱逐到其他节点去，但是当我们维护完成后，之前的 Pod 并不会自动回到该节点上来，因为 Pod 一旦被绑定了节点是不会触发重新调度的，由于这些变化，Kubernetes 集群在一段时间内就可能会出现不均衡的状态，所以需要均衡器来重新平衡集群。</p>
<p>当然我们可以去手动做一些集群的平衡，比如手动去删掉某些 Pod，触发重新调度就可以了，但是显然这是一个繁琐的过程，也不是解决问题的方式。为了解决实际运行中集群资源无法充分利用或浪费的问题，可以使用 <a target="_blank" rel="noopener" href="https://github.com/kubernetes-sigs/descheduler">descheduler</a> 组件对集群的 Pod 进行调度优化，<code>descheduler</code> 可以根据一些规则和配置策略来帮助我们重新平衡集群状态，其核心原理是根据其策略配置找到可以被移除的 Pod 并驱逐它们，其本身并不会进行调度被驱逐的 Pod，而是依靠默认的调度器来实现，目前支持的策略有：</p>
<ul>
<li>RemoveDuplicates</li>
<li>LowNodeUtilization</li>
<li>RemovePodsViolatingInterPodAntiAffinity</li>
<li>RemovePodsViolatingNodeAffinity</li>
<li>RemovePodsViolatingNodeTaints</li>
<li>RemovePodsViolatingTopologySpreadConstraint</li>
<li>RemovePodsHavingTooManyRestarts</li>
<li>PodLifeTime</li>
</ul>
<p>这些策略都是可以启用或者禁用的，作为策略的一部分，也可以配置与策略相关的一些参数，默认情况下，所有策略都是启用的。另外，还有一些通用配置，如下：</p>
<ul>
<li><code>nodeSelector</code>：限制要处理的节点</li>
<li><code>evictLocalStoragePods</code>: 驱逐使用 LocalStorage 的 Pods</li>
<li><code>ignorePvcPods</code>: 是否忽略配置 PVC 的 Pods，默认是 False</li>
<li><code>maxNoOfPodsToEvictPerNode</code>：节点允许的最大驱逐 Pods 数</li>
</ul>
<p>我们可以通过如下所示的 <code>DeschedulerPolicy</code> 来配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">nodeSelector:</span> <span class="string">prod=dev</span></span><br><span class="line"><span class="attr">evictLocalStoragePods:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">maxNoOfPodsToEvictPerNode:</span> <span class="number">40</span></span><br><span class="line"><span class="attr">ignorePvcPods:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">strategies:</span> <span class="comment"># 配置策略</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure>



<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>descheduler</code> 可以以 <code>Job</code>、<code>CronJob</code> 或者 <code>Deployment</code> 的形式运行在 k8s 集群内，同样我们可以使用 Helm Chart 来安装 <code>descheduler</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ helm repo add descheduler https://kubernetes-sigs.github.io/descheduler/</span><br></pre></td></tr></table></figure>



<p>通过 Helm Chart 我们可以配置 <code>descheduler</code> 以 <code>CronJob</code> 或者 <code>Deployment</code> 方式运行，默认情况下 <code>descheduler</code> 会以一个 <code>critical pod</code> 运行，以避免被自己或者 kubelet 驱逐了，需要确保集群中有 <code>system-cluster-critical</code> 这个 Priorityclass：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get priorityclass system-cluster-critical</span><br><span class="line">NAME                      VALUE        GLOBAL-DEFAULT   AGE</span><br><span class="line">system-cluster-critical   2000000000   false            87d</span><br></pre></td></tr></table></figure>



<p>使用 Helm Chart 安装默认情况下会以 <code>CronJob</code> 的形式运行，执行周期为 <code>schedule: &quot;*/2 * * * *&quot;</code>，这样每隔两分钟会执行一次 <code>descheduler</code> 任务，默认的配置策略如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">descheduler</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">policy.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    apiVersion: &quot;descheduler/v1alpha1&quot;</span></span><br><span class="line"><span class="string">    kind: &quot;DeschedulerPolicy&quot;</span></span><br><span class="line"><span class="string">    strategies:</span></span><br><span class="line"><span class="string">      LowNodeUtilization:</span></span><br><span class="line"><span class="string">        enabled: true</span></span><br><span class="line"><span class="string">        params:</span></span><br><span class="line"><span class="string">          nodeResourceUtilizationThresholds:</span></span><br><span class="line"><span class="string">            targetThresholds:</span></span><br><span class="line"><span class="string">              cpu: 50</span></span><br><span class="line"><span class="string">              memory: 50</span></span><br><span class="line"><span class="string">              pods: 50</span></span><br><span class="line"><span class="string">            thresholds:</span></span><br><span class="line"><span class="string">              cpu: 20</span></span><br><span class="line"><span class="string">              memory: 20</span></span><br><span class="line"><span class="string">              pods: 20</span></span><br><span class="line"><span class="string">      RemoveDuplicates:</span></span><br><span class="line"><span class="string">        enabled: true</span></span><br><span class="line"><span class="string">      RemovePodsViolatingInterPodAntiAffinity:</span></span><br><span class="line"><span class="string">        enabled: true</span></span><br><span class="line"><span class="string">      RemovePodsViolatingNodeAffinity:</span></span><br><span class="line"><span class="string">        enabled: true</span></span><br><span class="line"><span class="string">        params:</span></span><br><span class="line"><span class="string">          nodeAffinityType:</span></span><br><span class="line"><span class="string">          - requiredDuringSchedulingIgnoredDuringExecution</span></span><br><span class="line"><span class="string">      RemovePodsViolatingNodeTaints:</span></span><br><span class="line"><span class="string">        enabled: true</span></span><br></pre></td></tr></table></figure>



<p>通过配置 <code>DeschedulerPolicy</code> 的 <code>strategies</code>，可以指定 <code>descheduler</code> 的执行策略，这些策略都是可以启用或禁用的，下面我们会详细介绍，这里我们使用默认策略即可，使用如下命令直接安装即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ helm upgrade --install descheduler descheduler/descheduler --set image.repository=cnych/descheduler,podSecurityPolicy.create=false -n kube-system</span><br><span class="line">Release &quot;descheduler&quot; does not exist. Installing it now.</span><br><span class="line">NAME: descheduler</span><br><span class="line">LAST DEPLOYED: Fri Jan 21 10:35:55 2022</span><br><span class="line">NAMESPACE: kube-system</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">NOTES:</span><br><span class="line">Descheduler installed as a cron job.</span><br></pre></td></tr></table></figure>



<p>部署完成后会创建一个 <code>CronJob</code> 资源对象来平衡集群状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get cronjob -n kube-system</span><br><span class="line">NAME          SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE</span><br><span class="line">descheduler   */2 * * * *   False     1        27s             31s</span><br><span class="line">➜ kubectl get job -n kube-system</span><br><span class="line">NAME                   COMPLETIONS   DURATION   AGE</span><br><span class="line">descheduler-27378876   1/1           72s        79s</span><br><span class="line">➜ kubectl get pods -n kube-system -l job-name=descheduler-27378876</span><br><span class="line">NAME                            READY   STATUS      RESTARTS   AGE</span><br><span class="line">descheduler-27378876--1-btjmd   0/1     Completed   0          2m21s</span><br></pre></td></tr></table></figure>



<p>正常情况下就会创建一个对应的 Job 来执行 <code>descheduler</code> 任务，我们可以通过查看日志可以了解做了哪些平衡操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl logs -f descheduler-27378876--1-btjmd -n kube-system</span><br><span class="line">I0121 02:37:10.127266       1 named_certificates.go:53] &quot;Loaded SNI cert&quot; index=0 certName=&quot;self-signed loopback&quot; certDetail=&quot;\&quot;apiserver-loopback-client@1642732630\&quot; [serving] validServingFor=[apiserver-loopback-client] issuer=\&quot;apiserver-loopback-client-ca@1642732629\&quot; (2022-01-21 01:37:09 +0000 UTC to 2023-01-21 01:37:09 +0000 UTC (now=2022-01-21 02:37:10.127237 +0000 UTC))&quot;</span><br><span class="line">I0121 02:37:10.127324       1 secure_serving.go:195] Serving securely on [::]:10258</span><br><span class="line">I0121 02:37:10.127363       1 tlsconfig.go:240] &quot;Starting DynamicServingCertificateController&quot;</span><br><span class="line">I0121 02:37:10.138724       1 node.go:46] &quot;Node lister returned empty list, now fetch directly&quot;</span><br><span class="line">I0121 02:37:10.172264       1 nodeutilization.go:167] &quot;Node is overutilized&quot; node=&quot;master1&quot; usage=map[cpu:1225m memory:565Mi pods:16] usagePercentage=map[cpu:61.25 memory:15.391786081415567 pods:14.545454545454545]</span><br><span class="line">I0121 02:37:10.172313       1 nodeutilization.go:164] &quot;Node is underutilized&quot; node=&quot;node1&quot; usage=map[cpu:675m memory:735Mi pods:16] usagePercentage=map[cpu:16.875 memory:9.542007959787252 pods:14.545454545454545]</span><br><span class="line">I0121 02:37:10.172328       1 nodeutilization.go:170] &quot;Node is appropriately utilized&quot; node=&quot;node2&quot; usage=map[cpu:975m memory:1515Mi pods:15] usagePercentage=map[cpu:24.375 memory:19.66820054018583 pods:13.636363636363637]</span><br><span class="line">I0121 02:37:10.172340       1 lownodeutilization.go:100] &quot;Criteria for a node under utilization&quot; CPU=20 Mem=20 Pods=20</span><br><span class="line">I0121 02:37:10.172346       1 lownodeutilization.go:101] &quot;Number of underutilized nodes&quot; totalNumber=1</span><br><span class="line">I0121 02:37:10.172355       1 lownodeutilization.go:114] &quot;Criteria for a node above target utilization&quot; CPU=50 Mem=50 Pods=50</span><br><span class="line">I0121 02:37:10.172360       1 lownodeutilization.go:115] &quot;Number of overutilized nodes&quot; totalNumber=1</span><br><span class="line">I0121 02:37:10.172374       1 nodeutilization.go:223] &quot;Total capacity to be moved&quot; CPU=1325 Mem=3267772416 Pods=39</span><br><span class="line">I0121 02:37:10.172399       1 nodeutilization.go:226] &quot;Evicting pods from node&quot; node=&quot;master1&quot; usage=map[cpu:1225m memory:565Mi pods:16]</span><br><span class="line">I0121 02:37:10.172485       1 nodeutilization.go:229] &quot;Pods on node&quot; node=&quot;master1&quot; allPods=16 nonRemovablePods=13 removablePods=3</span><br><span class="line">I0121 02:37:10.172495       1 nodeutilization.go:236] &quot;Evicting pods based on priority, if they have same priority, they&#x27;ll be evicted based on QoS tiers&quot;</span><br><span class="line">I0121 02:37:10.180353       1 evictions.go:130] &quot;Evicted pod&quot; pod=&quot;default/topo-demo-6bbf65d967-lzlfh&quot; reason=&quot;LowNodeUtilization&quot;</span><br><span class="line">I0121 02:37:10.181506       1 nodeutilization.go:269] &quot;Evicted pods&quot; pod=&quot;default/topo-demo-6bbf65d967-lzlfh&quot; err=&lt;nil&gt;</span><br><span class="line">I0121 02:37:10.181541       1 nodeutilization.go:294] &quot;Updated node usage&quot; node=&quot;master1&quot; CPU=1225 Mem=592445440 Pods=15</span><br><span class="line">I0121 02:37:10.182496       1 event.go:291] &quot;Event occurred&quot; object=&quot;default/topo-demo-6bbf65d967-lzlfh&quot; kind=&quot;Pod&quot; apiVersion=&quot;v1&quot; type=&quot;Normal&quot; reason=&quot;Descheduled&quot; message=&quot;pod evicted by sigs.k8s.io/deschedulerLowNodeUtilization&quot;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>从日志中我们就可以清晰的知道因为什么策略驱逐了哪些 Pods。</p>
<h2 id="PDB"><a href="#PDB" class="headerlink" title="PDB"></a>PDB</h2><p>由于使用 <code>descheduler</code> 会将 Pod 驱逐进行重调度，但是如果一个服务的所有副本都被驱逐的话，则可能导致该服务不可用。如果服务本身存在单点故障，驱逐的时候肯定就会造成服务不可用了，这种情况我们强烈建议使用反亲和性和多副本来避免单点故障，但是如果服务本身就被打散在多个节点上，这些 Pod 都被驱逐的话，这个时候也会造成服务不可用了，这种情况下我们可以通过配置 <code>PDB（PodDisruptionBudget）</code> 对象来避免所有副本同时被删除，比如我们可以设置在驱逐的时候某应用最多只有一个副本不可用，则创建如下所示的资源清单即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodDisruptionBudget</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pdb-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">maxUnavailable:</span> <span class="number">1</span> <span class="comment"># 设置最多不可用的副本数量，或者使用 minAvailable，可以使用整数或百分比</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 匹配Pod标签</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">demo</span></span><br></pre></td></tr></table></figure>



<p>关于 PDB 的更多详细信息可以查看官方文档：<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/run-application/configure-pdb/%E3%80%82">https://kubernetes.io/docs/tasks/run-application/configure-pdb/。</a></p>
<p>所以如果我们使用 <code>descheduler</code> 来重新平衡集群状态，那么我们强烈建议给应用创建一个对应的 <code>PodDisruptionBudget</code> 对象进行保护。</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="PodLifeTime"><a href="#PodLifeTime" class="headerlink" title="PodLifeTime"></a>PodLifeTime</h3><p>该策略用于驱逐比 <code>maxPodLifeTimeSeconds</code> 更旧的 Pods，可以通过 <code>podStatusPhases</code> 来配置哪类状态的 Pods 会被驱逐，建议为每个应用程序创建一个 PDB，以确保应用程序的可用性，比如我们可以配置如下所示的策略来驱逐运行超过 7 天的 Pod：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;PodLifeTime&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">maxPodLifeTimeSeconds:</span> <span class="number">604800</span> <span class="comment"># Pods 运行最多7天</span></span><br></pre></td></tr></table></figure>



<h3 id="RemoveDuplicates"><a href="#RemoveDuplicates" class="headerlink" title="RemoveDuplicates"></a>RemoveDuplicates</h3><p>该策略确保只有一个和 Pod 关联的 RS、Deployment 或者 Job 资源对象运行在同一节点上。如果还有更多的 Pod 则将这些重复的 Pod 进行驱逐，以便更好地在集群中分散 Pod。如果某些节点由于某些原因崩溃了，这些节点上的 Pod 漂移到了其他节点，导致多个与 RS 关联的 Pod 在同一个节点上运行，就有可能发生这种情况，一旦出现故障的节点再次准备就绪，就可以启用该策略来驱逐这些重复的 Pod。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/tkf2ne.png" alt="RemoveDuplicates"></p>
<p>配置策略的时候，可以指定参数 <code>excludeOwnerKinds</code> 用于排除类型，这些类型下的 Pod 不会被驱逐：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;RemoveDuplicates&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">removeDuplicates:</span></span><br><span class="line">        <span class="attr">excludeOwnerKinds:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;ReplicaSet&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="LowNodeUtilization"><a href="#LowNodeUtilization" class="headerlink" title="LowNodeUtilization"></a>LowNodeUtilization</h3><p>该策略主要用于查找未充分利用的节点，并从其他节点驱逐 Pod，以便 kube-scheudler 重新将它们调度到未充分利用的节点上。该策略的参数可以通过字段 <code>nodeResourceUtilizationThresholds</code> 进行配置。</p>
<p>节点的利用率不足可以通过配置 <code>thresholds</code> 阈值参数来确定，可以通过 CPU、内存和 Pods 数量的百分比进行配置。如果节点的使用率均低于所有阈值，则认为该节点未充分利用。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/pbmrlv.png" alt="LowNodeUtilization"></p>
<p>此外，还有一个可配置的阈值 <code>targetThresholds</code>，用于计算可能驱逐 Pods 的潜在节点，该参数也可以配置 CPU、内存以及 Pods 数量的百分比进行配置。<code>thresholds</code> 和 <code>targetThresholds</code> 可以根据你的集群需求进行动态调整，如下所示示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;LowNodeUtilization&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">nodeResourceUtilizationThresholds:</span></span><br><span class="line">        <span class="attr">thresholds:</span></span><br><span class="line">          <span class="attr">&#x27;cpu&#x27;:</span> <span class="number">20</span></span><br><span class="line">          <span class="attr">&#x27;memory&#x27;:</span> <span class="number">20</span></span><br><span class="line">          <span class="attr">&#x27;pods&#x27;:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">targetThresholds:</span></span><br><span class="line">          <span class="attr">&#x27;cpu&#x27;:</span> <span class="number">50</span></span><br><span class="line">          <span class="attr">&#x27;memory&#x27;:</span> <span class="number">50</span></span><br><span class="line">          <span class="attr">&#x27;pods&#x27;:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>



<p>需要注意的是：</p>
<ul>
<li>仅支持以下三种资源类型：cpu、memory、pods</li>
<li><code>thresholds</code> 和 <code>targetThresholds</code> 必须配置相同的类型</li>
<li>参数值的访问是 0-100（百分制）</li>
<li>相同的资源类型，<code>thresholds</code> 的配置不能高于 <code>targetThresholds</code> 的配置</li>
</ul>
<p>如果未指定任何资源类型，则默认是 100%，以避免节点从未充分利用变为过度利用。和 <code>LowNodeUtilization</code> 策略关联的另一个参数是 <code>numberOfNodes</code>，只有当未充分利用的节点数大于该配置值的时候，才可以配置该参数来激活该策略，该参数对于大型集群非常有用，其中有一些节点可能会频繁使用或短期使用不足，默认情况下，numberOfNodes 为 0。</p>
<h3 id="RemovePodsViolatingInterPodAntiAffinity"><a href="#RemovePodsViolatingInterPodAntiAffinity" class="headerlink" title="RemovePodsViolatingInterPodAntiAffinity"></a>RemovePodsViolatingInterPodAntiAffinity</h3><p>该策略可以确保从节点中删除违反 Pod 反亲和性的 Pod，比如某个节点上有 podA 这个 Pod，并且 podB 和 podC（在同一个节点上运行）具有禁止它们在同一个节点上运行的反亲和性规则，则 podA 将被从该节点上驱逐，以便 podB 和 podC 运行正常运行。当 podB 和 podC 已经运行在节点上后，反亲和性规则被创建就会发送这样的问题。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/2q9llh.png" alt="RemovePodsViolatingInterPodAntiAffinity"></p>
<p>要禁用该策略，直接配置成 false 即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;RemovePodsViolatingInterPodAntiAffinity&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h3 id="RemovePodsViolatingNodeTaints"><a href="#RemovePodsViolatingNodeTaints" class="headerlink" title="RemovePodsViolatingNodeTaints"></a>RemovePodsViolatingNodeTaints</h3><p>该策略可以确保从节点中删除违反 <code>NoSchedule</code> 污点的 Pod，比如有一个名为 podA 的 Pod，通过配置容忍 <code>key=value:NoSchedule</code> 允许被调度到有该污点配置的节点上，如果节点的污点随后被更新或者删除了，则污点将不再被 Pods 的容忍满足，然后将被驱逐：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;RemovePodsViolatingNodeTaints&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h3 id="RemovePodsViolatingNodeAffinity"><a href="#RemovePodsViolatingNodeAffinity" class="headerlink" title="RemovePodsViolatingNodeAffinity"></a>RemovePodsViolatingNodeAffinity</h3><p>该策略确保从节点中删除违反节点亲和性的 Pod。比如名为 podA 的 Pod 被调度到了节点 nodeA，podA 在调度的时候满足了节点亲和性规则 <code>requiredDuringSchedulingIgnoredDuringExecution</code>，但是随着时间的推移，节点 nodeA 不再满足该规则了，那么如果另一个满足节点亲和性规则的节点 nodeB 可用，则 podA 将被从节点 nodeA 驱逐，如下所示的策略配置示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;RemovePodsViolatingNodeAffinity&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">nodeAffinityType:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;requiredDuringSchedulingIgnoredDuringExecution&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="RemovePodsViolatingTopologySpreadConstraint"><a href="#RemovePodsViolatingTopologySpreadConstraint" class="headerlink" title="RemovePodsViolatingTopologySpreadConstraint"></a>RemovePodsViolatingTopologySpreadConstraint</h3><p>该策略确保从节点驱逐违反拓扑分布约束的 Pods，具体来说，它试图驱逐将拓扑域平衡到每个约束的 <code>maxSkew</code> 内所需的最小 Pod 数，不过该策略需要 k8s 版本高于 1.18 才能使用。</p>
<p>默认情况下，此策略仅处理硬约束，如果将参数 <code>includeSoftConstraints</code> 设置为 True，也将支持软约束。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;RemovePodsViolatingTopologySpreadConstraint&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">includeSoftConstraints:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h3 id="RemovePodsHavingTooManyRestarts"><a href="#RemovePodsHavingTooManyRestarts" class="headerlink" title="RemovePodsHavingTooManyRestarts"></a>RemovePodsHavingTooManyRestarts</h3><p>该策略确保从节点中删除重启次数过多的 Pods，它的参数包括 <code>podRestartThreshold</code>（这是应将 Pod 逐出的重新启动次数），以及包括<code>InitContainers</code>，它确定在计算中是否应考虑初始化容器的重新启动，策略配置如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;RemovePodsHavingTooManyRestarts&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">podsHavingTooManyRestarts:</span></span><br><span class="line">        <span class="attr">podRestartThreshold:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">includingInitContainers:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h2 id="Filter-Pods"><a href="#Filter-Pods" class="headerlink" title="Filter Pods"></a>Filter Pods</h2><p>在驱逐 Pods 的时候，有时并不需要所有 Pods 都被驱逐，<code>descheduler</code> 提供了两种主要的方式进行过滤：命名空间过滤和优先级过滤。</p>
<h3 id="命名空间过滤"><a href="#命名空间过滤" class="headerlink" title="命名空间过滤"></a>命名空间过滤</h3><p>该策略可以配置是包含还是排除某些名称空间。可以使用该策略的有：</p>
<ul>
<li>PodLifeTime</li>
<li>RemovePodsHavingTooManyRestarts</li>
<li>RemovePodsViolatingNodeTaints</li>
<li>RemovePodsViolatingNodeAffinity</li>
<li>RemovePodsViolatingInterPodAntiAffinity</li>
<li>RemoveDuplicates</li>
<li>RemovePodsViolatingTopologySpreadConstraint</li>
</ul>
<p>比如只驱逐某些命令空间下的 Pods，则可以使用 <code>include</code> 参数进行配置，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;PodLifeTime&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">podLifeTime:</span></span><br><span class="line">        <span class="attr">maxPodLifeTimeSeconds:</span> <span class="number">86400</span></span><br><span class="line">      <span class="attr">namespaces:</span></span><br><span class="line">        <span class="attr">include:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;namespace1&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;namespace2&#x27;</span></span><br></pre></td></tr></table></figure>



<p>又或者要排除掉某些命令空间下的 Pods，则可以使用 <code>exclude</code> 参数配置，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;PodLifeTime&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">podLifeTime:</span></span><br><span class="line">        <span class="attr">maxPodLifeTimeSeconds:</span> <span class="number">86400</span></span><br><span class="line">      <span class="attr">namespaces:</span></span><br><span class="line">        <span class="attr">exclude:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;namespace1&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;namespace2&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="优先级过滤"><a href="#优先级过滤" class="headerlink" title="优先级过滤"></a>优先级过滤</h3><p>所有策略都可以配置优先级阈值，只有在该阈值以下的 Pod 才会被驱逐，我们可以通过设置 <code>thresholdPriorityClassName</code>（将阈值设置为指定优先级类别的值）或 <code>thresholdPriority</code>（直接设置阈值）参数来指定该阈值。默认情况下，该阈值设置为 <code>system-cluster-critical</code> 这个 PriorityClass 类的值。</p>
<p>比如使用 <code>thresholdPriority</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;PodLifeTime&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">podLifeTime:</span></span><br><span class="line">        <span class="attr">maxPodLifeTimeSeconds:</span> <span class="number">86400</span></span><br><span class="line">      <span class="attr">thresholdPriority:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>



<p>或者使用 <code>thresholdPriorityClassName</code> 进行过滤：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">&#x27;descheduler/v1alpha1&#x27;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">&#x27;DeschedulerPolicy&#x27;</span></span><br><span class="line"><span class="attr">strategies:</span></span><br><span class="line">  <span class="attr">&#x27;PodLifeTime&#x27;:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">podLifeTime:</span></span><br><span class="line">        <span class="attr">maxPodLifeTimeSeconds:</span> <span class="number">86400</span></span><br><span class="line">      <span class="attr">thresholdPriorityClassName:</span> <span class="string">&#x27;priorityclass1&#x27;</span></span><br></pre></td></tr></table></figure>



<p>不过需要注意不能同时配置 <code>thresholdPriority</code> 和 <code>thresholdPriorityClassName</code>，如果指定的优先级类不存在，则 descheduler 不会创建它，并且会引发错误。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>当使用 descheduler 驱除 Pods 的时候，需要注意以下几点：</p>
<ul>
<li>关键性 Pod 不会被驱逐，比如 <code>priorityClassName</code> 设置为 <code>system-cluster-critical</code> 或 <code>system-node-critical</code> 的 Pod</li>
<li>不属于 RS、Deployment 或 Job 管理的 Pods 不会被驱逐</li>
<li>DaemonSet 创建的 Pods 不会被驱逐</li>
<li>使用 <code>LocalStorage</code> 的 Pod 不会被驱逐，除非设置 <code>evictLocalStoragePods: true</code></li>
<li>具有 PVC 的 Pods 不会被驱逐，除非设置 <code>ignorePvcPods: true</code></li>
<li>在 <code>LowNodeUtilization</code> 和 <code>RemovePodsViolatingInterPodAntiAffinity</code> 策略下，Pods 按优先级从低到高进行驱逐，如果优先级相同，<code>Besteffort</code> 类型的 Pod 要先于 <code>Burstable</code> 和 <code>Guaranteed</code> 类型被驱逐</li>
<li><code>annotations</code> 中带有 <code>descheduler.alpha.kubernetes.io/evict</code> 字段的 Pod 都可以被驱逐，该注释用于覆盖阻止驱逐的检查，用户可以选择驱逐哪个 Pods</li>
<li>如果 Pods 驱逐失败，可以设置 <code>--v=4</code> 从 <code>descheduler</code> 日志中查找原因，如果驱逐违反 PDB 约束，则不会驱逐这类 Pods</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/DevStream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/DevStream/" class="post-title-link" itemprop="url">DevStream</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：20:42:57" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/Devops/" itemprop="url" rel="index"><span itemprop="name">Devops</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DevOps-工具链管理器-DevStream-还真是神器"><a href="#DevOps-工具链管理器-DevStream-还真是神器" class="headerlink" title="DevOps 工具链管理器 DevStream 还真是神器"></a>DevOps 工具链管理器 DevStream 还真是神器</h1><p><a target="_blank" rel="noopener" href="https://github.com/devstream-io/devstream">DevStream</a> 是一个开源的 DevOps 工具链管理器，因开发者而生，由开发者开发，为开发者服务。</p>
<p>想象你正在开始一个新的项目或组建一个新的团队。在写第一行代码之前，你需要一个能够高效运转 SDLC(软件开发生命周期)和承载开发至部署全过程的工具。</p>
<p>通常情况下，你需要以下几个部分来高效地工作。</p>
<ul>
<li>项目管理软件或  <code>issue</code> 追溯工具（JIRA 等）</li>
<li>源代码管理（GitHub、Bitbucket 等）</li>
<li>持续集成（Jenkins、CircleCI、Travis CI 等）</li>
<li>持续交付&#x2F;部署（Flux CD&#x2F;Flux2、Argo CD 等)</li>
<li>密钥和证书的单一事实来源(A single source of truth)（密钥管理器，如 HashiCorp 的 Vault）</li>
<li>集成化的日志和监控工具（例如，ELK、Prometheus&#x2F;Grafana）</li>
<li>……</li>
</ul>
<p>实际的情况可能远不止这些，要找到合适的组件本身就不容易了，再将这些工具整合起来就更难了，需要花费大量的时间和精力。而 <code>DevStream</code> 就是为简化整合 DevOps 组件而构建的工具，有点类似于 <code>yum</code>、<code>apt</code> 这些软件包管理工具，<code>DevStream</code> 就是 DevOps 工具领域的软件包管理器。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>DevOps 中通用的一些概念，比如 Git、Docker、Kubernetes、Continuous Integratoin、Continuous Delivery 和 GitOps，这些也是 DevStream 的核心概念。</p>
<p><code>DevStream</code> 中涉及到几个自己的概念：Config（配置）、Tool（工具）、State（状态）、Resource（资源），这几个概念构成了 <code>DevStream</code> 的整个工作流，下面我们来具体了解下这几个概念。</p>
<h3 id="Config（配置）"><a href="#Config（配置）" class="headerlink" title="Config（配置）"></a>Config（配置）</h3><p><code>DevStream</code> 通过配置文件来定义你的 DevOps 工具链，一共包括 3 个配置文件：</p>
<ul>
<li>main config file（主配置文件）</li>
<li>variable config file（变量配置文件）</li>
<li>tool config file（工具配置文件）</li>
</ul>
<p><strong>主配置文件</strong></p>
<p>默认情况下，dtm（DevStream 的命令行工具）会尝试使用 <code>./config.yaml</code> 作为主配置文件。主配置文件主要包含 3 个部分：</p>
<ul>
<li><code>varFile</code>：var 文件的文件路径</li>
<li><code>toolFile</code>：工具文件的文件路径</li>
<li><code>state</code>：与状态相关的设置</li>
</ul>
<p>如下所示的 <code>config.yaml</code> 文件就是一个主配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.yaml</span></span><br><span class="line"><span class="attr">varFile:</span> <span class="string">variables.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">toolFile:</span> <span class="string">tools.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">state:</span></span><br><span class="line">  <span class="attr">backend:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">stateFile:</span> <span class="string">devstream.state</span></span><br></pre></td></tr></table></figure>

<p><strong>变量配置文件</strong></p>
<p>变量配置文件是一个包含键值对的 YAML 文件，可以在工具配置文件中使用。</p>
<p>如下所示的 <code>variables.yaml</code> 文件就是一个变量配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># variables.yaml</span></span><br><span class="line"><span class="attr">githubUsername:</span> <span class="string">cnych</span></span><br><span class="line"><span class="attr">repoName:</span> <span class="string">dtm-test-go</span></span><br><span class="line"><span class="attr">defaultBranch:</span> <span class="string">main</span></span><br><span class="line"><span class="attr">dockerhubUsername:</span> <span class="string">cnych</span></span><br></pre></td></tr></table></figure>

<p><strong>工具配置文件</strong></p>
<p>工具配置文件包含工具列表。工具文件包含以下内容：</p>
<ul>
<li>目前只有一个配置块，即 <code>tools</code></li>
<li><code>tools</code> 是一个字典列表</li>
<li>每个字典都定义了一个由 <code>DevStream</code> 插件管理的 DevOps <strong>工具</strong></li>
<li>每个字典（工具）都有以下必填字段：<ul>
<li><code>name</code>：工具&#x2F;插件的名称，字符串，不带下划线</li>
<li><code>instanceID</code>：该工具实例的 id</li>
<li>一个配置文件中可以有重复的名称，也可以在一个配置文件中有重复的 <code>instanceID</code>，但是 <code>name + instanceID</code> 的组合在一个配置文件中必须是唯一的</li>
</ul>
</li>
<li>每个工具都有一个可选字段，即 <code>options</code>，它是一个包含该特定插件参数的字典</li>
<li>每个工具都有一个可选字段，即 <code>dependsOn</code>，用来定义相关依赖项</li>
</ul>
<p>如下所示的 <code>tools.yaml</code> 文件就定义了一个工具配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tools.yaml</span></span><br><span class="line"><span class="attr">tools:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">github-repo-scaffolding-golang</span></span><br><span class="line">  <span class="attr">instanceID:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">owner:</span> [[ <span class="string">githubUsername</span> ]]</span><br><span class="line">    <span class="attr">org:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">repo:</span> [[ <span class="string">repoName</span> ]]</span><br><span class="line">    <span class="attr">branch:</span> [[ <span class="string">defaultBranch</span> ]]</span><br><span class="line">    <span class="attr">image_repo:</span> [[ <span class="string">dockerhubUsername</span> ]]<span class="string">/[[</span> <span class="string">repoName</span> <span class="string">]]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jira-github-integ</span></span><br><span class="line">  <span class="attr">instanceID:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">dependsOn:</span> [ <span class="string">&quot;github-repo-scaffolding-golang.default&quot;</span> ]</span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">owner:</span> [[ <span class="string">githubUsername</span> ]]</span><br><span class="line">    <span class="attr">repo:</span> [[ <span class="string">repoName</span> ]]</span><br><span class="line">    <span class="attr">jiraBaseUrl:</span> <span class="string">https://xxx.atlassian.net</span></span><br><span class="line">    <span class="attr">jiraUserEmail:</span> <span class="string">foo@bar.com</span></span><br><span class="line">    <span class="attr">jiraProjectKey:</span> <span class="string">zzz</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>配置文件中的变量可以看到我们是通过 <code>[[ varNameHere ]]</code> 来定义的。<code>DevStream</code> 将使用提供的 var 文件来渲染上面的配置。</p>
<p><strong>state</strong></p>
<p>主配置文件中还包括一个 <code>state</code> 属性，<code>state</code> 部分指定存储 <code>DevStream</code> 状态的位置。到目前的 v0.6.0 版本开始，<code>DevStream</code> 同时支持 <code>local</code> 和 <code>s3</code> 后端存储来保存 <code>DevStream</code> 的状态。</p>
<p>如果使用的是 <code>local</code> 模式，那么 <code>state.options.stateFile</code> 是必须配置的属性。如果使用 <code>s3</code> 这种后端存储模式，则对应的配置如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">varFile:</span> <span class="string">variables.yaml</span></span><br><span class="line"><span class="attr">toolFile:</span> <span class="string">tools.yaml</span></span><br><span class="line"><span class="attr">state:</span></span><br><span class="line">  <span class="attr">backend:</span> <span class="string">s3</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">bucket:</span> <span class="string">devstream-remote-state</span></span><br><span class="line">    <span class="attr">region:</span> <span class="string">ap-southeast-1</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">devstream.state</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>state.options</code> 属性下的 <code>bucket</code>、<code>region</code> 和 <code>key</code> 都是 <code>s3</code> 后端的必填字段。在真正使用的时候我们需要通过环境变量来配置 AWS 的相关密钥信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export AWS_ACCESS_KEY_ID=ID_HERE</span><br><span class="line">export AWS_SECRET_ACCESS_KEY=SECRET_HERE</span><br><span class="line">export AWS_DEFAULT_REGION=REGION_HERE</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：同样我们也可以将多个 YAML 文件放在同一个文件中，并用三个破折号 (—) 分隔不同的文件。</p>
</blockquote>
<h3 id="Tool（工具）"><a href="#Tool（工具）" class="headerlink" title="Tool（工具）"></a>Tool（工具）</h3><ul>
<li>每个工具对应着一个插件，可以用来安装、配置或集成一些 DevOps 工具。</li>
<li>每个工具都有其名称、InstanceID 和选项。</li>
<li>每个工具都可以有其依赖项，这些依赖项由 <code>dependsOn</code> 字段指定。</li>
</ul>
<p><code>dependsOn</code> 是一个字符串数组，每个元素都是一个依赖。每个依赖项都以 <code>TOOL_NAME.INSTANCE_ID</code> 的格式命名。</p>
<h3 id="State（状态）"><a href="#State（状态）" class="headerlink" title="State（状态）"></a>State（状态）</h3><p>State 记录了您的 DevOps 工具链的当前状态，它包含每个工具的配置和当前状态。</p>
<ul>
<li>状态是一个 Map</li>
<li>Map 中的每个状态都是一个包含名称、插件、选项和资源的结构</li>
</ul>
<h3 id="Resource（资源）"><a href="#Resource（资源）" class="headerlink" title="Resource（资源）"></a>Resource（资源）</h3><p>我们将创建的插件称为资源，插件的 <code>Read()</code> 接口将返回对该资源的描述，该描述又存储为状态的一部分。</p>
<p><code>DevStream</code> 的整个工作流如下图所示：<img data-src="https://mudutestmenu.mudu.tv/upload/ooss8o.jpg" alt="img"></p>
<ul>
<li>首先获取工具状态</li>
<li>如果状态中没找到工具，则调用 <code>Create()</code> 接口创建</li>
<li>如果状态中找到了工具，则从状态中进行配置对比，如果有变化，则调用 <code>Update()</code> 接口进行更新</li>
<li>如果没有变化则调用 <code>Read()</code> 接口从资源中获取描述信息</li>
<li>如果没有对应的资源，则调用 <code>Create()</code> 接口创建资源</li>
<li>如果有对应的资源，则从状态中进行资源对比，如果有变化，同样调用 <code>Update()</code> 接口更新</li>
<li>如果没任何变化则忽略</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>DevStream</code> 的命令行工具叫 <code>dtm</code>，我们只需要下载该文件即可，前往 Release 页面 <a target="_blank" rel="noopener" href="https://github.com/devstream-io/devstream/releases">https://github.com/devstream-io/devstream/releases</a> 打开最新的版本，下载对应平台的安装包（目前只支持 Linux 和 MacOS 系统）。</p>
<p>比如我这里是 Mac m1 平台，则下载 <a target="_blank" rel="noopener" href="https://devstream.gateway.scarf.sh/releases/v0.7.0/dtm-darwin-arm64">https://devstream.gateway.scarf.sh/releases/v0.7.0/dtm-darwin-arm64</a> 这个安装包，</p>
<p>标记 dtm 为可执行文件，然后将其移动到 PATH 路径下面去：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv dtm-darwin-arm64 dtm</span><br><span class="line">chmod +x dtm</span><br><span class="line">sudo mv dtm /usr/local/bin</span><br></pre></td></tr></table></figure>

<p>现在我们可以通过执行 dtm 命令来验证是否安装成功。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/mjl37o.png" alt="img"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>安装完成后我们就可以使用 <code>dtm</code> 工具了，直接执行 <code>dtm</code> 命令会显示目前所有的可用命令。</p>
<p>比如使用 <code>dtm list plugins</code> 命令可以查看目前 <code>DevStream</code> 支持的插件列表。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dtm list plugins</span></span><br><span class="line">argocd</span><br><span class="line">argocdapp</span><br><span class="line">devlake</span><br><span class="line">github-repo-scaffolding-golang</span><br><span class="line">githubactions-golang</span><br><span class="line">githubactions-nodejs</span><br><span class="line">githubactions-python</span><br><span class="line">gitlab-ce-docker</span><br><span class="line">gitlab-repo-scaffolding-golang</span><br><span class="line">gitlabci-generic</span><br><span class="line">gitlabci-golang</span><br><span class="line">hashicorp-vault</span><br><span class="line">helm-generic</span><br><span class="line">jenkins</span><br><span class="line">jira-github-integ</span><br><span class="line">kube-prometheus</span><br><span class="line">openldap</span><br><span class="line">tekton</span><br><span class="line">trello</span><br><span class="line">trello-github-integ</span><br></pre></td></tr></table></figure>

<p>使用 <code>dtm show config</code> 命令可以显示默认的配置信息，其实就是 3 个主要配置文件的配置样例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dtm show config</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">defaultconfig.yaml sample:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">var file path, you can <span class="built_in">set</span> it to absolute path or relative path.</span></span><br><span class="line">varFile: variables.yaml # here is a relative path. (defaults is ./variables.yaml)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tool file path, you can <span class="built_in">set</span> it to absolute path or relative path.</span></span><br><span class="line">toolFile: tools.yaml # here is a relative path.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">state config</span></span><br><span class="line">state:</span><br><span class="line">  backend: local # backend can be local or s3</span><br><span class="line">  options:</span><br><span class="line">    stateFile: devstream.state</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tools.yaml sample:</span></span><br><span class="line">tools:</span><br><span class="line">  - name: github-repo-scaffolding-golang</span><br><span class="line">    instanceID: default</span><br><span class="line">    options:</span><br><span class="line">      owner: [ [ githubUsername ] ]</span><br><span class="line">      org: &quot;&quot;</span><br><span class="line">      repo: [ [ repoName ] ]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">variables.yaml sample:</span></span><br><span class="line">githubUsername: daniel-hutao</span><br><span class="line">repo: go-webapp-demo</span><br></pre></td></tr></table></figure>

<p>此外我们还可以在 <code>show config</code> 命令后面添加一个 <code>--plugin</code> 参数，来显示指定插件的配置信息，比如我们查看 argocd 的配置，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dtm show config --plugin argocd</span></span><br><span class="line">tools:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">name of the tool</span></span><br><span class="line">  - name: argocd</span><br><span class="line">    # id of the tool instance</span><br><span class="line">    instanceID: default</span><br><span class="line">    # format: name.instanceID; If specified, dtm will make sure the dependency is applied first before handling this tool.</span><br><span class="line">    dependsOn: [ ]</span><br><span class="line">    # options for the plugin</span><br><span class="line">    options:</span><br><span class="line">      # need to create the namespace or not, default: false</span><br><span class="line">      create_namespace: true</span><br><span class="line">      repo:</span><br><span class="line">        # name of the Helm repo</span><br><span class="line">        name: argo</span><br><span class="line">        # url of the Helm repo</span><br><span class="line">        url: https://argoproj.github.io/argo-helm</span><br><span class="line">      # Helm chart information</span><br><span class="line">      chart:</span><br><span class="line">        # name of the chart</span><br><span class="line">        chart_name: argo/argo-cd</span><br><span class="line">        # release name of the chart</span><br><span class="line">        release_name: argocd</span><br><span class="line">        # k8s namespace where ArgoCD will be installed</span><br><span class="line">        namespace: argocd</span><br><span class="line">        # whether to wait for the release to be deployed or not</span><br><span class="line">        wait: true</span><br><span class="line">        # the time to wait for any individual Kubernetes operation (like Jobs for hooks). This defaults to 5m0s</span><br><span class="line">        timeout: 5m</span><br><span class="line">        # whether to perform a CRD upgrade during installation</span><br><span class="line">        upgradeCRDs: true</span><br><span class="line">        # custom configuration (Optional). You can refer to [ArgoCD values.yaml](https://github.com/argoproj/argo-helm/blob/master/charts/argo-cd/values.yaml)</span><br><span class="line">        values_yaml: |</span><br><span class="line">          controller:</span><br><span class="line">            service:</span><br><span class="line">              port: 8080</span><br></pre></td></tr></table></figure>

<p>如果我们想要开发自己的插件，可以使用 <code>dtm develop</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dtm develop</span></span><br><span class="line">Develop is used for develop a new plugin</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  dtm develop [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  create-plugin   Create a new plugin</span><br><span class="line">  validate-plugin Validate a plugin</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help   help for develop</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">      --debug   debug level log</span><br><span class="line"></span><br><span class="line">Use &quot;dtm develop [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure>

<p>其中包含 <code>create-plugin</code> 和 <code>validate-plugin</code> 两个子命令，一个用于创建一个新的插件，一个用于校验插件使用，比如创建一个名为 <code>plugin-demo</code> 的插件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dtm develop create-plugin</span></span><br><span class="line">2022-07-02 12:10:29 ✖ [FATAL]  the name must be not &quot;&quot;, you can specify it by --name flag</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dtm develop create-plugin --name plugin-demo</span></span><br><span class="line">2022-07-02 12:10:45 ℹ [INFO]  Render template files finished.</span><br><span class="line">2022-07-02 12:10:45 ℹ [INFO]  Persist all files finished.</span><br><span class="line"></span><br><span class="line">The DevStream PMC (project management committee) sincerely thank you for your devotion and enthusiasm in creating new plugins!</span><br><span class="line"></span><br><span class="line">To make the process easy as a breeze, DevStream(dtm) has generated some templated source code files for you to flatten the learning curve and reduce manual copy-paste.</span><br><span class="line">In the generated templates, dtm has left some special marks in the format of &quot;TODO(dtm)&quot;.</span><br><span class="line">Please look for these TODOs by global search. Once you find them, you will know what to do with them. Also, please remember to check our documentation on creating a new plugin:</span><br><span class="line"></span><br><span class="line">**README_when_create_plugin.md**</span><br><span class="line"></span><br><span class="line">Source code files created.</span><br><span class="line"></span><br><span class="line">Happy hacking, buddy!</span><br><span class="line">Please give us feedback through GitHub issues if you encounter any difficulties. We guarantee that you will receive unrivaled help from our passionate community!</span><br></pre></td></tr></table></figure>

<p>上面的命令会创建一个插件开发的脚手架，结构如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree .</span></span><br><span class="line">.</span><br><span class="line">├── README_when_create_plugin.md</span><br><span class="line">├── cmd</span><br><span class="line">│   └── plugin</span><br><span class="line">│       └── plugin-demo</span><br><span class="line">│           └── main.go</span><br><span class="line">├── docs</span><br><span class="line">│   └── plugins</span><br><span class="line">│       └── plugin-demo.md</span><br><span class="line">└── internal</span><br><span class="line">    └── pkg</span><br><span class="line">        ├── plugin</span><br><span class="line">        │   └── plugindemo</span><br><span class="line">        │       ├── create.go</span><br><span class="line">        │       ├── delete.go</span><br><span class="line">        │       ├── options.go</span><br><span class="line">        │       ├── plugindemo.go</span><br><span class="line">        │       ├── read.go</span><br><span class="line">        │       ├── update.go</span><br><span class="line">        │       └── validate.go</span><br><span class="line">        └── show</span><br><span class="line">            └── config</span><br><span class="line">                └── plugins</span><br><span class="line">                    └── plugin-demo.yaml</span><br><span class="line"></span><br><span class="line">12 directories, 11 files</span><br></pre></td></tr></table></figure>

<p>然后可以根据我们自己的实际需求去开发对应的插件即可，开发完成后可以校验插件的有效性。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dtm develop validate-plugin --name plugin-demo</span></span><br><span class="line">2022-07-02 12:13:05 ✔ [SUCCESS]  Plugin &lt;plugin-demo&gt; passed validation.</span><br></pre></td></tr></table></figure>

<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>接下来我们使用 <code>DevStream</code> 来实践下如何快速创建我们的 DevOps 工具链。</p>
<p>首先创建一个名为 <code>devstream-demo</code> 的目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir devstream-demo &amp;&amp; cd devstream-demo</span><br></pre></td></tr></table></figure>

<p>然后在该目录下创建一个名为 <code>config.yaml</code> 的主配置文件，文件内容如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.yaml</span></span><br><span class="line"><span class="attr">varFile:</span> <span class="string">variables-gitops.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">toolFile:</span> <span class="string">tools-gitops.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">state:</span></span><br><span class="line">  <span class="attr">backend:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">stateFile:</span> <span class="string">devstream.state</span></span><br></pre></td></tr></table></figure>

<p>在该主配置文件中我们指定了 <code>varFile</code> 和 <code>toolFile</code> 两个配置文件，已经使用了本地存储状态信息。</p>
<p>同样在该目录下面创建对应的变量配置文件 <code>variables-gitops.yaml</code>，内容如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># variables-gitops.yaml</span></span><br><span class="line"><span class="attr">githubUsername:</span> <span class="string">cnych</span></span><br><span class="line"><span class="attr">repoName:</span> <span class="string">dtm-test-go</span></span><br><span class="line"><span class="attr">defaultBranch:</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dockerhubUsername:</span> <span class="string">cnych</span></span><br><span class="line"></span><br><span class="line"><span class="attr">argocdNamespace:</span> <span class="string">argocd</span></span><br><span class="line"><span class="attr">argocdDeployTimeout:</span> <span class="string">5m</span></span><br></pre></td></tr></table></figure>

<p>该配置文件中我们定义了一些后面工具中需要使用到的变量。</p>
<p>接下来创建工具配置文件 <code>tools-gitops.yaml</code>，文件内容如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tools-gitops.yaml</span></span><br><span class="line"><span class="attr">tools:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">github-repo-scaffolding-golang</span></span><br><span class="line">  <span class="attr">instanceID:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">owner:</span> [[ <span class="string">githubUsername</span> ]]</span><br><span class="line">    <span class="attr">org:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">repo:</span> [[ <span class="string">repoName</span> ]]</span><br><span class="line">    <span class="attr">branch:</span> [[ <span class="string">defaultBranch</span> ]]</span><br><span class="line">    <span class="attr">image_repo:</span> [[ <span class="string">dockerhubUsername</span> ]]<span class="string">/[[</span> <span class="string">repoName</span> <span class="string">]]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">githubactions-golang</span></span><br><span class="line">  <span class="attr">instanceID:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">dependsOn:</span> [<span class="string">&quot;github-repo-scaffolding-golang.default&quot;</span>]</span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="string">$&#123;&#123;</span> <span class="string">github-repo-scaffolding-golang.default.outputs.owner</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">org:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">$&#123;&#123;</span> <span class="string">github-repo-scaffolding-golang.default.outputs.repo</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">language:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">go</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">&quot;1.17&quot;</span></span><br><span class="line">    <span class="attr">branch:</span> [[ <span class="string">defaultBranch</span> ]]</span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">True</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">&quot;go build ./...&quot;</span></span><br><span class="line">    <span class="attr">test:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">True</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">&quot;go test ./...&quot;</span></span><br><span class="line">      <span class="attr">coverage:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">True</span></span><br><span class="line">        <span class="attr">profile:</span> <span class="string">&quot;-race -covermode=atomic&quot;</span></span><br><span class="line">        <span class="attr">output:</span> <span class="string">&quot;coverage.out&quot;</span></span><br><span class="line">    <span class="attr">docker:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">True</span></span><br><span class="line">      <span class="attr">registry:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">dockerhub</span></span><br><span class="line">        <span class="attr">username:</span> [[ <span class="string">dockerhubUsername</span> ]]</span><br><span class="line">        <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">github-repo-scaffolding-golang.default.outputs.repo</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">argocd</span></span><br><span class="line">  <span class="attr">instanceID:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">create_namespace:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">argo</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://argoproj.github.io/argo-helm</span></span><br><span class="line">    <span class="attr">chart:</span></span><br><span class="line">      <span class="attr">chart_name:</span> <span class="string">argo/argo-cd</span></span><br><span class="line">      <span class="attr">release_name:</span> <span class="string">argocd</span></span><br><span class="line">      <span class="attr">namespace:</span> [[ <span class="string">argocdNamespace</span> ]]</span><br><span class="line">      <span class="attr">wait:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">timeout:</span> [[ <span class="string">argocdDeployTimeout</span> ]]</span><br><span class="line">      <span class="attr">upgradeCRDs:</span> <span class="literal">true</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">argocdapp</span></span><br><span class="line">  <span class="attr">instanceID:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">dependsOn:</span> [<span class="string">&quot;argocd.default&quot;</span>, <span class="string">&quot;github-repo-scaffolding-golang.default&quot;</span>]</span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">app:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github-repo-scaffolding-golang.default.outputs.repo</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">namespace:</span> [[ <span class="string">argocdNamespace</span> ]]</span><br><span class="line">    <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="string">https://kubernetes.default.svc</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">source:</span></span><br><span class="line">      <span class="attr">valuefile:</span> <span class="string">values.yaml</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">helm/$&#123;&#123;</span> <span class="string">github-repo-scaffolding-golang.default.outputs.repo</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">repoURL:</span> <span class="string">$&#123;&#123;</span> <span class="string">github-repo-scaffolding-golang.default.outputs.repoURL</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面的配置文件中我们定义了 4 个工具，每个工具的 <code>name+instanceID</code> 需要唯一。</p>
<p>其中第一个工具为 <a target="_blank" rel="noopener" href="https://docs.devstream.io/en/latest/plugins/github-repo-scaffolding-golang/">github-repo-scaffolding-golang</a> ，该插件使用一个 Golang Web 应用程序的脚手架代码去创建一个 GitHub 代码仓库，使用该插件之前需要配置一个名为 <code>GITHUB_TOKEN</code> 的环境变量，可以前往 <a target="_blank" rel="noopener" href="https://github.com/settings/tokens">https://github.com/settings/tokens</a> 创建一个 <code>Personal access tokens</code>，记得要有 repo 和 GitHub Actions 相关权限。</p>
<p>第二个工具插件为 <a target="_blank" rel="noopener" href="https://docs.devstream.io/en/latest/plugins/githubactions-golang/">githubactions-golang</a> ，这个插件会创建一些 Golang GitHub Actions 的工作流，同样该插件依赖 <code>GITHUB_TOKEN</code> 这个环境变量，如果启用了 Docker 镜像构建&#x2F;推送，则还需要设置另外两个环境变量：<code>DOCKERHUB_USERNAME</code> 与 <code>DOCKERHUB_TOKEN</code>，Docker 的 Token 信息可以访问页面 <a target="_blank" rel="noopener" href="https://hub.docker.com/settings/security?generateToken=true">https://hub.docker.com/settings/security?generateToken=true</a> 去创建获取。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/zswhg3.png" alt="img"></p>
<p>第三个插件是 <a target="_blank" rel="noopener" href="https://docs.devstream.io/en/latest/plugins/argocd/">argocd</a> ，该插件会使用 Helm chart 的方式在现有 Kubernetes 集群中安装 ArgoCD。</p>
<p>第四个插件是 <a target="_blank" rel="noopener" href="https://docs.devstream.io/en/latest/plugins/argocdapp/">argocdapp</a> ，此插件会创建一个 ArgoCD Application 的自定义资源。需要注意使用该插件之前必须要保证 ArgoCD 已经安装。</p>
<p>配置定义完之后，我们只需要在根目录下面执行 <code>dtm init</code>，该命令就会下载所有定义的相关插件，如果你使用的是 <code>s3</code> 来存储状态信息，则当再次执行该命令的时候会先从远程下载对应的状态信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dtm init</span></span><br><span class="line">2022-07-02 12:36:03 ℹ [INFO]  Got Backend from config: local</span><br><span class="line">2022-07-02 12:36:03 ℹ [INFO]  Using dir &lt;.devstream&gt; to store plugins.</span><br><span class="line">2022-07-02 12:36:05 ℹ [INFO]  Downloading: [github-repo-scaffolding-golang-darwin-arm64_0.7.0.so] ...</span><br><span class="line"> 15.05 MiB / 15.05 MiB [=================================] 100.00% 3.30 MiB/s 4s</span><br><span class="line">2022-07-02 12:36:10 ✔ [SUCCESS]  [github-repo-scaffolding-golang-darwin-arm64_0.7.0.so] download succeeded.</span><br><span class="line">2022-07-02 12:36:11 ℹ [INFO]  Downloading: [github-repo-scaffolding-golang-darwin-arm64_0.7.0.md5] ...</span><br><span class="line"> 33 B / 33 B [===============================================] 100.00% 49 B/s 0s</span><br><span class="line">2022-07-02 12:36:11 ✔ [SUCCESS]  [github-repo-scaffolding-golang-darwin-arm64_0.7.0.md5] download succeeded.</span><br><span class="line">2022-07-02 12:36:11 ℹ [INFO]  Plugin: github-repo-scaffolding-golang-darwin-arm64_0.7.0.so doesn&#x27;t match with .md5 and will be downloaded.</span><br><span class="line">2022-07-02 12:36:12 ℹ [INFO]  Downloading: [github-repo-scaffolding-golang-darwin-arm64_0.7.0.so] ...</span><br><span class="line"> 15.05 MiB / 15.05 MiB [=================================] 100.00% 4.71 MiB/s 3s</span><br><span class="line">2022-07-02 12:36:15 ✔ [SUCCESS]  [github-repo-scaffolding-golang-darwin-arm64_0.7.0.so] download succeeded.</span><br><span class="line">2022-07-02 12:36:15 ℹ [INFO]  Downloading: [github-repo-scaffolding-golang-darwin-arm64_0.7.0.md5] ...</span><br><span class="line"> 33 B / 33 B [=========================================] 100.00% 133.44 KiB/s 0s</span><br><span class="line">2022-07-02 12:36:15 ✔ [SUCCESS]  [github-repo-scaffolding-golang-darwin-arm64_0.7.0.md5] download succeeded.</span><br><span class="line">2022-07-02 12:36:16 ℹ [INFO]  Downloading: [githubactions-golang-darwin-arm64_0.7.0.so] ...</span><br><span class="line"> 17.49 MiB / 17.49 MiB [=================================] 100.00% 4.05 MiB/s 4s</span><br><span class="line">2022-07-02 12:36:20 ✔ [SUCCESS]  [githubactions-golang-darwin-arm64_0.7.0.so] download succeeded.</span><br><span class="line">2022-07-02 12:36:21 ℹ [INFO]  Downloading: [githubactions-golang-darwin-arm64_0.7.0.md5] ...</span><br><span class="line"> 33 B / 33 B [=========================================] 100.00% 206.08 KiB/s 0s</span><br><span class="line">2022-07-02 12:36:21 ✔ [SUCCESS]  [githubactions-golang-darwin-arm64_0.7.0.md5] download succeeded.</span><br><span class="line">2022-07-02 12:36:21 ℹ [INFO]  Plugin: githubactions-golang-darwin-arm64_0.7.0.so doesn&#x27;t match with .md5 and will be downloaded.</span><br><span class="line">2022-07-02 12:36:22 ℹ [INFO]  Downloading: [githubactions-golang-darwin-arm64_0.7.0.so] ...</span><br><span class="line"> 17.49 MiB / 17.49 MiB [=================================] 100.00% 4.50 MiB/s 3s</span><br><span class="line">2022-07-02 12:36:25 ✔ [SUCCESS]  [githubactions-golang-darwin-arm64_0.7.0.so] download succeeded.</span><br><span class="line">2022-07-02 12:36:26 ℹ [INFO]  Downloading: [githubactions-golang-darwin-arm64_0.7.0.md5] ...</span><br><span class="line"> 33 B / 33 B [=========================================] 100.00% 104.90 KiB/s 0s</span><br><span class="line">2022-07-02 12:36:26 ✔ [SUCCESS]  [githubactions-golang-darwin-arm64_0.7.0.md5] download succeeded.</span><br><span class="line">2022-07-02 12:36:27 ℹ [INFO]  Downloading: [argocd-darwin-arm64_0.7.0.so] ...</span><br><span class="line"> 78.22 MiB / 78.22 MiB [================================] 100.00% 1.99 MiB/s 39s</span><br><span class="line">2022-07-02 12:37:06 ✔ [SUCCESS]  [argocd-darwin-arm64_0.7.0.so] download succeeded.</span><br><span class="line">2022-07-02 12:37:07 ℹ [INFO]  Downloading: [argocd-darwin-arm64_0.7.0.md5] ...</span><br><span class="line"> 33 B / 33 B [=========================================] 100.00% 186.01 KiB/s 0s</span><br><span class="line">2022-07-02 12:37:07 ✔ [SUCCESS]  [argocd-darwin-arm64_0.7.0.md5] download succeeded.</span><br><span class="line">2022-07-02 12:37:07 ℹ [INFO]  Plugin: argocd-darwin-arm64_0.7.0.so doesn&#x27;t match with .md5 and will be downloaded.</span><br><span class="line">2022-07-02 12:37:08 ℹ [INFO]  Downloading: [argocd-darwin-arm64_0.7.0.so] ...</span><br><span class="line"> 78.22 MiB / 78.22 MiB [================================] 100.00% 2.53 MiB/s 30s</span><br><span class="line">2022-07-02 12:37:39 ✔ [SUCCESS]  [argocd-darwin-arm64_0.7.0.so] download succeeded.</span><br><span class="line">2022-07-02 12:37:40 ℹ [INFO]  Downloading: [argocd-darwin-arm64_0.7.0.md5] ...</span><br><span class="line"> 33 B / 33 B [=========================================] 100.00% 136.46 KiB/s 0s</span><br><span class="line">2022-07-02 12:37:40 ✔ [SUCCESS]  [argocd-darwin-arm64_0.7.0.md5] download succeeded.</span><br><span class="line">2022-07-02 12:37:41 ℹ [INFO]  Downloading: [argocdapp-darwin-arm64_0.7.0.so] ...</span><br><span class="line"> 68.19 MiB / 68.19 MiB [================================] 100.00% 2.41 MiB/s 28s</span><br><span class="line">2022-07-02 12:38:09 ✔ [SUCCESS]  [argocdapp-darwin-arm64_0.7.0.so] download succeeded.</span><br><span class="line">2022-07-02 12:38:10 ℹ [INFO]  Downloading: [argocdapp-darwin-arm64_0.7.0.md5] ...</span><br><span class="line"> 33 B / 33 B [=========================================] 100.00% 256.96 KiB/s 0s</span><br><span class="line">2022-07-02 12:38:10 ✔ [SUCCESS]  [argocdapp-darwin-arm64_0.7.0.md5] download succeeded.</span><br><span class="line">2022-07-02 12:38:10 ℹ [INFO]  Plugin: argocdapp-darwin-arm64_0.7.0.so doesn&#x27;t match with .md5 and will be downloaded.</span><br><span class="line">2022-07-02 12:38:10 ℹ [INFO]  Downloading: [argocdapp-darwin-arm64_0.7.0.so] ...</span><br><span class="line"> 68.19 MiB / 68.19 MiB [================================] 100.00% 1.39 MiB/s 48s</span><br><span class="line">2022-07-02 12:38:59 ✔ [SUCCESS]  [argocdapp-darwin-arm64_0.7.0.so] download succeeded.</span><br><span class="line">2022-07-02 12:39:01 ℹ [INFO]  Downloading: [argocdapp-darwin-arm64_0.7.0.md5] ...</span><br><span class="line"> 33 B / 33 B [=========================================] 100.00% 120.98 KiB/s 0s</span><br><span class="line">2022-07-02 12:39:01 ✔ [SUCCESS]  [argocdapp-darwin-arm64_0.7.0.md5] download succeeded.</span><br><span class="line">2022-07-02 12:39:01 ✔ [SUCCESS]  Initialize finished.</span><br></pre></td></tr></table></figure>

<p>当我们再次执行 <code>dtm init</code> 命令的时候可以看到没有任何相关操作，这是因为前面我们已经将相关的插件全部下载到了本地。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dtm init</span></span><br><span class="line">2022-07-02 12:39:42 ℹ [INFO]  Got Backend from config: local</span><br><span class="line">2022-07-02 12:39:42 ℹ [INFO]  Using dir &lt;.devstream&gt; to store plugins.</span><br><span class="line">2022-07-02 12:39:42 ℹ [INFO]  Plugin: github-repo-scaffolding-golang-darwin-arm64_0.7.0.so already exists, no need to download.</span><br><span class="line">2022-07-02 12:39:42 ℹ [INFO]  Plugin: githubactions-golang-darwin-arm64_0.7.0.so already exists, no need to download.</span><br><span class="line">2022-07-02 12:39:43 ℹ [INFO]  Plugin: argocd-darwin-arm64_0.7.0.so already exists, no need to download.</span><br><span class="line">2022-07-02 12:39:43 ℹ [INFO]  Plugin: argocdapp-darwin-arm64_0.7.0.so already exists, no need to download.</span><br><span class="line">2022-07-02 12:39:43 ✔ [SUCCESS]  Initialize finished.</span><br></pre></td></tr></table></figure>

<p>初始化完成后会在当前目录下面创建一个 <code>.devstream</code> 的目录，该目录下面就是保存下载下来的插件相关文件。</p>
<p>接下来我们只需要在根目录下面执行 <code>dtm apply</code> 命令即可根据我们的配置文件创建或更新 DevOps 工具链了。</p>
<p>首先要记得配置需要的环境变量，比如我们这里上面的定义几个插件需要配置下面的 3 个环境变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GITHUB_TOKEN=xxx</span><br><span class="line">export DOCKERHUB_USERNAME=cnych</span><br><span class="line">export DOCKERHUB_TOKEN=xxx</span><br></pre></td></tr></table></figure>

<p>另外还需要一个在本地可访问的 Kubernetes 集群。</p>
<p>配置完成后直接执行 <code>dtm apply</code> 命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dtm apply</span></span><br><span class="line">2022-07-02 13:17:15 ℹ [INFO]  Apply started.</span><br><span class="line">2022-07-02 13:17:15 ℹ [INFO]  Got Backend from config: local</span><br><span class="line">2022-07-02 13:17:15 ℹ [INFO]  Using dir &lt;.devstream&gt; to store plugins.</span><br><span class="line">2022-07-02 13:17:15 ℹ [INFO]  Using local backend. State file: devstream.state.</span><br><span class="line">2022-07-02 13:17:17 ℹ [INFO]  Tool (argocd/default) found in config but doesn&#x27;t exist in the state, will be created.</span><br><span class="line">2022-07-02 13:17:17 ℹ [INFO]  Tool (argocdapp/default) found in config but doesn&#x27;t exist in the state, will be created.</span><br><span class="line">Continue? [y/n]</span><br><span class="line">Enter a value (Default is n): y</span><br><span class="line"></span><br><span class="line">2022-07-02 12:54:38 ℹ [INFO]  Start executing the plan.</span><br><span class="line">2022-07-02 12:54:38 ℹ [INFO]  Changes count: 4.</span><br><span class="line">2022-07-02 12:54:38 ℹ [INFO]  -------------------- [  Processing progress: 1/4.  ] --------------------</span><br><span class="line">2022-07-02 12:54:38 ℹ [INFO]  Processing: (github-repo-scaffolding-golang/default) -&gt; Create ...</span><br><span class="line">2022-07-02 12:54:43 ℹ [INFO]  The repo dtm-test-go has been created.</span><br><span class="line">2022-07-02 12:54:55 ✔ [SUCCESS]  Tool (github-repo-scaffolding-golang/default) Create done.</span><br><span class="line">2022-07-02 12:54:55 ℹ [INFO]  -------------------- [  Processing progress: 3/4.  ] -</span><br><span class="line">2022-07-02 13:17:19 ℹ [INFO]  Processing: (argocd/default) -&gt; Create ...</span><br><span class="line">2022-07-02 13:17:28 ℹ [INFO]  Creating or updating helm chart ...</span><br><span class="line">2022/07/02 13:17:33 creating 1 resource(s)</span><br><span class="line">2022/07/02 13:17:33 creating 1 resource(s)</span><br><span class="line">2022/07/02 13:17:33 creating 1 resource(s)</span><br><span class="line">2022/07/02 13:17:33 creating 1 resource(s)</span><br><span class="line">2022/07/02 13:17:33 Clearing discovery cache</span><br><span class="line">2022/07/02 13:17:33 beginning wait for 4 resources with timeout of 1m0s</span><br><span class="line">2022/07/02 13:17:39 creating 43 resource(s)</span><br><span class="line">2022/07/02 13:17:39 beginning wait for 43 resources with timeout of 5m0s</span><br><span class="line">2022/07/02 13:17:40 Deployment is not ready: argocd/argocd-applicationset-controller. 0 out of 1 expected pods are ready</span><br><span class="line">2022/07/02 13:17:42 Deployment is not ready: argocd/argocd-applicationset-controller. 0 out of 1 expected pods are ready</span><br><span class="line">......</span><br><span class="line">2022/07/02 13:19:44 Deployment is not ready: argocd/argocd-applicationset-controller. 0 out of 1 expected pods are ready</span><br><span class="line">2022/07/02 13:38:27 Deployment is not ready: argocd/argocd-dex-server. 0 out of 1 expected pods are ready</span><br><span class="line">2022/07/02 13:38:30 release installed successfully: argocd/argo-cd-4.9.11</span><br><span class="line">2022-07-02 13:38:30 ✔ [SUCCESS]  Tool (argocd/default) Create done.</span><br><span class="line">2022-07-02 13:38:30 ℹ [INFO]  -------------------- [  Processing progress: 4/4.  ] --------------------</span><br><span class="line">2022-07-02 13:38:30 ℹ [INFO]  Processing: (argocdapp/default) -&gt; Create ...</span><br><span class="line">2022-07-02 13:38:31 ℹ [INFO]  application.argoproj.io/dtm-test-go created</span><br><span class="line">2022-07-02 13:38:31 ✔ [SUCCESS]  Tool (argocdapp/default) Create done.</span><br><span class="line">2022-07-02 13:38:31 ℹ [INFO]  -------------------- [  Processing done.  ] --------------------</span><br><span class="line">2022-07-02 13:38:31 ✔ [SUCCESS]  All plugins applied successfully.</span><br><span class="line">2022-07-02 13:38:31 ✔ [SUCCESS]  Apply finished.</span><br></pre></td></tr></table></figure>

<p>在 <code>apply</code> 的过程中会将执行的状态保存在定义的状态后端存储中，比如我们这里使用的是本地存储，则会在根目录的 <code>devstream.state</code> 文件中保存执行的状态，比如我们这里一共 4 个工具链，如果前两个执行完成，后面两个执行识别了，则会在该文件中保存前两个插件的状态，下一次重新 apply 的时候则只需要执行后面两个工具链即可。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/3bro7b.png" alt="img"></p>
<p>我们上面定义的工具链最终会为我们在 GitHub 上创建一个 Golang Web 的脚手架应用代码仓库。<img data-src="https://mudutestmenu.mudu.tv/upload/m39ck4.jpg" alt="img"></p>
<p>会使用 Github Actions 来进行 CI 操作，构建 Docker 镜像。<img data-src="https://mudutestmenu.mudu.tv/upload/odq34d.jpg" alt="img"></p>
<p>CI 流程最后会推送镜像到 Docker Hub。<img data-src="https://mudutestmenu.mudu.tv/upload/905lff.jpg" alt="img"></p>
<p>然后会在 Kubernetes 中部署 ArgoCD。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n argocd</span></span><br><span class="line">NAME                                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">argocd-application-controller-0                     1/1     Running   0          5m55s</span><br><span class="line">argocd-applicationset-controller-64d8c477f4-2wrg6   1/1     Running   0          5m55s</span><br><span class="line">argocd-dex-server-dbdbf5499-krmfz                   1/1     Running   0          5m35s</span><br><span class="line">argocd-notifications-controller-b67c4bdb4-22t9l     1/1     Running   0          5m55s</span><br><span class="line">argocd-redis-df9db799b-8gbpv                        1/1     Running   0          5m55s</span><br><span class="line">argocd-repo-server-56769cdd47-zs65j                 1/1     Running   0          5m55s</span><br><span class="line">argocd-server-7d4745f689-w5pp7                      1/1     Running   0          5m55s</span><br></pre></td></tr></table></figure>

<p>最后会通过 ArgoCD 来进行 CD 操作，将我们的示例应用部署到 Kubernetes 集群中去，其实就是创建了一个 ArgoCD 的 Application 对象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get applications -n argocd</span></span><br><span class="line">NAME          SYNC STATUS   HEALTH STATUS</span><br><span class="line">dtm-test-go   Unknown       Healthy</span><br></pre></td></tr></table></figure>

<p>我们也可以通过 ArgoCD 查看部署的应用详情。<img data-src="https://mudutestmenu.mudu.tv/upload/zxiiua.jpg" alt="img"></p>
<p>最后如果想要删除整个工具链则只需要执行 <code>dtm delete</code> 命令即可。</p>
<p>整个流程体验非常顺畅（除了因为某些原因访问 GitHub 超级慢之外），我们只需要根据需要在配置文件中定义对应的插件即可，关于插件的具体配置方式可以参考官方文档 <a target="_blank" rel="noopener" href="https://docs.devstream.io/en/latest/plugins/plugins-list/">https://docs.devstream.io/en/latest/plugins/plugins-list/</a> 了解更多相关信息。</p>
<p>只需要在一个  <code>YAML</code> 配置文件中定义你所需要的 DevOps 工具，只需按一个命令就能建立起整个 DevOps 工具链和 SDLC 工作流了，所以说 <code>DevStream</code> 是神器完全不为过。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/GET%20%E5%92%8C%20POST%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/GET%20%E5%92%8C%20POST%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">GET 和 POST请求方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:32:06" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 HTTP 协议中，<code>GET</code> 和 <code>POST</code> 是两种最常用的请求方法。它们在功能、用途和行为上存在显著的区别。</p>
<hr>
<h3 id="主要区别概览"><a href="#主要区别概览" class="headerlink" title="主要区别概览"></a>主要区别概览</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">GET 请求</th>
<th align="left">POST 请求</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>用途</strong></td>
<td align="left">从服务器<strong>获取</strong>资源</td>
<td align="left">向服务器<strong>提交</strong>数据以创建&#x2F;修改资源</td>
</tr>
<tr>
<td align="left"><strong>数据位置</strong></td>
<td align="left">数据（参数）放在 URL 的 <code>?</code> 后面（查询字符串）</td>
<td align="left">数据放在 HTTP 请求的<strong>请求体</strong>中</td>
</tr>
<tr>
<td align="left"><strong>可见性</strong></td>
<td align="left">参数在 URL 中可见</td>
<td align="left">参数在 URL 中不可见 (在请求体中)</td>
</tr>
<tr>
<td align="left"><strong>数据长度</strong></td>
<td align="left">受 URL 长度限制（不同浏览器&#x2F;服务器有不同限制）</td>
<td align="left">理论上无长度限制（浏览器&#x2F;服务器会有实际限制）</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">不适合传输敏感数据（明文暴露在 URL）</td>
<td align="left">相对安全（数据不在 URL 中暴露，但仍需 HTTPS 加密）</td>
</tr>
<tr>
<td align="left"><strong>可缓存性</strong></td>
<td align="left">可缓存</td>
<td align="left">不可缓存</td>
</tr>
<tr>
<td align="left"><strong>幂等性</strong></td>
<td align="left"><strong>幂等</strong> (Idempotent)</td>
<td align="left"><strong>非幂等</strong> (Non-idempotent)</td>
</tr>
<tr>
<td align="left"><strong>可重复发送性</strong></td>
<td align="left">可重复发送，无副作用</td>
<td align="left">重复发送可能导致副作用（如重复创建记录）</td>
</tr>
<tr>
<td align="left"><strong>书签&#x2F;历史</strong></td>
<td align="left">可被书签收藏，保留在浏览器历史记录中</td>
<td align="left">不可被书签收藏，不会保留在历史记录中</td>
</tr>
</tbody></table>
<hr>
<h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><h4 id="1-用途："><a href="#1-用途：" class="headerlink" title="1. 用途："></a>1. 用途：</h4><ul>
<li><p><strong>GET：</strong> 主要用于从服务器<strong>请求（获取）</strong>数据。它应该是“只读”操作，即不应该改变服务器上的资源状态。</p>
<ul>
<li><strong>示例：</strong> 访问网页、查询数据库（搜索、筛选）、获取图片或文件。</li>
</ul>
</li>
<li><p><strong>POST：</strong> 主要用于向服务器<strong>提交（发送）</strong>数据，通常是为了<strong>创建或更新</strong>服务器上的资源。它会导致服务器状态的变化。</p>
<ul>
<li><strong>示例：</strong> 提交表单（注册、发布文章）、上传文件、发送评论。</li>
</ul>
</li>
</ul>
<h4 id="2-数据传输方式："><a href="#2-数据传输方式：" class="headerlink" title="2. 数据传输方式："></a>2. 数据传输方式：</h4><ul>
<li><p><strong>GET：</strong> 数据通过 <strong>URL 的查询字符串</strong>（query string）传输。参数附加在 URL 的 <code>?</code> 后面，多个参数用 <code>&amp;</code> 连接。</p>
<ul>
<li><code>http://example.com/search?query=hello+world&amp;page=1</code></li>
<li>由于数据在 URL 中，因此会被浏览器历史记录、服务器日志记录，也容易被缓存。</li>
</ul>
</li>
<li><p><strong>POST：</strong> 数据通过 HTTP <strong>请求体 (Request Body)</strong> 传输。</p>
<ul>
<li>数据不会在 URL 中显示。</li>
<li>可以发送各种格式的数据（如 <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>application/json</code>, <code>text/xml</code> 等），由 <code>Content-Type</code> 头指定。</li>
</ul>
</li>
</ul>
<h4 id="3-数据长度限制："><a href="#3-数据长度限制：" class="headerlink" title="3. 数据长度限制："></a>3. 数据长度限制：</h4><ul>
<li><strong>GET：</strong> URL 的长度通常有限制（通常在 2KB 到 8KB 之间，具体取决于浏览器和服务器配置）。因此，GET 不适合传输大量数据。</li>
<li><strong>POST：</strong> 请求体的大小理论上没有限制，只受服务器内存、磁盘空间等实际资源的限制。因此，POST 适合传输大量数据，例如文件上传。</li>
</ul>
<h4 id="4-安全性-Security-vs-Privacy-："><a href="#4-安全性-Security-vs-Privacy-：" class="headerlink" title="4. 安全性 (Security vs. Privacy)："></a>4. 安全性 (Security vs. Privacy)：</h4><ul>
<li><p><strong>GET：</strong></p>
<ul>
<li><strong>不安全</strong>（Regarding <strong>Privacy</strong>）：由于数据暴露在 URL 中，不适合传输敏感信息（如密码、API 密钥、个人身份信息）。这些信息可能被浏览器历史记录、服务器日志、代理服务器，甚至通过网络嗅探器看到。</li>
<li>关于“安全性”：GET 只是获取数据，不会修改服务器状态，所以从“改变状态”的角度来说是安全的。</li>
</ul>
</li>
<li><p><strong>POST：</strong></p>
<ul>
<li><strong>相对安全</strong>（Regarding <strong>Privacy</strong>）：数据在请求体中传输，不会直接暴露在 URL 里。但是，这并不意味着数据是加密的！默认情况下，HTTP POST 传输的数据仍然是明文的。要确保数据加密，<strong>必须使用 HTTPS</strong>。</li>
</ul>
</li>
</ul>
<h4 id="5-缓存性："><a href="#5-缓存性：" class="headerlink" title="5. 缓存性："></a>5. 缓存性：</h4><ul>
<li><strong>GET：</strong> 请求的响应可以被浏览器、代理服务器等缓存，从而提高访问速度。</li>
<li><strong>POST：</strong> 请求的响应通常<strong>不会</strong>被缓存，每次请求都会发送到服务器。</li>
</ul>
<h4 id="6-幂等性-Idempotence-："><a href="#6-幂等性-Idempotence-：" class="headerlink" title="6. 幂等性 (Idempotence)："></a>6. 幂等性 (Idempotence)：</h4><ul>
<li><p><strong>幂等 (Idempotent)：</strong> 指的是一个操作执行多次与执行一次所产生的结果是相同的，并且不会产生额外的副作用。</p>
</li>
<li><p><strong>GET：</strong> 是<strong>幂等的</strong>。无论你执行一个 GET 请求多少次，它都应该返回相同的资源状态，并且不会对服务器产生任何副作用。</p>
<ul>
<li><strong>示例：</strong> 请求一张图片，无论请求多少次，图片不会变，服务器状态也不会变。</li>
</ul>
</li>
<li><p><strong>POST：</strong> 是<strong>非幂等的</strong>。重复的 POST 请求通常会产生额外的副作用，例如重复创建资源或多次执行相同的操作。</p>
<ul>
<li><strong>示例：</strong> 提交一个订单表单，如果重复 POST，可能会创建多个订单。</li>
</ul>
</li>
</ul>
<h4 id="7-可重复发送性："><a href="#7-可重复发送性：" class="headerlink" title="7. 可重复发送性："></a>7. 可重复发送性：</h4><ul>
<li><strong>GET：</strong> 可以点击浏览器的刷新按钮或返回按钮而不会产生任何问题。</li>
<li><strong>POST：</strong> 当你尝试刷新或返回一个 POST 请求的页面时，浏览器通常会发出警告，询问你是否要重新提交表单，因为重复提交可能会导致副作用。</li>
</ul>
<h4 id="8-书签-历史记录："><a href="#8-书签-历史记录：" class="headerlink" title="8. 书签&#x2F;历史记录："></a>8. 书签&#x2F;历史记录：</h4><ul>
<li><strong>GET：</strong> 由于 URL 中包含了所有参数，可以方便地将一个带有特定查询条件的页面（如搜索结果页）添加书签，或者在浏览器历史记录中找到。</li>
<li><strong>POST：</strong> 由于数据在请求体中，URL 本身不包含提交的数据，所以不能直接将 POST 请求添加书签，也不会保留在浏览器历史记录中。</li>
</ul>
<hr>
<h3 id="何时使用-GET-和-POST？"><a href="#何时使用-GET-和-POST？" class="headerlink" title="何时使用 GET 和 POST？"></a>何时使用 GET 和 POST？</h3><ul>
<li><p><strong>使用 GET 当：</strong></p>
<ul>
<li>你需要从服务器获取数据。</li>
<li>请求是幂等的，即重复请求不会改变服务器状态。</li>
<li>数据量小，且不包含敏感信息（或是在 HTTPS 下敏感信息暴露在 URL 也可接受）。</li>
<li>希望请求的 URL 可以被分享、收藏或刷新。</li>
</ul>
</li>
<li><p><strong>使用 POST 当：</strong></p>
<ul>
<li>你需要向服务器提交数据以创建或修改资源。</li>
<li>请求不是幂等的（重复请求会产生副作用）。</li>
<li>需要传输大量数据或敏感数据。</li>
<li>包含文件上传。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong> 虽然在某些情况下，GET 可以传递数据（例如通过查询字符串），POST 也可以获取数据（通过请求体发送查询条件），但它们的核心设计目的是不同的。遵循 RESTful 原则和 HTTP 规范，合理选择 GET 和 POST 方法，对于构建健壮和可维护的 Web 应用至关重要。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Dockerfile%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Dockerfile%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Dockerfile 最佳实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:31:59" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/Devops/" itemprop="url" rel="index"><span itemprop="name">Devops</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a>Dockerfile 最佳实践</h1><p><code>Docker</code>官方关于<code>Dockerfile</code>最佳实践原文链接地址：<a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></p>
<p><code>Docker</code>可以通过从<code>Dockerfile</code>包含所有命令的文本文件中读取指令自动构建镜像，以便构建给定镜像。</p>
<p><code>Dockerfiles</code>使用特定的格式并使用一组特定的指令。您可以在 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">Dockerfile Reference</a> 页面上了解基础知识 。如果你是新手写作<code>Dockerfile</code>，你应该从那里开始。</p>
<p>本文档介绍了由 Docker，Inc. 和 Docker 社区推荐的用于构建高效镜像的最佳实践和方法。要查看更多实践和建议，请查看 <a target="_blank" rel="noopener" href="https://github.com/docker-library/buildpack-deps/blob/master/jessie/Dockerfile">Dockerfile for buildpack-deps</a>。</p>
<h2 id="一般准则和建议"><a href="#一般准则和建议" class="headerlink" title="一般准则和建议"></a>一般准则和建议</h2><h3 id="容器应该是短暂的"><a href="#容器应该是短暂的" class="headerlink" title="容器应该是短暂的"></a>容器应该是短暂的</h3><p>通过 Dockerfile 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。我们可以查看下<a target="_blank" rel="noopener" href="https://12factor.net/zh_cn/processes">12 Factor(12要素)应用程序方法</a>的进程部分，可以让我们理解这种无状态方式运行容器的动机。</p>
<h3 id="建立上下文"><a href="#建立上下文" class="headerlink" title="建立上下文"></a>建立上下文</h3><p>当你发出一个<code>docker build</code>命令时，当前的工作目录被称为构建上下文。默认情况下，Dockerfile 就位于该路径下，当然您也可以使用-f参数来指定不同的位置。无论 Dockerfile 在什么地方，当前目录中的所有文件内容都将作为构建上下文发送到 Docker 守护进程中去。</p>
<p>下面是一个构建上下文的示例，为构建上下文创建一个目录并 cd 放入其中。将“hello”写入一个文本文件hello，然后并创建一个<code>Dockerfile</code>并运行<code>cat</code>。从构建上下文（.）中构建图像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir myproject &amp;&amp; cd myproject</span><br><span class="line">echo &quot;hello&quot; &gt; hello</span><br><span class="line">echo -e &quot;FROM busybox\nCOPY /hello /\nRUN cat /hello&quot; &gt; Dockerfile</span><br><span class="line">docker build -t helloapp:v1 .</span><br></pre></td></tr></table></figure>

<p>现在移动 Dockerfile 和 hello 到不同的目录，并建立了图像的第二个版本（不依赖于缓存中的最后一个版本）。使用<code>-f</code>指向 Dockerfile 并指定构建上下文的目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p dockerfiles context</span><br><span class="line">mv Dockerfile dockerfiles &amp;&amp; mv hello context</span><br><span class="line">docker build --no-cache -t helloapp:v2 -f dockerfiles/Dockerfile context</span><br></pre></td></tr></table></figure>

<p>在构建的时候包含不需要的文件会导致更大的构建上下文和更大的镜像大小。这会增加构建时间，拉取和推送镜像的时间以及容器的运行时间大小。要查看您的构建环境有多大，请在构建您的系统时查找这样的消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dockerfile：</span><br><span class="line">Sending build context to Docker daemon  187.8MB</span><br></pre></td></tr></table></figure>

<h3 id="使用-dockerignore文件"><a href="#使用-dockerignore文件" class="headerlink" title="使用.dockerignore文件"></a>使用<code>.dockerignore</code>文件</h3><p>使用 Dockerfile 构建镜像时最好是将 Dockerfile 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个<code>.dockerignore</code>文件来指定要忽略的文件和目录。.dockerignore 文件的排除模式语法和 Git 的 .gitignore 文件相似。</p>
<h3 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h3><p>在 Docker 17.05 以上版本中，你可以使用 多阶段构建 来减少所构建镜像的大小。上一节课我们已经重点讲解过了。</p>
<h3 id="避免安装不必要的包"><a href="#避免安装不必要的包" class="headerlink" title="避免安装不必要的包"></a>避免安装不必要的包</h3><p>为了降低复杂性、减少依赖、减小文件大小和构建时间，应该避免安装额外的或者不必要的软件包。例如，不要在数据库镜像中包含一个文本编辑器。</p>
<h3 id="一个容器只专注做一件事情"><a href="#一个容器只专注做一件事情" class="headerlink" title="一个容器只专注做一件事情"></a>一个容器只专注做一件事情</h3><p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如一个 web 应用程序可能包含三个独立的容器：web应用、数据库、缓存，每个容器都是独立的镜像，分开运行。但这并不是说一个容器就只跑一个进程，因为有的程序可能会自行产生其他进程，比如 Celery 就可以有很多个工作进程。虽然“每个容器跑一个进程”是一条很好的法则，但这并不是一条硬性的规定。我们主要是希望一个容器只关注一件事情，尽量保持干净和模块化。</p>
<p>如果容器互相依赖，你可以使用<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/networking/">Docker 容器网络</a>来把这些容器连接起来，我们前面已经跟大家讲解过 Docker 的容器网络模式了。</p>
<h3 id="最小化镜像层数"><a href="#最小化镜像层数" class="headerlink" title="最小化镜像层数"></a>最小化镜像层数</h3><p>在 Docker 17.05 甚至更早 1.10之 前，尽量减少镜像层数是非常重要的，不过现在的版本已经有了一定的改善了：</p>
<ul>
<li>在 1.10 以后，只有 RUN、COPY 和 ADD 指令会创建层，其他指令会创建临时的中间镜像，但是不会直接增加构建的镜像大小了。</li>
<li>上节课我们也讲解到了 17.05 版本以后增加了多阶段构建的支持，允许我们把需要的数据直接复制到最终的镜像中，这就允许我们在中间阶段包含一些工具或者调试信息了，而且不会增加最终的镜像大小。</li>
</ul>
<p>当然减少<code>RUN、COPY、ADD</code>的指令仍然是很有必要的，但是我们也需要在 Dockerfile 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p>
<h3 id="对多行参数排序"><a href="#对多行参数排序" class="headerlink" title="对多行参数排序"></a>对多行参数排序</h3><p>只要有可能，就将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易，也更容易阅读和审查。建议在反斜杠符号 \ 之前添加一个空格，可以增加可读性。 下面是来自 buildpack-deps 镜像的例子：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">  bzr \</span></span><br><span class="line"><span class="language-bash">  cvs \</span></span><br><span class="line"><span class="language-bash">  git \</span></span><br><span class="line"><span class="language-bash">  mercurial \</span></span><br><span class="line"><span class="language-bash">  subversion</span></span><br></pre></td></tr></table></figure>

<h3 id="构建缓存"><a href="#构建缓存" class="headerlink" title="构建缓存"></a>构建缓存</h3><p>在镜像的构建过程中，Docker 根据 Dockerfile 指定的顺序执行每个指令。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。当然如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用<code>--no-cache=true</code>选项。</p>
<p>如果你想在构建的过程中使用了缓存，那么了解什么时候可以什么时候无法找到匹配的镜像就很重要了，Docker中缓存遵循的基本规则如下：</p>
<ul>
<li>从一个基础镜像开始（FROM 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</li>
<li>在大多数情况下，只需要简单地对比 Dockerfile 中的指令和子镜像。然而，有些指令需要更多的检查和解释。</li>
<li>对于 ADD 和 COPY 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验值。这些文件的修改时间和最后访问时间不会被纳入校验的范围。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验值进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</li>
<li>除了 ADD 和 COPY 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 RUN apt-get -y update 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。</li>
<li>一旦缓存失效，所有后续的 Dockerfile 指令都将产生新的镜像，缓存不会被使用。</li>
</ul>
<h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>下面是一些常用的 Dockerfile 指令，我们也分别来总结下，根据上面的建议和下面这些指令的合理使用，可以帮助我们编写高效且易维护的 Dockerfile 文件。</p>
<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用<a target="_blank" rel="noopener" href="https://hub.docker.com/_/alpine/">Alpine</a>镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p>
<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 LABEL 开头加上一个或多个标签对。</p>
<p>下面的示例展示了各种不同的可能格式。<code>#</code>开头的行是注释内容。</p>
<blockquote>
<p>注意：如果你的字符串包含空格，那么它必须被引用或者空格必须被转义。如果您的字符串包含内部引号字符（”），则也可以将其转义。</p>
</blockquote>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set one or more individual labels</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=<span class="string">&quot;ACME Incorporated&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version.is-production=<span class="string">&quot;&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>一个镜像可以包含多个标签，在 1.10 之前，建议将所有标签合并为一条<code>LABEL</code>指令，以防止创建额外的层，但是现在这个不再是必须的了，以上内容也可以写成下面这样:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="language-bash">      com.example.is-production=<span class="string">&quot;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>关于标签可以接受的键值对，参考<a target="_blank" rel="noopener" href="https://docs.docker.com/config/labels-custom-metadata/">Understanding object labels</a>。</p>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>为了保持 Dockerfile 文件的可读性，以及可维护性，建议将长的或复杂的<code>RUN</code>指令用反斜杠<code>\</code>分割成多行。</p>
<p>RUN 指令最常见的用法是安装包用的<code>apt-get</code>。因为<code>RUN apt-get</code>指令会安装包，所以有几个问题需要注意。</p>
<ul>
<li>不要使用 RUN apt-get upgrade 或 dist-upgrade，如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 foo，需要升级，使用 apt-get install -y foo 就行，该指令会自动升级 foo 包。</li>
<li>永远将 RUN apt-get update 和 apt-get install 组合成一条 RUN 声明，例如：</li>
</ul>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">        package-bar \</span></span><br><span class="line"><span class="language-bash">        package-baz \</span></span><br><span class="line"><span class="language-bash">        package-foo</span></span><br></pre></td></tr></table></figure>

<p>将 apt-get update 放在一条单独的 RUN 声明中会导致缓存问题以及后续的 apt-get install 失败。比如，假设你有一个 Dockerfile 文件：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl</span></span><br></pre></td></tr></table></figure>

<p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 apt-get install 添加了一个包：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl nginx</span></span><br></pre></td></tr></table></figure>

<p>Docker 发现修改后的 RUN apt-get update 指令和之前的完全一样。所以，apt-get update 不会执行，而是使用之前的缓存镜像。因为 apt-get update 没有运行，后面的 apt-get install 可能安装的是过时的 curl 和 nginx 版本。</p>
<p>使用<strong>RUN apt-get update &amp;&amp; apt-get install -y</strong>可以确保你的<code>Dockerfiles</code>每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作<code>cache busting(缓存破坏)</code>。你也可以显示指定一个包的版本号来达到 cache-busting，这就是所谓的固定版本，例如：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    package-bar \</span></span><br><span class="line"><span class="language-bash">    package-baz \</span></span><br><span class="line"><span class="language-bash">    package-foo=1.3.*</span></span><br></pre></td></tr></table></figure>

<p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p>
<p>下面是一个 RUN 指令的示例模板，展示了所有关于 apt-get 的建议。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    aufs-tools \</span></span><br><span class="line"><span class="language-bash">    automake \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    dpkg-sig \</span></span><br><span class="line"><span class="language-bash">    libcap-dev \</span></span><br><span class="line"><span class="language-bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="language-bash">    mercurial \</span></span><br><span class="line"><span class="language-bash">    reprepro \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="language-bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>

<p>其中 s3cmd 指令指定了一个版本号<code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 apt-get udpate 缓存失效并确保安装的是新版本。</p>
<p>另外，清理掉 apt 缓存 var&#x2F;lib&#x2F;apt&#x2F;lists 可以减小镜像大小。因为 RUN 指令的开头为 apt-get udpate，包缓存总是会在 apt-get install 之前刷新。</p>
<blockquote>
<p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p>
</blockquote>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code>指令用于执行目标镜像中包含的软件和任何参数。CMD 几乎都是以<code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code>的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 Apache)，你可能会执行类似于<code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code>形式的命令。</p>
<p>多数情况下，CMD 都需要一个交互式的 shell (bash, Python, perl 等)，例如 CMD [“perl”, “-de0”]，或者 CMD [“PHP”, “-a”]。使用这种形式意味着，当你执行类似<code>docker run -it python</code>时，你会进入一个准备好的 shell 中。</p>
<p>CMD 在极少的情况下才会以 CMD [“param”, “param”] 的形式与<code>ENTRYPOINT</code>协同使用，除非你和你的镜像使用者都对 ENTRYPOINT 的工作方式十分熟悉。</p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><code>EXPOSE</code>指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。</p>
<p>例如，提供 Apache web 服务的镜像应该使用 EXPOSE 80，而提供 MongoDB 服务的镜像使用 EXPOSE 27017。</p>
<p>对于外部访问，用户可以在执行 docker run 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>为了方便新程序运行，你可以使用<code>ENV</code>来为容器中安装的程序更新 PATH 环境变量。例如使用<strong>ENV PATH &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;bin:$PATH</strong>来确保<code>CMD [&quot;nginx&quot;]</code>能正确运行。</p>
<p>ENV 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 PGDATA。 最后，ENV 也能用于设置常见的版本号，比如下面的示例：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …ENV PATH /usr/local/postgres-<span class="variable">$PG_MAJOR</span>/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure>

<p>类似于程序中的常量，这种方法可以让你只需改变 ENV 指令来自动的改变容器中的软件版本。</p>
<h3 id="ADD-和-COPY"><a href="#ADD-和-COPY" class="headerlink" title="ADD 和 COPY"></a>ADD 和 COPY</h3><p>虽然<code>ADD</code>和<code>COPY</code>功能类似，但一般优先使用 COPY。因为它比 ADD 更透明。COPY 只支持简单将本地文件拷贝到容器中，而 ADD 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，ADD的最佳用例是将本地 tar 文件自动提取到镜像中，例如<strong>ADD rootfs.tar.xz</strong>。</p>
<p>如果你的 Dockerfile 有多个步骤需要使用上下文中不同的文件。单独 COPY 每个文件，而不是一次性的 COPY 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --requirement /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /tmp/</span></span><br></pre></td></tr></table></figure>

<p>如果将<code>COPY . /tmp/</code>放置在 RUN 指令之前，只要 . 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p>
<p>为了让镜像尽量小，最好不要使用 ADD 指令从远程 URL 获取包，而是使用 curl 和 wget。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> http://example.com/big.tar.xz /usr/src/things/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>

<p>而是应该使用下面这种方法：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span></span><br><span class="line"><span class="language-bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>

<p>上面使用的管道操作，所以没有中间文件需要删除。 对于其他不需要 ADD 的自动提取功能的文件或目录，你应该使用 COPY。</p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p><code>ENTRYPOINT</code>的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 CMD 提供默认选项）。</p>
<p>例如，下面的示例镜像提供了命令行工具 s3cmd:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;s3cmd&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>现在直接运行该镜像创建的容器会显示命令帮助：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run s3cmd</span></span><br></pre></td></tr></table></figure>

<p>或者提供正确的参数来执行某个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run s3cmd <span class="built_in">ls</span> s3://mybucket</span></span><br></pre></td></tr></table></figure>

<p>这样镜像名可以当成命令行的参考。ENTRYPOINT 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p>
<p>例如，Postgres 官方镜像使用下面的脚本作为 ENTRYPOINT：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">if [ &quot;$1&quot; = &#x27;postgres&#x27; ]; then</span><br><span class="line">    chown -R postgres &quot;$PGDATA&quot;</span><br><span class="line"></span><br><span class="line">    if [ -z &quot;$(ls -A &quot;$PGDATA&quot;)&quot; ]; then</span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    exec gosu postgres &quot;$@&quot;fi</span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p>
</blockquote>
<p>该辅助脚本被拷贝到容器，并在容器启动时通过 ENTRYPOINT 执行：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-entrypoint.sh /</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>该脚本可以让用户用几种不同的方式和 Postgres 交互。你可以很简单地启动 Postgres：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run postgres</span></span><br></pre></td></tr></table></figure>

<p>也可以执行 Postgres 并传递参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run postgres postgres --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure>

<p>最后，你还可以启动另外一个完全不同的工具，比如 Bash：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --<span class="built_in">rm</span> -it postgres bash</span></span><br></pre></td></tr></table></figure>

<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME</code>指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 VOLUME来管理镜像中的可变部分和用户可以改变的部分。</p>
<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>如果某个服务不需要特权执行，建议使用 USER 指令切换到非 root 用户。先在 Dockerfile 中使用类似 RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres 的指令创建用户和用户组。</p>
<blockquote>
<p>注意：在镜像中，用户和用户组每次被分配的 UID&#x2F;GID 都是不确定的，下次重新构建镜像时被分配到的 UID&#x2F;GID 可能会不一样。如果要依赖确定的 UID&#x2F;GID，你应该显示的指定一个 UID&#x2F;GID。</p>
</blockquote>
<p>你应该避免使用 sudo，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 sudo 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 gosu。</p>
<p>最后，为了减少层数和复杂度，避免频繁地使用 USER 来回切换用户。</p>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>为了清晰性和可靠性，你应该总是在<code>WORKDIR</code>中使用<strong>绝对路径</strong>。另外，你应该使用 WORKDIR 来替代类似于 RUN cd … &amp;&amp; do-something 的指令，后者难以阅读、排错和维护。</p>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>格式：**ONBUILD &lt;其它指令&gt;**。 <code>ONBUILD</code>是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。</p>
<p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行 npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，一般来说会这样写 Dockerfile：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题：</p>
<p>如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile，而第二个项目的 Dockerfile 就会被自动修复。</p>
<p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 Dockerfile 就会变为：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 my-node 的话，各个项目内的自己的 Dockerfile 就变为：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br></pre></td></tr></table></figure>

<p>基础镜像变化后，各个项目都用这个 Dockerfile 重新构建镜像，会继承基础镜像的更新。</p>
<p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 Dockerfile 里面有些东西需要调整呢？比如 npm install 都需要加一些参数，那怎么办？这一行 RUN 是不可能放入基础镜像的，因为涉及到了当前项目的 .&#x2F;package.json，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 Dockerfile 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p>
<p>ONBUILD 可以解决这个问题。让我们用 ONBUILD 重新写一下基础镜像的 Dockerfile:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br></pre></td></tr></table></figure>

<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install，生成应用镜像。</p>
<h2 id="官方仓库示例"><a href="#官方仓库示例" class="headerlink" title="官方仓库示例"></a>官方仓库示例</h2><p>这些官方仓库的 Dockerfile 都是参考典范：<a target="_blank" rel="noopener" href="https://github.com/docker-library/docs">https://github.com/docker-library/docs</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/GPUStack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/GPUStack/" class="post-title-link" itemprop="url">GPUStack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:38:18" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">大模型</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GPUStack：打造企业级私有大模型服务的开源利器"><a href="#GPUStack：打造企业级私有大模型服务的开源利器" class="headerlink" title="GPUStack：打造企业级私有大模型服务的开源利器"></a>GPUStack：打造企业级私有大模型服务的开源利器</h1><p>最近，一个国产开源项目凭借高质量的代码、飞快的迭代速度和简洁友好的操作体验正在悄然崛起。短短半年内，这个项目已经在国内外开源社区获得了众多的拥趸和生产用户。它就是今天要介绍的开源项目 - <strong>GPUStack</strong>。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/jwaj7c.png" alt="GPUStack"></p>
<p><code>GPUStack</code> 是一个 100% 开源的大模型服务平台，用户只需要简单的设置，就可以高效整合包括 NVIDIA、Apple Metal、华为昇腾和摩尔线程在内的各种异构 GPU&#x2F;NPU 资源，构建异构 GPU 集群，在私有环境提供企业级的大模型部署解决方案。</p>
<p><code>GPUStack</code> 支持私有化部署 RAG 系统和 AI Agent 系统所需的各种关键模型，包括 LLM 大语言模型、VLM 多模态模型、Embedding 文本嵌入模型、Rerank 重排序模型、Text-to-Image 文生图模型，以及 Speech-to-Text（STT）和 Text-to-Speech（TTS）语音模型等。并提供统一认证和高可用负载均衡的 OpenAI 兼容 API，供用户从各类大模型云服务无缝迁移到本地部署的私有大模型服务。</p>
<blockquote>
<p>GitHub：<strong><a target="_blank" rel="noopener" href="https://github.com/gpustack/gpustack">https://github.com/gpustack/gpustack</a></strong></p>
</blockquote>
<h2 id="GPUStack-介绍"><a href="#GPUStack-介绍" class="headerlink" title="GPUStack 介绍"></a>GPUStack 介绍</h2><p><strong>GPUStack</strong> 是一个集群化和自动化的大模型部署解决方案，用户不需要手动管理多台 GPU 节点和手动协调分配资源，通过 GPUStack 内置的紧凑调度、分散调度、指定 Worker 标签调度、指定 GPU 调度等各种调度策略，用户无需手动干预即可自动分配合适的 GPU 资源来运行大模型。</p>
<p>对于无法在单个 GPU 节点运行的大参数量模型，<strong>GPUStack</strong> 提供分布式推理功能，可以自动将模型运行在跨主机的多个 GPU 上。同时，在实验环境中，用户还可以采用 <strong>GPU&amp;CPU 混合推理</strong>或<strong>纯 CPU 推理</strong>模式，利用 CPU 算力来运行大模型，提供更广泛的兼容性和灵活性。</p>
<p>GPUStack 具有以下特点：</p>
<ul>
<li><strong>多平台和异构 GPU 支持</strong></li>
</ul>
<p><strong>GPUStack</strong> 支持 amd64 和 arm64 架构的 Linux、Windows 和 macOS 平台，可以纳管 NVIDIA、Apple Metal、华为昇腾和摩尔线程等各种类型的 GPU&#x2F;NPU。</p>
<ul>
<li><strong>多推理引擎和多版本支持</strong></li>
</ul>
<p><strong>GPUStack</strong> 支持 <strong>vLLM</strong>、<strong>llama-box（基于 llama.cpp 与 stable-diffusion.cpp ）</strong>和 <strong>vox-box</strong> 推理引擎，满足不同场景下的大模型部署需求。</p>
<p><strong>vLLM</strong> 是面向生产环境的高性能推理引擎，专为高并发和高吞吐量场景优化，广泛应用于数据中心场景，但仅支持 Linux 系统，适用于对性能有要求的应用场景。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/gpustack/llama-box">llama-box</a> 是 GPUStack 推出的推理引擎，基于 <strong>llama.cpp</strong> 与 <strong>stable-diffusion.cpp</strong>，提供对 LLM 大语言模型、VLM 多模态模型、Embedding 文本嵌入模型、Rerank 重排序模型、Text-to-Image 文生图模型的支持。</p>
<p><strong>llama-box</strong> 是一个灵活、兼容多平台的推理引擎，<strong>兼容 Linux、Windows 和 macOS</strong>，支持在 <strong>NVIDIA、Apple Metal、华为昇腾和摩尔线程</strong>等各种 GPU&#x2F;NPU 环境以及 CPU 环境运行模型，它的灵活性和兼容性使其成为资源有限场景（如 AI PC 和 Edge）的理想选择。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/gpustack/vox-box">vox-box</a> 是 GPUStack 提供的专注于语音模型的推理引擎，支持 <strong>Text-to-Speech（TTS）</strong>和 <strong>Speech-to-Text（STT）</strong>模型，并提供 OpenAI 兼容 API。目前对接了 <strong>Whisper</strong>、<strong>FunASR</strong>、<strong>Bark</strong> 和 <strong>CosyVoice</strong> 后端，支持运行 <strong>Whisper</strong>、<strong>Paraformer</strong>、<strong>Conformer</strong>、<strong>SenseVoice</strong> 等 STT 模型，以及 <strong>Bark</strong> 和 <strong>CosyVoice</strong> 等 TTS 模型。</p>
<p>GPUStack 还提供<strong>推理引擎的版本管理能力</strong>。用户可以<strong>在部署模型时，为每个模型固定任意可用的推理引擎版本</strong>。运维人员可以灵活使用多个推理引擎版本来满足新旧模型的兼容需求，在引入新模型的同时保证旧模型的稳定运行。</p>
<ul>
<li><strong>多模型类型支持</strong></li>
</ul>
<p><strong>GPUStack</strong> 支持 LLM 大语言模型、VLM 多模态模型、Embedding 文本嵌入模型、Rerank 重排序模型、Text-to-Image 文生图模型、Speech-to-Text（STT）和 Text-to-Speech（TTS）语音模型等各种模型，用户可以选择从 Hugging Face、ModelScope、Ollama Library、私有模型仓库或本地路径部署这些模型。</p>
<ul>
<li><strong>大语言模型</strong></li>
</ul>
<p><strong>GPUStack</strong> 可以在 <strong>NVIDIA</strong>、<strong>Apple Metal</strong>、<strong>华为昇腾</strong>和<strong>摩尔线程</strong>等各种 GPU &#x2F; NPU 上运行 LLM。同时支持 vLLM 和 llama-box 后端使得 GPUStack 可以全面地覆盖从实验室研发测试场景到生产应用落地场景，从数据中心、云到桌面、边缘的各种环境。</p>
<p>GPUStack 在 Playground 中提供了模型调测的能力，还支持多模型对比视图，可以同时对比多个模型的问答内容和性能数据，以评估不同模型、不同权重、不同 Prompt 参数、不同量化、不同 GPU、不同推理后端的模型推理表现。</p>
<p>如果需要跟 RAG 系统或 AI Agent 系统集成，GPUStack 提供了 OpenAI 兼容的 API，可以通过 <code>View Code</code> 查看动态生成的 API 调用代码示例。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/jg4kme.png" alt="img"></p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/7tod66.png" alt="img"></p>
<ul>
<li><strong>多模态模型</strong></li>
</ul>
<p>GPUStack 可以部署各种多模态模型，例如 Llama3.2-Vision、Pixtral、Qwen2-VL、LLaVA、InternVL2 等等，用于图像识别等任务，在 Playground 试验场中可以调测模型验证效果。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/viof4w.png" alt="img"></p>
<ul>
<li><strong>Embedding 文本嵌入模型</strong></li>
</ul>
<p>在 RAG 系统中，<strong>Embedding 模型</strong>用于将知识库中的文本转化为向量，存储到向量数据库。当用户提问时，问题同样会经过 Embedding 模型的向量化处理，通过计算向量距离在向量数据库中检索出最相关的上下文，并将其与用户问题一起传递给大模型。GPUStack <strong>支持在 Linux、Windows 和 macOS 平台的各种 GPU&#x2F;NPU 上</strong>部署 Embedding 模型。</p>
<p>Playground 还可以对 <strong>Embedding 模型</strong>进行调测，提供直观的可视化分析。通过对嵌入向量进行 PCA（主成分分析）降维，用户能够在降维坐标空间中对比多段文本的距离，直观判断向量距离和文本相似度。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/qqvxmg.png" alt="img"></p>
<ul>
<li><strong>Rerank 重排模型</strong></li>
</ul>
<p>在 RAG 系统中，<strong>Rerank 模型</strong>用于对向量检索召回的多个上下文进行重排序，确保将最相关的上下文传递给大模型，从而提高回答的准确性。GPUStack <strong>支持在 Linux、Windows 和 macOS 平台的各种 GPU&#x2F;NPU 上</strong>部署 Rerank 模型。</p>
<p>Playground 还可以对 <strong>Rerank 模型</strong>进行调测，提供直观的重排结果展示。用户可以输入 <strong>Query</strong> 和一组 <strong>Documents</strong>，模型会根据 Query 的内容对 Documents 进行排序，并返回每个文档的相关性得分。用户可以通过结果判断模型对输入的理解和排序的准确性。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/wly3px.png" alt="img"></p>
<ul>
<li><strong>文生图模型</strong></li>
</ul>
<p><strong>GPUStack</strong> 可以开箱即用地部署 <strong>Stable Diffusion</strong> 和 <strong>FLUX</strong> 等文生图模型，支持在 <strong>NVIDIA</strong>、<strong>Apple Metal</strong>、<strong>华为昇腾</strong>和<strong>摩尔线程</strong>等各种 GPU &#x2F; NPU 上运行文生图模型。并提供了 Playground 试验场供开发者调测图像生成的效果，从而试验不同模型的最佳实践参数配置。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/r7ed69.jpg" alt="img"></p>
<ul>
<li><strong>Text-to-Speech（TTS）文本转语音模型</strong></li>
</ul>
<p><strong>GPUStack</strong> 可以在 NVIDIA GPU 或 CPU 上部署 Text-to-Speech（TTS）文本转语音模型，并提供了 Playground 试验场供开发者调测文本转语音的效果。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/ckxpr1.png" alt="img"></p>
<ul>
<li><strong>Speech-to-Text（STT）语音转文本模型</strong></li>
</ul>
<p><strong>GPUStack</strong> 可以在 NVIDIA GPU 或 CPU 上部署 Speech-to-Text（STT）语音转文本模型，并提供了 Playground 试验场供开发者调测语音转文本的效果。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/vihhpo.png" alt="img"></p>
<ul>
<li><strong>集成对接能力</strong></li>
</ul>
<p>GPUStack 提供标准的 OpenAI 兼容 API，支持 LangChain、LlamaIndex、GraphRAG、Dify、FastGPT、RAGFlow、Open WebUI 等各种 LLM 应用框架、RAG 应用和 AI Agent 应用的对接。企业不仅可以快速将现有的大模型应用<strong>无缝迁移到 GPUStack 部署的私有模型服务</strong>，还能根据不同场景和需求，<strong>统一认证对接各种模型</strong>，灵活构建定制化的 RAG 系统和 AI Agent 应用。</p>
<ul>
<li><strong>企业级管理能力</strong></li>
</ul>
<p>GPUStack 是面向企业级的大模型部署解决方案，<strong>提供国产化支持、就地升级、推理引擎版本管理、模型升级、负载均衡高可用、用户管理、API 认证授权、GPU 和 LLM 观测指标、Dashboard 仪表板、离线部署等各种运维管理能力</strong>，帮助运维人员<strong>轻松应对异构适配、模型迭代、权限控制、运维观测等管理需求</strong>，降低了大模型部署和管理的复杂度。</p>
<h2 id="安装-GPUStack"><a href="#安装-GPUStack" class="headerlink" title="安装 GPUStack"></a>安装 GPUStack</h2><blockquote>
<p>需要 Python 3.10 ~ Python 3.12</p>
</blockquote>
<p>在 <strong>Linux</strong> 或 <strong>macOS</strong> 上通过以下命令安装（使用国内源加速）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sfL https://get.gpustack.ai | INSTALL_INDEX_URL=https://pypi.tuna.tsinghua.edu.cn/simple sh -s - --tools-download-base-url &quot;https://gpustack-1303613262.cos.ap-guangzhou.myqcloud.com&quot;</span><br></pre></td></tr></table></figure>

<p>在 <strong>Windows</strong> 上以管理员身份运行 <strong>Powershell</strong>，通过以下命令安装（使用国内源加速）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:INSTALL_INDEX_URL</span> = <span class="string">&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span></span><br><span class="line"><span class="built_in">Invoke-Expression</span> <span class="string">&quot;&amp; &#123; <span class="variable">$</span>((Invoke-WebRequest -Uri &#x27;https://get.gpustack.ai&#x27; -UseBasicParsing).Content) &#125; -- --tools-download-base-url &#x27;https://gpustack-1303613262.cos.ap-guangzhou.myqcloud.com&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<p>当看到以下输出时，说明已经成功部署并启动了 GPUStack：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[INFO]  GPUStack service is running.</span><br><span class="line">[INFO]  Install complete.</span><br><span class="line"></span><br><span class="line">GPUStack UI is available at http://localhost.</span><br><span class="line">Default username is &#x27;admin&#x27;.</span><br><span class="line">To get the default password, run &#x27;cat /var/lib/gpustack/initial_admin_password&#x27;.</span><br><span class="line"></span><br><span class="line">CLI &quot;gpustack&quot; is available from the command line. (You may need to open a new terminal or re-login for the PATH changes to take effect.)</span><br></pre></td></tr></table></figure>

<p>按照脚本的输出指引，拿到登录 GPUStack 的初始密码。</p>
<p>在 <strong>Linux</strong> 或 <strong>macOS</strong> 上执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/lib/gpustack/initial_admin_password</span><br></pre></td></tr></table></figure>

<p>在 <strong>Windows</strong> 上执行：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Content</span> <span class="literal">-Path</span> (<span class="built_in">Join-Path</span> <span class="literal">-Path</span> <span class="variable">$env:APPDATA</span> <span class="literal">-ChildPath</span> <span class="string">&quot;gpustack\initial_admin_password&quot;</span>) <span class="literal">-Raw</span></span><br></pre></td></tr></table></figure>

<p>在浏览器访问 GPUStack UI，用户名 <strong>admin</strong>，密码为上面获得的初始密码。</p>
<p>重新设置密码后，进入 GPUStack：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/y8w2qv.png" alt="img"></p>
<h2 id="纳管-GPU-资源"><a href="#纳管-GPU-资源" class="headerlink" title="纳管 GPU 资源"></a>纳管 GPU 资源</h2><p><strong>GPUStack</strong> 可以纳管 Linux、Windows 和 macOS 设备的 GPU 资源，通过以下步骤来纳管这些 GPU 资源。</p>
<p>其他节点需要通过认证 Token 加入 GPUStack 集群，在 GPUStack Server 节点执行以下命令获取 Token：</p>
<p>在 <strong>Linux</strong> 或 <strong>macOS</strong> 上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/lib/gpustack/token</span><br></pre></td></tr></table></figure>

<p>在 <strong>Windows</strong> 上：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Content</span> <span class="literal">-Path</span> (<span class="built_in">Join-Path</span> <span class="literal">-Path</span> <span class="variable">$env:APPDATA</span> <span class="literal">-ChildPath</span> <span class="string">&quot;gpustack\token&quot;</span>) <span class="literal">-Raw</span></span><br></pre></td></tr></table></figure>

<p>拿到 Token 后，在其他节点上运行以下命令添加 Worker 到 GPUStack，纳管这些节点的 GPU（将其中的 <strong><a target="_blank" rel="noopener" href="http://your_ip_address/">http://YOUR_IP_ADDRESS</a></strong> 替换为你的 GPUStack 访问地址，将 YOUR_TOKEN 替换为用于添加 Worker 的认证 Token）：</p>
<p>在 <strong>Linux</strong> 或 <strong>macOS</strong> 上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sfL https://get.gpustack.ai | INSTALL_INDEX_URL=https://pypi.tuna.tsinghua.edu.cn/simple sh -s - --server-url http://YOUR_IP_ADDRESS --token YOUR_TOKEN --tools-download-base-url &quot;https://gpustack-1303613262.cos.ap-guangzhou.myqcloud.com&quot;</span><br></pre></td></tr></table></figure>

<p>在 <strong>Windows</strong> 上：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:INSTALL_INDEX_URL</span> = <span class="string">&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span></span><br><span class="line"><span class="built_in">Invoke-Expression</span> <span class="string">&quot;&amp; &#123; <span class="variable">$</span>((Invoke-WebRequest -Uri &quot;</span>https://get.gpustack.ai<span class="string">&quot; -UseBasicParsing).Content) &#125; -- --server-url http://YOUR_IP_ADDRESS --token YOUR_TOKEN --tools-download-base-url &#x27;https://gpustack-1303613262.cos.ap-guangzhou.myqcloud.com&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过以上操作步骤，我们创建了一个 GPUStack 环境并纳管了多个 GPU 节点，后面就可以使用 GPUStack 来体验上面提及的各种功能了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Gateway%20API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Gateway%20API/" class="post-title-link" itemprop="url">Gateway API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:31:52" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Gateway-API"><a href="#Gateway-API" class="headerlink" title="Gateway API"></a>Gateway API</h1><p><code>Gateway API</code>（之前叫 Service API）是由 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/community/tree/master/sig-network">SIG-NETWORK 社区</a>管理的开源项目，项目地址：<a target="_blank" rel="noopener" href="https://gateway-api.sigs.k8s.io/%E3%80%82%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%E6%98%AF">https://gateway-api.sigs.k8s.io/。主要原因是</a> Ingress 资源对象不能很好的满足网络需求，很多场景下 Ingress 控制器都需要通过定义 annotations 或者 crd 来进行功能扩展，这对于使用标准和支持是非常不利的，新推出的 Gateway API 旨在通过可扩展的面向角色的接口来增强服务网络。</p>
<p>Gateway API 是 Kubernetes 中的一个 API 资源集合，包括 GatewayClass、Gateway、HTTPRoute、TCPRoute、Service 等，这些资源共同为各种网络用例构建模型。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/c4654k.png" alt="Gateway API"></p>
<p>Gateway API 的改进比当前的 Ingress 资源对象有很多更好的设计：</p>
<ul>
<li>面向角色 - Gateway 由各种 API 资源组成，这些资源根据使用和配置 Kubernetes 服务网络的角色进行建模。</li>
<li>通用性 - 和 Ingress 一样是一个具有众多实现的通用规范，Gateway API 是一个被设计成由许多实现支持的规范标准。</li>
<li>更具表现力 - Gateway API 资源支持基于 Header 头的匹配、流量权重等核心功能，这些功能在 Ingress 中只能通过自定义注解才能实现。</li>
<li>可扩展性 - Gateway API 允许自定义资源链接到 API 的各个层，这就允许在 API 结构的适当位置进行更精细的定制。</li>
</ul>
<p>还有一些其他值得关注的功能：</p>
<ul>
<li>GatewayClasses - <code>GatewayClasses</code> 将负载均衡实现的类型形式化，这些类使用户可以很容易了解到通过 Kubernetes 资源可以获得什么样的能力。</li>
<li>共享网关和跨命名空间支持 - 它们允许共享负载均衡器和 VIP，允许独立的路由资源绑定到同一个网关，这使得团队可以安全地共享（包括跨命名空间）基础设施，而不需要直接协调。</li>
<li>规范化路由和后端 - Gateway API 支持类型化的路由资源和不同类型的后端，这使得 API 可以灵活地支持各种协议（如 HTTP 和 gRPC）和各种后端服务（如 Kubernetes Service、存储桶或函数）。</li>
</ul>
<h2 id="面向角色设计"><a href="#面向角色设计" class="headerlink" title="面向角色设计"></a>面向角色设计</h2><p>无论是道路、电力、数据中心还是 Kubernetes 集群，基础设施都是为了共享而建的，然而共享基础设施提供了一个共同的挑战，那就是如何为基础设施用户提供灵活性的同时还能被所有者控制。</p>
<p>Gateway API 通过对 Kubernetes 服务网络进行面向角色的设计来实现这一目标，平衡了灵活性和集中控制。它允许共享的网络基础设施（硬件负载均衡器、云网络、集群托管的代理等）被许多不同的团队使用，所有这些都受到集群运维设置的各种策略和约束。下面的例子显示了是如何在实践中运行的。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/vvkrja.png" alt="gateway api demo"></p>
<p>一个集群运维人员创建了一个基于 GatewayClass 的 Gateway 资源，这个 Gateway 部署或配置了它所代表的基础网络资源，集群运维和特定的团队必须沟通什么可以附加到这个 Gateway 上来暴露他们的应用。 集中的策略，如 TLS，可以由集群运维在 Gateway 上强制执行，同时，Store 和 Site 应用在他们自己的命名空间中运行，但将他们的路由附加到相同的共享网关上，允许他们独立控制他们的路由逻辑。</p>
<p>这种关注点分离的设计可以使不同的团队能够管理他们自己的流量，同时将集中的策略和控制留给集群运维。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在整个 Gateway API 中涉及到 3 个角色：基础设施提供商、集群管理员、应用开发人员，在某些场景下可能还会涉及到应用管理员等角色。Gateway API 中定义了 3 种主要的资源模型：<code>GatewayClass</code>、<code>Gateway</code>、<code>Route</code>。</p>
<h3 id="GatewayClass"><a href="#GatewayClass" class="headerlink" title="GatewayClass"></a>GatewayClass</h3><p><code>GatewayClass</code> 定义了一组共享相同配置和动作的网关。每个<code>GatewayClass</code> 由一个控制器处理，是一个集群范围的资源，必须至少有一个 <code>GatewayClass</code> 被定义。</p>
<p>这与 Ingress 的 IngressClass 类似，在 Ingress v1beta1 版本中，与 GatewayClass 类似的是 <code>ingress-class</code> 注解，而在 Ingress V1 版本中，最接近的就是 <code>IngressClass</code> 资源对象。</p>
<h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><p>Gateway 网关描述了如何将流量转化为集群内的服务，也就是说，它定义了一个请求，要求将流量从不了解 Kubernetes 的地方转换到集群内的服务。例如，由云端负载均衡器、集群内代理或外部硬件负载均衡器发送到 Kubernetes 服务的流量。</p>
<p>它定义了对特定负载均衡器配置的请求，该配置实现了 GatewayClass 的配置和行为规范，该资源可以由管理员直接创建，也可以由处理 <code>GatewayClass</code> 的控制器创建。</p>
<p>Gateway 可以附加到一个或多个路由引用上，这些路由引用的作用是将流量的一个子集导向特定的服务。</p>
<h3 id="Route-资源"><a href="#Route-资源" class="headerlink" title="Route 资源"></a>Route 资源</h3><p>路由资源定义了特定的规则，用于将请求从网关映射到 Kubernetes 服务。</p>
<p>从 <code>v1alpha2</code> 版本开始，API 中包含四种 Route 路由资源类型，对于其他未定义的协议，鼓励采用特定实现的自定义路由类型，当然未来也可能会添加新的路由类型。</p>
<p><strong>HTTPRoute</strong></p>
<p><code>HTTPRoute</code> 是用于 HTTP 或 HTTPS 连接，适用于我们想要检查 HTTP 请求并使用 HTTP 请求进行路由或修改的场景，比如使用 HTTP Headers 头进行路由，或在请求过程中对它们进行修改。</p>
<p><strong>TLSRoute</strong></p>
<p>TLSRoute 用于 TLS 连接，通过 SNI 进行区分，它适用于希望使用 SNI 作为主要路由方法的地方，并且对 HTTP 等更高级别协议的属性不感兴趣，连接的字节流不经任何检查就被代理到后端。</p>
<p><strong>TCPRoute 和 UDPRoute</strong></p>
<p>TCPRoute（和 UDPRoute）旨在用于将一个或多个端口映射到单个后端。在这种情况下，没有可以用来选择同一端口的不同后端的判别器，所以每个 TCPRoute 在监听器上需要一个不同的端口。你可以使用 TLS，在这种情况下，未加密的字节流会被传递到后端，当然也可以不使用 TLS，这样加密的字节流将传递到后端。</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><code>GatewayClass</code>、<code>Gateway</code>、<code>xRoute</code> 和 <code>Service</code> 的组合定义了一个可实施的负载均衡器。下图说明了不同资源之间的关系:</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/isheoz.png" alt="组合关系"></p>
<p>使用反向代理实现的网关的典型客户端&#x2F;网关 API 请求流程如下所示：</p>
<ul>
<li><ol>
<li>客户端向 <code>http://foo.example.com</code> 发出请求</li>
</ol>
</li>
<li><ol>
<li>DNS 将域名解析为 <code>Gateway</code> 网关地址</li>
</ol>
</li>
<li><ol>
<li>反向代理在监听器上接收请求，并使用 Host Header 来匹配 HTTPRoute</li>
</ol>
</li>
<li><ol>
<li>(可选)反向代理可以根据 HTTPRoute 的匹配规则进行路由</li>
</ol>
</li>
<li><ol>
<li>(可选)反向代理可以根据 HTTPRoute 的过滤规则修改请求，即添加或删除 headers</li>
</ol>
</li>
<li><ol>
<li>最后，反向代理根据 HTTPRoute 的 <code>forwardTo</code> 规则，将请求转发给集群中的一个或多个对象，即服务。</li>
</ol>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>目前已经有很多 Gateway API 的控制器实现方案了，比如 Contour、Google Kubernetes Engine、Istio、Traefik 等等。接下来我们以 Traefik 为例来进行测试。不过需要注意的是 Traefik 目前是基于 <code>v1alpha1</code> 规范实现的，可能和上面提到的一些概念略有不同。</p>
<p>要在 Traefik 中使用 Gateway API，首先我们需要先手动安装 Gateway API 的 CRDs，使用如下命令即可安装，这将安装包括 GatewayClass、Gateway、HTTPRoute、TCPRoute 等 CRDs：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl kustomize &quot;github.com/kubernetes-sigs/gateway-api/config/crd?ref=v0.3.0&quot; \</span><br><span class="line">| kubectl apply -f -</span><br></pre></td></tr></table></figure>



<p>然后我们需要在 Traefik 中开启 <code>kubernetesgateway</code> 这个 Provider，同样基于前面 Traefik 章节中的 Helm Chart 包进行定义，设置 <code>experimental.kubernetesGateway.enabled=true</code>，完整的 Values 文件如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ci/deployment-prod.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable experimental features</span></span><br><span class="line"><span class="attr">experimental:</span></span><br><span class="line">  <span class="attr">kubernetesGateway:</span> <span class="comment"># 开启 gateway api 支持</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">providers:</span></span><br><span class="line">  <span class="attr">kubernetesCRD:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">allowCrossNamespace:</span> <span class="literal">true</span> <span class="comment"># 是否允许跨命名空间</span></span><br><span class="line">    <span class="attr">allowExternalNameServices:</span> <span class="literal">true</span> <span class="comment"># 是否允许使用 ExternalName 的服务</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kubernetesIngress:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">allowExternalNameServices:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="comment"># 其他忽略</span></span><br></pre></td></tr></table></figure>



<p>然后使用下面的命令更新 Traefik 即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ helm upgrade --install traefik ./traefik -f ./traefik/ci/deployment-prod.yaml --namespace kube-system</span><br></pre></td></tr></table></figure>



<p>更新完成后可以前往 Traefik 的 Dashboard 查看是否已经启用 <code>KubernetesGateway</code> 这个 Provider：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/uadnkk.png" alt="KubernetesGateway Provider"></p>
<p>正常情况下启用成功后 Traefik 也会创建一个默认的 <code>GatewayClass</code> 资源对象和 <code>Gateway</code> 实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get gatewayclass</span><br><span class="line">NAME      CONTROLLER                      AGE</span><br><span class="line">traefik   traefik.io/gateway-controller   4m13s</span><br><span class="line">➜ kubectl get gatewayclass traefik -o yaml</span><br><span class="line">apiVersion: networking.x-k8s.io/v1alpha1</span><br><span class="line">kind: GatewayClass</span><br><span class="line">metadata:</span><br><span class="line">  name: traefik</span><br><span class="line">spec:</span><br><span class="line">  controller: traefik.io/gateway-controller</span><br><span class="line">......</span><br><span class="line">➜ kubectl get gateway -n kube-system</span><br><span class="line">NAME              CLASS     AGE</span><br><span class="line">traefik-gateway   traefik   5m55s</span><br><span class="line">➜ kubectl get gateway -n kube-system traefik-gateway -o yaml</span><br><span class="line">apiVersion: networking.x-k8s.io/v1alpha1</span><br><span class="line">kind: Gateway</span><br><span class="line">metadata:</span><br><span class="line">  name: traefik-gateway</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  gatewayClassName: traefik</span><br><span class="line">  listeners:</span><br><span class="line">  - port: 8000</span><br><span class="line">    protocol: HTTP</span><br><span class="line">    routes:</span><br><span class="line">      group: networking.x-k8s.io</span><br><span class="line">      kind: HTTPRoute</span><br><span class="line">      namespaces:</span><br><span class="line">        from: Same</span><br><span class="line">      selector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          app: traefik</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>可以看到默认创建的 <code>Gateway</code> 实例引用了 <code>traefik</code> 这个 <code>GatewayClass</code>，其中 <code>listeners</code> 部分定义了该网关关联的监听器入口，监听器定义逻辑端点绑定在该网关地址上，至少需要指定一个监听器，下面的 <code>HTTPRoute</code> 定义了路由规则，<code>namespaces</code> 表示应该在哪些命名空间中为该网关选择路由，默认情况下，这被限制在该网关的命名空间中，<code>Selector</code> 则指定一组路由标签，如果定义了这个 Selector，则只路由匹配选择器与网关相关联的对象，一个空的选择器匹配所有对象，这里会去匹配具有 <code>app: traefik</code> 标签的对象。</p>
<blockquote>
<p>为了能够处理其他命名空间中的路由规则，我们可以将这里的 <code>namespaces.from</code> 修改为 <code>All</code>，但是经测试未生效？</p>
</blockquote>
<p>下面我们安装一个简单的 <code>whoami</code> 服务来进行测试，直接使用下面的资源清单部署对应的服务即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 01-whoami.yaml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">whoami</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">whoami</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">whoami</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whoami</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">containous/whoami</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">whoami</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">whoami</span></span><br></pre></td></tr></table></figure>



<p>测试服务部署完成后，我们就可以使用 Gateway API 的方式来进行流量配置了。</p>
<h3 id="部署一个简单的-Host-主机"><a href="#部署一个简单的-Host-主机" class="headerlink" title="部署一个简单的 Host 主机"></a>部署一个简单的 Host 主机</h3><p>在以前的方式中我们会创建一个 Ingress 或 IngressRoute 资源对象，这里我们将部署一个简单的 <code>HTTPRoute</code> 对象。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 02-whoami-httproute.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.x-k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HTTPRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">http-app-1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostnames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;whoami&#x27;</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">matches:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">path:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">Exact</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">forwardTo:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">whoami</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">weight:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>上面的 HTTPRoute 资源会捕捉到向 whoami 主机名发出的请求，并将其转发到上面部署的 whoami 服务，如果你现在对这个主机名进行请求，你会看到典型的 whoami 输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl apply -f 02-whoami-httproute.yaml</span><br><span class="line">➜ kubectl get httproute -n kube-system</span><br><span class="line">NAME         HOSTNAMES    AGE</span><br><span class="line">http-app-1   [&quot;whoami&quot;]   25s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 <span class="built_in">whoami</span> 这个主机名进行访问测试</span></span><br><span class="line">➜ curl -H &quot;Host: whoami&quot; http://192.168.31.108</span><br><span class="line">Hostname: whoami-6b465b89d6-lcg4k</span><br><span class="line">IP: 127.0.0.1</span><br><span class="line">IP: ::1</span><br><span class="line">IP: 10.244.1.87</span><br><span class="line">IP: fe80::cccc:6aff:fef8:eca9</span><br><span class="line">RemoteAddr: 10.244.1.85:60384</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: whoami</span><br><span class="line">User-Agent: curl/7.64.1</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">X-Forwarded-For: 192.168.31.9</span><br><span class="line">X-Forwarded-Host: whoami</span><br><span class="line">X-Forwarded-Port: 80</span><br><span class="line">X-Forwarded-Proto: http</span><br><span class="line">X-Forwarded-Server: traefik-84d4cccf9c-2pl5r</span><br><span class="line">X-Real-Ip: 192.168.31.9</span><br></pre></td></tr></table></figure>



<p>另外需要注意上面 HTTPRoute 对象中需要定义 <code>app：traefik</code> 标签，否则创建的 <code>Gateway</code> 实例不能关联上。</p>
<h3 id="带路径的-Host-主机"><a href="#带路径的-Host-主机" class="headerlink" title="带路径的 Host 主机"></a>带路径的 Host 主机</h3><p>上面的例子可以很容易地限制流量只在一个给定的子路径上进行路由。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 03-whoami-httproute-paths.yaml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.x-k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HTTPRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">http-app-1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostnames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">whoami</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">forwardTo:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">whoami</span></span><br><span class="line">          <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">matches:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">path:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">Exact</span> <span class="comment"># 匹配 /foo 的路径</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">/foo</span></span><br></pre></td></tr></table></figure>



<p>创建上面修改后的 HTTPRoute，你会发现之前的请求现在返回 404 错误，而请求 &#x2F;foo 路径后缀则返回成功。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -H &quot;Host: whoami&quot; http://192.168.31.108</span><br><span class="line">404 page not found</span><br><span class="line">➜ curl -H &quot;Host: whoami&quot; http://192.168.31.108/foo</span><br><span class="line">Hostname: whoami-6b465b89d6-p5vwz</span><br><span class="line">IP: 127.0.0.1</span><br><span class="line">IP: ::1</span><br><span class="line">IP: 10.244.2.154</span><br><span class="line">IP: fe80::7045:53ff:fef9:fadc</span><br><span class="line">RemoteAddr: 10.244.1.85:51686</span><br><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Host: whoami</span><br><span class="line">User-Agent: curl/7.64.1</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">X-Forwarded-For: 192.168.31.9</span><br><span class="line">X-Forwarded-Host: whoami</span><br><span class="line">X-Forwarded-Port: 80</span><br><span class="line">X-Forwarded-Proto: http</span><br><span class="line">X-Forwarded-Server: traefik-84d4cccf9c-2pl5r</span><br><span class="line">X-Real-Ip: 192.168.31.9</span><br></pre></td></tr></table></figure>



<p>关于请求的哪些部分可以被匹配的更多信息可以在官方 Gateway APIs 文档（<a target="_blank" rel="noopener" href="https://gateway-api.sigs.k8s.io/v1alpha1/api-types/httproute/#rules%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E3%80%82">https://gateway-api.sigs.k8s.io/v1alpha1/api-types/httproute/#rules）中找到。</a></p>
<h3 id="金丝雀发布"><a href="#金丝雀发布" class="headerlink" title="金丝雀发布"></a>金丝雀发布</h3><p>Gateway APIs 规范可以支持的另一个功能是金丝雀发布，假设你想在一个端点上运行两个不同的服务（或同一服务的两个版本），并将一部分请求路由到每个端点，则可以通过修改你的 HTTPRoute 来实现。</p>
<p>首先，我们需要运行第二个服务，这里我们快速生成一个 Nginx 的实例来进行测试。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 03-nginx.yaml</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>



<p>接着我们修改前面的 HTTPRoute 资源对象，其中有一个 weight 选项，可以为两个服务分别分配不同的权重，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 04-whoami-nginx-canary.yaml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.x-k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HTTPRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">traefik</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">http-app-1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostnames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">whoami</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">forwardTo:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">whoami</span></span><br><span class="line">          <span class="attr">weight:</span> <span class="number">3</span> <span class="comment"># 3/4 的请求到whoami</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">weight:</span> <span class="number">1</span> <span class="comment"># 1/4 的请求到whoami</span></span><br></pre></td></tr></table></figure>



<p>创建上面的 HTTPRoute 后，现在我们可以再次访问 whoami 服务，正常我们可以看到有大约 25%的请求会看到 Nginx 的响应，而不是 whoami 的响应。</p>
<p>到这里我们就使用 Traefik 来测试了 Kubernetes Gateway APIs 的使用。目前，Traefik 对 Gateway APIs 的实现是基于 <code>v1alpha1</code> 版本的规范，目前最新的规范是 <code>v1alpha2</code>，所以和最新的规范可能有一些出入的地方。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
