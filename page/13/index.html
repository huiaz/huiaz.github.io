<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hui&#39;s Blog">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="六一">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Secret/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Secret/" class="post-title-link" itemprop="url">Secret</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:54:45" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">配置管理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h1><p>前文我们学习 <code>ConfigMap</code> 的时候，我们说 <code>ConfigMap</code> 这个资源对象是 Kubernetes 当中非常重要的一个资源对象，一般情况下 ConfigMap 是用来存储一些非安全的配置信息，如果涉及到一些安全相关的数据的话用 ConfigMap 就非常不妥了，因为 ConfigMap 是明文存储的，这个时候我们就需要用到另外一个资源对象了：<code>Secret</code>，<code>Secret</code>用来保存敏感信息，例如密码、OAuth 令牌和 ssh key 等等，将这些信息放在 <code>Secret</code> 中比放在 Pod 的定义中或者 Docker 镜像中要更加安全和灵活。</p>
<p><code>Secret</code> 主要使用的有以下三种类型：</p>
<ul>
<li><code>Opaque</code>：base64 编码格式的 Secret，用来存储密码、密钥等；但数据也可以通过 <code>base64 –decode</code> 解码得到原始数据，所有加密性很弱。</li>
<li><code>kubernetes.io/dockercfg</code>: <code>~/.dockercfg</code> 文件的序列化形式</li>
<li><code>kubernetes.io/dockerconfigjson</code>：用来存储私有<code>docker registry</code>的认证信息，<code>~/.docker/config.json</code> 文件的序列化形式</li>
<li><code>kubernetes.io/service-account-token</code>：用于 <code>ServiceAccount</code>, ServiceAccount 创建时 Kubernetes 会默认创建一个对应的 Secret 对象，Pod 如果使用了 ServiceAccount，对应的 Secret 会自动挂载到 Pod 目录 <code>/run/secrets/kubernetes.io/serviceaccount</code> 中</li>
<li><code>kubernetes.io/ssh-auth</code>：用于 SSH 身份认证的凭据</li>
<li><code>kubernetes.io/basic-auth</code>：用于基本身份认证的凭据</li>
<li><code>bootstrap.kubernetes.io/token</code>：用于节点接入集群的校验的 Secret</li>
</ul>
<blockquote>
<p>上面是 Secret 对象内置支持的几种类型，通过为 Secret 对象的 type 字段设置一个非空的字符串值，也可以定义并使用自己 Secret 类型。如果 type 值为空字符串，则被视为 Opaque 类型。Kubernetes 并不对类型的名称作任何限制，不过，如果要使用内置类型之一， 则你必须满足为该类型所定义的所有要求。</p>
</blockquote>
<h2 id="Opaque-Secret"><a href="#Opaque-Secret" class="headerlink" title="Opaque Secret"></a>Opaque Secret</h2><p><code>Secret</code> 资源包含2个键值对： <code>data</code> 和 <code>stringData</code>，<code>data</code> 字段用来存储 base64 编码的任意数据，提供 <code>stringData</code> 字段是为了方便，它允许 Secret 使用未编码的字符串。 <code>data</code> 和 <code>stringData</code> 的键必须由字母、数字、<code>-</code>，<code>_</code> 或 <code>.</code> 组成。</p>
<p>比如我们来创建一个用户名为 admin，密码为 admin321 的 <code>Secret</code> 对象，首先我们需要先把用户名和密码做 <code>base64</code> 编码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ echo -n &quot;admin&quot; | base64</span><br><span class="line">YWRtaW4=</span><br><span class="line">➜  ~ echo -n &quot;admin321&quot; | base64</span><br><span class="line">YWRtaW4zMjE=</span><br></pre></td></tr></table></figure>

<p>然后我们就可以利用上面编码过后的数据来编写一个 YAML 文件：(secret-demo.yaml)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">YWRtaW4zMjE=</span></span><br></pre></td></tr></table></figure>



<p>然后我们就可以使用 kubectl 命令来创建了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f secret-demo.yaml</span><br><span class="line">secret &quot;mysecret&quot; created</span><br></pre></td></tr></table></figure>



<p>利用<code>get secret</code>命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get secret</span><br><span class="line">NAME                  TYPE                                  DATA      AGE</span><br><span class="line">default-token-n9w2d   kubernetes.io/service-account-token   3         33d</span><br><span class="line">mysecret              Opaque                                2         40s</span><br></pre></td></tr></table></figure>



<p>其中 <code>default-token-n9w2d</code> 为创建集群时默认创建的 Secret，被 <code>serviceacount/default</code> 引用。我们可以使用 <code>describe</code> 命令查看详情：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl describe secret mysecret</span><br><span class="line">Name:         mysecret</span><br><span class="line">Namespace:    default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Type:  Opaque</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">password:  8 bytes</span><br><span class="line">username:  5 bytes</span><br></pre></td></tr></table></figure>

<p>我们可以看到利用 describe 命令查看到的 Data 没有直接显示出来，如果想看到 Data 里面的详细信息，同样我们可以输出成YAML 文件进行查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get secret mysecret -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  password: YWRtaW4zMjE=</span><br><span class="line">  username: YWRtaW4=</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: 2018-06-19T15:27:06Z</span><br><span class="line">  name: mysecret</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;3694084&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/default/secrets/mysecret</span><br><span class="line">  uid: 39c139f5-73d5-11e8-a101-525400db4df7</span><br><span class="line">type: Opaque</span><br></pre></td></tr></table></figure>

<p>对于某些场景，你可能希望使用 <code>stringData</code> 字段，这字段可以将一个非 base64 编码的字符串直接放入 Secret 中， 当创建或更新该 Secret 时，此字段将被编码。</p>
<p>比如当我们部署应用时，使用 Secret 存储配置文件， 你希望在部署过程中，填入部分内容到该配置文件。例如，如果你的应用程序使用以下配置文件:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiUrl:</span> <span class="string">&quot;https://my.api.com/api/v1&quot;</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">&quot;&lt;user&gt;&quot;</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">&quot;&lt;password&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>那么我们就可以使用以下定义将其存储在 Secret 中:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">stringData:</span></span><br><span class="line">  <span class="attr">config.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    apiUrl: &quot;https://my.api.com/api/v1&quot;</span></span><br><span class="line"><span class="string">    username: &lt;user&gt;</span></span><br><span class="line"><span class="string">    password: &lt;password&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如我们直接创建上面的对象后重新获取对象的话 <code>config.yaml</code> 的值会被编码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get secret mysecret -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  config.yaml: YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IDx1c2VyPgpwYXNzd29yZDogPHBhc3N3b3JkPgo=</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Secret&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;name&quot;:&quot;mysecret&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;stringData&quot;:&#123;&quot;config.yaml&quot;:&quot;apiUrl: \&quot;https://my.api.com/api/v1\&quot;\nusername: \u003cuser\u003e\npassword: \u003cpassword\u003e\n&quot;&#125;,&quot;type&quot;:&quot;Opaque&quot;&#125;</span><br><span class="line">  creationTimestamp: &quot;2021-11-21T10:42:25Z&quot;</span><br><span class="line">  managedFields:</span><br><span class="line">  - apiVersion: v1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:data:</span><br><span class="line">        .: &#123;&#125;</span><br><span class="line">        f:config.yaml: &#123;&#125;</span><br><span class="line">      f:metadata:</span><br><span class="line">        f:annotations:</span><br><span class="line">          .: &#123;&#125;</span><br><span class="line">          f:kubectl.kubernetes.io/last-applied-configuration: &#123;&#125;</span><br><span class="line">      f:type: &#123;&#125;</span><br><span class="line">    manager: kubectl</span><br><span class="line">    operation: Update</span><br><span class="line">    time: &quot;2021-11-21T10:42:25Z&quot;</span><br><span class="line">  name: mysecret</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;857340&quot;</span><br><span class="line">  uid: 5a28d296-5f53-4e4c-92f3-c1d7c952ace2</span><br><span class="line">type: Opaque</span><br></pre></td></tr></table></figure>

<p>创建好 <code>Secret</code>对象后，有两种方式来使用它：</p>
<ul>
<li>以环境变量的形式</li>
<li>以Volume的形式挂载</li>
</ul>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>首先我们来测试下环境变量的方式，同样的，我们来使用一个简单的 busybox 镜像来测试下:(secret1-pod.yaml)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret1-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;env&quot;</span> ]</span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">USERNAME</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">secretKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">username</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PASSWORD</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">secretKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>

<p>主要需要注意的是上面环境变量中定义的 <code>secretKeyRef</code> 字段，和我们前文的 <code>configMapKeyRef</code> 类似，一个是从 <code>Secret</code> 对象中获取，一个是从 <code>ConfigMap</code> 对象中获取，创建上面的 Pod：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl create -f secret1-pod.yaml</span><br><span class="line">pod &quot;secret1-pod&quot; created</span><br></pre></td></tr></table></figure>

<p>然后我们查看Pod的日志输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl logs secret1-pod</span><br><span class="line">...</span><br><span class="line">USERNAME=admin</span><br><span class="line">PASSWORD=admin321</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到有 USERNAME 和 PASSWORD 两个环境变量输出出来。</p>
<h3 id="Volume-挂载"><a href="#Volume-挂载" class="headerlink" title="Volume 挂载"></a>Volume 挂载</h3><p>同样的我们用一个 Pod 来验证下 <code>Volume</code> 挂载，创建一个 Pod 文件：(secret2-pod.yaml)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret2-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret2</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ls /etc/secrets&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/secrets</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">     <span class="attr">secretName:</span> <span class="string">mysecret</span></span><br></pre></td></tr></table></figure>

<p>创建 Pod，然后查看输出日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl create -f secret-pod2.yaml</span><br><span class="line">pod &quot;secret2-pod&quot; created</span><br><span class="line">➜  ~ kubectl logs secret2-pod</span><br><span class="line">password</span><br><span class="line">username</span><br></pre></td></tr></table></figure>

<p>可以看到 Secret 把两个 key 挂载成了两个对应的文件。当然如果想要挂载到指定的文件上面，是不是也可以使用上一节课的方法：在 <code>secretName</code> 下面添加 <code>items</code> 指定 <code>key</code> 和 <code>path</code>，这个大家可以参考上节课 <code>ConfigMap</code> 中的方法去测试下。</p>
<h2 id="kubernetes-io-dockerconfigjson"><a href="#kubernetes-io-dockerconfigjson" class="headerlink" title="kubernetes.io&#x2F;dockerconfigjson"></a>kubernetes.io&#x2F;dockerconfigjson</h2><p>除了上面的 <code>Opaque</code> 这种类型外，我们还可以来创建用户 <code>docker registry</code> 认证的 <code>Secret</code>，直接使用&#96;&#96;kubectl create&#96; 命令创建即可，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl create secret docker-registry myregistry --docker-server=DOCKER_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL</span><br><span class="line">secret &quot;myregistry&quot; created</span><br></pre></td></tr></table></figure>

<p>除了上面这种方法之外，我们也可以通过指定文件的方式来创建镜像仓库认证信息，需要注意对应的 <code>KEY</code> 和 <code>TYPE</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret generic myregistry --from-file=.dockerconfigjson=/root/.docker/config.json --type=kubernetes.io/dockerconfigjson</span><br></pre></td></tr></table></figure>

<p>然后查看 Secret 列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get secret</span><br><span class="line">NAME                  TYPE                                  DATA      AGE</span><br><span class="line">default-token-n9w2d   kubernetes.io/service-account-token   3         33d</span><br><span class="line">myregistry            kubernetes.io/dockerconfigjson        1         15s</span><br><span class="line">mysecret              Opaque                                2         34m</span><br></pre></td></tr></table></figure>

<p>注意看上面的 TYPE 类型，myregistry 对应的是 <code>kubernetes.io/dockerconfigjson</code>，同样的可以使用 describe 命令来查看详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl describe secret myregistry</span><br><span class="line">Name:         myregistry</span><br><span class="line">Namespace:    default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/dockerconfigjson</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">.dockerconfigjson:  152 bytes</span><br></pre></td></tr></table></figure>

<p>同样的可以看到 Data 区域没有直接展示出来，如果想查看的话可以使用 <code>-o yaml</code> 来输出展示出来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get secret myregistry -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  .dockerconfigjson: eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0=</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: 2018-06-19T16:01:05Z</span><br><span class="line">  name: myregistry</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;3696966&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/default/secrets/myregistry</span><br><span class="line">  uid: f91db707-73d9-11e8-a101-525400db4df7</span><br><span class="line">type: kubernetes.io/dockerconfigjson</span><br></pre></td></tr></table></figure>

<p>可以把上面的 <code>data.dockerconfigjson</code> 下面的数据做一个 <code>base64</code> 解码，看看里面的数据是怎样的呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ echo eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0= | base64 -d</span><br><span class="line">&#123;&quot;auths&quot;:&#123;&quot;DOCKER_SERVER&quot;:&#123;&quot;username&quot;:&quot;DOCKER_USER&quot;,&quot;password&quot;:&quot;DOCKER_PASSWORD&quot;,&quot;email&quot;:&quot;DOCKER_EMAIL&quot;,&quot;auth&quot;:&quot;RE9DS0VSX1VTRVI6RE9DS0VSX1BBU1NXT1JE&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要拉取私有仓库中的 Docker 镜像的话就需要使用到上面的 myregistry 这个 <code>Secret</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: foo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: foo</span><br><span class="line">    image: 192.168.1.100:5000/test:v1</span><br><span class="line">  imagePullSecrets:</span><br><span class="line">  - name: myregistry</span><br></pre></td></tr></table></figure>

<p>imagePullSecrets</p>
<p><code>ImagePullSecrets</code> 与 <code>Secrets</code> 不同，因为 <code>Secrets</code> 可以挂载到 Pod 中，但是 <code>ImagePullSecrets</code> 只能由 Kubelet 访问。</p>
<p>我们需要拉取私有仓库镜像 <code>192.168.1.100:5000/test:v1</code>，我们就需要针对该私有仓库来创建一个如上的 <code>Secret</code>，然后在 Pod 中指定 <code>imagePullSecrets</code>。</p>
<p>除了设置 <code>Pod.spec.imagePullSecrets</code> 这种方式来获取私有镜像之外，我们还可以通过在 <code>ServiceAccount</code> 中设置 <code>imagePullSecrets</code>，然后就会自动为使用该 SA 的 Pod 注入 <code>imagePullSecrets</code> 信息：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2019-11-08T12:00:04Z&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;332&quot;</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/serviceaccounts/default</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">cc37a719-c4fe-4ebf-92da-e92c3e24d5d0</span></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default-token-5tsh4</span></span><br><span class="line"><span class="attr">imagePullSecrets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myregistry</span></span><br></pre></td></tr></table></figure>

<h2 id="kubernetes-io-basic-auth"><a href="#kubernetes-io-basic-auth" class="headerlink" title="kubernetes.io&#x2F;basic-auth"></a>kubernetes.io&#x2F;basic-auth</h2><p>该类型用来存放用于基本身份认证所需的凭据信息，使用这种 Secret 类型时，Secret 的 data 字段（不一定）必须包含以下两个键（相当于是约定俗成的一个规定）：</p>
<ul>
<li><code>username</code>: 用于身份认证的用户名</li>
<li><code>password</code>: 用于身份认证的密码或令牌</li>
</ul>
<p>以上两个键的键值都是 <code>base64</code> 编码的字符串。 然你也可以在创建 Secret 时使用 <code>stringData</code> 字段来提供明文形式的内容。下面的 YAML 是基本身份认证 Secret 的一个示例清单：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-basic-auth</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/basic-auth</span></span><br><span class="line"><span class="attr">stringData:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">admin321</span></span><br></pre></td></tr></table></figure>



<p>提供基本身份认证类型的 Secret 仅仅是出于用户方便性考虑，我们也可以使用 Opaque 类型来保存用于基本身份认证的凭据，不过使用内置的 Secret 类型的有助于对凭据格式进行统一处理。</p>
<h2 id="kubernetes-io-ssh-auth"><a href="#kubernetes-io-ssh-auth" class="headerlink" title="kubernetes.io&#x2F;ssh-auth"></a>kubernetes.io&#x2F;ssh-auth</h2><p>该类型用来存放 SSH 身份认证中所需要的凭据，使用这种 Secret 类型时，你就不一定必须在其 data（或 stringData）字段中提供一个 <code>ssh-privatekey</code> 键值对，作为要使用的 SSH 凭据。</p>
<p>如下所示是一个 SSH 身份认证 Secret 的配置示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-ssh-auth</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/ssh-auth</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">ssh-privatekey:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">MIIEpQIBAAKCAQEAulqb/Y</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>同样提供 SSH 身份认证类型的 Secret 也仅仅是出于用户方便性考虑，我们也可以使用 Opaque 类型来保存用于 SSH 身份认证的凭据，只是使用内置的 Secret 类型的有助于对凭据格式进行统一处理。</p>
<h2 id="kubernetes-io-tls"><a href="#kubernetes-io-tls" class="headerlink" title="kubernetes.io&#x2F;tls"></a>kubernetes.io&#x2F;tls</h2><p>该类型用来存放证书及其相关密钥（通常用在 TLS 场合）。此类数据主要提供给 Ingress 资源，用以校验 TLS 链接，当使用此类型的 Secret 时，Secret 配置中的 data （或 stringData）字段必须包含 <code>tls.key</code> 和 <code>tls.crt</code>主键。下面的 YAML 包含一个 TLS Secret 的配置示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-tls</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/tls</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">tls.crt:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        MIIC2DCCAcCgAwIBAgIBATANBgkqh ...</span></span><br><span class="line"><span class="string"></span>  <span class="attr">tls.key:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>提供 TLS 类型的 Secret 仅仅是出于用户方便性考虑，我们也可以使用 Opaque 类型来保存用于 TLS 服务器与&#x2F;或客户端的凭据。不过，使用内置的 Secret 类型的有助于对凭据格式进行统一化处理。当使用 kubectl 来创建 TLS Secret 时，我们可以像下面的例子一样使用 tls 子命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl create secret tls my-tls-secret \</span><br><span class="line">  --cert=path/to/cert/file \</span><br><span class="line">  --key=path/to/key/file</span><br></pre></td></tr></table></figure>



<p>需要注意的是用于 <code>--cert</code> 的公钥证书必须是 <code>.PEM</code> 编码的 （Base64 编码的 DER 格式），且与 <code>--key</code> 所给定的私钥匹配，私钥必须是通常所说的 PEM 私钥格式，且未加密。对这两个文件而言，PEM 格式数据的第一行和最后一行（例如，证书所对应的 <code>--------BEGIN CERTIFICATE-----</code> 和 <code>-------END CERTIFICATE----</code>）都不会包含在其中。</p>
<h2 id="kubernetes-io-service-account-token"><a href="#kubernetes-io-service-account-token" class="headerlink" title="kubernetes.io&#x2F;service-account-token"></a>kubernetes.io&#x2F;service-account-token</h2><p>另外一种 <code>Secret</code> 类型就是 <code>kubernetes.io/service-account-token</code>，用于被 <code>ServiceAccount</code> 引用。<code>ServiceAccout</code> 创建时 Kubernetes 会默认创建对应的 <code>Secret</code>，如下所示我们随意创建一个 Pod：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl run secret-pod3 --image nginx:1.7.9</span><br><span class="line">deployment.apps &quot;secret-pod3&quot; created</span><br><span class="line">➜  ~ kubectl get pods</span><br><span class="line">NAME                           READY     STATUS    RESTARTS   AGE</span><br><span class="line">...</span><br><span class="line">secret-pod3-78c8c76db8-7zmqm   1/1       Running   0          13s</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>我们可以直接查看这个 Pod 的详细信息：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attr">volumeMounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kube-api-access-lvhfb</span></span><br><span class="line">    <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">serviceAccount:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">serviceAccountName:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kube-api-access-lvhfb</span></span><br><span class="line">  <span class="attr">projected:</span></span><br><span class="line">    <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">    <span class="attr">sources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">serviceAccountToken:</span></span><br><span class="line">        <span class="attr">expirationSeconds:</span> <span class="number">3607</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">token</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">ca.crt</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">ca.crt</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">kube-root-ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">downwardAPI:</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">fieldRef:</span></span><br><span class="line">            <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">            <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">namespace</span></span><br></pre></td></tr></table></figure>



<p>当创建 Pod 的时候，如果没有指定 ServiceAccount，Pod 则会使用命名空间中名为 default 的 ServiceAccount，上面我们可以看到 <code>spec.serviceAccountName</code> 字段已经被自动设置了。</p>
<p>可以看到这里通过一个 <code>projected</code> 类型的 Volume 挂载到了容器的 <code>/var/run/secrets/kubernetes.io/serviceaccount</code> 的目录中，<code>projected</code> 类型的 Volume 可以同时挂载多个来源的数据，这里我们挂载了一个 downwardAPI 来获取 namespace，通过 ConfigMap 来获取 <code>ca.crt</code> 证书，然后还有一个 <code>serviceAccountToken</code> 类型的数据源。</p>
<p>在之前的版本（v1.20）中，是直接将 <code>default</code>（自动创建的）的 <code>ServiceAccount</code> 对应的 Secret 对象通过 Volume 挂载到了容器的 <code>/var/run/secrets/kubernetes.io/serviceaccount</code> 的目录中的，现在的版本提供了更多的配置选项，比如上面我们配置了 <code>expirationSeconds</code> 和 <code>path</code> 两个属性。</p>
<p>前面我们也提到了默认情况下当前 namespace 下面的 Pod 会默认使用 <code>default</code> 这个 ServiceAccount，对应的 <code>Secret</code> 会自动挂载到 Pod 的 <code>/var/run/secrets/kubernetes.io/serviceaccount/</code> 目录中，这样我们就可以在 Pod 里面获取到用于身份认证的信息了。</p>
<p>我们可以使用自动挂载给 Pod 的 ServiceAccount 凭据访问 API，我们也可以通过在 ServiceAccount 上设置 <code>automountServiceAccountToken: false</code> 来实现不给 ServiceAccount 自动挂载 API 凭据：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">build-robot</span></span><br><span class="line"><span class="attr">automountServiceAccountToken:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>此外也可以选择不给特定 Pod 自动挂载 API 凭据：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">build-robot</span></span><br><span class="line">  <span class="attr">automountServiceAccountToken:</span> <span class="literal">false</span></span><br><span class="line">  <span class="string">..</span></span><br></pre></td></tr></table></figure>

<p>如果 Pod 和 ServiceAccount 都指定了 <code>automountServiceAccountToken</code> 值，则 Pod 的 spec 优先于 ServiceAccount。</p>
<h3 id="ServiceAccount-Token-投影"><a href="#ServiceAccount-Token-投影" class="headerlink" title="ServiceAccount Token 投影"></a>ServiceAccount Token 投影</h3><p><code>ServiceAccount</code> 是 Pod 和集群 apiserver 通讯的访问凭证，传统方式下，在 Pod 中使用 ServiceAccount 可能会遇到如下的安全挑战：</p>
<ul>
<li><code>ServiceAccount</code> 中的 <code>JSON Web Token (JWT)</code> 没有绑定 audience 身份，因此所有 ServiceAccount 的使用者都可以彼此扮演，存在伪装攻击的可能</li>
<li>传统方式下每一个 ServiceAccount 都需要存储在一个对应的 Secret 中，并且会以文件形式存储在对应的应用节点上，而集群的系统组件在运行过程中也会使用到一些权限很高的 ServiceAccount，其增大了集群管控平面的攻击面，攻击者可以通过获取这些管控组件使用的 ServiceAccount 非法提权</li>
<li>ServiceAccount 中的 JWT token 没有设置过期时间，当上述 ServiceAccount 泄露情况发生时，只能通过轮转 ServiceAccount 的签发私钥来进行防范</li>
<li>每一个 ServiceAccount 都需要创建一个与之对应的 Secret，在大规模的应用部署下存在弹性和容量风险</li>
</ul>
<p>为解决这个问题 Kubernetes 提供了 ServiceAccount Token 投影特性用于增强 ServiceAccount 的安全性，ServiceAccount 令牌卷投影可使 Pod 支持以卷投影的形式将 ServiceAccount 挂载到容器中从而避免了对 Secret 的依赖。</p>
<p>通过 ServiceAccount 令牌卷投影可用于工作负载的 ServiceAccount 令牌是受时间限制，受 audience 约束的,并且不与 Secret 对象关联。如果删除了 Pod 或删除了 ServiceAccount，则这些令牌将无效，从而可以防止任何误用，Kubelet 还会在令牌即将到期时自动旋转令牌，另外，还可以配置希望此令牌可用的路径。</p>
<p>为了启用令牌请求投射（此功能在 Kubernetes 1.12 中引入，Kubernetes v1.20 已经稳定版本），你必须为 <code>kube-apiserver</code> 设置以下命令行参数，通过 kubeadm 安装的集群已经默认配置了：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">--service-account-issuer</span>  <span class="comment"># serviceaccount token 中的签发身份，即token payload中的iss字段。</span></span><br><span class="line"><span class="string">--service-account-key-file</span> <span class="comment"># token 私钥文件路径</span></span><br><span class="line"><span class="string">--service-account-signing-key-file</span>  <span class="comment"># token 签名私钥文件路径</span></span><br><span class="line"><span class="string">--api-audiences</span> <span class="string">(可选参数)</span>  <span class="comment"># 合法的请求token身份，用于apiserver服务端认证请求token是否合法。</span></span><br></pre></td></tr></table></figure>



<p>配置完成后就可以指定令牌的所需属性，例如身份和有效时间，这些属性在默认 ServiceAccount 令牌上无法配置。当删除 Pod 或 ServiceAccount 时，ServiceAccount 令牌也将对 API 无效。</p>
<p>我们可以使用名为 <code>ServiceAccountToken</code> 的 <code>ProjectedVolume</code> 类型在 PodSpec 上配置此功能，比如要向 Pod 提供具有 “vault” 用户以及两个小时有效期的令牌，可以在 PodSpec 中配置以下内容：</p>
<p>例如当 Pod 中需要使用 audience 为 vault 并且有效期为2个小时的 ServiceAccount 时，我们可以使用以下模板配置 PodSpec 来使用 ServiceAccount 令牌卷投影。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">build-robot</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/run/secrets/tokens</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">vault-token</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">build-robot</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vault-token</span></span><br><span class="line">    <span class="attr">projected:</span></span><br><span class="line">      <span class="attr">sources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">serviceAccountToken:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">vault-token</span></span><br><span class="line">          <span class="attr">expirationSeconds:</span> <span class="number">7200</span></span><br><span class="line">          <span class="attr">audience:</span> <span class="string">vault</span></span><br></pre></td></tr></table></figure>



<p>kubelet 组件会替 Pod 请求令牌并将其保存起来，通过将令牌存储到一个可配置的路径使之在 Pod 内可用，并在令牌快要到期的时候刷新它。 kubelet 会在令牌存在期达到其 TTL 的 80% 的时候或者令牌生命期超过 24 小时的时候主动轮换它。应用程序负责在令牌被轮换时重新加载其内容。对于大多数使用场景而言，周期性地（例如，每隔 5 分钟）重新加载就足够了。</p>
<h2 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h2><p>如果某个容器已经在通过环境变量使用某 Secret，对该 Secret 的更新不会被容器马上看见，除非容器被重启，当然我们可以使用一些第三方的解决方案在 Secret 发生变化时触发容器重启。</p>
<p>在 Kubernetes v1.21 版本提供了不可变的 Secret 和 ConfigMap 的可选配置[stable]，我们可以设置 Secret 和 ConfigMap 为不可变的，对于大量使用 Secret 或者 ConfigMap 的集群（比如有成千上万各不相同的 Secret 供 Pod 挂载）时，禁止变更它们的数据有很多好处：</p>
<ul>
<li>可以防止意外更新导致应用程序中断</li>
<li>通过将 Secret 标记为不可变来关闭 <code>kube-apiserver</code> 对其的 watch 操作，从而显著降低 <code>kube-apiserver</code> 的负载，提升集群性能</li>
</ul>
<p>这个特性通过可以通过 <code>ImmutableEmphemeralVolumes</code> 特性门来进行开启，从 v1.19 开始默认启用，我们可以通过将 Secret 的 <code>immutable</code> 字段设置为 true 创建不可更改的 Secret。 例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">immutable:</span> <span class="literal">true</span>  <span class="comment"># 标记为不可变</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一旦一个 Secret 或 ConfigMap 被标记为不可更改，撤销此操作或者更改 data 字段的内容都是不允许的，只能删除并重新创建这个 Secret。现有的 Pod 将维持对已删除 Secret 的挂载点，所以我们也是建议重新创建这些 Pod。</p>
</blockquote>
<h2 id="Secret-vs-ConfigMap"><a href="#Secret-vs-ConfigMap" class="headerlink" title="Secret vs ConfigMap"></a>Secret vs ConfigMap</h2><p>最后我们来对比下 <code>Secret</code> 和 <code>ConfigMap</code>这两种资源对象的异同点：</p>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>key&#x2F;value的形式</li>
<li>属于某个特定的命名空间</li>
<li>可以导出到环境变量</li>
<li>可以通过目录&#x2F;文件形式挂载</li>
<li>通过 volume 挂载的配置信息均可热更新</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>Secret 可以被 ServerAccount 关联</li>
<li>Secret 可以存储 <code>docker register</code> 的鉴权信息，用在 <code>ImagePullSecret</code> 参数中，用于拉取私有仓库的镜像</li>
<li>Secret 支持 <code>Base64</code> 加密</li>
<li>Secret 分为 <code>kubernetes.io/service-account-token</code>、<code>kubernetes.io/dockerconfigjson</code>、<code>Opaque</code> 三种类型，而 <code>Configmap</code> 不区分类型</li>
</ul>
<p>使用注意</p>
<p>同样 Secret 文件大小限制为 <code>1MB</code>（ETCD 的要求）；Secret 虽然采用 <code>Base64</code> 编码，但是我们还是可以很方便解码获取到原始信息，所以对于非常重要的数据还是需要慎重考虑，可以考虑使用 <a target="_blank" rel="noopener" href="https://www.vaultproject.io/">Vault</a> 来进行加密管理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Security%20Context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Security%20Context/" class="post-title-link" itemprop="url">Security Context</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:54:59" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">配置管理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Security-Context"><a href="#Security-Context" class="headerlink" title="Security Context"></a>Security Context</h1><p><img data-src="https://mudutestmenu.mudu.tv/upload/yg32hq.jpg" alt="Security Context"></p>
<p>我们有时候在运行一个容器的时候，可能需要使用 <code>sysctl</code> 命令来修改内核参数，比如 <code>net</code>、<code>vm</code>、<code>kernel</code> 等参数，但是 <code>systcl</code> 需要容器拥有超级权限，才可以使用，在 Docker 容器启动的时候我们可以加上 <code>--privileged</code> 参数来使用特权模式。那么在 Kubernetes 中应该如何来使用呢？</p>
<p>这个时候我们就需要使用到 Kubernetes 中的 <code>Security Context</code>，也就是常说的安全上下文，主要是来限制容器非法操作宿主节点的系统级别的内容，使得节点的系统或者节点上其他容器组受到影响。Kubernetes 提供了三种配置安全上下文级别的方法：</p>
<ul>
<li><code>Container-level Security Context</code>：仅应用到指定的容器</li>
<li><code>Pod-level Security Context</code>：应用到 Pod 内所有容器以及 Volume</li>
<li><code>Pod Security Policies（PSP，废弃）</code>：应用到集群内部所有 Pod 以及 Volume</li>
</ul>
<p>我们可以用如下几种方式来设置 <code>Security Context</code>：</p>
<ul>
<li>访问权限控制：根据用户 ID（UID）和组 ID（GID）来限制对资源（比如：文件）的访问权限</li>
<li>Security Enhanced Linux (SELinux)：为对象分配 <code>SELinux</code> 标签</li>
<li>以 privileged（特权）模式运行</li>
<li>Linux Capabilities：给某个特定的进程超级权限，而不用给 root 用户所有的 privileged 权限</li>
<li>AppArmor：使用程序文件来限制单个程序的权限</li>
<li>Seccomp：过滤容器中进程的系统调用（system call）</li>
<li>AllowPrivilegeEscalation（允许特权扩大）：此项配置是一个布尔值，定义了一个进程是否可以比其父进程获得更多的特权，直接效果是，容器的进程上是否被设置 <code>no_new_privs</code> 标记。当出现如下情况时，AllowPrivilegeEscalation 的值始终为 true：<ul>
<li>容器以 <code>privileged</code> 模式运行</li>
<li>容器拥有 <code>CAP_SYS_ADMIN</code> 的 Linux Capability</li>
</ul>
</li>
</ul>
<h2 id="为-Pod-设置-Security-Context"><a href="#为-Pod-设置-Security-Context" class="headerlink" title="为 Pod 设置 Security Context"></a>为 Pod 设置 Security Context</h2><p>我们只需要在 Pod 定义的资源清单文件中添加 <code>securityContext</code> 字段，就可以为 Pod 指定安全上下文相关的设定，通过该字段指定的内容将会对当前 Pod 中的所有容器生效。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">security-context-pod-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sec-ctx-vol</span></span><br><span class="line">      <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">securityContext:</span></span><br><span class="line">    <span class="attr">runAsUser:</span> <span class="number">1000</span></span><br><span class="line">    <span class="attr">runAsGroup:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">fsGroup:</span> <span class="number">2000</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sec-ctx-demo</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;sleep 60m&#x27;</span>]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sec-ctx-vol</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/pod/demo</span></span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<p>在当前资源清单文件中我们在 Pod 下面添加了 <code>securityContext</code> 字段，其中：</p>
<ul>
<li><code>runAsUser</code> 字段指定了该 Pod 中所有容器的进程都以 UID 1000 的身份运行</li>
<li><code>runAsGroup</code> 字段指定了该 Pod 中所有容器的进程都以 GID 3000 的身份运行<ul>
<li>如果省略该字段，容器进程的 GID 为 <code>root(0)</code></li>
<li>容器中创建的文件，其所有者为 userID 1000，groupID 3000</li>
</ul>
</li>
<li><code>fsGroup</code> 字段指定了该 Pod 的 fsGroup 为 2000<ul>
<li>数据卷 （对应挂载点 <code>/pod/demo</code> 的数据卷为 <code>sec-ctx-demo</code>） 的所有者以及在该数据卷下创建的任何文件，其 GID 都为 2000</li>
</ul>
</li>
</ul>
<p>下表是我们常用的一些 <code>securityContext</code> 字段设置内容介绍：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1662431444209.jpg" alt="Security Context List"></p>
<p>直接创建上面的 Pod 对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f security-context-pod-demo-1.yaml</span><br><span class="line">➜  ~ kubectl get pods</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">security-context-pod-demo   1/1     Running   0          6m45s</span><br></pre></td></tr></table></figure>



<p>运行完成后，我们可以验证下容器中的进程运行的 ownership：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl exec security-context-pod-demo top</span><br><span class="line">Mem: 7586020K used, 422948K free, 298660K shrd, 1247656K buff, 3867660K cached</span><br><span class="line">CPU:  2.1% usr  1.0% sys  0.0% nic 96.3% idle  0.2% io  0.0% irq  0.0% sirq</span><br><span class="line">Load average: 0.30 0.35 0.35 1/956 50</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND</span><br><span class="line">   46     0 1000     R     1292  0.0   0  0.0 top</span><br><span class="line">    1     0 1000     S     1280  0.0   0  0.0 sleep 60m</span><br></pre></td></tr></table></figure>



<p>我们直接运行一个 <code>top</code> 进程，查看容器中的所有正在执行的进程，我们可以看到 USER ID 都为 1000（<code>runAsUser</code> 指定的），然后查看下挂载的数据卷的 ownership：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl exec security-context-pod-demo -- ls -la /pod</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x    3 root     root          4096 Nov 26 15:44 .</span><br><span class="line">drwxr-xr-x    1 root     root          4096 Nov 26 15:44 ..</span><br><span class="line">drwxrwsrwx    2 root     2000             6 Nov 26 15:43 demo</span><br></pre></td></tr></table></figure>



<p>因为上面我们指定了 <code>fsGroup=2000</code>，所以声明挂载的数据卷 <code>/pod/demo</code> 的 GID 也变成了 2000。直接调用容器中的 id 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl exec security-context-pod-demo id</span><br><span class="line">uid=1000 gid=3000 groups=2000</span><br></pre></td></tr></table></figure>



<p>我们可以看到 gid 为 3000，与 <code>runAsGroup</code> 字段所指定的一致，如果 <code>runAsGroup</code> 字段被省略，则 gid 取值为 0（即 root），此时容器中的进程将可以操作 root Group 的文件。</p>
<p>比如我们现在想要去删除容器中的 <code>/tmp</code> 目录就没有权限了，因为该目录的用户和组都是 root，而我们当前要去删除使用的进程的 ID 号就变成了 1000:3000，所以没有权限操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl exec security-context-pod-demo -- ls -la /tmp</span><br><span class="line">total 8</span><br><span class="line">drwxrwxrwt    2 root     root          4096 Oct 29 02:40 .</span><br><span class="line">drwxr-xr-x    1 root     root          4096 Nov 26 15:44 ..</span><br><span class="line">➜  ~ kubectl exec security-context-pod-demo -- rm -rf /tmp</span><br><span class="line">rm: can&#x27;t remove &#x27;/tmp&#x27;: Permission denied</span><br></pre></td></tr></table></figure>



<h2 id="为容器设置-Security-Context"><a href="#为容器设置-Security-Context" class="headerlink" title="为容器设置 Security Context"></a>为容器设置 Security Context</h2><p>除了在 Pod 中可以设置安全上下文之外，我们还可以单独为某个容器设置安全上下文，同样也是通过 <code>securityContext</code> 字段设置，当该字段的配置与 Pod 级别的 securityContext 配置相冲突时，容器级别的配置将覆盖 Pod 级别的配置。容器级别的 securityContext 不影响 Pod 中的数据卷。如下资源清单所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">security-context-container-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">securityContext:</span></span><br><span class="line">    <span class="attr">runAsUser:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sec-ctx-demo</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;sleep 60m&#x27;</span>]</span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">runAsUser:</span> <span class="number">2000</span></span><br><span class="line">        <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<p>直接创建上面的 Pod 对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f https:/www.qikqiak.com/k8strain/security/manifests/security-context-pod-demo-2.yaml</span><br><span class="line">➜  ~ kubectl get pods</span><br><span class="line">NAME                              READY   STATUS              RESTARTS   AGE</span><br><span class="line">security-context-container-demo   1/1     Running             0          5s</span><br></pre></td></tr></table></figure>



<p>同样我们直接执行容器中的 <code>top</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl exec security-context-container-demo top</span><br><span class="line">Mem: 4991896K used, 3016924K free, 52308K shrd, 158364K buff, 3282996K cached</span><br><span class="line">CPU:  2.6% usr  7.8% sys  2.6% nic 86.8% idle  0.0% io  0.0% irq  0.0% sirq</span><br><span class="line">Load average: 0.12 0.09 0.12 1/848 10</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND</span><br><span class="line">    6     0 2000     R     1292  0.0   1  0.0 top</span><br><span class="line">    1     0 2000     S     1280  0.0   3  0.0 sleep 60m</span><br></pre></td></tr></table></figure>



<p>容器的进程以 UID 2000 的身份运行，该取值由 <code>spec.containers[*].securityContext.runAsUser</code> 容器组中的字段定义。Pod 中定义的 <code>spec.securityContext.runAsUser</code> 取值 1000 被覆盖。</p>
<h2 id="设置-Linux-Capabilities"><a href="#设置-Linux-Capabilities" class="headerlink" title="设置 Linux Capabilities"></a>设置 Linux Capabilities</h2><p>我们使用 <code>docker/nerdctl run</code> 的时候可以通过 <code>--cap-add</code> 和 <code>--cap-drop</code> 命令来给容器添加 <code>Linux Capabilities</code>。那么在 Kubernetes 下面如何来设置呢？要了解如何设置，首先我们还是需要了解下 <code>Linux Capabilities</code> 是什么？</p>
<h3 id="Linux-Capabilities"><a href="#Linux-Capabilities" class="headerlink" title="Linux Capabilities"></a>Linux Capabilities</h3><p>要了解 <code>Linux Capabilities</code>，这就得从 Linux 的权限控制发展来说明。在 Linux 2.2 版本之前，当内核对进程进行权限验证的时候，Linux 将进程划分为两类：特权进程（UID&#x3D;0，也就是超级用户）和非特权进程（UID!&#x3D;0），特权进程拥有所有的内核权限，而非特权进程则根据进程凭证（effective UID, effective GID，supplementary group 等）进行权限检查。</p>
<p>比如我们以常用的 <code>passwd</code> 命令为例，修改用户密码需要具有 root 权限，而普通用户是没有这个权限的。但是实际上普通用户又可以修改自己的密码，这是怎么回事呢？在 Linux 的权限控制机制中，有一类比较特殊的权限设置，比如 SUID(Set User ID on execution)，允许用户以可执行文件的 owner 的权限来运行可执行文件。因为程序文件 <code>/bin/passwd</code> 被设置了 <code>SUID</code> 标识，所以普通用户在执行 passwd 命令时，进程是以 passwd 的所有者，也就是 root 用户的身份运行，从而就可以修改密码了。</p>
<p>但是使用 <code>SUID</code> 却带来了新的安全隐患，当我们运行设置了 <code>SUID</code> 的命令时，通常只是需要很小一部分的特权，但是 <code>SUID</code> 却给了它 root 具有的全部权限，一旦 被设置了 <code>SUID</code> 的命令出现漏洞，是不是就很容易被利用了。</p>
<p>为此 Linux 引入了 <code>Capabilities</code> 机制来对 root 权限进行了更加细粒度的控制，实现按需进行授权，这样就大大减小了系统的安全隐患。</p>
<h4 id="什么是-Capabilities"><a href="#什么是-Capabilities" class="headerlink" title="什么是 Capabilities"></a>什么是 Capabilities</h4><p>从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 <code>capabilites</code>。<code>Capabilites</code> 每个单元都可以独立启用和禁用。这样当系统在作权限检查的时候就变成了：<strong>在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作</strong>。比如如果我们要设置系统时间，就得具有 <code>CAP_SYS_TIME</code> 这个 capabilites。下面是从 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities man page</a> 中摘取的 capabilites 列表：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/ymvrfw.jpg" alt="linux capabilities list"></p>
<h4 id="如何使用-Capabilities"><a href="#如何使用-Capabilities" class="headerlink" title="如何使用 Capabilities"></a>如何使用 Capabilities</h4><p>我们可以通过 <code>getcap</code> 和 <code>setcap</code> 两条命令来分别查看和设置程序文件的 <code>capabilities</code> 属性。比如当前我们是<code>test</code> 这个用户，使用 <code>getcap</code> 命令查看 <code>ping</code> 命令目前具有的 <code>capabilities</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ll /bin/ping</span><br><span class="line">-rwxr-xr-x. 1 root root 66176 Aug  4  2017 /bin/ping</span><br><span class="line">➜  ~ getcap /bin/ping</span><br><span class="line">/bin/ping = cap_net_admin,cap_net_raw+p</span><br></pre></td></tr></table></figure>



<p>我们可以看到具有 <code>cap_net_admin</code> 这个属性，所以我们现在可以执行 <code>ping</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ping www.qikqiak.com</span><br><span class="line">PING www.qikqiak.com.w.kunlungr.com (115.223.14.186) 56(84) bytes of data.</span><br><span class="line">64 bytes from 115.223.14.186 (115.223.14.186): icmp_seq=1 ttl=54 time=7.87 ms</span><br><span class="line">64 bytes from 115.223.14.186 (115.223.14.186): icmp_seq=2 ttl=54 time=7.85 ms</span><br></pre></td></tr></table></figure>



<p>但是如果我们把命令的 <code>capabilities</code> 属性移除掉：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo setcap cap_net_admin,cap_net_raw-p /bin/ping</span><br><span class="line">➜  ~ getcap /bin/ping</span><br><span class="line">/bin/ping =</span><br></pre></td></tr></table></figure>



<p>这个时候我们执行 <code>ping</code> 命令可以发现已经没有权限了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ping www.qikqiak.com</span><br><span class="line">ping: socket: Operation not permitted</span><br></pre></td></tr></table></figure>



<p>因为 ping 命令在执行时需要访问网络，所需的 <code>capabilities</code> 为 <code>cap_net_admin</code> 和 <code>cap_net_raw</code>，所以我们可以通过 <code>setcap</code> 命令可来添加它们：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo setcap cap_net_admin,cap_net_raw+p /bin/ping</span><br><span class="line">➜  ~ getcap /bin/ping</span><br><span class="line">/bin/ping = cap_net_admin,cap_net_raw+p</span><br><span class="line">➜  ~ ping www.qikqiak.com</span><br><span class="line">PING www.qikqiak.com.w.kunlungr.com (115.223.14.188) 56(84) bytes of data.</span><br><span class="line">64 bytes from 115.223.14.188 (115.223.14.188): icmp_seq=1 ttl=54 time=7.39 ms</span><br></pre></td></tr></table></figure>



<p>命令中的 <code>p</code> 表示 <code>Permitted</code> 集合(接下来会介绍)，<code>+</code> 号表示把指定的<code>capabilities</code> 添加到这些集合中，<code>-</code> 号表示从集合中移除。</p>
<p>对于可执行文件的属性中有三个集合来保存三类 <code>capabilities</code>，它们分别是：</p>
<ul>
<li>Permitted：在进程执行时，Permitted 集合中的 capabilites 自动被加入到进程的 Permitted 集合中。</li>
<li>Inheritable：Inheritable 集合中的 capabilites 会与进程的 Inheritable 集合执行与操作，以确定进程在执行 execve 函数后哪些 capabilites 被继承。</li>
<li>Effective：Effective 只是一个 bit。如果设置为开启，那么在执行 execve 函数后，Permitted 集合中新增的 capabilities 会自动出现在进程的 Effective 集合中。</li>
</ul>
<p>对于进程中有五种 <code>capabilities</code> 集合类型，相比文件的 <code>capabilites</code>，进程的 <code>capabilities</code> 多了两个集合，分别是 <code>Bounding</code> 和 <code>Ambient</code>。</p>
<p>我们可以通过下面的命名来查看当前进程的 <code>capabilities</code> 信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /proc/7029/status | grep &#x27;Cap&#x27;  #7029为PID</span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 0000000000000000</span><br><span class="line">CapEff: 0000000000000000</span><br><span class="line">CapBnd: 0000001fffffffff</span><br><span class="line">CapAmb: 0000000000000000</span><br></pre></td></tr></table></figure>



<p>然后我们可以使用 <code>capsh</code> 命令把它们转义为可读的格式，这样基本可以看出进程具有的 <code>capabilities</code> 了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ capsh --decode=0000001fffffffff</span><br><span class="line">0x0000001fffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,35,36</span><br></pre></td></tr></table></figure>



<h3 id="Container-Runtime-Capabilities"><a href="#Container-Runtime-Capabilities" class="headerlink" title="Container Runtime Capabilities"></a>Container Runtime Capabilities</h3><p>我们说容器本质上就是一个进程，所以理论上容器就会和进程一样会有一些默认的开放权限，默认情况下 Docker&#x2F;Containerd 会删除必须的 <code>capabilities</code> 之外的所有 <code>capabilities</code>，因为在容器中我们经常会以 root 用户来运行，使用 <code>capabilities</code> 现在后，容器中的使用的 root 用户权限就比我们平时在宿主机上使用的 root 用户权限要少很多了，这样即使出现了安全漏洞，也很难破坏或者获取宿主机的 root 权限，所以 Docker&#x2F;Containerd 支持 <code>Capabilities</code> 对于容器的安全性来说是非常有必要的。</p>
<p>不过我们在运行容器的时候可以通过指定 <code>--privileded</code> 参数来开启容器的超级权限，这个参数一定要慎用，因为他会获取系统 root 用户所有能力赋值给容器，并且会扫描宿主机的所有设备文件挂载到容器内部，所以是非常危险的操作。</p>
<p>但是如果你确实需要一些特殊的权限，我们可以通过 <code>--cap-add</code> 和 <code>--cap-drop</code> 这两个参数来动态调整，可以最大限度地保证容器的使用安全。下面表格中列出的 <code>Capabilities</code> 是 Docker 默认给容器添加的，我们可以通过 <code>--cap-drop</code> 去除其中一个或者多个：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/9bhohc.jpg" alt="docker capabilities"></p>
<p>下面表格中列出的 <code>Capabilities</code> 是 Docker 默认删除的，我们可以通过<code>--cap-add</code>添加其中一个或者多个：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/vdjb4e.jpg" alt="docker drop capabilities"></p>
<blockquote>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--cap-add`和`--cap-drop` 这两参数都支持`ALL`值，比如如果你想让某个容器拥有除了`MKNOD`之外的所有内核权限，那么可以执行下面的命令： `➜ ~ sudo docker run --cap-add=ALL --cap-drop=MKNOD ...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>比如现在我们需要修改网络接口数据，默认情况下是没有权限的，因为需要的 <code>NET_ADMIN</code> 这个 <code>Capabilities</code> 默认被移除了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker 一样的方式</span></span><br><span class="line">➜  ~ nerdctl run -it --rm busybox /bin/sh</span><br><span class="line">/ # ip link add dummy0 type dummy</span><br><span class="line">ip: RTNETLINK answers: Operation not permitted</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>



<p>所以在不使用 <code>--privileged</code> 的情况下（不建议）我们可以使用 <code>--cap-add=NET_ADMIN</code> 将这个 <code>Capabilities</code> 添加回来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl run -it --rm --cap-add=NET_ADMIN busybox /bin/sh</span><br><span class="line">/ # ip link add dummy0 type dummy</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>



<p>可以看到已经 OK 了。</p>
<h3 id="Kubernetes-配置-Capabilities"><a href="#Kubernetes-配置-Capabilities" class="headerlink" title="Kubernetes 配置 Capabilities"></a>Kubernetes 配置 Capabilities</h3><p>上面我介绍了在 Docker 容器下如何来配置 <code>Capabilities</code>，在 Kubernetes 中也可以很方便的来定义，我们只需要添加到 Pod 定义的 <code>spec.containers.securityContext.capabilities</code>中即可，也可以进行 <code>add</code> 和 <code>drop</code> 配置，同样上面的示例，我们要给 busybox 容器添加 <code>NET_ADMIN</code> 这个 <code>Capabilities</code>，对应的 YAML 文件可以这样定义：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cpb-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cpb-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cpb</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;3600&#x27;</span></span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">capabilities:</span></span><br><span class="line">          <span class="attr">add:</span> <span class="comment"># 添加</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line">          <span class="attr">drop:</span> <span class="comment"># 删除</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">KILL</span></span><br></pre></td></tr></table></figure>



<p>我们在 <code>securityContext</code> 下面添加了 <code>capabilities</code> 字段，其中添加了 <code>NET_ADMIN</code> 并且删除了 <code>KILL</code> 这个默认的容器 <code>Capabilities</code>，这样我们就可以在 Pod 中修改网络接口数据了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f cpb-demo.yaml</span><br><span class="line">➜  ~ kubectl get pods</span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">cpb-demo                  1/1     Running   0          2m9s</span><br><span class="line">➜  ~ kubectl exec -it cpb-demo /bin/sh</span><br><span class="line">/ # ip link add dummy0 type dummy</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>



<p>在 Kubernetes 中通过 <code>containers.securityContext.capabilities</code> 进行配置容器的 <code>Capabilities</code>，当然最终还是通过容器运行时的 <code>libcontainer</code> 去借助 <code>Linux kernel capabilities</code> 实现的权限管理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Service/" class="post-title-link" itemprop="url">Service</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:55:05" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>我们前面的课程中学习了一些常用控制器的基本用法，我们也了解到 Pod 的生命是有限的，死亡过后不会复活了。然后我们知道可以用 ReplicaSet 和 Deployment 来动态的创建和销毁 Pod，每个 Pod 都有自己的 IP 地址，但是如果 Pod 重建了的话那么他的 IP 很有可能也就变化了。这就会带来一个问题：比如我们有一些后端的 Pod 集合为集群中的其他应用提供 API 服务，如果我们在前端应用中把所有的这些后端的 Pod 的地址都写死，然后以某种方式去访问其中一个 Pod 的服务，这样看上去是可以工作的，对吧？但是如果这个 Pod 挂掉了，然后重新启动起来了，是不是 IP 地址非常有可能就变了，这个时候前端就极大可能访问不到后端的服务了。</p>
<p>遇到这样的问题该怎么解决呢？在没有使用 Kubernetes 之前，我相信可能很多同学都遇到过这样的问题，不一定是 IP 变化的问题，比如我们在部署一个 WEB 服务的时候，前端一般部署一个 Nginx 作为服务的入口，然后 Nginx 后面肯定就是挂载的这个服务的大量后端服务，很早以前我们可能是去手动更改 Nginx 配置中的 upstream 选项，来动态改变提供服务的数量，到后面出现了一些服务发现的工具，比如 Consul、ZooKeeper 还有我们熟悉的 etcd 等工具，有了这些工具过后我们就可以只需要把我们的服务注册到这些服务发现中心去就可以，然后让这些工具动态的去更新 Nginx 的配置就可以了，我们完全不用去手工的操作了，是不是非常方便。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/0dx0dj.jpg" alt="nginx consul"></p>
<p>同样的，要解决我们上面遇到的问题是不是实现一个服务发现的工具也可以解决？没错的，当我们 Pod 被销毁或者新建过后，我们可以把这个 Pod 的地址注册到这个服务发现中心去就可以，但是这样的话我们的前端应用就不能直接去连接后台的 Pod 集合了，应该连接到一个能够做服务发现的中间件上面，对吧？</p>
<p>为解决这个问题 Kubernetes 就为我们提供了这样的一个对象 - Service，Service 是一种抽象的对象，它定义了一组 Pod 的逻辑集合和一个用于访问它们的策略，其实这个概念和微服务非常类似。一个 Serivce 下面包含的 Pod 集合是由 Label Selector 来决定的。</p>
<p>比如我们上面的例子，假如我们后端运行了 3 个副本，这些副本都是可以替代的，因为前端并不关心它们使用的是哪一个后端服务。尽管由于各种原因后端的 Pod 集合会发送变化，但是前端却不需要知道这些变化，也不需要自己用一个列表来记录这些后端的服务，Service 的这种抽象就可以帮我们达到这种解耦的目的。</p>
<h2 id="三种-IP"><a href="#三种-IP" class="headerlink" title="三种 IP"></a>三种 IP</h2><p>在继续往下学习 Service 之前，我们需要先弄明白 Kubernetes 系统中的三种 IP，因为经常有同学混乱。</p>
<ul>
<li>Node IP：Node 节点的 IP 地址</li>
<li>Pod IP: Pod 的 IP 地址</li>
<li>Cluster IP: Service 的 IP 地址</li>
</ul>
<p>首先，Node IP 是 Kubernetes 集群中节点的物理网卡 IP 地址(一般为内网)，所有属于这个网络的服务器之间都可以直接通信，所以 Kubernetes 集群外要想访问 Kubernetes 集群内部的某个节点或者服务，肯定得通过 Node IP 进行通信（这个时候一般是通过外网 IP 了）</p>
<p>然后 Pod IP 是每个 Pod 的 IP 地址，它是网络插件进行分配的，前面我们已经讲解过</p>
<p>最后 Cluster IP 是一个虚拟的 IP，仅仅作用于 Kubernetes Service 这个对象，由 Kubernetes 自己来进行管理和分配地址。</p>
<h2 id="定义-Service"><a href="#定义-Service" class="headerlink" title="定义 Service"></a>定义 Service</h2><p>定义 Service 的方式和我们前面定义的各种资源对象的方式类型，例如，假定我们有一组 Pod 服务，它们对外暴露了 8080 端口，同时都被打上了 app&#x3D;myapp 这样的标签，那么我们就可以像下面这样来定义一个 Service 对象：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myservice</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">myapp-http</span></span><br></pre></td></tr></table></figure>



<p>然后通过的使用 <code>kubectl create -f myservice.yaml</code> 就可以创建一个名为 myservice 的 Service 对象，它会将请求代理到使用 TCP 端口为 8080，具有标签 <code>app=myapp</code> 的 Pod 上，这个 Service 会被系统分配一个我们上面说的 Cluster IP，该 Service 还会持续的监听 selector 下面的 Pod，会把这些 Pod 信息更新到一个名为 myservice 的 Endpoints 对象上去，这个对象就类似于我们上面说的 Pod 集合了。</p>
<p>需要注意的是，Service 能够将一个接收端口映射到任意的 targetPort。默认情况下，targetPort 将被设置为与 port 字段相同的值。可能更有趣的是，targetPort 可以是一个字符串，引用了 backend Pod 的一个端口的名称。因实际指派给该端口名称的端口号，在每个 backend Pod 中可能并不相同，所以对于部署和设计 Service，这种方式会提供更大的灵活性。</p>
<p>另外 Service 能够支持 TCP 和 UDP 协议，默认是 TCP 协议。</p>
<h2 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h2><p>前面我们讲到过，在 Kubernetes 集群中，每个 Node 会运行一个 kube-proxy 进程, 负责为 Service 实现一种 VIP（虚拟 IP，就是我们上面说的 clusterIP）的代理形式，现在的 Kubernetes 中默认是使用的 iptables 这种模式来代理。</p>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>这种模式，kube-proxy 会 watch apiserver 对 Service 对象和 Endpoints 对象的添加和移除。对每个 Service，它会添加上 iptables 规则，从而捕获到达该 Service 的 clusterIP（虚拟 IP）和端口的请求，进而将请求重定向到 Service 的一组 backend 中的某一个 Pod 上面。我们还可以使用 <code>Pod readiness 探针</code> 验证后端 Pod 可以正常工作，以便 iptables 模式下的 kube-proxy 仅看到测试正常的后端，这样做意味着可以避免将流量通过 <code>kube-proxy</code> 发送到已知失败的 Pod 中，所以对于线上的应用来说一定要做 readiness 探针。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1662434331870.png" alt="service iptables"></p>
<p>iptables 模式的 kube-proxy 默认的策略是，随机选择一个后端 Pod。</p>
<p>比如当创建 backend Service 时，Kubernetes 会给它指派一个虚拟 IP 地址，比如 10.0.0.1。假设 Service 的端口是 1234，该 Service 会被集群中所有的 kube-proxy 实例观察到。当 kube-proxy 看到一个新的 Service，它会安装一系列的 iptables 规则，从 VIP 重定向到 <code>per-Service</code> 规则。 该 <code>per-Service</code> 规则连接到 <code>per-Endpoint</code> 规则，该 <code>per-Endpoint</code> 规则会重定向（目标 <code>NAT</code>）到后端的 Pod。</p>
<h3 id="ipvs"><a href="#ipvs" class="headerlink" title="ipvs"></a>ipvs</h3><p>除了 iptables 模式之外，kubernetes 也支持 ipvs 模式，在 ipvs 模式下，kube-proxy watch Kubernetes 服务和端点，调用 <code>netlink</code> 接口相应地创建 IPVS 规则， 并定期将 IPVS 规则与 Kubernetes 服务和端点同步。该控制循环可确保 IPVS 状态与所需状态匹配。访问服务时，IPVS 　将流量定向到后端 Pod 之一。</p>
<p>IPVS 代理模式基于类似于 iptables 模式的 netfilter 钩子函数，但是使用<strong>哈希表</strong>作为基础数据结构，并且在内核空间中工作。 所以与 iptables 模式下的 kube-proxy 相比，IPVS 模式下的 kube-proxy 重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。与其他代理模式相比，IPVS 模式还支持更高的网络流量吞吐量。所以对于较大规模的集群会使用 ipvs 模式的 kube-proxy，只需要满足节点上运行 ipvs 的条件，然后我们就可以直接将 kube-proxy 的模式修改为 ipvs，如果不满足运行条件会自动降级为 iptables 模式，现在都推荐使用 ipvs 模式，可以大幅度提高 Service 性能。</p>
<p>IPVS 提供了更多选项来平衡后端 Pod 的流量，默认是 <code>rr</code>，有如下一些策略：</p>
<ul>
<li>rr: round-robin</li>
<li>lc: least connection (smallest number of open connections)</li>
<li>dh: destination hashing</li>
<li>sh: source hashing</li>
<li>sed: shortest expected delay</li>
<li>nq: never queue</li>
</ul>
<p>不过现在只能整体修改策略，可以通过 kube-proxy 中配置 <code>–ipvs-scheduler</code> 参数来实现，暂时不支持特定的 Service 进行配置。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/1662434366375.png" alt="service ipvs"></p>
<p>我们也可以实现基于客户端 IP 的会话亲和性，可以将 service.spec.sessionAffinity 的值设置为 “ClientIP” （默认值为 “None”）即可，此外还可以通过适当设置 <code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> 来设置最大会话停留时间（默认值为 10800 秒，即 3 小时）:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">ClientIP</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure>



<p>亲和性</p>
<p>Service 只支持两种形式的会话亲和性服务：None 和 ClientIP，不支持基于 cookie 的会话亲和性，这是因为 Service 不是在 HTTP 层面上工作的，处理的是 TCP 和 UDP 包，并不关心其中的载荷内容，因为 cookie 是 HTTP 协议的一部分，Service 并不知道它们，所有会话亲和性不能基于 Cookie。</p>
<h2 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h2><p>我们在定义 Service 的时候可以指定一个自己需要的类型的 Service，如果不指定的话默认是 <code>ClusterIP</code>类型。</p>
<p>我们可以使用的服务类型如下：</p>
<ul>
<li>ClusterIP：通过集群的内部 IP 暴露服务，选择该值，服务只能够在集群内部可以访问，这也是默认的服务类型。</li>
<li>NodePort：通过<strong>每个 Node 节点</strong>上的 IP 和静态端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求 <code>NodeIp:NodePort</code>，可以从集群的外部访问一个 NodePort 服务。</li>
<li>LoadBalancer：使用云提供商的负载局衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务，这个需要结合具体的云厂商进行操作。</li>
<li>ExternalName：通过返回 <code>CNAME</code> 和它的值，可以将服务映射到 <code>externalName</code> 字段的内容（例如， foo.bar.example.com）。</li>
</ul>
<h3 id="NodePort-类型"><a href="#NodePort-类型" class="headerlink" title="NodePort 类型"></a>NodePort 类型</h3><p>如果设置 type 的值为 “NodePort”，Kubernetes master 将从给定的配置范围内（默认：30000-32767）分配端口，每个 Node 将从该端口（每个 Node 上的同一端口）代理到 Service。该端口将通过 Service 的 <code>spec.ports[*].nodePort</code> 字段被指定，如果不指定的话会自动生成一个端口。</p>
<p>需要注意的是，Service 将能够通过 <code>spec.ports[].nodePort</code> 和 <code>spec.clusterIp:spec.ports[].port</code> 而对外可见。</p>
<p>接下来我们来给大家创建一个 NodePort 的服务来访问我们前面的 Nginx 服务：(service-nodeport-demo.yaml)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myservice</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">myapp-http</span></span><br></pre></td></tr></table></figure>



<p>创建该 Service:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f service-demo.yaml</span><br></pre></td></tr></table></figure>



<p>然后我们可以查看 Service 对象信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        27d</span><br><span class="line">myservice    NodePort    10.104.57.198   &lt;none&gt;        80:32560/TCP   14h</span><br></pre></td></tr></table></figure>



<p>我们可以看到 myservice 的 TYPE 类型已经变成了 NodePort，后面的 PORT(S) 部分也多了一个 32560 的映射端口。</p>
<h3 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h3><p>ExternalName 是 Service 的特例，它没有 <code>selector</code>，也没有定义任何的端口和 Endpoint。对于运行在集群外部的服务，它通过返回该外部服务的别名这种方式来提供服务。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">my.database.example.com</span></span><br></pre></td></tr></table></figure>



<p>当访问地址 <code>my-service.prod.svc.cluster.local</code>（后面服务发现的时候我们会再深入讲解）时，集群的 DNS 服务将返回一个值为 my.database.example.com 的 <code>CNAME</code> 记录。访问这个服务的工作方式与其它的相同，唯一不同的是重定向发生在 DNS 层，而且不会进行代理或转发。如果后续决定要将数据库迁移到 Kubernetes 集群中，可以启动对应的 Pod，增加合适的 Selector 或 Endpoint，修改 Service 的 type，完全不需要修改调用的代码，这样就完全解耦了。</p>
<p>除了可以直接通过 <code>externalName</code> 指定外部服务的域名之外，我们还可以通过自定义 Endpoints 来创建 Service，前提是 <code>clusterIP=None</code>，名称要和 Service 保持一致，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">etcd-k8s</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">etcd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">port</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">2379</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">etcd-k8s</span> <span class="comment"># 名称必须和 Service 一致</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">etcd</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">10.151</span><span class="number">.30</span><span class="number">.57</span> <span class="comment"># Service 将连接重定向到 endpoint</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">port</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">2379</span> <span class="comment"># endpoint 的目标端口</span></span><br></pre></td></tr></table></figure>



<p>上面这个服务就是将外部的 etcd 服务引入到 Kubernetes 集群中来。</p>
<h2 id="externalIPs"><a href="#externalIPs" class="headerlink" title="externalIPs"></a>externalIPs</h2><p>Service 的属性中还有一个 <code>externalIPs</code> 的属性，从 Kubernetes 官网文档可以看到该属性的相关描述：</p>
<blockquote>
<p>如果外部的 IP 路由到集群中一个或多个 Node 上，Kubernetes Service 会被暴露给这些 <code>externalIPs</code>。通过外部 IP（作为目的 IP 地址）进入到集群，传到 Service 的端口上的流量，将会被路由到 Service 的 Endpoint 上，<code>externalIPs</code> 不会被 Kubernetes 管理，它属于集群管理员的职责范畴。</p>
</blockquote>
<p>这里最重要的一点就是确保使用哪个 IP 来访问 Kubernetes 集群，使用外部 IP Service 类型，我们可以将 Service 绑定到连接集群的 IP。</p>
<blockquote>
<p>参考文档：<a target="_blank" rel="noopener" href="https://www.fadhil-blog.dev/blog/kubernetes-external-ip/">https://www.fadhil-blog.dev/blog/kubernetes-external-ip/</a></p>
</blockquote>
<h2 id="获取客户端-IP"><a href="#获取客户端-IP" class="headerlink" title="获取客户端 IP"></a>获取客户端 IP</h2><p>通常，当集群内的客户端连接到服务的时候，是支持服务的 Pod 可以获取到客户端的 IP 地址的，但是，当通过节点端口接收到连接时，由于对数据包执行了源网络地址转换（SNAT），因此数据包的源 IP 地址会发生变化，后端的 Pod 无法看到实际的客户端 IP，对于某些应用来说是个问题，比如，nginx 的请求日志就无法获取准确的客户端访问 IP 了，比如下面我们的应用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<p>直接创建后可以查看 nginx 服务被自动分配了一个 32761 的 NodePort 端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP        28d</span><br><span class="line">nginx        NodePort    10.106.190.194   &lt;none&gt;        80:32761/TCP   48m</span><br><span class="line">➜  ~ kubectl get pods -o wide</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE     IP             NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-54f57cf6bf-nwtjp            1/1     Running   0          3m      10.244.3.15    ydzs-node3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-54f57cf6bf-ptvgs            1/1     Running   0          2m59s   10.244.2.13    ydzs-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-54f57cf6bf-xhs8g            1/1     Running   0          2m59s   10.244.1.16    ydzs-node1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>



<p>我们可以看到这个 3 个 Pod 被分配到了 3 个不同的节点，这个时候我们通过 master 节点的 NodePort 端口来访问下我们的服务，因为我这里只有 master 节点可以访问外网，这个时候我们查看 nginx 的 Pod 日志可以看到其中获取到的 clientIP 是 <code>10.151.30.11</code>，其实是 master 节点的内网 IP，并不是我们期望的真正的浏览器端访问的 IP 地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl logs -f nginx-54f57cf6bf-xhs8g</span><br><span class="line">10.151.30.11 - - [07/Dec/2019:16:44:38 +0800] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure>



<p>这个是因为我们 master 节点上并没有对应的 Pod，所以通过 master 节点去访问应用的时候必然需要额外的网络跳转才能到达其他节点上 Pod，在跳转过程中由于对数据包进行了 SNAT，所以看到的是 master 节点的 IP。这个时候我们可以在 Service 设置 <code>externalTrafficPolicy</code> 来减少网络跳数：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Local</span></span><br></pre></td></tr></table></figure>



<p>如果 Service 中配置了 <code>externalTrafficPolicy=Local</code>，并且通过服务的节点端口来打开外部连接，则 Service 会代理到本地运行的 Pod，如果本地没有本地 Pod 存在，则连接将挂起，比如我们这里设置上该字段更新，这个时候我们去通过 master 节点的 NodePort 访问应用是访问不到的，因为 master 节点上并没有对应的 Pod 运行，所以需要确保负载均衡器将连接转发给至少具有一个 Pod 的节点。</p>
<p>但是需要注意的是使用这个参数有一个缺点，通常情况下，请求都是均匀分布在所有 Pod 上的，但是使用了这个配置的话，情况就有可能不一样了。比如我们有两个节点上运行了 3 个 Pod，假如节点 A 运行一个 Pod，节点 B 运行两个 Pod，如果负载均衡器在两个节点间均衡分布连接，则节点 A 上的 Pod 将接收到所有请求的 50%，但节点 B 上的两个 Pod 每个就只接收 25% 。</p>
<p>由于增加了<code>externalTrafficPolicy: Local</code>这个配置后，接收请求的节点和目标 Pod 都在一个节点上，所以没有额外的网络跳转（不执行 SNAT），所以就可以拿到正确的客户端 IP，如下所示我们把 Pod 都固定到 master 节点上：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">&#x27;Exists&#x27;</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">kubernetes.io/hostname:</span> <span class="string">ydzs-master</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Local</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<p>更新服务后，然后再通过 NodePort 访问服务可以看到拿到的就是正确的客户端 IP 地址了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl logs -f nginx-ddc8f997b-ptb7b</span><br><span class="line">182.149.166.11 - - [07/Dec/2019:17:03:43 +0800] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/StatefulSet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/StatefulSet/" class="post-title-link" itemprop="url">StatefulSet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:06:04" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E6%8E%A7%E5%88%B6%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">控制器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="StatefulSet-控制器"><a href="#StatefulSet-控制器" class="headerlink" title="StatefulSet 控制器"></a>StatefulSet 控制器</h1><p>前面我们学习了 Deployment 和 ReplicaSet 两种资源对象得使用，在实际使用的过程中，Deployment 并不能编排所有类型的应用，对<strong>无状态服务</strong>编排是非常容易的，但是对于<strong>有状态服务</strong>就无能为力了。我们需要先明白一个概念：什么是有状态服务，什么是无状态服务。</p>
<ul>
<li><code>无状态服务（Stateless Service）</code>：该服务运行的实例不会在本地存储需要持久化的数据，并且多个实例对于同一个请求响应的结果是完全一致的，比如前面我们讲解的 WordPress 实例，我们是不是可以同时启动多个实例，但是我们访问任意一个实例得到的结果都是一样的吧？因为他唯一需要持久化的数据是存储在 MySQL 数据库中的，所以我们可以说 WordPress 这个应用是无状态服务，但是 MySQL 数据库就不是了，因为他需要把数据持久化到本地。</li>
<li><code>有状态服务（Stateful Service）</code>：就和上面的概念是对立的了，该服务运行的实例需要在本地存储持久化数据，比如上面的 MySQL 数据库，你现在运行在节点 A，那么他的数据就存储在节点 A 上面的，如果这个时候你把该服务迁移到节点 B 去的话，那么就没有之前的数据了，因为他需要去对应的数据目录里面恢复数据，而此时没有任何数据。</li>
</ul>
<p>现在对<code>有状态</code>和<code>无状态</code>有一定的认识了吧，比如我们常见的 WEB 应用，是通过 Session 来保持用户的登录状态的，如果我们将 Session 持久化到节点上，那么该应用就是一个有状态的服务了，因为我现在登录进来你把我的 Session 持久化到节点 A 上了，下次我登录的时候可能会将请求路由到节点 B 上去了，但是节点 B 上根本就没有我当前的 Session 数据，就会被认为是未登录状态了，这样就导致我前后两次请求得到的结果不一致了。所以一般为了横向扩展，我们都会把这类 WEB 应用改成无状态的服务，怎么改？将 Session 数据存入一个公共的地方，比如 Redis 里面，是不是就可以了，对于一些客户端请求 API 的情况，我们就不使用 Session 来保持用户状态，改成用 Token 也是可以的。</p>
<p>无状态服务利用我们前面的 Deployment 可以很好的进行编排，对应有状态服务，需要考虑的细节就要多很多了，容器化应用程序最困难的任务之一，就是设计有状态分布式组件的部署体系结构。由于无状态组件没有预定义的<strong>启动顺序、集群要求、点对点 TCP 连接、唯一的网络标识符、正常的启动和终止要求</strong>等，因此可以很容易地进行容器化。诸如数据库，大数据分析系统，分布式 key&#x2F;value 存储、消息中间件需要有复杂的分布式体系结构，都可能会用到上述功能。为此，Kubernetes 引入了 <code>StatefulSet</code> 这种资源对象来支持这种复杂的需求。<code>StatefulSet</code> 类似于 <code>ReplicaSet</code>，但是它可以处理 Pod 的启动顺序，为保留每个 Pod 的状态设置唯一标识，具有以下几个功能特性：</p>
<ul>
<li>稳定的、唯一的网络标识符</li>
<li>稳定的、持久化的存储</li>
<li>有序的、优雅的部署和缩放</li>
<li>有序的、优雅的删除和终止</li>
<li>有序的、自动滚动更新</li>
</ul>
<h2 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h2><p>在我们学习 StatefulSet 对象之前，我们还必须了解一个新的概念：<code>Headless Service</code>。<code>Service</code> 其实在之前我们和大家提到过，Service 是应用服务的抽象，通过 Labels 为应用提供负载均衡和服务发现，每个 Service 都会自动分配一个 cluster IP 和 DNS 名，在集群内部我们可以通过该地址或者通过 FDQN 的形式来访问服务。比如，一个 Deployment 有 3 个 Pod，那么我就可以定义一个 Service，有如下两种方式来访问这个 Service：</p>
<ul>
<li>cluster IP 的方式，比如：当我访问 10.109.169.155 这个 Service 的 IP 地址时，10.109.169.155 其实就是一个 VIP，它会把请求转发到该 Service 所代理的 Endpoints 列表中的某一个 Pod 上。具体原理我们会在后面的 Service 章节中和大家深入了解。</li>
<li>Service 的 DNS 方式，比如我们访问<code>“mysvc.mynamespace.svc.cluster.local”</code>这条 DNS 记录，就可以访问到 mynamespace 这个命名空间下面名为 mysvc 的 Service 所代理的某一个 Pod。</li>
</ul>
<p>对于 DNS 这种方式实际上也有两种情况：</p>
<ul>
<li>第一种就是普通的 Service，我们访问<code>“mysvc.mynamespace.svc.cluster.local”</code>的时候是通过集群中的 DNS 服务解析到的 mysvc 这个 Service 的 cluster IP 的</li>
<li>第二种情况就是<code>Headless Service</code>，对于这种情况，我们访问<code>“mysvc.mynamespace.svc.cluster.local”</code>的时候是直接解析到的 mysvc 代理的某一个具体的 Pod 的 IP 地址，中间少了 cluster IP 的转发，这就是二者的最大区别，Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 的记录方式解析到后面的 Pod 的 IP 地址。</li>
</ul>
<p>比如我们定义一个如下的 <code>Headless Service</code>：(headless-svc.yaml)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>



<p>实际上 <code>Headless Service</code> 在定义上和普通的 Service 几乎一致, 只是他的 <code>clusterIP=None</code>，所以，这个 Service 被创建后并不会被分配一个 cluster IP，而是会以 DNS 记录的方式暴露出它所代理的 Pod，而且还有一个非常重要的特性，对于 <code>Headless Service</code> 所代理的所有 Pod 的 IP 地址都会绑定一个如下所示的 DNS 记录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pod-name&gt;.&lt;svc-name&gt;.&lt;namespace&gt;.svc.cluster.local</span><br></pre></td></tr></table></figure>

<p>这个 DNS 记录正是 Kubernetes 集群为 Pod 分配的一个唯一标识，只要我们知道 Pod 的名字，以及它对应的 Service 名字，就可以组装出这样一条 DNS 记录访问到 Pod 的 IP 地址，这个能力是非常重要的，接下来我们就来看下 StatefulSet 资源对象是如何结合 Headless Service 提供服务的。</p>
<h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>在开始之前，我们先准备两个 1G 的存储卷（PV），在后面的课程中我们也会和大家详细讲解 PV 和 PVC 的使用方法的，这里我们先不深究：（pv.yaml）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp/pv001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv002</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp/pv002</span></span><br></pre></td></tr></table></figure>

<p>然后直接创建 PV 即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f pv.yaml</span><br><span class="line">persistentvolume &quot;pv001&quot; created</span><br><span class="line">persistentvolume &quot;pv002&quot; created</span><br><span class="line">➜  ~ kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE</span><br><span class="line">pv001     1Gi        RWO            Recycle          Available                                      12s</span><br><span class="line">pv002     1Gi        RWO            Recycle          Available                                      11s</span><br></pre></td></tr></table></figure>

<p>可以看到成功创建了两个 PV 对象，状态是：<code>Available</code>。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>然后接下来声明一个如下所示的 StatefulSet 资源清单：（nginx-sts.yaml）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">&#x27;nginx&#x27;</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">      <span class="attr">spec:</span></span><br><span class="line">        <span class="attr">accessModes:</span> [<span class="string">&#x27;ReadWriteOnce&#x27;</span>]</span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>

<p>从上面的资源清单中可以看出和我们前面的 Deployment 基本上也是一致的，也是通过声明的 Pod 模板来创建 Pod 的，另外上面资源清单中和 <code>volumeMounts</code> 进行关联的不是 <code>volumes</code> 而是一个新的属性：<code>volumeClaimTemplates</code>，该属性会自动创建一个 PVC 对象，其实这里就是一个 PVC 的模板，和 Pod 模板类似，PVC 被创建后会自动去关联当前系统中和他合适的 PV 进行绑定。除此之外，还多了一个 <code>serviceName: &quot;nginx&quot;</code> 的字段，<code>serviceName</code> 就是管理当前 <code>StatefulSet</code> 的服务名称，该服务必须在 StatefulSet 之前存在，并且负责该集合的网络标识，Pod 会遵循以下格式获取 DNS&#x2F;主机名：<code>pod-specific-string.serviceName.default.svc.cluster.local</code>，其中 <code>pod-specific-string</code> 由 StatefulSet 控制器管理。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/g3n6bg.jpg" alt="StatefulSet"></p>
<p><code>StatefulSet</code> 的拓扑结构和其他用于部署的资源对象其实比较类似，比较大的区别在于 <code>StatefulSet</code> 引入了 PV 和 PVC 对象来持久存储服务产生的状态，这样所有的服务虽然可以被杀掉或者重启，但是其中的数据由于 PV 的原因不会丢失。</p>
<p><strong>注意</strong></p>
<p>由于我们这里用 <code>volumeClaimTemplates</code> 声明的模板是挂载点的方式，并不是 volume，所有实际上上当于把 PV 的存储挂载到容器中，所以会覆盖掉容器中的数据，在容器启动完成后我们可以手动在 PV 的存储里面新建 index.html 文件来保证容器的正常访问，当然也可以进入到容器中去创建，这样更加方便：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">for</span> i <span class="keyword">in</span> 0 1; <span class="keyword">do</span> kubectl <span class="built_in">exec</span> web-<span class="variable">$i</span> -- sh -c <span class="string">&#x27;echo hello $(hostname) &gt; /usr/share/nginx/html/index.html&#x27;</span>; <span class="keyword">done</span></span></span><br></pre></td></tr></table></figure>



<p>现在我们优先创建上面定义的 <code>Headless Service</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f headless-svc.yaml</span><br><span class="line">service/nginx created</span><br><span class="line">➜  ~ kubectl get service nginx</span><br><span class="line">NAME    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">nginx   ClusterIP   None         &lt;none&gt;        80/TCP    9s</span><br></pre></td></tr></table></figure>



<p><code>Headless Service</code> 创建完成后就可以来创建对应的 StatefulSet 对象了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f nginx-sts.yaml</span><br><span class="line">statefulset.apps/web created</span><br><span class="line">➜  ~ kubectl get pvc</span><br><span class="line">NAME        STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">www-web-0   Bound    pv001    1Gi        RWO                           10m</span><br><span class="line">www-web-1   Bound    pv002    1Gi        RWO                           6m26s</span><br></pre></td></tr></table></figure>



<p>可以看到这里通过 Volume 模板自动生成了两个 PVC 对象，也自动和 PV 进行了绑定。这个时候我们可以快速通过一个 <code>--watch</code> 参数来查看 Pod 的创建过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get pods -l app=nginx --watch</span><br><span class="line">NAME                      READY   STATUS              RESTARTS   AGE</span><br><span class="line">web-0                     0/1     ContainerCreating   0          1s</span><br><span class="line">web-0                     1/1     Running             0          2s</span><br><span class="line">web-1                     0/1     Pending             0          0s</span><br><span class="line">web-1                     0/1     Pending             0          0s</span><br><span class="line">web-1                     0/1     ContainerCreating   0          0s</span><br><span class="line">web-1                     1/1     Running             0          6s</span><br></pre></td></tr></table></figure>



<p>我们仔细观察整个过程出现了两个 Pod：<code>web-0</code> 和 <code>web-1</code>，而且这两个 Pod 是按照顺序进行创建的，<code>web-0</code> 启动起来后 <code>web-1</code> 才开始创建。如同上面 StatefulSet 概念中所提到的，StatefulSet 中的 Pod 拥有一个具有稳定的、独一无二的身份标志。这个标志基于 StatefulSet 控制器分配给每个 Pod 的唯一顺序索引。Pod 的名称的形式为<code>&lt;statefulset name&gt;-&lt;ordinal index&gt;</code>。我们这里的对象拥有两个副本，所以它创建了两个 Pod 名称分别为：web-0 和 web-1，我们可以使用 <code>kubectl exec</code> 命令进入到容器中查看它们的 hostname：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl exec web-0 hostname</span><br><span class="line">web-0</span><br><span class="line">➜  ~ kubectl exec web-1 hostname</span><br><span class="line">web-1</span><br></pre></td></tr></table></figure>



<p><strong>顺序</strong></p>
<p>StatefulSet 中 Pod 副本的创建会按照序列号<strong>升序</strong>处理，副本的更新和删除会按照序列号<strong>降序</strong>处理。</p>
<p>可以看到，这两个 Pod 的 hostname 与 Pod 名字是一致的，都被分配了对应的编号。我们随意查看一个 Pod 的描述信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl describe pod web-0</span><br><span class="line">Name:               web-0</span><br><span class="line">Namespace:          default</span><br><span class="line">Priority:           0</span><br><span class="line">PriorityClassName:  &lt;none&gt;</span><br><span class="line">Node:               ydzs-node3/10.151.30.57</span><br><span class="line">Start Time:         Sun, 17 Nov 2019 12:32:50 +0800</span><br><span class="line">Labels:             app=nginx</span><br><span class="line">                    controller-revision-hash=web-6c5c7fd59b</span><br><span class="line">                    statefulset.kubernetes.io/pod-name=web-0</span><br><span class="line">Annotations:        podpreset.admission.kubernetes.io/podpreset-time-preset: 2062768</span><br><span class="line">Status:             Running</span><br><span class="line">IP:                 10.244.3.98</span><br><span class="line">Controlled By:      StatefulSet/web</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>我们可以看到<code>Controlled By: StatefulSet/web</code>，证明我们的 Pod 是直接受到 StatefulSet 控制器管理的。</p>
<p>现在我们创建一个 busybox（该镜像中有一系列的工具）的容器，在容器中用 DNS 的方式来访问一下这个 <code>Headless Service</code>，由于我们这里只是单纯的为了测试，所以没必要写资源清单文件来声明，用<code>kubectl run</code>命令启动一个测试的容器即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl run -it --image busybox:1.28.3 test --restart=Never --rm /bin/sh</span><br><span class="line">If you don&#x27;t see a command prompt, try pressing enter.</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>



<p>busybox 镜像</p>
<p><code>busybox</code> 最新版本的镜像有 BUG，会出现 <code>nslookup</code> 提示无法解析的问题，我们这里使用老一点的镜像版本 <code>1.28.3</code> 即可。</p>
<p>如果对 <code>kubectl run</code> 命令的使用参数不清楚，我们可以使用 <code>kubectl run --help</code> 命令查看可使用的参数。我们这里使用 <code>kubectl run</code> 命令启动了一个以 busybox 为镜像的 Pod，<code>--rm</code> 参数意味着我们退出 Pod 后就会被删除，和之前的 <code>docker run</code> 命令用法基本一致，现在我们在这个 Pod 容器里面可以使用 <code>nslookup</code> 命令来尝试解析下上面我们创建的 <code>Headless Service</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ # nslookup nginx</span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      nginx</span><br><span class="line">Address 1: 10.244.1.175 web-1.nginx.default.svc.cluster.local</span><br><span class="line">Address 2: 10.244.4.83 web-0.nginx.default.svc.cluster.local</span><br><span class="line">/ # ping nginx</span><br><span class="line">PING nginx (10.244.1.175): 56 data bytes</span><br><span class="line">64 bytes from 10.244.1.175: seq=0 ttl=62 time=1.076 ms</span><br><span class="line">64 bytes from 10.244.1.175: seq=1 ttl=62 time=1.029 ms</span><br><span class="line">64 bytes from 10.244.1.175: seq=2 ttl=62 time=1.075 ms</span><br></pre></td></tr></table></figure>



<p>我们直接解析 <code>Headless Service</code> 的名称，可以看到得到的是两个 Pod 的解析记录，但实际上如果我们通过<code>nginx</code>这个 DNS 去访问我们的服务的话，并不会随机或者轮询背后的两个 Pod，而是访问到一个固定的 Pod，所以不能代替普通的 Service。如果分别解析对应的 Pod 呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/ <span class="comment"># nslookup web-0.nginx</span></span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      web-0.nginx</span><br><span class="line">Address 1: 10.244.4.83 web-0.nginx.default.svc.cluster.local</span><br><span class="line">/ # nslookup web-1.nginx</span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      web-1.nginx</span><br><span class="line">Address 1: 10.244.1.175 web-1.nginx.default.svc.cluster.local</span><br></pre></td></tr></table></figure>



<p>可以看到解析 <code>web-0.nginx</code> 的时候解析到了 <code>web-0</code> 这个 Pod 的 IP，<code>web-1.nginx</code> 解析到了 <code>web-1</code> 这个 Pod 的 IP，而且这个 DNS 地址还是稳定的，因为 Pod 名称就是固定的，比如我们这个时候去删掉 <code>web-0</code> 和 <code>web-1</code> 这两个 Pod：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl delete pod -l app=nginx</span><br><span class="line">pod &quot;web-0&quot; deleted</span><br><span class="line">pod &quot;web-1&quot; deleted</span><br></pre></td></tr></table></figure>



<p>删除完成后才看 Pod 状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get pods -l app=nginx</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">web-0   1/1     Running   0          42s</span><br><span class="line">web-1   1/1     Running   0          39s</span><br></pre></td></tr></table></figure>



<p>可以看到 StatefulSet 控制器仍然会安装顺序创建出两个 Pod 副本出来，而且 Pod 的唯一标识依然没变，所以这两个 Pod 的网络标识还是固定的，我们依然可以通过<code>web-0.nginx</code>去访问到<code>web-0</code>这个 Pod，虽然 Pod 已经重建了，对应 Pod IP 已经变化了，但是访问这个 Pod 的地址依然没变，并且他们依然还是关联的之前的 PVC，数据并不会丢失：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ # nslookup web-0.nginx</span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      web-0.nginx</span><br><span class="line">Address 1: 10.244.3.98 web-0.nginx.default.svc.cluster.local</span><br><span class="line">/ # nslookup web-1.nginx</span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      web-1.nginx</span><br><span class="line">Address 1: 10.244.1.176 web-1.nginx.default.svc.cluster.local</span><br></pre></td></tr></table></figure>



<p>通过 <code>Headless Service</code>，StatefulSet 就保证了 Pod 网络标识的唯一稳定性，由于 Pod IP 并不是固定的，所以我们访问<code>有状态应用</code>实例的时候，就必须使用 DNS 记录的方式来访问了，所以很多同学偶尔有固定的 Pod IP 的需求，或许可以用这种方式来代替。</p>
<p>最后我们可以通过删除 StatefulSet 对象来删除所有的 Pod，仔细观察也会发现是按照倒序的方式进行删除的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl delete statefulsets web</span><br><span class="line">statefulset.apps &quot;web&quot; deleted</span><br><span class="line">➜  ~ kubectl get pods --watch</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">web-1   1/1   Terminating   0     3h/31m</span><br><span class="line">web-0   1/1   Terminating   0     3h/31m</span><br></pre></td></tr></table></figure>



<h3 id="管理策略"><a href="#管理策略" class="headerlink" title="管理策略"></a>管理策略</h3><p>对于某些分布式系统来说，StatefulSet 的顺序性保证是不必要和&#x2F;或者不应该的，这些系统仅仅要求唯一性和身份标志。为了解决这个问题，我们只需要在声明 StatefulSet 的时候重新设置 <code>spec.podManagementPolicy</code> 的策略即可。</p>
<p>默认的管理策略是 <code>OrderedReady</code>，表示让 StatefulSet 控制器遵循上文演示的顺序性保证。除此之外，还可以设置为 <code>Parallel</code> 管理模式，表示让 StatefulSet 控制器并行的终止所有 Pod，在启动或终止另一个 Pod 前，不必等待这些 Pod 变成 Running 和 Ready 或者完全终止状态。</p>
<h3 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h3><p>前面课程中我们学习了 Deployment 的升级策略，在 StatefulSet 中同样也支持两种升级策略：<code>onDelete</code> 和 <code>RollingUpdate</code>，同样可以通过设置 <code>.spec.updateStrategy.type</code> 进行指定。</p>
<ul>
<li><code>OnDelete</code>: 该策略表示当更新了 <code>StatefulSet</code> 的模板后，只有手动删除旧的 Pod 才会创建新的 Pod。</li>
<li><code>RollingUpdate</code>：该策略表示当更新 StatefulSet 模板后会自动删除旧的 Pod 并创建新的 Pod，如果更新发生了错误，这次“滚动更新”就会停止。不过需要注意 StatefulSet 的 Pod 在部署时是顺序从 0<del>n 的，而在滚动更新时，这些 Pod 则是按逆序的方式即 n</del>0 一次删除并创建。</li>
</ul>
<p>另外<code>SatefulSet</code> 的滚动升级还支持 <code>Partitions</code>的特性，可以通过<code>.spec.updateStrategy.rollingUpdate.partition</code> 进行设置，在设置 partition 后，SatefulSet 的 Pod 中序号大于或等于 partition 的 Pod 会在 StatefulSet 的模板更新后进行滚动升级，而其余的 Pod 保持不变，这个功能是不是可以实现<strong>灰度发布</strong>？大家可以去手动验证下。</p>
<p>在实际的项目中，其实我们还是很少会去直接通过 StatefulSet 来部署我们的有状态服务的，除非你自己能够完全能够 hold 住，对于一些特定的服务，我们可能会使用更加高级的 Operator 来部署，比如 etcd-operator、prometheus-operator 等等，这些应用都能够很好的来管理有状态的服务，而不是单纯的使用一个 StatefulSet 来部署一个 Pod 就行，因为对于有状态的应用最重要的还是数据恢复、故障转移等等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/T%20%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/T%20%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">T 类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:06:10" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>您好，这是一个非常棒的问题，它触及了 Go 语言类型系统的核心。</p>
<p><strong>核心答案是：是的，从语言语法的角度来看，对于任何一个已定义的类型 <code>T</code>，你都可以构造出其对应的指针类型 <code>*T</code>。</strong></p>
<p><code>*</code> 符号在 Go 中是一个<strong>类型构造器（Type Constructor）</strong>。它的作用就是，给定一个类型 <code>T</code>，它会创建一个新类型，这个新类型就是“指向 <code>T</code> 的指针”。这个规则是普适的，适用于几乎所有类型。</p>
<hr>
<h3 id="原理解析与示例"><a href="#原理解析与示例" class="headerlink" title="原理解析与示例"></a>原理解析与示例</h3><p>让我们通过不同种类的 <code>T</code> 来验证这个规则：</p>
<h4 id="1-基本类型-Basic-Types"><a href="#1-基本类型-Basic-Types" class="headerlink" title="1. 基本类型 (Basic Types)"></a>1. 基本类型 (Basic Types)</h4><p>对于 <code>int</code>, <code>float64</code>, <code>string</code>, <code>bool</code> 等基础类型，都可以创建它们的指针类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span>       <span class="comment">// 类型 T 是 int</span></span><br><span class="line"><span class="keyword">var</span> p_i *<span class="type">int</span>    <span class="comment">// 类型 *T 是 *int</span></span><br><span class="line">p_i = &amp;i</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span>    <span class="comment">// 类型 T 是 string</span></span><br><span class="line"><span class="keyword">var</span> p_s *<span class="type">string</span> <span class="comment">// 类型 *T 是 *string</span></span><br><span class="line">p_s = &amp;s</span><br></pre></td></tr></table></figure>

<p><strong>用途：</strong> 主要用于在函数间共享或修改变量的值。</p>
<h4 id="2-复合类型-Composite-Types"><a href="#2-复合类型-Composite-Types" class="headerlink" title="2. 复合类型 (Composite Types)"></a>2. 复合类型 (Composite Types)</h4><p>对于 <code>struct</code> 和 <code>array</code>，同样可以创建它们的指针类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123; Name <span class="type">string</span> &#125;</span><br><span class="line"><span class="keyword">var</span> u User          <span class="comment">// 类型 T 是 User</span></span><br><span class="line"><span class="keyword">var</span> p_u *User       <span class="comment">// 类型 *T 是 *User</span></span><br><span class="line">p_u = &amp;u</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span>    <span class="comment">// 类型 T 是 [5]int (数组)</span></span><br><span class="line"><span class="keyword">var</span> p_arr *[<span class="number">5</span>]<span class="type">int</span>  <span class="comment">// 类型 *T 是 *[5]int</span></span><br><span class="line">p_arr = &amp;arr</span><br></pre></td></tr></table></figure>

<p><strong>用途：</strong> 对于 <code>struct</code>，使用指针非常普遍，可以避免在函数调用时发生大对象的拷贝，并且可以直接修改原对象。对于数组，虽然不常见，但语法上完全支持。</p>
<h4 id="3-指针类型本身-Pointer-to-Pointer"><a href="#3-指针类型本身-Pointer-to-Pointer" class="headerlink" title="3. 指针类型本身 (Pointer to Pointer)"></a>3. 指针类型本身 (Pointer to Pointer)</h4><p>你甚至可以为一个指针类型创建指针，形成多级指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span>         <span class="comment">// 类型 T 是 *int</span></span><br><span class="line"><span class="keyword">var</span> pp **<span class="type">int</span>       <span class="comment">// 类型 *T 是 **int</span></span><br><span class="line">pp = &amp;p</span><br></pre></td></tr></table></figure>
<p>这里，<code>T</code> 是 <code>*int</code>，那么 <code>*T</code> 就是 <code>*(*int)</code>，也就是 <code>**int</code>。</p>
<h4 id="4-函数类型-Function-Types"><a href="#4-函数类型-Function-Types" class="headerlink" title="4. 函数类型 (Function Types)"></a>4. 函数类型 (Function Types)</h4><p>函数类型也可以拥有其指针类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">string</span>  <span class="comment">// 定义一个函数类型 T</span></span><br><span class="line"><span class="keyword">var</span> f MyFunc                   <span class="comment">// 类型 T 是 MyFunc</span></span><br><span class="line"><span class="keyword">var</span> p_f *MyFunc                <span class="comment">// 类型 *T 是 *MyFunc</span></span><br><span class="line">p_f = &amp;f</span><br></pre></td></tr></table></figure>

<p><strong>用途：</strong> 这种情况非常罕见。因为函数变量本身就像引用一样工作，直接传递函数变量即可，几乎没有必要使用函数指针。</p>
<h4 id="5-接口类型-Interface-Types"><a href="#5-接口类型-Interface-Types" class="headerlink" title="5. 接口类型 (Interface Types)"></a>5. 接口类型 (Interface Types)</h4><p>接口类型也可以有指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="type">error</span>       <span class="comment">// 类型 T 是 error (接口)</span></span><br><span class="line"><span class="keyword">var</span> p_e *<span class="type">error</span>      <span class="comment">// 类型 *T 是 *error</span></span><br><span class="line">p_e = &amp;e</span><br></pre></td></tr></table></figure>

<p><strong>用途：</strong> 同样非常罕见。接口本身就包含了一个指向底层具体类型实例的指针，它已经具有指针的行为。对接口变量再取一次指针（<code>*error</code>）通常意味着逻辑上的混淆，只在极少数需要修改接口变量本身指向的场景下才可能用到。</p>
<hr>
<h3 id="重要区别：语法可行性-vs-实践必要性"><a href="#重要区别：语法可行性-vs-实践必要性" class="headerlink" title="重要区别：语法可行性 vs. 实践必要性"></a>重要区别：语法可行性 vs. 实践必要性</h3><p>虽然语法上所有 <code>T</code> 都有 <code>*T</code>，但在<strong>实际开发中，我们并不会对所有类型都使用其指针形式</strong>。这里最需要区分的就是 Go 的<strong>引用类型</strong>。</p>
<p><strong>切片 (Slices), 映射 (Maps), 通道 (Channels)</strong> 这三种是<strong>引用类型</strong>。</p>
<p>这意味着它们变量本身就是一个“描述符”或“头结构”（header），其内部已经包含了指向底层数据结构的指针。</p>
<p><strong>示例：切片 (<code>[]T</code>)</strong></p>
<p>一个切片变量的结构大致如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span> <span class="comment">// 指向底层数组的指针</span></span><br><span class="line">    Len  <span class="type">int</span>     <span class="comment">// 长度</span></span><br><span class="line">    Cap  <span class="type">int</span>     <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你将一个切片传递给函数时，你传递的是这个 <code>sliceHeader</code> 的一个副本。因为 <code>Data</code> 指针被复制了，所以函数内部对切片元素的修改会影响到原始切片。</p>
<p>因此，你<strong>几乎不需要</strong>定义一个指向切片的指针 <code>*[]int</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s 的类型 T 是 []int</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// p_s 的类型 *T 是 *[]int。语法上正确，但通常没有必要。</span></span><br><span class="line"><span class="keyword">var</span> p_s *[]<span class="type">int</span> </span><br><span class="line">p_s = &amp;s </span><br></pre></td></tr></table></figure>

<p><strong>什么时候需要 <code>*[]int</code>？</strong><br>只有当你需要在函数内部修改<strong>切片头自身</strong>时，比如重新给一个 <code>nil</code> 切片分配内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reallocate</span><span class="params">(s *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> || *s == <span class="literal">nil</span> &#123;</span><br><span class="line">        *s = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>) <span class="comment">// 这里必须用指针才能修改调用方的切片变量本身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但更地道的 Go 写法是让函数返回修改后的新切片，而不是使用指针参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reallocateAppend</span><span class="params">(s []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-T-和-T-的实践"><a href="#总结-T-和-T-的实践" class="headerlink" title="总结 T 和 *T 的实践"></a>总结 T 和 *T 的实践</h3><table>
<thead>
<tr>
<th align="left">类型 <code>T</code></th>
<th align="left"><code>*T</code> 是否存在 (语法)</th>
<th align="left"><code>*T</code> 是否常用 (实践)</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>int</code>, <code>bool</code>, <code>string</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>常用</strong></td>
<td align="left">用于在函数中修改原始值。</td>
</tr>
<tr>
<td align="left"><code>struct</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>非常常用</strong></td>
<td align="left">避免大对象拷贝，修改原始对象。</td>
</tr>
<tr>
<td align="left"><code>array</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>不常用</strong></td>
<td align="left">数组是值类型，传递数组指针可避免拷贝，但通常直接用切片替代。</td>
</tr>
<tr>
<td align="left"><strong><code>slice</code> (<code>[]T</code>)</strong></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>极不常用</strong></td>
<td align="left">切片本身是引用类型，通常直接传递即可。</td>
</tr>
<tr>
<td align="left"><strong><code>map</code> (<code>map[K]V</code>)</strong></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>极不常用</strong></td>
<td align="left">Map 本身是引用类型。</td>
</tr>
<tr>
<td align="left"><strong><code>channel</code> (<code>chan T</code>)</strong></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>极不常用</strong></td>
<td align="left">Channel 本身是引用类型。</td>
</tr>
<tr>
<td align="left"><code>interface</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>极不常用</strong></td>
<td align="left">接口已经是引用&#x2F;指针的语义。</td>
</tr>
<tr>
<td align="left"><code>func</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>极不常用</strong></td>
<td align="left">函数变量本身就是引用。</td>
</tr>
</tbody></table>
<p><strong>结论：</strong></p>
<p>从纯粹的类型系统规则来看，对于任何类型 <code>T</code>，<code>*T</code> 都是一个合法的、可以被构造出来的类型。但从编程实践和语言设计的角度来看，对于已经是引用语义的类型（slice, map, channel），使用它们的指针形式 <code>*T</code> 是没有必要的，甚至可能是一种坏味道（code smell），除非你有非常明确的理由需要修改那个引用头本身。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%20vs.%20UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%20vs.%20UDP/" class="post-title-link" itemprop="url">TCP vs. UDP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:07:15" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="TCP-和-UDP-有什么区别？"><a href="#TCP-和-UDP-有什么区别？" class="headerlink" title="TCP 和 UDP 有什么区别？"></a>TCP 和 UDP 有什么区别？</h3><p>TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）都是互联网协议（IP）之上的传输层协议，它们都负责在应用程序之间传输数据。然而，它们的设计理念和提供的服务截然不同，因此适用于不同的应用场景。</p>
<hr>
<h3 id="：核心区别概览"><a href="#：核心区别概览" class="headerlink" title="\：核心区别概览"></a>\：核心区别概览</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">TCP (传输控制协议)</th>
<th align="left">UDP (用户数据报协议)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可靠性</strong></td>
<td align="left"><strong>可靠</strong>：保证数据传输的完整性、顺序性，无重复、无丢失。</td>
<td align="left"><strong>不可靠</strong>：尽力而为传输，不保证数据是否到达、顺序、是否重复。</td>
</tr>
<tr>
<td align="left"><strong>连接状态</strong></td>
<td align="left"><strong>面向连接</strong>：数据传输前需进行“三次握手”建立连接，结束时需“四次挥手”断开连接。</td>
<td align="left"><strong>无连接</strong>：直接发送数据报，无需建立或断开连接。</td>
</tr>
<tr>
<td align="left"><strong>传输方式</strong></td>
<td align="left">**字节流 (Byte Stream)**：将应用数据视为一串无结构的字节流，发送时分割成段。</td>
<td align="left">**数据报 (Datagram)**：将应用数据视为独立的、带有边界的数据包。</td>
</tr>
<tr>
<td align="left"><strong>顺序性</strong></td>
<td align="left"><strong>有顺序保证</strong>：接收方会根据序列号重新排序，确保数据按发送顺序交付。</td>
<td align="left"><strong>无顺序保证</strong>：数据包可能乱序到达。</td>
</tr>
<tr>
<td align="left"><strong>错误控制</strong></td>
<td align="left"><strong>有</strong>：通过校验和、确认机制、重传机制来检测并纠正错误。</td>
<td align="left"><strong>无</strong>：只有校验和，用于检测数据损坏，但不纠正或重传。</td>
</tr>
<tr>
<td align="left"><strong>流量控制</strong></td>
<td align="left"><strong>有</strong>：通过滑动窗口机制，防止发送方数据发送过快，导致接收方缓冲区溢出。</td>
<td align="left"><strong>无</strong>：不控制发送速率。</td>
</tr>
<tr>
<td align="left"><strong>拥塞控制</strong></td>
<td align="left"><strong>有</strong>：根据网络拥堵情况动态调整发送速率，防止网络崩溃。</td>
<td align="left"><strong>无</strong>：不控制发送速率，可能加剧网络拥堵。</td>
</tr>
<tr>
<td align="left"><strong>头部开销</strong></td>
<td align="left">较大 (通常 20 字节)，因为它需要包含序列号、确认号、窗口大小等信息。</td>
<td align="left">较小 (固定 8 字节)，只包含源端口、目的端口、长度和校验和。</td>
</tr>
<tr>
<td align="left"><strong>传输速度</strong></td>
<td align="left">相对较慢，因为有大量机制保证可靠性。</td>
<td align="left">相对较快，因为开销小，无复杂的控制逻辑。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>需要高可靠性的应用</strong>：文件传输、网页浏览、电子邮件、安全通信。</td>
<td align="left"><strong>允许少量数据丢失、对实时性要求高、对延迟敏感的应用</strong>：在线音视频、游戏、DNS 查询。</td>
</tr>
<tr>
<td align="left"><strong>典型应用协议</strong></td>
<td align="left">HTTP, HTTPS, FTP, SSH, SMTP, POP3, IMAP, Telnet.</td>
<td align="left">DNS, DHCP, SNMP, RTP (多用于音视频流传输), VoIP, 在线游戏。</td>
</tr>
</tbody></table>
<hr>
<h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><h4 id="1-可靠性"><a href="#1-可靠性" class="headerlink" title="1. 可靠性"></a>1. 可靠性</h4><ul>
<li><strong>TCP：</strong> <strong>可靠</strong>。通过序列号、确认应答、超时重传、流量控制和拥塞控制等机制，TCP 保证了数据<strong>不丢失、不重复、按顺序到达</strong>。如果网络拥塞或数据包丢失，TCP 会自动处理重传，确保数据的完整性。</li>
<li><strong>UDP：</strong> <strong>不可靠</strong>。UDP 只是简单地将数据报从应用层传输到网络层，尽力而为地发送。它<strong>不保证</strong>数据报一定能到达目的地，<strong>不保证</strong>到达的顺序，也<strong>不提供</strong>任何错误重传机制。如果数据报丢失或乱序，应用程序需要自己处理。</li>
</ul>
<h4 id="2-连接状态"><a href="#2-连接状态" class="headerlink" title="2. 连接状态"></a>2. 连接状态</h4><ul>
<li><strong>TCP：</strong> <strong>面向连接</strong>。在数据传输开始之前，客户端和服务器之间必须使用著名的“三次握手”过程建立一个逻辑上的连接。数据传输完成后，需要“四次挥手”来断开连接。这种连接的建立和维护需要额外的开销。</li>
<li><strong>UDP：</strong> <strong>无连接</strong>。UDP 发送数据无需事先建立连接。每个 UDP 数据报都是一个独立的实体，直接从发送方传输到接收方，彼此之间没有关联。这减少了协议开销和延迟。</li>
</ul>
<h4 id="3-传输方式"><a href="#3-传输方式" class="headerlink" title="3. 传输方式"></a>3. 传输方式</h4><ul>
<li><strong>TCP：</strong> **字节流 (Byte Stream)**。TCP 将应用层的数据视为一个连续的字节流，并将其分割成适合网络传输的“段”（Segment）。它不保留应用层数据的消息边界。例如，如果你发送了两次 <code>write(&quot;hello&quot;); write(&quot;world&quot;);</code>，TCP 可能会将其合并为一次 <code>hello world</code> 传输。</li>
<li><strong>UDP：</strong> **数据报 (Datagram)**。UDP 保留了应用层数据的消息边界。每个 <code>sendto()</code> 调用都会发送一个独立的 UDP 数据报。例如，如果你发送了两次 <code>send(&quot;hello&quot;); send(&quot;world&quot;);</code>，接收方也会收到两个独立的数据报，一个包含 “hello”，一个包含 “world”。</li>
</ul>
<h4 id="4-头部开销"><a href="#4-头部开销" class="headerlink" title="4. 头部开销"></a>4. 头部开销</h4><ul>
<li><strong>TCP：</strong> 头部（Header）通常至少有 <strong>20 字节</strong>，还可能包含可选字段。这额外的字节用于携带序列号、确认号、窗口大小、标志位等用于实现可靠性和流控制的信息。</li>
<li><strong>UDP：</strong> 头部只有固定的 <strong>8 字节</strong>，包含源端口号、目的端口号、数据报长度和校验和。结构非常简单。</li>
</ul>
<h4 id="5-速度与性能"><a href="#5-速度与性能" class="headerlink" title="5. 速度与性能"></a>5. 速度与性能</h4><ul>
<li><strong>TCP：</strong> 由于其复杂的可靠性机制（确认、重传、流控、拥塞控制），TCP 的传输速度相对较慢，延迟也可能更高。但它确保了数据传输的完整性和正确性。</li>
<li><strong>UDP：</strong> 由于其简单的无状态、无连接特性，UDP 的传输速度通常更快，延迟更低。然而，它不保证数据的可靠性，可能会导致数据丢失或乱序。</li>
</ul>
<hr>
<h3 id="选择-TCP-还是-UDP？"><a href="#选择-TCP-还是-UDP？" class="headerlink" title="选择 TCP 还是 UDP？"></a>选择 TCP 还是 UDP？</h3><p>选择哪种协议取决于你的应用程序的需求：</p>
<ul>
<li><p><strong>选择 TCP 如果：</strong></p>
<ul>
<li><strong>数据完整性至关重要：</strong> 你不能容忍任何数据丢失或损坏（例如，文件下载、网页加载、电子邮件）。</li>
<li><strong>需要顺序交付：</strong> 数据必须以发送时的顺序到达（例如，在线支付、数据库同步）。</li>
<li><strong>对网络拥堵不敏感或需要自动处理：</strong> 你希望协议能自动调整发送速率以适应网络状况。</li>
</ul>
</li>
<li><p><strong>选择 UDP 如果：</strong></p>
<ul>
<li><strong>实时性要求高，允许少量数据丢失：</strong> 延迟是关键，偶尔丢失一些数据包可以接受（例如，实时语音通话、视频会议、在线游戏）。</li>
<li><strong>需要广播或多播：</strong> UDP 支持一对多通信。</li>
<li><strong>应用程序自己实现可靠性：</strong> 应用层可以根据需要添加自己的错误检测和纠正机制，以获得更大的灵活性。</li>
<li><strong>低开销：</strong> 对协议头部开销和连接建立&#x2F;维护的开销有严格限制时。</li>
</ul>
</li>
</ul>
<p>在实践中，许多复杂的应用程序会结合使用两种协议，例如，WebRTC（用于音视频通话）就可能使用 UDP 传输媒体流以降低延迟，而使用 TCP 来建立信令通道。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%20%E4%B8%AD%E7%9A%84%20%60RST%60%EF%BC%88Reset%EF%BC%89%E6%8A%A5%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%20%E4%B8%AD%E7%9A%84%20%60RST%60%EF%BC%88Reset%EF%BC%89%E6%8A%A5%E6%96%87/" class="post-title-link" itemprop="url">TCP 中的 `RST`（Reset）报文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:07:12" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP 中的 <code>RST</code>（Reset）报文是一种特殊的控制报文，它表示连接的异常终止或拒绝。与正常关闭连接的 <code>FIN</code> 报文不同，<code>RST</code> 是一种“硬”关闭，它强制终止连接，不进行正常的四次挥手过程，也不保证任何未发送或未确认的数据被可靠传递。</p>
<p>以下是 TCP 中出现 <code>RST</code> 报文的几种常见情况：</p>
<h3 id="1-端口未开放（连接被拒绝）"><a href="#1-端口未开放（连接被拒绝）" class="headerlink" title="1. 端口未开放（连接被拒绝）"></a>1. 端口未开放（连接被拒绝）</h3><p>当客户端向一个服务器的某个端口发起 TCP 连接（发送 <code>SYN</code> 报文），但该端口并没有任何进程在监听（即端口未开放或服务器不接受该连接），或者服务器明确拒绝接收该连接时，服务器会立即返回一个 <code>RST</code> 报文作为对 <code>SYN</code> 报文的响应。</p>
<ul>
<li><strong>场景：</strong> 你尝试 <code>telnet 192.168.1.100 80</code>，但服务器上没有 web 服务运行在 80 端口。</li>
<li><strong>表现：</strong> 客户端收到 <code>RST</code> 后，会报告“Connection refused”之类的错误。</li>
</ul>
<h3 id="2-半开连接或无效连接"><a href="#2-半开连接或无效连接" class="headerlink" title="2. 半开连接或无效连接"></a>2. 半开连接或无效连接</h3><p>当一方的 TCP 连接意外关闭（例如，进程崩溃、拔掉网线、操作系统重启等），而另一方没有意识到连接已经中断，仍然尝试向此已关闭的连接发送数据时，已关闭的一方（或其操作系统）会发送一个 <code>RST</code> 报文，告知对方此连接已不再有效。</p>
<ul>
<li><strong>场景：</strong> 客户端向服务器发送了一些数据，但服务器的进程突然崩溃了。当客户端再次发送数据时，操作系统发现对应的套接字已经不存在或处于无效状态，就会发送 <code>RST</code>。</li>
<li><strong>表现：</strong> 客户端收到 <code>RST</code> 后，其 <code>send()</code> 或 <code>recv()</code> 调用会返回错误，通常是 <code>ECONNRESET</code>（Connection reset by peer）。</li>
</ul>
<h3 id="3-连接超时或探测后的强制关闭"><a href="#3-连接超时或探测后的强制关闭" class="headerlink" title="3. 连接超时或探测后的强制关闭"></a>3. 连接超时或探测后的强制关闭</h3><ul>
<li><strong>TCP Keep-alive 超时：</strong> 如果开启了 TCP <code>Keep-alive</code> 选项，当连接长时间没有数据传输时，TCP 会发送探测报文。如果连续多个探测报文都没有得到响应，TCP 协议栈会认为连接已经断开，然后会主动关闭连接，并可能向应用程序报告错误（例如发送 <code>RST</code> 给本地的对端，或在无法收到响应时，本地连接直接进入 <code>CLOSED</code> 状态）。</li>
<li><strong>应用程序层心跳超时：</strong> 应用程序自己实现的心跳机制可以检测对端是否存活，如果对端长时间无响应，本端应用程序可以选择通过发送 <code>RST</code> 来强制关闭连接。</li>
</ul>
<h3 id="4-应用程序主动终止连接（紧急关闭）"><a href="#4-应用程序主动终止连接（紧急关闭）" class="headerlink" title="4. 应用程序主动终止连接（紧急关闭）"></a>4. 应用程序主动终止连接（紧急关闭）</h3><p>某些情况下，应用程序会明确指示 TCP 栈立即终止连接，而不是进行正常的四次挥手。这通常通过设置套接字选项 <code>SO_LINGER</code> 来实现：</p>
<ul>
<li><strong><code>SO_LINGER</code> 选项：</strong> 如果将 <code>SO_LINGER</code> 的 <code>l_onoff</code> 设置为 <code>true</code> 且 <code>l_linger</code> 设置为 <code>0</code> (即零linger)，那么当调用 <code>close()</code> 时，TCP 协议栈会立即发送一个 <code>RST</code> 报文给对端，并且丢弃所有在发送缓冲区中尚未发送的数据。</li>
<li><strong>用途：</strong> 这种方式通常用于清除不完整或错误状态的连接，或者在对数据丢失不敏感的场景下快速释放资源。</li>
</ul>
<h3 id="5-无效的报文段到达"><a href="#5-无效的报文段到达" class="headerlink" title="5. 无效的报文段到达"></a>5. 无效的报文段到达</h3><p>当 TCP 协议栈收到一个不属于任何当前连接的报文段，但该报文段的源 IP、源端口、目的 IP、目的端口与某个已存在或最近关闭的连接相关，但序列号或确认号完全不在预期范围内时，可能会发送一个 <code>RST</code> 报文，以表明收到了一个“不合法”的报文段，并尝试让发送方中止发送。</p>
<ul>
<li><strong>场景：</strong> 例如，一个过期的、属于旧连接的报文段到达，或者一个恶意的、序列号不匹配的报文段。这种情况下发送 <code>RST</code> 是为了防止被误认为是有效数据。</li>
</ul>
<h3 id="6-网络防火墙-IDS-阻止"><a href="#6-网络防火墙-IDS-阻止" class="headerlink" title="6. 网络防火墙&#x2F;IDS 阻止"></a>6. 网络防火墙&#x2F;IDS 阻止</h3><p>防火墙或入侵检测系统（IDS&#x2F;IPS）可能会主动发送 <code>RST</code> 报文来阻止或中断它们认为可疑或非法的连接尝试或数据流。例如，如果检测到端口扫描、非法访问尝试或恶意流量模式，防火墙可能会注入 <code>RST</code> 来强制关闭连接。</p>
<h3 id="总结-RST-报文的特点："><a href="#总结-RST-报文的特点：" class="headerlink" title="总结 RST 报文的特点："></a>总结 <code>RST</code> 报文的特点：</h3><ul>
<li><strong>即时终止：</strong> 连接立即断开，没有等待。</li>
<li><strong>无数据保障：</strong> 任何未发送或未确认的数据都可能丢失。</li>
<li><strong>异常或错误指示：</strong> 通常表示连接出现了问题，而不是一个平稳的结束。</li>
</ul>
<p>因此，在设计应用程序时，应该尽量进行正常的四次挥手来关闭连接，只有在确实需要强制终止或处理异常时才考虑 <code>RST</code> 的情况。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/" class="post-title-link" itemprop="url">TCP 初始序列号 ISN 怎么取值的？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:06:34" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP 初始序列号 (Initial Sequence Number, ISN) 的取值是一个重要且精心设计的机制，它对于 TCP 连接的健壮性、安全性以及避免“历史连接”的干扰至关重要。</p>
<h3 id="ISN-的生成方式"><a href="#ISN-的生成方式" class="headerlink" title="ISN 的生成方式"></a>ISN 的生成方式</h3><p>TCP 规范 (RFC 793 和后来的 RFC 1948、RFC 6528) 规定，ISN 的选择算法应该<strong>随机化</strong>。具体来说：</p>
<ol>
<li><p><strong>基于时钟（时间戳）+ 递增计数器 + 随机偏移：</strong></p>
<ul>
<li>大多数现代操作系统实现采用的是一个<strong>32位的计数器</strong>，该计数器以一个固定的频率（例如，每4微秒或更短）递增。</li>
<li>当需要生成新的 ISN 时，取当前计数器的值。</li>
<li>为了增加随机性，通常还会<strong>加上一个伪随机数</strong>作为偏移量。</li>
<li>这样可以确保每次连接生成的 ISN 都是不同的，并且难以预测。</li>
</ul>
</li>
<li><p><strong>每隔一段时间随机增加一个偏移量：</strong><br>为了进一步增强安全性，通常会周期性地给这个递增计数器<strong>添加一个大的随机偏移量</strong>，或者在每次系统启动时初始化为不同的随机值。</p>
</li>
</ol>
<p><strong>核心思想：随机性和不可预测性。</strong></p>
<h3 id="为什么-ISN-必须是随机的？"><a href="#为什么-ISN-必须是随机的？" class="headerlink" title="为什么 ISN 必须是随机的？"></a>为什么 ISN 必须是随机的？</h3><p>ISN 的随机性主要基于以下几个重要的原因：</p>
<ol>
<li><p><strong>防止“历史连接”对当前连接的干扰（最重要的原因）：</strong><br>这也是前面三次握手提到防止“失效的链接请求报文段”的原因。</p>
<ul>
<li>想象一个场景：一个 TCP 连接由于网络问题被中断，但网络中仍然可能存在属于这个旧连接的、过时的数据包（例如，延迟的 SYN 报文、延迟的 ACK 报文或延迟的数据报文）。</li>
<li>如果客户端和服务器每次建立连接都使用固定的或可预测的 ISN，那么一个旧连接的报文段就可能携带与新连接的 ISN 相同或接近的序列号，从而<strong>被错误地识别为属于新连接的合法数据</strong>。</li>
<li><strong>例子：</strong> 客户端 A 和服务器 B 建立连接，ISN&#x3D;1000。传输一些数据后，连接中断并被关闭（或超时）。随即，客户端 A 又立即请求与服务器 B 建立新的连接。<ul>
<li><strong>如果 ISN 是固定的 (比如总是 1000)：</strong> 服务器可能收到一个旧连接中延迟的、序列号是 1005 的数据包。如果新的连接也从 1000 开始，那么这个 1005 的数据包可能被新连接错误地接受。</li>
<li><strong>如果 ISN 是随机的 (比如新连接的 ISN&#x3D;12345678)：</strong> 旧连接中延迟的 1005 数据包将与新连接的序列号毫无关系，会被直接丢弃，因为它不在新的连接的期望序列号窗口内。</li>
</ul>
</li>
<li>通过随机化 ISN，可以大大降低旧连接的过时报文段在生命周期内“恰好”拥有与新连接相同的序列号的可能性，从而有效避免了这种“串扰”或“劫持”。</li>
</ul>
</li>
<li><p><strong>防止 TCP 劫持 (TCP Session Hijacking)：</strong></p>
<ul>
<li>如果攻击者能够预测下一个连接的 ISN，他们就可以伪造报文段。例如，攻击者可以在 TCP 连接建立过程中，抢先发送一个伪造的 ACK 包，其序列号和确认号恰好是双方期望的下一个序列号，从而欺骗一方认为连接已经成功建立，并注入恶意数据。</li>
<li>ISN 的随机性使得攻击者难以猜测正确的序列号，从而大大增加了 TCP 劫持的难度。</li>
</ul>
</li>
<li><p><strong>提高安全性：</strong></p>
<ul>
<li>随机的 ISN 使得端口扫描、会话预测等攻击变得更加困难。</li>
</ul>
</li>
</ol>
<h3 id="ISN-的生命周期"><a href="#ISN-的生命周期" class="headerlink" title="ISN 的生命周期"></a>ISN 的生命周期</h3><p>需要注意的是，一个 TCP 连接一旦建立，它的 ISN 就固定了。在连接的整个生命周期中，后续所有的数据报文的序列号都是在这个 ISN 的基础上累加的。如果连接断开并重新建立，即使是相同的客户端和服务器通过相同的端口通信，也会生成一个新的、随机的 ISN。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>TCP 初始序列号 (ISN) 的取值策略是确保其<strong>随机性和不可预测性</strong>。这主要通过一个结合时间戳（或递增计数器）和随机偏移的算法来实现。这种随机性对于防止旧连接报文的干扰（即“已失效的连接请求报文段”问题）以及增强连接的安全性（防止 TCP 劫持）至关重要。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/" class="post-title-link" itemprop="url">TCP 客户端在发送 SYN 之后宕机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:07:10" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。</p>
<p>假设客户端 A 尝试连接服务器 B。</p>
<h3 id="1-客户端发送-SYN-第一次握手"><a href="#1-客户端发送-SYN-第一次握手" class="headerlink" title="1. 客户端发送 SYN (第一次握手)"></a>1. 客户端发送 SYN (第一次握手)</h3><ul>
<li><strong>客户端 A：</strong> 生成一个 SYN 包，<code>Seq = client_ISN</code>，发送给服务器 B。</li>
<li>发送后，客户端 A 的 TCP 状态会从 <code>CLOSED</code> 变为 <code>SYN_SENT</code>。</li>
</ul>
<h3 id="2-客户端-A-宕机"><a href="#2-客户端-A-宕机" class="headerlink" title="2. 客户端 A 宕机"></a>2. 客户端 A 宕机</h3><ul>
<li>就在发送 SYN 包之后，客户端 A 突然崩溃（例如，操作系统蓝屏、电源故障、进程被杀掉等）。这意味着客户端 A 的所有网络状态、定时器、内存中的 TCP 控制块信息都瞬间丢失了。</li>
</ul>
<h3 id="3-服务器-B-的处理"><a href="#3-服务器-B-的处理" class="headerlink" title="3. 服务器 B 的处理"></a>3. 服务器 B 的处理</h3><ul>
<li><strong>服务器 B 收到 SYN：</strong> 服务器 B 收到了客户端 A 发送的 SYN 包。</li>
<li><strong>服务器 B 响应 SYN+ACK：</strong> 服务器 B 按照 TCP 握手流程，会进入 <code>SYN_RCVD</code> 状态，并向客户端 A 发送 SYN+ACK 包 (<code>Seq = server_ISN</code>, <code>Ack = client_ISN + 1</code>)。</li>
<li><strong>服务器 B 等待客户端 ACK：</strong> 服务器 B 此时会启动一个定时器（称为 SYN-ACK 重传定时器）。它在等待客户端 A 发送第三次握手的 ACK 报文。</li>
</ul>
<h3 id="4-客户端-A-的未来"><a href="#4-客户端-A-的未来" class="headerlink" title="4. 客户端 A 的未来"></a>4. 客户端 A 的未来</h3><ul>
<li>因为客户端 A 已经宕机，它<strong>不可能</strong>收到服务器 B 发来的 SYN+ACK 报文。</li>
<li>它<strong>更不可能</strong>发送第三次握手的 ACK 报文。</li>
</ul>
<h3 id="5-服务器-B-的超时处理"><a href="#5-服务器-B-的超时处理" class="headerlink" title="5. 服务器 B 的超时处理"></a>5. 服务器 B 的超时处理</h3><ul>
<li>服务器 B 会一直等待客户端 A 的 ACK。</li>
<li>当 SYN-ACK 重传定时器超时后，服务器 B 会<strong>重传</strong> SYN+ACK 报文。</li>
<li>这个重传过程会持续进行<strong>几次</strong>（通常是 3 到 5 次，具体次数取决于操作系统的 TCP 参数配置，例如 Linux 默认 <code>net.ipv4.tcp_synack_retries</code>）。</li>
<li>在每次重传之后，超时时间会呈指数级增长（例如，1秒，2秒，4秒，8秒…）。</li>
<li>如果经过多次重传后，服务器 B <strong>仍然没有收到</strong>客户端 A 的 ACK 报文：<ul>
<li>服务器 B 会认定客户端 A 不可达，或者客户端 A 根本没有响应意愿。</li>
<li>服务器 B 会<strong>放弃</strong>这个连接尝试，将为这个半开连接（Half-Open Connection，也称为 SYN 半连接）分配的所有资源（如端口、内存中的 TCP 控制块等）<strong>释放掉</strong>。</li>
<li>服务器 B 的这个连接状态会从 <code>SYN_RCVD</code> 最终回到 <code>CLOSED</code>。</li>
</ul>
</li>
</ul>
<h3 id="6-对双方的影响总结："><a href="#6-对双方的影响总结：" class="headerlink" title="6. 对双方的影响总结："></a>6. 对双方的影响总结：</h3><ul>
<li><strong>对客户端 A (宕机方)：</strong> 无后续影响。它已经崩溃，所有状态都消失了。当它重新启动并尝试建立新的连接时，那将是全新的连接，与之前失败的尝试无关。</li>
<li><strong>对服务器 B (接收方)：</strong><ul>
<li><strong>资源占用：</strong> 在客户端 A 宕机到服务器 B 超时释放资源这段时间内，服务器 B 会为这个未完成的半开连接占用一定的资源（主要是内存中的 TCP 控制块）。</li>
<li><strong>超时后释放：</strong> 一旦超时机制发挥作用，资源就会被释放，对服务器的正常运行不会造成长期影响。</li>
<li><strong>潜在的拒绝服务攻击 (DoS&#x2F;DDoS)：</strong> 如果恶意攻击者短时间内向服务器发送大量的 SYN 包，然后不响应 SYN+ACK（比如发送 SYN 后立即宕机，或者伪造源 IP），这就会导致服务器维护大量半开连接，耗尽服务器的资源，这就是著名的 <strong>SYN Flood 攻击</strong>。为了缓解这种攻击，操作系统通常会有一些保护机制，如 SYN Cookies、降低 SYN 半连接队列大小、或更快的超时释放等。</li>
</ul>
</li>
</ul>
<h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ul>
<li><strong>超时机制：</strong> TCP 的重传和超时机制是处理这种异常情况的关键。它确保服务器不会无限期地等待一个永远不会到来的响应。</li>
<li><strong>资源释放：</strong> 及时释放半开连接的资源对于服务器的稳定运行至关重要。</li>
<li><strong>SYN Flood 攻击：</strong> 这是这种场景的一个主要安全隐患。</li>
</ul>
<p>所以，总的来说，当客户端发送 SYN 后宕机，服务器会等待一段时间并重传几次 SYN+ACK，如果一直没有收到响应，最终会超时并释放为该连接分配的资源。这是一个 TCP 协议通过其超时和重传机制处理网络异常和不可靠性的典型例子。</p>
<p>TCP SYN Flood 攻击的目标是耗尽服务器的资源（主要是半开连接队列，也称 SYN backlog），使合法用户无法建立新的连接。服务器一般会等待的时间长度是其处理 SYN Flood 攻击能力的关键因素之一。</p>
<h3 id="服务器等待的时间（SYN-ACK-重传定时器）"><a href="#服务器等待的时间（SYN-ACK-重传定时器）" class="headerlink" title="服务器等待的时间（SYN-ACK 重传定时器）"></a>服务器等待的时间（SYN-ACK 重传定时器）</h3><p>服务器在收到 SYN 并发送 SYN-ACK 后，会启动一个定时器来等待客户端的 ACK。这个定时器就是 SYN-ACK 重传定时器。其行为如下：</p>
<ol>
<li><strong>初始超时：</strong> 第一次等待 ACK 的时间。这个值通常比较短，例如 1 秒或 3 秒。</li>
<li><strong>指数退避重传：</strong> 如果在初始超时时间内没有收到 ACK，服务器会重传 SYN-ACK，并将下一次的超时时间翻倍。例如，1秒 -&gt; 2秒 -&gt; 4秒 -&gt; 8秒…</li>
<li><strong>重传次数限制：</strong> 服务器不会无限重传。它会有一个最大重传次数限制（例如 5 次）。</li>
</ol>
<p>这些参数通常是操作系统级别的配置：</p>
<ul>
<li><strong>Linux 系统：</strong><ul>
<li><code>net.ipv4.tcp_synack_retries</code>: 控制 SYN-ACK 的最大重传次数。默认值通常是 5 或 6。</li>
<li><code>net.ipv4.tcp_syn_retries</code>: (主要是客户端) 控制 SYN 的最大重传次数。</li>
<li><code>net.ipv4.tcp_retries2</code>: 重传数据的最大重传次数 (不是指 SYN&#x2F;SYN-ACK)。</li>
<li><code>net.ipv4.tcp_rtos</code>: (很少直接调整) 连接超时时的初始 RTO (Retransmission Timeout) 值，会影响第一次重传的时间。</li>
</ul>
</li>
</ul>
<p><strong>举例 (Linux 默认 <code>tcp_synack_retries=5</code>)：</strong><br>假设初始超时时间为 1 秒。</p>
<ul>
<li>第一次 SYN-ACK 发送。等待 1 秒。</li>
<li>1 秒后未收到 ACK。重传 SYN-ACK。等待 2 秒。</li>
<li>2 秒后未收到 ACK。重传 SYN-ACK。等待 4 秒。</li>
<li>4 秒后未收到 ACK。重传 SYN-ACK。等待 8 秒。</li>
<li>8 秒后未收到 ACK。重传 SYN-ACK。等待 16 秒。</li>
<li>16 秒后未收到 ACK。放弃连接。</li>
</ul>
<p><strong>总共等待时间：</strong> 1 + 2 + 4 + 8 + 16 &#x3D; <strong>31 秒</strong> (这只是一个近似值，实际还可能受到 RTO min&#x2F;max 限制以及其他因素影响)。</p>
<p>这意味着，一个半开连接在服务器上<strong>最长可能占用三十秒左右</strong>的资源才会因为超时被释放。</p>
<h3 id="SYN-Flood-攻击如何利用这个时间？"><a href="#SYN-Flood-攻击如何利用这个时间？" class="headerlink" title="SYN Flood 攻击如何利用这个时间？"></a>SYN Flood 攻击如何利用这个时间？</h3><p>攻击者利用的就是这段“最长等待时间”和服务器<strong>半开连接队列</strong>的有限大小。</p>
<ol>
<li><strong>伪造源 IP：</strong> 攻击者发送 SYN 包时，伪造一个不存在的源 IP 地址。这样即使服务器回复 SYN-ACK，这个 SYN-ACK 也发送到了一个不存在的 IP，攻击者永远不会收到它，就无法完成三次握手。</li>
<li><strong>大量发送：</strong> 攻击者在短时间内向目标服务器发送巨量的这种伪造 SYN 包。</li>
<li><strong>耗尽队列：</strong> 服务器为每个收到的 SYN 包分配资源（半开连接条目），并回复 SYN-ACK。由于 ACK 永远不会到来，这些半开连接会一直占用队列中的位置，直到超时被释放。如果攻击发送 SYN 包的速度远超服务器释放半开连接的速度，那么半开连接队列很快就会被填满。</li>
<li><strong>拒绝服务：</strong> 一旦半开连接队列满了，服务器就无法再接受新的合法连接请求，导致拒绝服务。</li>
</ol>
<h3 id="防御-SYN-Flood-攻击的常见策略："><a href="#防御-SYN-Flood-攻击的常见策略：" class="headerlink" title="防御 SYN Flood 攻击的常见策略："></a>防御 SYN Flood 攻击的常见策略：</h3><p>为了对抗这种攻击，服务器和网络设备采取了多种防御机制：</p>
<ol>
<li><strong>减小 <code>net.ipv4.tcp_synack_retries</code>：</strong> 缩短半开连接的存活时间，例如设置为 2 或 3，这样可以在 7-15 秒内释放资源。但这可能增加在短暂网络拥塞时合法连接建立失败的风险。</li>
<li><strong>增大 <code>net.ipv4.tcp_max_syn_backlog</code>：</strong> 增大半开连接队列的大小，使其可以容纳更多的半开连接。但这会消耗更多内存，并且当攻击流量非常大时，效果有限。</li>
<li><strong>SYN Cookies (最常用和有效的方法之一)：</strong><ul>
<li>服务器在收到 SYN 后，不立即分配资源，而是计算一个包含客户端 IP、端口、服务器 IP、端口、时间戳以及一个秘密信息的散列值，将这个散列值作为 ISN 放入 SYN-ACK 包的序列号字段并发送。</li>
<li>当客户端发回 ACK 时，服务器会重新根据 ACK 包中的相关信息计算一次散列值，并与 ACK 报文中携带的序列号进行比对。如果匹配，就认为这是一个合法连接，然后才正式为该连接分配资源并进入 <code>ESTABLISHED</code> 状态。</li>
<li>这样，除非客户端发送最终的 ACK，否则服务器不会为半开连接消耗大量资源。大幅降低了 SYN Flood 的危害。</li>
</ul>
</li>
<li><strong>SYN Proxy &#x2F; SYN 防火墙：</strong> 中间设备（如防火墙、负载均衡器）代服务器完成三次握手。当它们收到客户端 SYN 后，先回复 SYN-ACK。只有当客户端回复 ACK 后，中间设备才认为这是合法连接，然后才将真正的 SYN 包发送给后端服务器。这样，后端服务器看到的都是已经建立握手的合法连接，减轻了服务器的压力。</li>
<li><strong>TCP Fast Open (TFO)：</strong> 虽然主要用于加速连接建立，但其原理（使用 Cookie 避免完整握手建立连接）在某种程度上也能间接缓解小规模的 SYN Flood。</li>
<li><strong>IP 信誉系统和黑名单：</strong> 识别并阻止来自已知恶意 IP 地址的流量。</li>
<li><strong>流量清洗：</strong> 将攻击流量重定向到专业的 DDoS 清洗服务进行过滤。</li>
</ol>
<p>总而言之，服务器为了应对 SYN Flood 攻击，会通过超时机制等待一段时间，以便判断连接是否能够建立，但这段时间也是攻击者利用的关键点。防御策略旨在缩短等待时间、减少资源占用或完全规避半开连接队列的消耗。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%20%E7%9A%84%20SACK/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%20%E7%9A%84%20SACK/" class="post-title-link" itemprop="url">TCP 的 SACK</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:06:49" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP 的 SACK（Selective Acknowledgement，选择性确认）机制是为了解决快速重传机制的一个<strong>不足之处</strong>，尤其是在<strong>出现多个数据包丢失</strong>的情况下，SACK 能显著提高 TCP 的效率和吞吐量。</p>
<h3 id="快速重传的局限性回顾："><a href="#快速重传的局限性回顾：" class="headerlink" title="快速重传的局限性回顾："></a>快速重传的局限性回顾：</h3><p>我们知道，快速重传在单个或少量数据包丢失时非常有效。它通过检测到三个重复 ACK 来推断丢失的报文段并立即重传。</p>
<p>然而，它的局限性在于：</p>
<ol>
<li><strong>只能推断一个丢失的报文段：</strong> 当发送方收到三个重复 ACK 时，它只能知道确认号所指向的那个（通常是被期望接收的）报文段丢失了。</li>
<li><strong>“笨拙”的重传序列：</strong> 如果<strong>多个不连续的报文段</strong>丢失，或者重传的报文段本身又丢失了，快速重传机制就显得力不从心。发送方只能一个接一个地重传，每重传一个丢失的包，都需要等待新的重复 ACK 来触发下一个重传，或者最终退化回超时重传。<ul>
<li>例如：发送了 1, 2, 3, 4, 5, 6。</li>
<li>假设 2 和 4 都丢失了。</li>
<li>接收方收到 1，ACK for 2。</li>
<li>接收方收到 3，重复 ACK for 2。</li>
<li>接收方收到 5，重复 ACK for 2。</li>
<li>接收方收到 6，重复 ACK for 2。</li>
<li>发送方收到 3 个重复 ACK for 2，快速重传 2。</li>
<li>现在发送方等待 2 的 ACK。如果又接收到 SACK 之前的报文，可能还会继续发送重复 ACK，但关于 4 丢失的信息并不能被高效地传递。等到 2 的 ACK 到达后，它才会发现 4 还没有被接收，然后重复这个过程，或者最终超时重传。</li>
<li>这种“盲目”的重传效率低下，会在网络中浪费大量带宽，并增加重传延迟。</li>
</ul>
</li>
</ol>
<h3 id="SACK-的引入目的："><a href="#SACK-的引入目的：" class="headerlink" title="SACK 的引入目的："></a>SACK 的引入目的：</h3><p>SACK 的引入就是为了解决上述“多个数据包丢失”场景下的效率问题。它的核心思想是：<strong>让接收方精确地告诉发送方，它已经成功接收了哪些“乱序”的数据块，从而让发送方只重传真正丢失的数据块，而不是盲目地猜测。</strong></p>
<p><strong>SACK 如何工作：</strong></p>
<ol>
<li><p><strong>SACK 选项：</strong> SACK 机制通过在 TCP 报文头部添加一个可选的 <code>SACK</code> 选项来实现。</p>
</li>
<li><p><strong>接收方报告：</strong> 当接收方发现收到的数据包是乱序的（即中间有缺失），它在发送 ACK 报文时，除了标准的确认号（表明期望收到的下一个按序字节）之外，<strong>还会利用 SACK 选项报告它已经成功接收到的、非连续的、按序的数据块的范围</strong>。</p>
<ul>
<li>这些数据块通常以 “起始序列号 - 结束序列号” 的形式报告。</li>
<li>例如，如果接收方收到了 1, 3, 4, 5, 6，而 2 丢失了。它会发送一个 ACK for 2，并在 SACK 选项中报告它收到了 [3-7]（SACK 块的结束序列号通常是最后一个被确认的字节的下一个字节，所以 6 意味着 SACK 块是 3 到 6，下一个字节是 7）。</li>
</ul>
</li>
<li><p><strong>发送方利用 SACK 信息：</strong> 发送方收到带有 SACK 选项的 ACK 后，它可以：</p>
<ul>
<li><strong>构建一个“缺失地图”：</strong> 根据标准 ACK 和 SACK 信息，发送方可以精确地知道哪些数据块已经到达接收方，哪些数据块是真正丢失的。</li>
<li><strong>精确重传：</strong> 发送方只会重传那些被 SACK 报告为“缺失”的数据块。这避免了重复发送接收方已经收到的数据。</li>
</ul>
</li>
</ol>
<h3 id="SACK-解决的具体问题："><a href="#SACK-解决的具体问题：" class="headerlink" title="SACK 解决的具体问题："></a>SACK 解决的具体问题：</h3><ul>
<li><strong>多包丢失时的低效率：</strong> 解决了传统快速重传在多个乱序包丢失时效率低下的问题，避免了所谓的“重传风暴”或多次触发快速重传才能恢复所有丢失包的情况。</li>
<li><strong>带宽浪费：</strong> 防止了无谓地重传那些接收方已经收到的数据包。</li>
<li><strong>提高吞吐量和降低延迟：</strong> 通过更高效的重传机制，减少了数据恢复时间，使得连接可以更快地恢复到全速传输状态，从而提升了整体吞吐量并降低了应用延迟。</li>
<li><strong>拥塞控制的优化：</strong> 配合 SACK 信息，TCP 的拥塞控制算法（例如 NewReno 或 SACK-based FACK&#x2F;Rate-Halving）可以更精确地判断网络拥塞程度，并进行更精细的拥塞窗口调整，进一步提高效率。</li>
</ul>
<p><strong>总结：</strong></p>
<p><strong>超时重传</strong>是“保底”的可靠性机制。<br><strong>快速重传</strong>是针对<strong>单个或少量丢包</strong>时提升效率的机制。<br><strong>SACK</strong> 则更进一步，是针对<strong>多个、不连续丢包</strong>时，通过提供<strong>更精确的接收方状态信息</strong>，从而实现<strong>更高效、更精确的重传</strong>，最大限度地减少了重传数据量和等待时间，显著提升了 TCP 在复杂网络环境下的性能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
