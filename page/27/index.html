<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hui&#39;s Blog">
<meta property="og:url" content="http://example.com/page/27/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="六一">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/27/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E8%8A%82%E7%82%B9%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E8%8A%82%E7%82%B9%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">节点监控</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:14:30" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="节点监控"><a href="#节点监控" class="headerlink" title="节点监控"></a>节点监控</h1><p>前面我们和大家学习了怎样用 Promethues 来监控 Kubernetes 集群中的应用，但是对于 Kubernetes 集群本身的监控也是非常重要的，我们需要时时刻刻了解集群的运行状态。</p>
<h2 id="监控方案"><a href="#监控方案" class="headerlink" title="监控方案"></a>监控方案</h2><p>对于集群的监控一般我们需要考虑以下几个方面：</p>
<ul>
<li>Kubernetes 节点的监控：比如节点的 cpu、load、disk、memory 等指标</li>
<li>内部系统组件的状态：比如 kube-scheduler、kube-controller-manager、kubedns&#x2F;coredns 等组件的详细运行状态</li>
<li>编排级的 metrics：比如 Deployment 的状态、资源请求、调度和 API 延迟等数据指标</li>
</ul>
<p>Kubernetes 集群的监控方案目前主要有以下几种方案：</p>
<ul>
<li><code>cAdvisor</code>：<a target="_blank" rel="noopener" href="https://github.com/google/cadvisor">cAdvisor</a> 是 Google 开源的容器资源监控和性能分析工具，它是专门为容器而生，本身也支持 Docker 容器。</li>
<li><code>kube-state-metrics</code>：<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kube-state-metrics">kube-state-metrics</a> 通过监听 API Server 生成有关资源对象的状态指标，比如 Deployment、Node、Pod，需要注意的是 kube-state-metrics 只是简单提供一个 metrics 数据，并不会存储这些指标数据，所以我们可以使用 Prometheus 来抓取这些数据然后存储。</li>
<li><code>metrics-server</code>：metrics-server 也是一个集群范围内的资源数据聚合工具，是 Heapster 的替代品，同样的，metrics-server 也只是显示数据，并不提供数据存储服务。</li>
</ul>
<p>不过 kube-state-metrics 和 metrics-server 之间还是有很大不同的，二者的主要区别如下：</p>
<ul>
<li>kube-state-metrics 主要关注的是业务相关的一些元数据，比如 Deployment、Pod、副本状态等</li>
<li>metrics-server 主要关注的是<a target="_blank" rel="noopener" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/resource-metrics-api.md">资源度量 API</a> 的实现，比如 CPU、文件描述符、内存、请求延时等指标。</li>
</ul>
<h2 id="监控集群节点"><a href="#监控集群节点" class="headerlink" title="监控集群节点"></a>监控集群节点</h2><p>要监控节点同样我们这里使用 <a target="_blank" rel="noopener" href="https://github.com/prometheus/node_exporter">node_exporter</a>，由于每个节点我们都需要获取到监控指标数据，所以我们可以通过 DaemonSet 控制器来部署该服务，这样每一个节点都会自动运行一个 <code>node-exporter</code> 的 Pod，如果我们从集群中删除或者添加节点后，也会进行自动扩展。</p>
<p>在部署 <code>node-exporter</code> 的时候有一些细节需要注意，如下资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">hostPID:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">hostIPC:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">prom/node-exporter:v1.3.1</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--web.listen-address=$(HOSTIP):9100</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--path.procfs=/host/proc</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--path.sysfs=/host/sys</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--path.rootfs=/host/root</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--no-collector.hwmon</span> <span class="comment"># 禁用不需要的一些采集器</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--no-collector.nfs</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--no-collector.nfsd</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--no-collector.nvme</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--no-collector.dmi</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--no-collector.arp</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--collector.filesystem.ignored-mount-points=^/(dev|proc|sys|var/lib/containerd/.+|/var/lib/docker/.+|var/lib/kubelet/pods/.+)($|/)</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--collector.filesystem.ignored-fs-types=^(autofs|binfmt_misc|cgroup|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|mqueue|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|sysfs|tracefs)$</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9100</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">HOSTIP</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">fieldRef:</span></span><br><span class="line">                  <span class="attr">fieldPath:</span> <span class="string">status.hostIP</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">150m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">180Mi</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">150m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">180Mi</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">runAsUser:</span> <span class="number">65534</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proc</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/host/proc</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sys</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/host/sys</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/host/root</span></span><br><span class="line">              <span class="attr">mountPropagation:</span> <span class="string">HostToContainer</span></span><br><span class="line">              <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">tolerations:</span> <span class="comment"># 添加容忍</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proc</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/proc</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dev</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/dev</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sys</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/sys</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>

<p>由于我们要获取到的数据是主机的监控指标数据，而我们的 <code>node-exporter</code> 是运行在容器中的，所以我们在 Pod 中需要配置一些 Pod 的安全策略，这里我们就添加了 <code>hostPID: true</code>、<code>hostIPC: true</code>、<code>hostNetwork: true</code> 3 个策略，用来使用主机的 <code>PID namespace</code>、<code>IPC namespace</code> 以及主机网络，这些 namespace 就是用于容器隔离的关键技术，要注意这里的 namespace 和集群中的 namespace 是两个完全不相同的概念。</p>
<p>另外我们还将主机的 <code>/dev</code>、<code>/proc</code>、<code>/sys</code>这些目录挂载到容器中，这些因为我们采集的很多节点数据都是通过这些文件夹下面的文件来获取到的，比如我们在使用 <code>top</code> 命令可以查看当前 cpu 使用情况，数据就来源于文件 <code>/proc/stat</code>，使用 <code>free</code> 命令可以查看当前内存使用情况，其数据来源是来自 <code>/proc/meminfo</code> 文件。</p>
<p>另外由于我们集群使用的是 <code>kubeadm</code> 搭建的，所以如果希望 master 节点也一起被监控，则需要添加相应的容忍，然后直接创建上面的资源对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl apply -f https://p8s.io/docs/k8s/manifests/prometheus/node-exporter.yaml</span><br><span class="line">☸ ➜ kubectl get pods -n kube-mon -l app=node-exporter -o wide</span><br><span class="line">NAME                  READY   STATUS    RESTARTS      AGE   IP               NODE      NOMINATED NODE   READINESS GATES</span><br><span class="line">node-exporter-b6w2v   1/1     Running   0             25m   192.168.31.31    master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">node-exporter-dmldp   1/1     Running   8 (20m ago)   25m   192.168.31.108   node1     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">node-exporter-wdxsb   1/1     Running   6 (22m ago)   25m   192.168.31.46    node2     &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>部署完成后，我们可以看到在 3 个节点上都运行了一个 Pod，由于我们指定了 <code>hostNetwork=true</code>，所以在每个节点上就会绑定一个端口 9100，我们可以通过这个端口去获取到监控指标数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ curl 10.151.31.31:9100/metrics</span><br><span class="line">...</span><br><span class="line">node_filesystem_device_error&#123;device=&quot;shm&quot;,fstype=&quot;tmpfs&quot;,mountpoint=&quot;/rootfs/var/lib/docker/containers/aefe8b1b63c3aa5f27766053ec817415faf8f6f417bb210d266fef0c2da64674/shm&quot;&#125; 1</span><br><span class="line">node_filesystem_device_error&#123;device=&quot;shm&quot;,fstype=&quot;tmpfs&quot;,mountpoint=&quot;/rootfs/var/lib/docker/containers/c8652ca72230496038a07e4fe4ee47046abb5f88d9d2440f0c8a923d5f3e133c/shm&quot;&#125; 1</span><br><span class="line">node_filesystem_device_error&#123;device=&quot;tmpfs&quot;,fstype=&quot;tmpfs&quot;,mountpoint=&quot;/dev&quot;&#125; 0</span><br><span class="line">node_filesystem_device_error&#123;device=&quot;tmpfs&quot;,fstype=&quot;tmpfs&quot;,mountpoint=&quot;/dev/shm&quot;&#125; 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">访问控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:12:19" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好的，作为一名运维工程师，我来详细描述在 Nginx 中如何配置访问控制，并提供具体的配置示例。</p>
<p>访问控制是保障 Web 应用安全的重要一环，Nginx 提供了多种灵活的方式来实现对资源的访问限制，包括基于 IP 地址的访问控制、基于用户认证的访问控制以及结合两者使用。</p>
<h3 id="Nginx-访问控制的类型"><a href="#Nginx-访问控制的类型" class="headerlink" title="Nginx 访问控制的类型"></a>Nginx 访问控制的类型</h3><p>Nginx 主要通过以下两种方式进行访问控制：</p>
<ol>
<li><strong>基于 IP 地址的访问控制 (Allow&#x2F;Deny)：</strong> 根据客户端的 IP 地址判断是否允许访问。</li>
<li><strong>基于用户认证的访问控制 (HTTP Basic Authentication)：</strong> 要求用户输入用户名和密码才能访问受保护的资源。</li>
</ol>
<p>还有一些高级的访问控制，例如基于 JWT 验证（需要 Lua 模块或其他定制开发），或者与第三方认证服务集成，但最常用和基础的就是上述两种。</p>
<hr>
<h3 id="1-基于-IP-地址的访问控制-Allow-Deny"><a href="#1-基于-IP-地址的访问控制-Allow-Deny" class="headerlink" title="1. 基于 IP 地址的访问控制 (Allow&#x2F;Deny)"></a>1. 基于 IP 地址的访问控制 (Allow&#x2F;Deny)</h3><p>这是最直接的访问控制方式，适用于限制特定 IP 地址或 IP 段的访问。</p>
<p><strong>指令：</strong></p>
<ul>
<li><code>allow address | CIDR | all;</code>：允许指定的 IP 地址、IP 段或所有 IP 访问。</li>
<li><code>deny address | CIDR | all;</code>：拒绝指定的 IP 地址、IP 段或所有 IP 访问。</li>
</ul>
<p><strong>规则顺序：</strong><br>Nginx 的 <code>allow</code> 和 <code>deny</code> 规则是按顺序处理的。当一个连接到达时，Nginx 会从上到下查找第一个匹配的规则：</p>
<ul>
<li>如果匹配到 <code>deny</code> 规则，则拒绝访问。</li>
<li>如果匹配到 <code>allow</code> 规则，则允许访问。</li>
<li>如果没有匹配到任何规则：<ul>
<li>如果存在至少一个 <code>allow</code> 规则，则默认拒绝（即只允许明确 <code>allow</code> 的）。</li>
<li>如果存在至少一个 <code>deny</code> 规则，则默认允许（即除了明确 <code>deny</code> 的，都允许）。</li>
<li><strong>最佳实践：</strong> 为了安全起见，通常会以 <code>deny all;</code> 结尾，或者使用 <code>allow all;</code> 结尾来明确默认行为。</li>
</ul>
</li>
</ul>
<p><strong>配置位置：</strong> <code>http</code>、<code>server</code>、<code>location</code> 块。</p>
<hr>
<h4 id="示例-1-仅允许特定-IP-访问-白名单"><a href="#示例-1-仅允许特定-IP-访问-白名单" class="headerlink" title="示例 1: 仅允许特定 IP 访问 (白名单)"></a>示例 1: 仅允许特定 IP 访问 (白名单)</h4><p>假设你有一个管理后台 <code>/admin</code>，只允许公司内网 IP (例如 <code>192.168.1.0/24</code>) 和你的家庭 IP (<code>203.0.113.42</code>) 访问。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /admin/ &#123;</span><br><span class="line">        <span class="attribute">allow</span> <span class="number">192.168.1.0</span>/<span class="number">24</span>; <span class="comment"># 允许 192.168.1.0 到 192.168.1.255 的所有 IP</span></span><br><span class="line">        <span class="attribute">allow</span> <span class="number">203.0.113.42</span>;   <span class="comment"># 允许你的家庭 IP</span></span><br><span class="line">        <span class="attribute">deny</span> all;             <span class="comment"># 拒绝所有其他 IP 访问</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># ... 其他 /admin 相关的配置，例如代理到后端应用</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_admin; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 其他公共资源，默认允许所有访问</span></span><br><span class="line">        <span class="comment"># deny all; # 如果这里也写 deny all，则整个网站都拒绝，不符合预期</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>当请求 <code>/admin/</code> 路径时，Nginx 首先检查客户端 IP 是否在 <code>192.168.1.0/24</code> 或 <code>203.0.113.42</code> 范围内。</li>
<li>如果是，则允许访问。</li>
<li>如果不是，由于有 <code>deny all;</code>，请求会被拒绝，客户端会收到 <code>403 Forbidden</code> 错误。</li>
</ul>
<hr>
<h4 id="示例-2-拒绝特定-IP-访问-黑名单"><a href="#示例-2-拒绝特定-IP-访问-黑名单" class="headerlink" title="示例 2: 拒绝特定 IP 访问 (黑名单)"></a>示例 2: 拒绝特定 IP 访问 (黑名单)</h4><p>假设你发现有恶意 IP (例如 <code>10.0.0.1</code> 和一个 IP 段 <code>172.16.0.0/16</code>) 正在爬取你的网站，你想禁止它们。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">deny</span> <span class="number">10.0.0.1</span>;           <span class="comment"># 拒绝单个 IP</span></span><br><span class="line">        <span class="attribute">deny</span> <span class="number">172.16.0.0</span>/<span class="number">16</span>;       <span class="comment"># 拒绝一个 IP 段</span></span><br><span class="line">        <span class="attribute">allow</span> all;              <span class="comment"># 允许所有其他 IP 访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ... 其他网站的配置</span></span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>请求到来时，Nginx 会先检查是否是 <code>10.0.0.1</code> 或 <code>172.16.0.0/16</code> 中的 IP。</li>
<li>如果是，则拒绝访问并返回 <code>403 Forbidden</code>。</li>
<li>如果不是，由于有 <code>allow all;</code>，则允许访问。</li>
</ul>
<hr>
<p><strong>重要提示：</strong></p>
<ul>
<li><p>Nginx 默认是判断客户端的原始 IP 地址 ( <code>$remote_addr</code> )。</p>
</li>
<li><p>如果 Nginx 前面还有一层或多层反向代理服务器（如 CDN、负载均衡器等），那么 <code>$remote_addr</code> 可能会是代理服务器的 IP 地址。在这种情况下，你需要配置 Nginx 信任代理服务器，并从 <code>X-Forwarded-For</code> 或 <code>X-Real-IP</code> 等 HTTP 请求头中获取真实的客户端 IP。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 http 块或 server 块配置</span></span><br><span class="line"><span class="attribute">set_real_ip_from</span> <span class="number">192.168.1.0</span>/<span class="number">24</span>; <span class="comment"># 你的上游代理服务器 IP 段</span></span><br><span class="line"><span class="attribute">set_real_ip_from</span> <span class="number">10.0.0.0</span>/<span class="number">8</span>;    <span class="comment"># 另一个代理服务器 IP 段</span></span><br><span class="line"><span class="attribute">real_ip_header</span> X-Forwarded-For; <span class="comment"># 或 X-Real-IP</span></span><br><span class="line"><span class="attribute">real_ip_recursive</span> <span class="literal">on</span>; <span class="comment"># 递归获取最原始的客户端IP</span></span><br></pre></td></tr></table></figure>
<p>配置了这些指令后，<code>$remote_addr</code> 变量就会被替换为真实的客户端 IP，<code>allow/deny</code> 规则也能正确工作。</p>
</li>
</ul>
<hr>
<h3 id="2-基于用户认证的访问控制-HTTP-Basic-Authentication"><a href="#2-基于用户认证的访问控制-HTTP-Basic-Authentication" class="headerlink" title="2. 基于用户认证的访问控制 (HTTP Basic Authentication)"></a>2. 基于用户认证的访问控制 (HTTP Basic Authentication)</h3><p>这种方式要求用户提供有效的用户名和密码才能访问受保护的资源。</p>
<p><strong>指令：</strong></p>
<ul>
<li><code>auth_basic &quot;Your Authentication Realm&quot;;</code>：启用 HTTP Basic Authentication，并设置认证领域名称（显示给用户的提示信息）。</li>
<li><code>auth_basic_user_file /path/to/.htpasswd_file;</code>：指定存储用户名和密码的文件路径。</li>
</ul>
<p><strong>生成<code>.htpasswd</code>文件：</strong><br>你需要使用 <code>htpasswd</code> 工具来生成加密的用户名和密码文件。这个工具通常随 Apache HTTP Server 或作为独立包提供 (<code>apt install apache2-utils</code> 或 <code>yum install httpd-tools</code>)。</p>
<ol>
<li><strong>创建第一个用户：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> htpasswd -c /etc/nginx/.htpasswd admin</span><br><span class="line"><span class="comment"># 输入密码两次后，会创建 /etc/nginx/.htpasswd 文件并添加用户 admin</span></span><br></pre></td></tr></table></figure></li>
<li><strong>添加更多用户 (不要使用 <code>-c</code> 选项，否则会覆盖现有文件)：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> htpasswd /etc/nginx/.htpasswd user1</span><br><span class="line"><span class="comment"># 输入密码两次后，会向 /etc/nginx/.htpasswd 文件中添加用户 user1</span></span><br></pre></td></tr></table></figure></li>
<li><strong>注意：</strong> <code>.htpasswd</code> 文件应该存放在 Nginx 用户（通常是 <code>nginx</code> 或 <code>www-data</code>）有读取权限但不能被 Web 访问到的安全位置（例如 <code>/etc/nginx/</code> 目录下）。</li>
</ol>
<p><strong>配置位置：</strong> <code>http</code>、<code>server</code>、<code>location</code> 块。</p>
<hr>
<h4 id="示例-3-对-private-目录进行密码保护"><a href="#示例-3-对-private-目录进行密码保护" class="headerlink" title="示例 3: 对 /private 目录进行密码保护"></a>示例 3: 对 <code>/private</code> 目录进行密码保护</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /private/ &#123;</span><br><span class="line">        <span class="attribute">auth_basic</span> <span class="string">&quot;Restricted Access&quot;</span>; <span class="comment"># 认证领域名称，会显示给用户</span></span><br><span class="line">        <span class="attribute">auth_basic_user_file</span> /etc/nginx/.htpasswd; <span class="comment"># 指向密码文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ... 其他 /private 相关的配置</span></span><br><span class="line">        <span class="attribute">root</span> /var/www/html; <span class="comment"># 假设 /private/ 指向 /var/www/html/private/ 目录</span></span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 其他公共资源</span></span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>当用户尝试访问 <code>http://your_domain.com/private/</code> 时，浏览器会弹出一个对话框，要求输入用户名和密码。</li>
<li>如果输入的用户名和密码与 <code>/etc/nginx/.htpasswd</code> 文件中的记录匹配，Nginx 就允许访问。</li>
<li>如果认证失败，Nginx 会返回 <code>401 Unauthorized</code> 错误。</li>
</ul>
<hr>
<h4 id="示例-4-结合-IP-地址和用户认证"><a href="#示例-4-结合-IP-地址和用户认证" class="headerlink" title="示例 4: 结合 IP 地址和用户认证"></a>示例 4: 结合 IP 地址和用户认证</h4><p>你可以将两种访问控制方式结合起来，实现更严格的策略。例如，只有来自特定 IP 段的用户才会被要求输入密码，其他 IP 直接拒绝。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /secure_area/ &#123;</span><br><span class="line">        <span class="comment"># 1. IP 白名单</span></span><br><span class="line">        <span class="attribute">allow</span> <span class="number">192.168.1.0</span>/<span class="number">24</span>; <span class="comment"># 只允许内网 IP 访问</span></span><br><span class="line">        <span class="attribute">deny</span> all;             <span class="comment"># 其他 IP 直接拒绝</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 对允许的 IP 进行密码认证</span></span><br><span class="line">        <span class="attribute">auth_basic</span> <span class="string">&quot;Secure Area Login&quot;</span>;</span><br><span class="line">        <span class="attribute">auth_basic_user_file</span> /etc/nginx/.htpasswd_secure_area;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ... /secure_area 相关的配置</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_secure_app;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 其他公共资源</span></span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>请求到达 <code>/secure_area/</code> 时，Nginx 首先进行 IP 检查。</li>
<li>如果 IP 不在 <code>192.168.1.0/24</code> 范围内，请求立即被 <code>deny all;</code> 拒绝（<code>403 Forbidden</code>）。</li>
<li>如果 IP 在 <code>192.168.1.0/24</code> 范围内，Nginx 接着强制进行用户名密码认证。认证通过才允许访问。</li>
</ul>
<hr>
<h3 id="应用和调试"><a href="#应用和调试" class="headerlink" title="应用和调试"></a>应用和调试</h3><p>配置完成后，请务必进行以下操作：</p>
<ol>
<li><p><strong>检查 Nginx 配置语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nginx -t</span><br></pre></td></tr></table></figure>
<p>确保没有语法错误。</p>
</li>
<li><p><strong>重载 Nginx 服务：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl reload nginx</span><br><span class="line"><span class="comment"># 或 sudo service nginx reload</span></span><br></pre></td></tr></table></figure>
<p>使新配置生效。</p>
</li>
<li><p><strong>测试访问：</strong> 使用不同的 IP 地址和认证凭据测试你的访问控制规则，确保它们按预期工作。</p>
</li>
<li><p><strong>注意错误页面：</strong> Nginx 默认的 403 Forbidden 或 401 Unauthorized 页面可能不够友好。你可以通过 <code>error_page</code> 指令配置自定义的错误页面：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 server 块中</span></span><br><span class="line"><span class="attribute">error_page</span> <span class="number">403</span> /custom_403.html;</span><br><span class="line"><span class="attribute">error_page</span> <span class="number">401</span> /custom_401.html;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> = /custom_403.html &#123;</span><br><span class="line">    <span class="attribute">root</span> /var/www/html; <span class="comment"># 你的 HTML 文件存放位置</span></span><br><span class="line">    internal; <span class="comment"># 内部请求，不能直接访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> = /custom_401.html &#123;</span><br><span class="line">    <span class="attribute">root</span> /var/www/html;</span><br><span class="line">    internal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过这些方法，你可以在 Nginx 中灵活且有效地实现各种访问控制策略，增强你的 Web 服务的安全性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%96%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%96%B0/" class="post-title-link" itemprop="url">证书更新</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:20:13" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">集群管理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="更新一个10年有效期的-Kubernetes-证书"><a href="#更新一个10年有效期的-Kubernetes-证书" class="headerlink" title="更新一个10年有效期的 Kubernetes 证书"></a>更新一个10年有效期的 Kubernetes 证书</h1><p>使用 kubeadm 安装 kubernetes 集群非常方便，但是也有一个比较烦人的问题就是默认的证书有效期只有一年时间，所以需要考虑证书升级的问题，本文的演示集群版本为 v1.16.2 版本，不保证下面的操作对其他版本也适用，<strong>在操作之前一定要先对证书目录进行备份，防止操作错误进行回滚</strong>。本文主要介绍两种方式来更新集群证书。</p>
<h3 id="手动更新证书"><a href="#手动更新证书" class="headerlink" title="手动更新证书"></a>手动更新证书</h3><p>由 kubeadm 生成的客户端证书默认只有一年有效期，我们可以通过 <code>check-expiration</code> 命令来检查证书是否过期：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm alpha certs check-expiration</span></span><br><span class="line">CERTIFICATE                EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span><br><span class="line">admin.conf                 Nov 07, 2020 11:59 UTC   73d             no</span><br><span class="line">apiserver                  Nov 07, 2020 11:59 UTC   73d             no</span><br><span class="line">apiserver-etcd-client      Nov 07, 2020 11:59 UTC   73d             no</span><br><span class="line">apiserver-kubelet-client   Nov 07, 2020 11:59 UTC   73d             no</span><br><span class="line">controller-manager.conf    Nov 07, 2020 11:59 UTC   73d             no</span><br><span class="line">etcd-healthcheck-client    Nov 07, 2020 11:59 UTC   73d             no</span><br><span class="line">etcd-peer                  Nov 07, 2020 11:59 UTC   73d             no</span><br><span class="line">etcd-server                Nov 07, 2020 11:59 UTC   73d             no</span><br><span class="line">front-proxy-client         Nov 07, 2020 11:59 UTC   73d             no</span><br><span class="line">scheduler.conf             Nov 07, 2020 11:59 UTC   73d             no</span><br></pre></td></tr></table></figure>

<p>该命令显示 <code>/etc/kubernetes/pki</code> 文件夹中的客户端证书以及 kubeadm 使用的 <code>KUBECONFIG</code> 文件中嵌入的客户端证书的到期时间&#x2F;剩余时间。</p>
<blockquote>
<p><code>kubeadm</code> 不能管理由外部 CA 签名的证书，如果是外部得证书，需要自己手动去管理证书的更新。</p>
</blockquote>
<p>另外需要说明的是上面的列表中没有包含 <code>kubelet.conf</code>，因为 kubeadm 将 kubelet 配置为自动更新证书。</p>
<p>另外 kubeadm 会在控制面板升级的时候自动更新所有证书，所以使用 kubeadm 搭建得集群最佳的做法是经常升级集群，这样可以确保你的集群保持最新状态并保持合理的安全性。但是对于实际的生产环境我们可能并不会去频繁得升级集群，所以这个时候我们就需要去手动更新证书。</p>
<p>要手动更新证书也非常方便，我们只需要通过 <code>kubeadm alpha certs renew</code> 命令即可更新你的证书，这个命令用 CA（或者 front-proxy-CA ）证书和存储在 <code>/etc/kubernetes/pki</code> 中的密钥执行更新。</p>
<blockquote>
<p>如果你运行了一个高可用的集群，这个命令需要在所有控制面板节点上执行。</p>
</blockquote>
<p>接下来我们来更新我们的集群证书，下面的操作都是在 master 节点上进行，首先备份原有证书：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> /etc/kubernetes.bak</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r /etc/kubernetes/pki/ /etc/kubernetes.bak</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> /etc/kubernetes/*.conf /etc/kubernetes.bak</span></span><br></pre></td></tr></table></figure>

<p>然后备份 etcd 数据目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r /var/lib/etcd /var/lib/etcd.bak</span></span><br></pre></td></tr></table></figure>

<p>接下来执行更新证书的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm alpha certs renew all --config=kubeadm.yaml</span></span><br><span class="line">kubeadm alpha certs renew all --config=kubeadm.yaml</span><br><span class="line">certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself renewed</span><br><span class="line">certificate for serving the Kubernetes API renewed</span><br><span class="line">certificate the apiserver uses to access etcd renewed</span><br><span class="line">certificate for the API server to connect to kubelet renewed</span><br><span class="line">certificate embedded in the kubeconfig file for the controller manager to use renewed</span><br><span class="line">certificate for liveness probes to healthcheck etcd renewed</span><br><span class="line">certificate for etcd nodes to communicate with each other renewed</span><br><span class="line">certificate for serving etcd renewed</span><br><span class="line">certificate for the front proxy client renewed</span><br><span class="line">certificate embedded in the kubeconfig file for the scheduler manager to use renewed</span><br></pre></td></tr></table></figure>

<p>通过上面的命令证书就一键更新完成了，这个时候查看上面的证书可以看到过期时间已经是一年后的时间了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm alpha certs check-expiration</span></span><br><span class="line">CERTIFICATE                EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span><br><span class="line">admin.conf                 Aug 26, 2021 03:47 UTC   364d            no</span><br><span class="line">apiserver                  Aug 26, 2021 03:47 UTC   364d            no</span><br><span class="line">apiserver-etcd-client      Aug 26, 2021 03:47 UTC   364d            no</span><br><span class="line">apiserver-kubelet-client   Aug 26, 2021 03:47 UTC   364d            no</span><br><span class="line">controller-manager.conf    Aug 26, 2021 03:47 UTC   364d            no</span><br><span class="line">etcd-healthcheck-client    Aug 26, 2021 03:47 UTC   364d            no</span><br><span class="line">etcd-peer                  Aug 26, 2021 03:47 UTC   364d            no</span><br><span class="line">etcd-server                Aug 26, 2021 03:47 UTC   364d            no</span><br><span class="line">front-proxy-client         Aug 26, 2021 03:47 UTC   364d            no</span><br><span class="line">scheduler.conf             Aug 26, 2021 03:47 UTC   364d            no</span><br></pre></td></tr></table></figure>

<p>然后记得更新下 kubeconfig 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm init phase kubeconfig all --config kubeadm.yaml</span></span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Using existing kubeconfig file: &quot;/etc/kubernetes/admin.conf&quot;</span><br><span class="line">[kubeconfig] Using existing kubeconfig file: &quot;/etc/kubernetes/kubelet.conf&quot;</span><br><span class="line">[kubeconfig] Using existing kubeconfig file: &quot;/etc/kubernetes/controller-manager.conf&quot;</span><br><span class="line">[kubeconfig] Using existing kubeconfig file: &quot;/etc/kubernetes/scheduler.conf&quot;</span><br></pre></td></tr></table></figure>

<p>将新生成的 admin 配置文件覆盖掉原本的 admin 文件:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> <span class="variable">$HOME</span>/.kube/config <span class="variable">$HOME</span>/.kube/config.old</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span></span><br></pre></td></tr></table></figure>

<p>完成后重启 kube-apiserver、kube-controller、kube-scheduler、etcd 这 4 个容器即可，我们可以查看 apiserver 的证书的有效期来验证是否更新成功：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> | openssl s_client -showcerts -connect 127.0.0.1:6443 -servername api 2&gt;/dev/null | openssl x509 -noout -enddate</span></span><br><span class="line">notAfter=Aug 26 03:47:23 2021 GMT</span><br></pre></td></tr></table></figure>

<p>可以看到现在的有效期是一年过后的，证明已经更新成功了。</p>
<h3 id="用-Kubernetes-证书-API-更新证书"><a href="#用-Kubernetes-证书-API-更新证书" class="headerlink" title="用 Kubernetes 证书 API 更新证书"></a>用 Kubernetes 证书 API 更新证书</h3><p>除了上述的一键手动更新证书之外，还可以使用 Kubernetes 证书 API 执行手动证书更新。对于线上环境我们可能并不会去冒险经常更新集群或者去更新证书，这些毕竟是有风险的，所以我们希望生成的证书有效期足够长，虽然从安全性角度来说不推荐这样做，但是对于某些场景下一个足够长的证书有效期也是非常有必要的。有很多管理员就是去手动更改 kubeadm 的源码为 10 年，然后重新编译来创建集群，这种方式虽然可以达到目的，但是不推荐使用这种方式，特别是当你想要更新集群的时候，还得用新版本进行更新。其实 Kubernetes 提供了一种 API 的方式可以来帮助我们生成一个足够长证书有效期。</p>
<p>要使用内置的 API 方式来签名，首先我们需要配置 kube-controller-manager 组件的 <code>--experimental-cluster-signing-duration</code> 参数，将其调整为 10 年，我们这里是 kubeadm 安装的集群，所以直接修改静态 Pod 的 yaml 文件即可:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi /etc/kubernetes/manifests/kube-controller-manager.yaml</span></span><br><span class="line">......</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - command:</span><br><span class="line">    - kube-controller-manager</span><br><span class="line">    # 设置证书有效期为 10 年</span><br><span class="line">    - --experimental-cluster-signing-duration=87600h</span><br><span class="line">    - --client-ca-file=/etc/kubernetes/pki/ca.crt</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>修改完成后 kube-controller-manager 会自动重启生效。然后我们需要使用下面的命令为 Kubernetes 证书 API 创建一个证书签名请求。如果您设置例如 <code>cert-manager</code> 等外部签名者，则会自动批准证书签名请求（CSRs）。否者，您必须使用 <code>kubectl certificate</code> 命令手动批准证书。以下 kubeadm 命令输出要批准的证书名称，然后等待批准发生：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm alpha certs renew all --use-api --config kubeadm.yaml &amp;</span></span><br></pre></td></tr></table></figure>

<p>输出类似于以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] 2890</span><br><span class="line">[certs] Certificate request &quot;kubeadm-cert-kubernetes-admin-pn99f&quot; created</span><br></pre></td></tr></table></figure>

<p>然后接下来我们需要去手动批准证书：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get csr</span></span><br><span class="line">NAME                                  AGE   REQUESTOR          CONDITION</span><br><span class="line">kubeadm-cert-kubernetes-admin-pn99f   64s   kubernetes-admin   Pending</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动批准证书</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl certificate approve kubeadm-cert-kubernetes-admin-pn99f</span></span><br><span class="line">certificatesigningrequest.certificates.k8s.io/kubeadm-cert-kubernetes-admin-pn99f approved</span><br></pre></td></tr></table></figure>

<p>用同样的方式为处于 Pending 状态的 csr 执行批准操作，直到所有的 csr 都批准完成为止。最后所有的 csr 列表状态如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get csr</span></span><br><span class="line">NAME                                                AGE     REQUESTOR          CONDITION</span><br><span class="line">kubeadm-cert-front-proxy-client-llhrj               30s     kubernetes-admin   Approved,Issued</span><br><span class="line">kubeadm-cert-kube-apiserver-2s6kf                   2m43s   kubernetes-admin   Approved,Issued</span><br><span class="line">kubeadm-cert-kube-apiserver-etcd-client-t9pkx       2m7s    kubernetes-admin   Approved,Issued</span><br><span class="line">kubeadm-cert-kube-apiserver-kubelet-client-pjbjm    108s    kubernetes-admin   Approved,Issued</span><br><span class="line">kubeadm-cert-kube-etcd-healthcheck-client-8dcn8     64s     kubernetes-admin   Approved,Issued</span><br><span class="line">kubeadm-cert-kubernetes-admin-pn99f                 4m29s   kubernetes-admin   Approved,Issued</span><br><span class="line">kubeadm-cert-system:kube-controller-manager-mr86h   79s     kubernetes-admin   Approved,Issued</span><br><span class="line">kubeadm-cert-system:kube-scheduler-t8lnw            17s     kubernetes-admin   Approved,Issued</span><br><span class="line">kubeadm-cert-ydzs-master-cqh4s                      52s     kubernetes-admin   Approved,Issued</span><br><span class="line">kubeadm-cert-ydzs-master-lvbr5                      41s     kubernetes-admin   Approved,Issued</span><br></pre></td></tr></table></figure>

<p>批准完成后检查证书的有效期：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm alpha certs check-expiration</span></span><br><span class="line">CERTIFICATE                EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span><br><span class="line">admin.conf                 Nov 05, 2029 11:53 UTC   9y              no</span><br><span class="line">apiserver                  Nov 05, 2029 11:54 UTC   9y              no</span><br><span class="line">apiserver-etcd-client      Nov 05, 2029 11:53 UTC   9y              no</span><br><span class="line">apiserver-kubelet-client   Nov 05, 2029 11:54 UTC   9y              no</span><br><span class="line">controller-manager.conf    Nov 05, 2029 11:54 UTC   9y              no</span><br><span class="line">etcd-healthcheck-client    Nov 05, 2029 11:53 UTC   9y              no</span><br><span class="line">etcd-peer                  Nov 05, 2029 11:53 UTC   9y              no</span><br><span class="line">etcd-server                Nov 05, 2029 11:54 UTC   9y              no</span><br><span class="line">front-proxy-client         Nov 05, 2029 11:54 UTC   9y              no</span><br><span class="line">scheduler.conf             Nov 05, 2029 11:53 UTC   9y              no</span><br></pre></td></tr></table></figure>

<p>我们可以看到已经延长小 10 年了，这是因为 ca 证书的有效期只有 10 年。</p>
<p>但是现在我们还不能直接重启控制面板的几个组件，这是因为使用 kubeadm 安装的集群对应的 etcd 默认是使用的 <code>/etc/kubernetes/pki/etcd/ca.crt</code> 这个证书进行前面的，而上面我们用命令 <code>kubectl certificate approve</code> 批准过后的证书是使用的默认的 <code>/etc/kubernetes/pki/ca.crt</code> 证书进行签发的，所以我们需要替换 etcd 中的 ca 机构证书:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先拷贝静态 Pod 资源清单</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r /etc/kubernetes/manifests/ /etc/kubernetes/manifests.bak</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi /etc/kubernetes/manifests/etcd.yaml</span></span><br><span class="line">......</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - command:</span><br><span class="line">    - etcd</span><br><span class="line">    # 修改为 CA 文件</span><br><span class="line">    - --peer-trusted-ca-file=/etc/kubernetes/pki/ca.crt</span><br><span class="line">    - --trusted-ca-file=/etc/kubernetes/pki/ca.crt</span><br><span class="line">......</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /var/lib/etcd</span><br><span class="line">      name: etcd-data</span><br><span class="line">    - mountPath: /etc/kubernetes/pki  # 更改证书目录</span><br><span class="line">      name: etcd-certs</span><br><span class="line">  volumes:</span><br><span class="line">  - hostPath:</span><br><span class="line">      path: /etc/kubernetes/pki  # 将 pki 目录挂载到 etcd 中去</span><br><span class="line">      type: DirectoryOrCreate</span><br><span class="line">    name: etcd-certs</span><br><span class="line">  - hostPath:</span><br><span class="line">      path: /var/lib/etcd</span><br><span class="line">      type: DirectoryOrCreate</span><br><span class="line">    name: etcd-data</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>由于 kube-apiserver 要连接 etcd 集群，所以也需要重新修改对应的 etcd ca 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi /etc/kubernetes/manifests/kube-apiserver.yaml</span></span><br><span class="line">......</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - command:</span><br><span class="line">    - kube-apiserver</span><br><span class="line">    # 将etcd ca文件修改为默认的ca.crt文件</span><br><span class="line">    - --etcd-cafile=/etc/kubernetes/pki/ca.crt</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>除此之外还需要替换 <code>requestheader-client-ca-file</code> 文件，默认是 <code>/etc/kubernetes/pki/front-proxy-ca.crt</code> 文件，现在也需要替换成默认的 CA 文件，否则使用聚合 API，比如安装了 metrics-server 后执行 <code>kubectl top</code> 命令就会报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> /etc/kubernetes/pki/ca.crt /etc/kubernetes/pki/front-proxy-ca.crt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> /etc/kubernetes/pki/ca.key /etc/kubernetes/pki/front-proxy-ca.key</span></span><br></pre></td></tr></table></figure>

<p>由于是静态 Pod，修改完成后上面的组件都会自动重启生效。由于我们当前版本的 kubelet 默认开启了证书自动轮转，所以 kubelet 的证书也不用再去管理了，这样我就将证书更新成 10 有效期了。<strong>在操作之前一定要先对证书目录进行备份，防止操作错误进行回滚</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="post-title-link" itemprop="url">负载均衡</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：20:42:57" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是负载均衡（Load-Balancing）？"><a href="#什么是负载均衡（Load-Balancing）？" class="headerlink" title="什么是负载均衡（Load Balancing）？"></a>什么是负载均衡（Load Balancing）？</h3><p>在 Web 服务器环境中，<strong>负载均衡</strong>是一种将网络请求（流量）有效地分发到多个服务器（通常称为后端服务器或上游服务器）上的技术。其核心目标是：</p>
<ol>
<li><strong>提高系统可用性：</strong> 当某台后端服务器出现故障时，负载均衡器可以将流量自动路由到健康的服务器，避免服务中断。</li>
<li><strong>提高系统性能：</strong> 通过将请求分散到多台服务器上，可以避免单台服务器过载，缩短响应时间，提高处理能力。</li>
<li><strong>提高系统可伸缩性：</strong> 随着业务增长，可以通过简单地增加后端服务器来扩展系统的处理能力，而无需升级单台服务器。</li>
<li><strong>优化资源利用：</strong> 确保所有后端服务器都能得到合理的利用，而不是某些服务器空闲而另一些过载。</li>
</ol>
<p>简单来说，负载均衡器就像一个交通指挥官，它接收到客户端的请求后，不会让请求直接去某一台具体的服务器，而是根据预设的算法和规则，将其导向当前最合适（或下一个）的后端服务器去处理，并将处理结果返回给客户端。</p>
<h3 id="负载均衡的常见算法"><a href="#负载均衡的常见算法" class="headerlink" title="负载均衡的常见算法"></a>负载均衡的常见算法</h3><p>负载均衡器会根据不同的算法来决定将请求分发给哪台后端服务器。Nginx 支持多种算法：</p>
<ol>
<li><strong>轮询 (Round Robin)：</strong><ul>
<li><strong>原理：</strong> 默认算法。请求按时间顺序依次分发到后端服务器，即第一个请求给服务器 A，第二个给服务器 B，第三个给服务器 C，然后第四个再给服务器 A，以此类推。</li>
<li><strong>优点：</strong> 简单公平，易于实现。</li>
<li><strong>缺点：</strong> 不考虑服务器实际负载或处理能力，如果后端服务器性能不一致，可能会导致性能好的服务器空闲，性能差的服务器过载。</li>
</ul>
</li>
<li><strong>加权轮询 (Weighted Round Robin)：</strong><ul>
<li><strong>原理：</strong> 在轮询的基础上，为每台服务器设置一个权重（weight）。权重越高的服务器将获得越多的请求。</li>
<li><strong>优点：</strong> 能够根据后端服务器的性能差异进行更智能的分发。</li>
<li><strong>缺点：</strong> 依然不考虑实时负载。如果权重设置不合理，也可能导致问题。</li>
</ul>
</li>
<li><strong>最少连接 (Least Connected)：</strong><ul>
<li><strong>原理：</strong> 将新的请求发送给当前活动连接数最少的后端服务器。</li>
<li><strong>优点：</strong> 更智能，考虑了服务器的实时负载情况，使得负载更均衡。适用于会话时间较长的场景。</li>
<li><strong>缺点：</strong> 需要负载均衡器实时维护连接数，增加了额外开销。</li>
</ul>
</li>
<li><strong>IP 哈希 (IP Hash)：</strong><ul>
<li><strong>原理：</strong> 根据客户端的 IP 地址计算一个哈希值，然后根据这个哈希值决定将请求发送给哪台后端服务器。来自相同 IP 的请求通常会始终被发送到同一台服务器。</li>
<li><strong>优点：</strong> 实现了“会话粘性&#x2F;会话保持 (Session Affinity)”，对于需要保持用户会话状态的应用非常有用，避免了会话数据丢失。</li>
<li><strong>缺点：</strong> 如果某个 IP 地址的请求量非常大，可能会导致该 IP 对应的服务器负载过高。在有大量代理服务器的情况下，所有请求可能来自同一个代理IP，导致负载不均。</li>
</ul>
</li>
<li><strong>通用哈希 (Generic Hash)：</strong><ul>
<li><strong>原理：</strong> 允许用户指定一个字符串（可以是 URL、Header 甚至 Cookie 等）作为哈希键，然后根据该键的哈希值来分发请求。</li>
<li><strong>优点：</strong> 提供了比 IP Hash 更灵活的会话粘性方式。</li>
<li><strong>缺点：</strong> 和 IP Hash 类似，如果哈希键的分布不均，可能导致负载不均。</li>
</ul>
</li>
<li><strong>随机 (Random)：</strong> <strong>（Nginx Plus 功能，或通过 Lua 脚本实现）</strong><ul>
<li><strong>原理：</strong> 随机选择一台后端服务器。可以结合权重。</li>
<li><strong>优点：</strong> 简单，适用于后端服务器数量大且性能差异不大的情况。</li>
</ul>
</li>
</ol>
<h3 id="如何在-Nginx-中配置负载均衡？"><a href="#如何在-Nginx-中配置负载均衡？" class="headerlink" title="如何在 Nginx 中配置负载均衡？"></a>如何在 Nginx 中配置负载均衡？</h3><p>Nginx 通过 <code>upstream</code> 模块来实现强大的负载均衡功能。</p>
<h4 id="基本配置结构"><a href="#基本配置结构" class="headerlink" title="基本配置结构"></a>基本配置结构</h4><p>负载均衡的配置主要在 <code>http</code> 块中通过 <code>upstream</code> 指令定义一个后端服务器组，然后在 <code>server</code> 块的 <code>location</code> 中通过 <code>proxy_pass</code> 指令引用这个组。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 1: 在 http 块中定义一个上游服务器组 (upstream)</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># limit_conn_zone ... # 其他 http 块配置</span></span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> my_webapp_cluster &#123;</span><br><span class="line">        <span class="comment"># 定义后端服务器列表</span></span><br><span class="line">        <span class="attribute">server</span> backend1.example.com:<span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">server</span> backend2.example.com:<span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">server</span> backend3.example.com:<span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 可选：指定负载均衡算法（默认是轮询）</span></span><br><span class="line">        <span class="comment"># least_conn;  # 最少连接数</span></span><br><span class="line">        <span class="comment"># ip_hash;     # IP 哈希</span></span><br><span class="line">        <span class="comment"># random;      # 随机 (Nginx Plus 或特定模块)</span></span><br><span class="line">        <span class="comment"># hash $request_uri consistent; # 通用哈希，根据URI做一致性哈希 (Nginx Plus)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 可选：健康检查和故障转移</span></span><br><span class="line">        <span class="comment"># server backend4.example.com:8080 backup; # 备用服务器，只有当所有主服务器都失效时才启用</span></span><br><span class="line">        <span class="comment"># server backend5.example.com:8080 down;   # 标记为永久离线，不工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 2: 配置一个 server 块来监听客户端请求，并使用 upstream 组</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 将所有请求代理到上面定义的 upstream 组</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://my_webapp_cluster;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 常见的 proxy_set_header 配置，用于传递客户端信息给后端</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_buffering</span> <span class="literal">off</span>; <span class="comment"># 通常对于动态内容禁用缓冲，直接流式传输</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="各种负载均衡算法的-Nginx-配置示例"><a href="#各种负载均衡算法的-Nginx-配置示例" class="headerlink" title="各种负载均衡算法的 Nginx 配置示例"></a>各种负载均衡算法的 Nginx 配置示例</h4><p><strong>1. 轮询 (Round Robin) - 默认</strong></p>
<p>这是最简单的配置，不需要额外的指令，<code>upstream</code> 块中的 <code>server</code> 指令列表就是轮询。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> my_webapp_cluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.10:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.11:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.12:8080</span>;</span><br><span class="line">    <span class="comment"># 默认就是轮询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 加权轮询 (Weighted Round Robin)</strong></p>
<p>通过 <code>weight</code> 参数为每个 <code>server</code> 指定权重。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> my_webapp_cluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.10:8080</span> weight=<span class="number">5</span>; <span class="comment"># 这台服务器会获得 5 份请求</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.11:8080</span> weight=<span class="number">3</span>; <span class="comment"># 这台服务器会获得 3 份请求</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.12:8080</span> weight=<span class="number">1</span>; <span class="comment"># 这台服务器会获得 1 份请求</span></span><br><span class="line">    <span class="comment"># 总共 9 份请求，按比例分配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 最少连接 (Least Connected)</strong></p>
<p>在 <code>upstream</code> 块内添加 <code>least_conn;</code> 指令。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> my_webapp_cluster &#123;</span><br><span class="line">    least_conn; <span class="comment"># 使用最少连接算法</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.10:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.11:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.12:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. IP 哈希 (IP Hash)</strong></p>
<p>在 <code>upstream</code> 块内添加 <code>ip_hash;</code> 指令。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> my_webapp_cluster &#123;</span><br><span class="line">    ip_hash; <span class="comment"># 使用 IP 哈希算法</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.10:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.11:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.12:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 如果使用 <code>ip_hash</code>，并且后端服务器数量发生变化（如移除或增加），可能会导致一部分用户的会话被重定向到不同的服务器，从而丢失会话。</p>
<p><strong>5. 通用哈希 (Generic Hash) - Nginx Plus 或结合 <code>map</code> 模块</strong></p>
<p>这是一个更高级的功能，在开源版中通常需要结合其他模块实现或依赖 Nginx Plus。<br>例如，根据 URI 进行哈希：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if Nginx Plus</span></span><br><span class="line"><span class="section">upstream</span> my_webapp_cluster &#123;</span><br><span class="line">    <span class="attribute">hash</span> <span class="variable">$request_uri</span> consistent; <span class="comment"># 根据请求URI哈希，并使用一致性哈希，降低后端变化时的影响</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.10:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.11:8080</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开源版通常需要变通，例如通过 map 和 proxy_next_upstream 来模拟特定逻辑</span></span><br></pre></td></tr></table></figure>

<h4 id="健康检查和故障转移"><a href="#健康检查和故障转移" class="headerlink" title="健康检查和故障转移"></a>健康检查和故障转移</h4><p>Nginx 的 <code>upstream</code> 模块还支持一些参数来增强负载均衡的可靠性：</p>
<ul>
<li><strong><code>backup</code>：</strong> 标记服务器为备用服务器。只有当所有非 <code>backup</code> 服务器都失效时，请求才会被发送到 <code>backup</code> 服务器。<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> my_webapp_cluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.10:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.11:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.12:8080</span> backup; <span class="comment"># 备用服务器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>down</code>：</strong> 明确标记服务器为离线状态，不参与负载均衡。<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> my_webapp_cluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.10:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.11:8080</span> down; <span class="comment"># 这台服务器将不会收到请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>max_fails=number</code> 和 <code>fail_timeout=time</code>：</strong> 这两个参数通常一起使用，用于简单的健康检查。<ul>
<li><code>max_fails</code>：在 <code>fail_timeout</code> 期间，如果与服务器通信失败的次数达到 <code>max_fails</code>，则 Nginx 会认为该服务器已失效。默认是 1。0 表示不检查。</li>
<li><code>fail_timeout</code>：如果服务器在 <code>fail_timeout</code> 时间内被标记为失效，Nginx 会在这段时间内停止向其发送请求。这段时间过后，Nginx 会尝试向它发送一次请求，如果成功则重新标记为正常。默认是 10 秒。<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> my_webapp_cluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.10:8080</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.11:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>注意：</strong> 这里的健康检查是<strong>被动健康检查</strong>。Nginx 只有在尝试向后端服务器发送请求并失败后，才能感知到服务器的故障。对于更复杂的<strong>主动健康检查</strong>（例如定期发送探测请求来检查服务器状态），需要 Nginx Plus 版本提供的 <code>health_check</code> 指令，或者通过第三方模块（如 <code>nginx_upstream_check_module</code>）或外部脚本实现。</li>
</ul>
</li>
</ul>
<h4 id="配置完成后"><a href="#配置完成后" class="headerlink" title="配置完成后"></a>配置完成后</h4><ol>
<li><strong>保存 Nginx 配置文件</strong>。</li>
<li><strong>测试配置文件的语法</strong>：<code>sudo nginx -t</code></li>
<li><strong>重新加载 Nginx 配置</strong>：<code>sudo systemctl reload nginx</code> 或 <code>sudo service nginx reload</code></li>
</ol>
<p>通过以上配置，Nginx 就能有效地将客户端请求分发到后端服务器集群，从而实现高可用、可伸缩和高性能的 Web 服务。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E8%B0%83%E5%BA%A6%E5%99%A8%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E8%B0%83%E5%BA%A6%E5%99%A8%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">调度器介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:11:40" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E8%B0%83%E5%BA%A6%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">调度器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h1><p><code>kube-scheduler</code> 是 kubernetes 的核心组件之一，主要负责整个集群资源的调度功能，根据特定的调度算法和策略，将 Pod 调度到最优的工作节点上面去，从而更加合理、更加充分的利用集群的资源，这也是我们选择使用 kubernetes 一个非常重要的理由。如果一门新的技术不能帮助企业节约成本、提供效率，我相信是很难推进的。</p>
<h2 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h2><p>默认情况下，<code>kube-scheduler</code> 提供的默认调度器能够满足我们绝大多数的要求，我们前面和大家接触的示例也基本上用的默认的策略，都可以保证我们的 Pod 可以被分配到资源充足的节点上运行。但是在实际的线上项目中，可能我们自己会比 kubernetes 更加了解我们自己的应用，比如我们希望一个 Pod 只能运行在特定的几个节点上，或者这几个节点只能用来运行特定类型的应用，这就需要我们的调度器能够可控。</p>
<p><code>kube-scheduler</code> 的主要作用就是根据特定的调度算法和调度策略将 Pod 调度到合适的 Node 节点上去，是一个独立的二进制程序，启动之后会一直监听 API Server，获取到 <code>PodSpec.NodeName</code> 为空的 Pod，对每个 Pod 都会创建一个 binding。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/v4xz3f.png" alt="kube-scheduler structrue"></p>
<p>这个过程在我们看来好像比较简单，但在实际的生产环境中，需要考虑的问题就有很多了：</p>
<ul>
<li>如何保证全部的节点调度的公平性？要知道并不是所有节点资源配置一定都是一样的</li>
<li>如何保证每个节点都能被分配资源？</li>
<li>集群资源如何能够被高效利用？</li>
<li>集群资源如何才能被最大化使用？</li>
<li>如何保证 Pod 调度的性能和效率？</li>
<li>用户是否可以根据自己的实际需求定制自己的调度策略？</li>
</ul>
<p>考虑到实际环境中的各种复杂情况，kubernetes 的调度器采用插件化的形式实现，可以方便用户进行定制或者二次开发，我们可以自定义一个调度器并以插件形式和 kubernetes 进行集成。</p>
<p>kubernetes 调度器的源码位于 <code>kubernetes/pkg/scheduler</code> 中，其中 Scheduler 创建和运行的核心程序，对应的代码在 <code>pkg/scheduler/scheduler.go</code>，如果要查看 <code>kube-scheduler</code> 的入口程序，对应的代码在 <code>cmd/kube-scheduler/scheduler.go</code>。</p>
<p>调度主要分为以下几个部分：</p>
<ul>
<li>首先是<strong>预选过程</strong>，过滤掉不满足条件的节点，这个过程称为 <code>Predicates</code>（过滤）</li>
<li>然后是<strong>优选过程</strong>，对通过的节点按照优先级排序，称之为 <code>Priorities</code>（打分）</li>
<li>最后从中选择优先级最高的节点，如果中间任何一步骤有错误，就直接返回错误</li>
</ul>
<p><code>Predicates</code> 阶段首先遍历全部节点，过滤掉不满足条件的节点，属于<code>强制性</code>规则，这一阶段输出的所有满足要求的节点将被记录并作为第二阶段的输入，如果所有的节点都不满足条件，那么 Pod 将会一直处于 Pending 状态，直到有节点满足条件，在这期间调度器会不断的重试。</p>
<p>所以我们在部署应用的时候，如果发现有 Pod 一直处于 Pending 状态，那么就是没有满足调度条件的节点，这个时候可以去检查下节点资源是否可用。</p>
<p><code>Priorities</code> 阶段即再次对节点进行筛选，如果有多个节点都满足条件的话，那么系统会按照节点的优先级(<code>priorites</code>)大小对节点进行排序，最后选择优先级最高的节点来部署 Pod 应用。</p>
<p>下面是调度过程的简单示意图：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/fnomoy.png" alt="kube-scheduler filter"></p>
<p>更详细的流程是这样的：</p>
<ul>
<li>首先，客户端通过 API Server 的 REST API 或者 kubectl 工具创建 Pod 资源</li>
<li>API Server 收到用户请求后，存储相关数据到 etcd 数据库中</li>
<li>调度器监听 API Server 查看到还未被调度(bind)的 Pod 列表，循环遍历地为每个 Pod 尝试分配节点，这个分配过程就是我们上面提到的两个阶段：<ul>
<li>预选阶段(Predicates)，过滤节点，调度器用一组规则过滤掉不符合要求的 Node 节点，比如 Pod 设置了资源的 request，那么可用资源比 Pod 需要的资源少的主机显然就会被过滤掉</li>
<li>优选阶段(Priorities)，为节点的优先级打分，将上一阶段过滤出来的 Node 列表进行打分，调度器会考虑一些整体的优化策略，比如把 Deployment 控制的多个 Pod 副本尽量分布到不同的主机上，使用最低负载的主机等等策略</li>
</ul>
</li>
<li>经过上面的阶段过滤后选择打分最高的 Node 节点和 Pod 进行 <code>binding</code> 操作，然后将结果存储到 etcd 中 最后被选择出来的 Node 节点对应的 kubelet 去执行创建 Pod 的相关操作（当然也是 watch APIServer 发现的）。</li>
</ul>
<p>目前调度器已经全部通过插件的方式实现了调度框架，默认开启的调度插件如以下代码所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg/scheduler/algorithmprovider/registry.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDefaultConfig</span><span class="params">()</span></span> *schedulerapi.Plugins &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;schedulerapi.Plugins&#123;</span><br><span class="line">        QueueSort: &amp;schedulerapi.PluginSet&#123;</span><br><span class="line">            Enabled: []schedulerapi.Plugin&#123;</span><br><span class="line">                &#123;Name: queuesort.Name&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        PreFilter: &amp;schedulerapi.PluginSet&#123;</span><br><span class="line">            Enabled: []schedulerapi.Plugin&#123;</span><br><span class="line">                &#123;Name: noderesources.FitName&#125;,</span><br><span class="line">                &#123;Name: nodeports.Name&#125;,</span><br><span class="line">                &#123;Name: podtopologyspread.Name&#125;,</span><br><span class="line">                &#123;Name: interpodaffinity.Name&#125;,</span><br><span class="line">                &#123;Name: volumebinding.Name&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        Filter: &amp;schedulerapi.PluginSet&#123;</span><br><span class="line">            Enabled: []schedulerapi.Plugin&#123;</span><br><span class="line">                &#123;Name: nodeunschedulable.Name&#125;,</span><br><span class="line">                &#123;Name: noderesources.FitName&#125;,</span><br><span class="line">                &#123;Name: nodename.Name&#125;,</span><br><span class="line">                &#123;Name: nodeports.Name&#125;,</span><br><span class="line">                &#123;Name: nodeaffinity.Name&#125;,</span><br><span class="line">                &#123;Name: volumerestrictions.Name&#125;,</span><br><span class="line">                &#123;Name: tainttoleration.Name&#125;,</span><br><span class="line">                &#123;Name: nodevolumelimits.EBSName&#125;,</span><br><span class="line">                &#123;Name: nodevolumelimits.GCEPDName&#125;,</span><br><span class="line">                &#123;Name: nodevolumelimits.CSIName&#125;,</span><br><span class="line">                &#123;Name: nodevolumelimits.AzureDiskName&#125;,</span><br><span class="line">                &#123;Name: volumebinding.Name&#125;,</span><br><span class="line">                &#123;Name: volumezone.Name&#125;,</span><br><span class="line">                &#123;Name: podtopologyspread.Name&#125;,</span><br><span class="line">                &#123;Name: interpodaffinity.Name&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        PostFilter: &amp;schedulerapi.PluginSet&#123;</span><br><span class="line">            Enabled: []schedulerapi.Plugin&#123;</span><br><span class="line">                &#123;Name: defaultpreemption.Name&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        PreScore: &amp;schedulerapi.PluginSet&#123;</span><br><span class="line">            Enabled: []schedulerapi.Plugin&#123;</span><br><span class="line">                &#123;Name: interpodaffinity.Name&#125;,</span><br><span class="line">                &#123;Name: podtopologyspread.Name&#125;,</span><br><span class="line">                &#123;Name: tainttoleration.Name&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        Score: &amp;schedulerapi.PluginSet&#123;</span><br><span class="line">            Enabled: []schedulerapi.Plugin&#123;</span><br><span class="line">                &#123;Name: noderesources.BalancedAllocationName, Weight: <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;Name: imagelocality.Name, Weight: <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;Name: interpodaffinity.Name, Weight: <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;Name: noderesources.LeastAllocatedName, Weight: <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;Name: nodeaffinity.Name, Weight: <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;Name: nodepreferavoidpods.Name, Weight: <span class="number">10000</span>&#125;,</span><br><span class="line">                <span class="comment">// Weight is doubled because:</span></span><br><span class="line">                <span class="comment">// - This is a score coming from user preference.</span></span><br><span class="line">                <span class="comment">// - It makes its signal comparable to NodeResourcesLeastAllocated.</span></span><br><span class="line">                &#123;Name: podtopologyspread.Name, Weight: <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;Name: tainttoleration.Name, Weight: <span class="number">1</span>&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        Reserve: &amp;schedulerapi.PluginSet&#123;</span><br><span class="line">            Enabled: []schedulerapi.Plugin&#123;</span><br><span class="line">                &#123;Name: volumebinding.Name&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        PreBind: &amp;schedulerapi.PluginSet&#123;</span><br><span class="line">            Enabled: []schedulerapi.Plugin&#123;</span><br><span class="line">                &#123;Name: volumebinding.Name&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        Bind: &amp;schedulerapi.PluginSet&#123;</span><br><span class="line">            Enabled: []schedulerapi.Plugin&#123;</span><br><span class="line">                &#123;Name: defaultbinder.Name&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从上面我们可以看出调度器的一系列算法由各种插件在调度的不同阶段来完成，下面我们就先来了解下调度框架。</p>
<h3 id="调度框架"><a href="#调度框架" class="headerlink" title="调度框架"></a>调度框架</h3><p>调度框架定义了一组扩展点，用户可以实现扩展点定义的接口来定义自己的调度逻辑（我们称之为<strong>扩展</strong>），并将扩展注册到扩展点上，调度框架在执行调度工作流时，遇到对应的扩展点时，将调用用户注册的扩展。调度框架在预留扩展点时，都是有特定的目的，有些扩展点上的扩展可以改变调度程序的决策方法，有些扩展点上的扩展只是发送一个通知。</p>
<p>我们知道每当调度一个 Pod 时，都会按照两个过程来执行：调度过程和绑定过程。</p>
<p>调度过程为 Pod 选择一个合适的节点，绑定过程则将调度过程的决策应用到集群中（也就是在被选定的节点上运行 Pod），将调度过程和绑定过程合在一起，称之为<strong>调度上下文（scheduling context）</strong>。需要注意的是调度过程是<code>同步</code>运行的（同一时间点只为一个 Pod 进行调度），绑定过程可异步运行（同一时间点可并发为多个 Pod 执行绑定）。</p>
<p>调度过程和绑定过程遇到如下情况时会中途退出：</p>
<ul>
<li>调度程序认为当前没有该 Pod 的可选节点</li>
<li>内部错误</li>
</ul>
<p>这个时候，该 Pod 将被放回到 <strong>待调度队列</strong>，并等待下次重试。</p>
<h4 id="扩展点（Extension-Points）"><a href="#扩展点（Extension-Points）" class="headerlink" title="扩展点（Extension Points）"></a>扩展点（Extension Points）</h4><p>下图展示了调度框架中的调度上下文及其中的扩展点，一个扩展可以注册多个扩展点，以便可以执行更复杂的有状态的任务。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20220114165454.png" alt="scheduling framework extensions"></p>
<ol>
<li><code>QueueSort</code> 扩展用于对 Pod 的待调度队列进行排序，以决定先调度哪个 Pod，<code>QueueSort</code> 扩展本质上只需要实现一个方法 <code>Less(Pod1, Pod2)</code> 用于比较两个 Pod 谁更优先获得调度即可，同一时间点只能有一个 <code>QueueSort</code> 插件生效。</li>
<li><code>Pre-filter</code> 扩展用于对 Pod 的信息进行预处理，或者检查一些集群或 Pod 必须满足的前提条件，如果 <code>pre-filter</code> 返回了 error，则调度过程终止。</li>
<li><code>Filter</code> 扩展用于排除那些不能运行该 Pod 的节点，对于每一个节点，调度器将按顺序执行 <code>filter</code> 扩展；如果任何一个 <code>filter</code> 将节点标记为不可选，则余下的 <code>filter</code> 扩展将不会被执行。调度器可以同时对多个节点执行 <code>filter</code> 扩展。</li>
<li><code>Post-filter</code> 是一个通知类型的扩展点，调用该扩展的参数是 <code>filter</code> 阶段结束后被筛选为<strong>可选节点</strong>的节点列表，可以在扩展中使用这些信息更新内部状态，或者产生日志或 metrics 信息。</li>
<li><code>Scoring</code> 扩展用于为所有可选节点进行打分，调度器将针对每一个节点调用 <code>Soring</code> 扩展，评分结果是一个范围内的整数。在 <code>normalize scoring</code> 阶段，调度器将会把每个 <code>scoring</code> 扩展对具体某个节点的评分结果和该扩展的权重合并起来，作为最终评分结果。</li>
<li><code>Normalize scoring</code> 扩展在调度器对节点进行最终排序之前修改每个节点的评分结果，注册到该扩展点的扩展在被调用时，将获得同一个插件中的 <code>scoring</code> 扩展的评分结果作为参数，调度框架每执行一次调度，都将调用所有插件中的一个 <code>normalize scoring</code> 扩展一次。</li>
<li><code>Reserve</code> 是一个通知性质的扩展点，有状态的插件可以使用该扩展点来获得节点上为 Pod 预留的资源，该事件发生在调度器将 Pod 绑定到节点之前，目的是避免调度器在等待 Pod 与节点绑定的过程中调度新的 Pod 到节点上时，发生实际使用资源超出可用资源的情况（因为绑定 Pod 到节点上是异步发生的）。这是调度过程的最后一个步骤，Pod 进入 reserved 状态以后，要么在绑定失败时触发 Unreserve 扩展，要么在绑定成功时，由 Post-bind 扩展结束绑定过程。</li>
<li><code>Permit</code> 扩展用于阻止或者延迟 Pod 与节点的绑定。Permit 扩展可以做下面三件事中的一项：<ul>
<li>approve（批准）：当所有的 permit 扩展都 approve 了 Pod 与节点的绑定，调度器将继续执行绑定过程</li>
<li>deny（拒绝）：如果任何一个 permit 扩展 deny 了 Pod 与节点的绑定，Pod 将被放回到待调度队列，此时将触发 <code>Unreserve</code> 扩展</li>
<li>wait（等待）：如果一个 permit 扩展返回了 wait，则 Pod 将保持在 permit 阶段，直到被其他扩展 approve，如果超时事件发生，wait 状态变成 deny，Pod 将被放回到待调度队列，此时将触发 Unreserve 扩展</li>
</ul>
</li>
<li><code>Pre-bind</code> 扩展用于在 Pod 绑定之前执行某些逻辑。例如，pre-bind 扩展可以将一个基于网络的数据卷挂载到节点上，以便 Pod 可以使用。如果任何一个 <code>pre-bind</code> 扩展返回错误，Pod 将被放回到待调度队列，此时将触发 Unreserve 扩展。</li>
<li><code>Bind</code> 扩展用于将 Pod 绑定到节点上：<ul>
<li>只有所有的 pre-bind 扩展都成功执行了，bind 扩展才会执行</li>
<li>调度框架按照 bind 扩展注册的顺序逐个调用 bind 扩展</li>
<li>具体某个 bind 扩展可以选择处理或者不处理该 Pod</li>
<li>如果某个 bind 扩展处理了该 Pod 与节点的绑定，余下的 bind 扩展将被忽略</li>
</ul>
</li>
<li><code>Post-bind</code> 是一个通知性质的扩展：<ul>
<li>Post-bind 扩展在 Pod 成功绑定到节点上之后被动调用</li>
<li>Post-bind 扩展是绑定过程的最后一个步骤，可以用来执行资源清理的动作</li>
</ul>
</li>
<li><code>Unreserve</code> 是一个通知性质的扩展，如果为 Pod 预留了资源，Pod 又在被绑定过程中被拒绝绑定，则 unreserve 扩展将被调用。Unreserve 扩展应该释放已经为 Pod 预留的节点上的计算资源。在一个插件中，reserve 扩展和 unreserve 扩展应该成对出现。</li>
</ol>
<p>如果我们要实现自己的插件，必须向调度框架注册插件并完成配置，另外还必须实现扩展点接口，对应的扩展点接口我们可以在源码 <code>pkg/scheduler/framework/v1alpha1/interface.go</code> 文件中找到，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Plugin is the parent type for all the scheduling framework plugins.</span></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> QueueSortPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plugin</span><br><span class="line">    Less(*PodInfo, *PodInfo) <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreFilterPlugin is an interface that must be implemented by &quot;prefilter&quot; plugins.</span></span><br><span class="line"><span class="comment">// These plugins are called at the beginning of the scheduling cycle.</span></span><br><span class="line"><span class="keyword">type</span> PreFilterPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plugin</span><br><span class="line">    PreFilter(pc *PluginContext, p *v1.Pod) *Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FilterPlugin is an interface for Filter plugins. These plugins are called at the</span></span><br><span class="line"><span class="comment">// filter extension point for filtering out hosts that cannot run a pod.</span></span><br><span class="line"><span class="comment">// This concept used to be called &#x27;predicate&#x27; in the original scheduler.</span></span><br><span class="line"><span class="comment">// These plugins should return &quot;Success&quot;, &quot;Unschedulable&quot; or &quot;Error&quot; in Status.code.</span></span><br><span class="line"><span class="comment">// However, the scheduler accepts other valid codes as well.</span></span><br><span class="line"><span class="comment">// Anything other than &quot;Success&quot; will lead to exclusion of the given host from</span></span><br><span class="line"><span class="comment">// running the pod.</span></span><br><span class="line"><span class="keyword">type</span> FilterPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plugin</span><br><span class="line">    Filter(pc *PluginContext, pod *v1.Pod, nodeName <span class="type">string</span>) *Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostFilterPlugin is an interface for Post-filter plugin. Post-filter is an</span></span><br><span class="line"><span class="comment">// informational extension point. Plugins will be called with a list of nodes</span></span><br><span class="line"><span class="comment">// that passed the filtering phase. A plugin may use this data to update internal</span></span><br><span class="line"><span class="comment">// state or to generate logs/metrics.</span></span><br><span class="line"><span class="keyword">type</span> PostFilterPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plugin</span><br><span class="line">    PostFilter(pc *PluginContext, pod *v1.Pod, nodes []*v1.Node, filteredNodesStatuses NodeToStatusMap) *Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ScorePlugin is an interface that must be implemented by &quot;score&quot; plugins to rank</span></span><br><span class="line"><span class="comment">// nodes that passed the filtering phase.</span></span><br><span class="line"><span class="keyword">type</span> ScorePlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plugin</span><br><span class="line">    Score(pc *PluginContext, p *v1.Pod, nodeName <span class="type">string</span>) (<span class="type">int</span>, *Status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ScoreWithNormalizePlugin is an interface that must be implemented by &quot;score&quot;</span></span><br><span class="line"><span class="comment">// plugins that also need to normalize the node scoring results produced by the same</span></span><br><span class="line"><span class="comment">// plugin&#x27;s &quot;Score&quot; method.</span></span><br><span class="line"><span class="keyword">type</span> ScoreWithNormalizePlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ScorePlugin</span><br><span class="line">    NormalizeScore(pc *PluginContext, p *v1.Pod, scores NodeScoreList) *Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReservePlugin is an interface for Reserve plugins. These plugins are called</span></span><br><span class="line"><span class="comment">// at the reservation point. These are meant to update the state of the plugin.</span></span><br><span class="line"><span class="comment">// This concept used to be called &#x27;assume&#x27; in the original scheduler.</span></span><br><span class="line"><span class="comment">// These plugins should return only Success or Error in Status.code. However,</span></span><br><span class="line"><span class="comment">// the scheduler accepts other valid codes as well. Anything other than Success</span></span><br><span class="line"><span class="comment">// will lead to rejection of the pod.</span></span><br><span class="line"><span class="keyword">type</span> ReservePlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plugin</span><br><span class="line">    Reserve(pc *PluginContext, p *v1.Pod, nodeName <span class="type">string</span>) *Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreBindPlugin is an interface that must be implemented by &quot;prebind&quot; plugins.</span></span><br><span class="line"><span class="comment">// These plugins are called before a pod being scheduled.</span></span><br><span class="line"><span class="keyword">type</span> PreBindPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plugin</span><br><span class="line">    PreBind(pc *PluginContext, p *v1.Pod, nodeName <span class="type">string</span>) *Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostBindPlugin is an interface that must be implemented by &quot;postbind&quot; plugins.</span></span><br><span class="line"><span class="comment">// These plugins are called after a pod is successfully bound to a node.</span></span><br><span class="line"><span class="keyword">type</span> PostBindPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plugin</span><br><span class="line">    PostBind(pc *PluginContext, p *v1.Pod, nodeName <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnreservePlugin is an interface for Unreserve plugins. This is an informational</span></span><br><span class="line"><span class="comment">// extension point. If a pod was reserved and then rejected in a later phase, then</span></span><br><span class="line"><span class="comment">// un-reserve plugins will be notified. Un-reserve plugins should clean up state</span></span><br><span class="line"><span class="comment">// associated with the reserved Pod.</span></span><br><span class="line"><span class="keyword">type</span> UnreservePlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plugin</span><br><span class="line">    Unreserve(pc *PluginContext, p *v1.Pod, nodeName <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PermitPlugin is an interface that must be implemented by &quot;permit&quot; plugins.</span></span><br><span class="line"><span class="comment">// These plugins are called before a pod is bound to a node.</span></span><br><span class="line"><span class="keyword">type</span> PermitPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plugin</span><br><span class="line">    Permit(pc *PluginContext, p *v1.Pod, nodeName <span class="type">string</span>) (*Status, time.Duration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BindPlugin is an interface that must be implemented by &quot;bind&quot; plugins. Bind</span></span><br><span class="line"><span class="comment">// plugins are used to bind a pod to a Node.</span></span><br><span class="line"><span class="keyword">type</span> BindPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plugin</span><br><span class="line">    Bind(pc *PluginContext, p *v1.Pod, nodeName <span class="type">string</span>) *Status</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于调度框架插件的启用或者禁用，我们可以使用安装集群时的 <a target="_blank" rel="noopener" href="https://godoc.org/k8s.io/kubernetes/pkg/scheduler/apis/config#KubeSchedulerConfiguration">KubeSchedulerConfiguration</a> 资源对象来进行配置。下面的例子中的配置启用了一个实现了 <code>reserve</code> 和 <code>preBind</code> 扩展点的插件，并且禁用了另外一个插件，同时为插件 foo 提供了一些配置信息：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubescheduler.config.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeSchedulerConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="attr">reserve:</span></span><br><span class="line">    <span class="attr">enabled:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">bar</span></span><br><span class="line">    <span class="attr">disabled:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">baz</span></span><br><span class="line">  <span class="attr">preBind:</span></span><br><span class="line">    <span class="attr">enabled:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">disabled:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">baz</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pluginConfig:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">args:</span> <span class="string">&gt;</span></span><br><span class="line">      <span class="string">foo插件可以解析的任意内容</span></span><br></pre></td></tr></table></figure>



<p>扩展的调用顺序如下：</p>
<ul>
<li>如果某个扩展点没有配置对应的扩展，调度框架将使用默认插件中的扩展</li>
<li>如果为某个扩展点配置且激活了扩展，则调度框架将先调用默认插件的扩展，再调用配置中的扩展</li>
<li>默认插件的扩展始终被最先调用，然后按照 <code>KubeSchedulerConfiguration</code> 中扩展的激活 <code>enabled</code> 顺序逐个调用扩展点的扩展</li>
<li>可以先禁用默认插件的扩展，然后在 <code>enabled</code> 列表中的某个位置激活默认插件的扩展，这种做法可以改变默认插件的扩展被调用时的顺序</li>
</ul>
<p>假设默认插件 foo 实现了 <code>reserve</code> 扩展点，此时我们要添加一个插件 bar，想要在 foo 之前被调用，则应该先禁用 foo 再按照 bar foo 的顺序激活。示例配置如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubescheduler.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeSchedulerConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="attr">reserve:</span></span><br><span class="line">    <span class="attr">enabled:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">bar</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">disabled:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br></pre></td></tr></table></figure>



<p>在源码目录 <code>pkg/scheduler/framework/plugins/examples</code> 中有几个示范插件，我们可以参照其实现方式。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>其实要实现一个调度框架的插件，并不难，我们只要实现对应的扩展点，然后将插件注册到调度器中即可，下面是默认调度器在初始化的时候注册的插件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg/scheduler/algorithmprovider/registry.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRegistry</span><span class="params">()</span></span> Registry &#123;</span><br><span class="line">    <span class="keyword">return</span> Registry&#123;</span><br><span class="line">        <span class="comment">// FactoryMap:</span></span><br><span class="line">        <span class="comment">// New plugins are registered here.</span></span><br><span class="line">        <span class="comment">// example:</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//  stateful_plugin.Name: stateful.NewStatefulMultipointExample,</span></span><br><span class="line">        <span class="comment">//  fooplugin.Name: fooplugin.New,</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是可以看到默认并没有注册一些插件，所以要想让调度器能够识别我们的插件代码，就需要自己来实现一个调度器了，当然这个调度器我们完全没必要完全自己实现，直接调用默认的调度器，然后在上面的 <code>NewRegistry()</code> 函数中将我们的插件注册进去即可。在 <code>kube-scheduler</code> 的源码文件 <code>kubernetes/cmd/kube-scheduler/app/server.go</code> 中有一个 <code>NewSchedulerCommand</code> 入口函数，其中的参数是一个类型为 <code>Option</code> 的列表，而这个 <code>Option</code> 恰好就是一个插件配置的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Option configures a framework.Registry.</span></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(framework.Registry)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSchedulerCommand creates a *cobra.Command object with default parameters and registryOptions</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSchedulerCommand</span><span class="params">(registryOptions ...Option)</span></span> *cobra.Command &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以我们完全就可以直接调用这个函数来作为我们的函数入口，并且传入我们自己实现的插件作为参数即可，而且该文件下面还有一个名为 <code>WithPlugin</code> 的函数可以来创建一个 <code>Option</code> 实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithPlugin creates an Option based on plugin name and factory.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPlugin</span><span class="params">(name <span class="type">string</span>, factory framework.PluginFactory)</span></span> Option &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(registry framework.Registry)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registry.Register(name, factory)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以最终我们的入口函数如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line"></span><br><span class="line">    command := app.NewSchedulerCommand(</span><br><span class="line">        app.WithPlugin(sample.Name, sample.New),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    logs.InitLogs()</span><br><span class="line">    <span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        _, _ = fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中 <code>app.WithPlugin(sample.Name, sample.New)</code> 就是我们接下来要实现的插件，从 <code>WithPlugin</code> 函数的参数也可以看出我们这里的 <code>sample.New</code> 必须是一个 <code>framework.PluginFactory</code> 类型的值，而 <code>PluginFactory</code> 的定义就是一个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PluginFactory = <span class="function"><span class="keyword">func</span><span class="params">(configuration *runtime.Unknown, f FrameworkHandle)</span></span> (Plugin, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<p>所以 <code>sample.New</code> 实际上就是上面的这个函数，在这个函数中我们可以获取到插件中的一些数据然后进行逻辑处理即可，插件实现如下所示，我们这里只是简单获取下数据打印日志，如果你有实际需求的可以根据获取的数据就行处理即可，我们这里只是实现了 <code>PreFilter</code>、<code>Filter</code>、<code>PreBind</code> 三个扩展点，其他的可以用同样的方式来扩展即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插件名称</span></span><br><span class="line"><span class="keyword">const</span> Name = <span class="string">&quot;sample-plugin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">    FavoriteColor  <span class="type">string</span> <span class="string">`json:&quot;favorite_color,omitempty&quot;`</span></span><br><span class="line">    FavoriteNumber <span class="type">int</span>    <span class="string">`json:&quot;favorite_number,omitempty&quot;`</span></span><br><span class="line">    ThanksTo       <span class="type">string</span> <span class="string">`json:&quot;thanks_to,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sample <span class="keyword">struct</span> &#123;</span><br><span class="line">    args   *Args</span><br><span class="line">    handle framework.FrameworkHandle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sample)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sample)</span></span> PreFilter(pc *framework.PluginContext, pod *v1.Pod) *framework.Status &#123;</span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;prefilter pod: %v&quot;</span>, pod.Name)</span><br><span class="line">    <span class="keyword">return</span> framework.NewStatus(framework.Success, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sample)</span></span> Filter(pc *framework.PluginContext, pod *v1.Pod, nodeName <span class="type">string</span>) *framework.Status &#123;</span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;filter pod: %v, node: %v&quot;</span>, pod.Name, nodeName)</span><br><span class="line">    <span class="keyword">return</span> framework.NewStatus(framework.Success, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sample)</span></span> PreBind(pc *framework.PluginContext, pod *v1.Pod, nodeName <span class="type">string</span>) *framework.Status &#123;</span><br><span class="line">    <span class="keyword">if</span> nodeInfo, ok := s.handle.NodeInfoSnapshot().NodeInfoMap[nodeName]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">&quot;prebind get node info error: %+v&quot;</span>, nodeName))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;prebind node info: %+v&quot;</span>, nodeInfo.Node())</span><br><span class="line">        <span class="keyword">return</span> framework.NewStatus(framework.Success, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//type PluginFactory = func(configuration *runtime.Unknown, f FrameworkHandle) (Plugin, error)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(configuration *runtime.Unknown, f framework.FrameworkHandle)</span></span> (framework.Plugin, <span class="type">error</span>) &#123;</span><br><span class="line">    args := &amp;Args&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := framework.DecodeInto(configuration, args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;get plugin config args: %+v&quot;</span>, args)</span><br><span class="line">    <span class="keyword">return</span> &amp;Sample&#123;</span><br><span class="line">        args: args,</span><br><span class="line">        handle: f,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>完整代码可以前往仓库 <a target="_blank" rel="noopener" href="https://github.com/cnych/sample-scheduler-framework">https://github.com/cnych/sample-scheduler-framework</a> 获取。</p>
</blockquote>
<p>实现完成后，编译打包成镜像即可，然后我们就可以当成普通的应用用一个 <code>Deployment</code> 控制器来部署即可，由于我们需要去获取集群中的一些资源对象，所以当然需要申请 RBAC 权限，然后同样通过 <code>--config</code> 参数来配置我们的调度器，同样还是使用一个 <code>KubeSchedulerConfiguration</code> 资源对象配置，可以通过 <code>plugins</code> 来启用或者禁用我们实现的插件，也可以通过 <code>pluginConfig</code> 来传递一些参数值给插件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sample-scheduler-clusterrole</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">events</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">delete</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bindings</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pods/binding</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pods/status</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">replicationcontrollers</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">apps</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">extensions</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">replicasets</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">apps</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">statefulsets</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">policy</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">poddisruptionbudgets</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">persistentvolumeclaims</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">persistentvolumes</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;storage.k8s.io&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">storageclasses</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">csinodes</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;coordination.k8s.io&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">leases</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;events.k8s.io&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">events</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sample-scheduler-sa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sample-scheduler-clusterrolebinding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sample-scheduler-clusterrole</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sample-scheduler-sa</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">scheduler-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">scheduler-config.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    apiVersion: kubescheduler.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="string">    kind: KubeSchedulerConfiguration</span></span><br><span class="line"><span class="string">    leaderElection:</span></span><br><span class="line"><span class="string">      leaderElect: true</span></span><br><span class="line"><span class="string">      leaseDuration: 15s</span></span><br><span class="line"><span class="string">      renewDeadline: 10s</span></span><br><span class="line"><span class="string">      resourceLock: endpointsleases</span></span><br><span class="line"><span class="string">      resourceName: sample-scheduler</span></span><br><span class="line"><span class="string">      resourceNamespace: kube-system</span></span><br><span class="line"><span class="string">      retryPeriod: 2s</span></span><br><span class="line"><span class="string">    profiles:</span></span><br><span class="line"><span class="string">      - schedulerName: sample-scheduler</span></span><br><span class="line"><span class="string">        plugins:</span></span><br><span class="line"><span class="string">          preFilter:</span></span><br><span class="line"><span class="string">            enabled:</span></span><br><span class="line"><span class="string">              - name: &quot;sample-plugin&quot;</span></span><br><span class="line"><span class="string">          filter:</span></span><br><span class="line"><span class="string">            enabled:</span></span><br><span class="line"><span class="string">              - name: &quot;sample-plugin&quot;</span></span><br><span class="line"><span class="string">        pluginConfig:</span></span><br><span class="line"><span class="string">          - name: sample-plugin</span></span><br><span class="line"><span class="string">            args:  # runtime.Object</span></span><br><span class="line"><span class="string">              favorColor: &quot;#326CE5&quot;</span></span><br><span class="line"><span class="string">              favorNumber: 7</span></span><br><span class="line"><span class="string">              thanksTo: &quot;Kubernetes&quot;</span></span><br><span class="line"><span class="string"></span><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sample-scheduler</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">sample-scheduler</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">component:</span> <span class="string">sample-scheduler</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">component:</span> <span class="string">sample-scheduler</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">sample-scheduler-sa</span></span><br><span class="line">      <span class="attr">priorityClassName:</span> <span class="string">system-cluster-critical</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">scheduler-config</span></span><br><span class="line">          <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">scheduler-config</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">scheduler</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">cnych/sample-scheduler:v0.2.4</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">sample-scheduler</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--config=/etc/kubernetes/scheduler-config.yaml</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--v=3</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">scheduler-config</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/etc/kubernetes</span></span><br><span class="line"><span class="comment">#          livenessProbe:</span></span><br><span class="line"><span class="comment">#            httpGet:</span></span><br><span class="line"><span class="comment">#              path: /healthz</span></span><br><span class="line"><span class="comment">#              port: 10251</span></span><br><span class="line"><span class="comment">#            initialDelaySeconds: 15</span></span><br><span class="line"><span class="comment">#          readinessProbe:</span></span><br><span class="line"><span class="comment">#            httpGet:</span></span><br><span class="line"><span class="comment">#              path: /healthz</span></span><br><span class="line"><span class="comment">#              port: 10251</span></span><br></pre></td></tr></table></figure>



<p>直接部署上面的资源对象即可，这样我们就部署了一个名为 <code>sample-scheduler</code> 的调度器了，接下来我们可以部署一个应用来使用这个调度器进行调度：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-scheduler</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">test-scheduler</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">test-scheduler</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">sample-scheduler</span> <span class="comment"># 指定使用的调度器，不指定使用默认的default-scheduler</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<p>这里需要注意的是我们现在手动指定了一个 <code>schedulerName</code> 的字段，将其设置成上面我们自定义的调度器名称 <code>sample-scheduler</code>。</p>
<p>我们直接创建这个资源对象，创建完成后查看我们自定义调度器的日志信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods -n kube-system -l component=sample-scheduler</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class="line">sample-scheduler-896658cd7-k7vcl   1/1     Running   0          57s</span><br><span class="line">➜ kubectl logs -f sample-scheduler-896658cd7-k7vcl -n kube-system</span><br><span class="line">I0114 09:14:18.878613       1 eventhandlers.go:173] add event for unscheduled pod default/test-scheduler-6486fd49fc-zjhcx</span><br><span class="line">I0114 09:14:18.878670       1 scheduler.go:464] Attempting to schedule pod: default/test-scheduler-6486fd49fc-zjhcx</span><br><span class="line">I0114 09:14:18.878706       1 sample.go:77] &quot;Start PreFilter Pod&quot; pod=&quot;test-scheduler-6486fd49fc-zjhcx&quot;</span><br><span class="line">I0114 09:14:18.878802       1 sample.go:93] &quot;Start Filter Pod&quot; pod=&quot;test-scheduler-6486fd49fc-zjhcx&quot; node=&quot;node2&quot; preFilterState=&amp;&#123;Resource:&#123;MilliCPU:0 Memory:0 EphemeralStorage:0 AllowedPodNumber:0 ScalarResources:map[]&#125;&#125;</span><br><span class="line">I0114 09:14:18.878835       1 sample.go:93] &quot;Start Filter Pod&quot; pod=&quot;test-scheduler-6486fd49fc-zjhcx&quot; node=&quot;node1&quot; preFilterState=&amp;&#123;Resource:&#123;MilliCPU:0 Memory:0 EphemeralStorage:0 AllowedPodNumber:0 ScalarResources:map[]&#125;&#125;</span><br><span class="line">I0114 09:14:18.879043       1 default_binder.go:51] Attempting to bind default/test-scheduler-6486fd49fc-zjhcx to node1</span><br><span class="line">I0114 09:14:18.886360       1 scheduler.go:609] &quot;Successfully bound pod to node&quot; pod=&quot;default/test-scheduler-6486fd49fc-zjhcx&quot; node=&quot;node1&quot; evaluatedNodes=3 feasibleNodes=2</span><br><span class="line">I0114 09:14:18.887426       1 eventhandlers.go:205] delete event for unscheduled pod default/test-scheduler-6486fd49fc-zjhcx</span><br><span class="line">I0114 09:14:18.887475       1 eventhandlers.go:225] add event for scheduled pod default/test-scheduler-6486fd49fc-zjhcx</span><br></pre></td></tr></table></figure>



<p>可以看到当我们创建完 Pod 后，在我们自定义的调度器中就出现了对应的日志，并且在我们定义的扩展点上面都出现了对应的日志，证明我们的示例成功了，也可以通过查看 Pod 的 <code>schedulerName</code> 来验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods</span><br><span class="line">NAME                              READY   STATUS    RESTARTS       AGE</span><br><span class="line">test-scheduler-6486fd49fc-zjhcx   1/1     Running   0              35s</span><br><span class="line">➜ kubectl get pod test-scheduler-6486fd49fc-zjhcx -o yaml</span><br><span class="line">......</span><br><span class="line">restartPolicy: Always</span><br><span class="line">schedulerName: sample-scheduler</span><br><span class="line">securityContext: &#123;&#125;</span><br><span class="line">serviceAccount: default</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>从 Kubernetes v1.17 版本开始，<code>Scheduler Framework</code> 内置的预选和优选函数已经全部插件化，所以要扩展调度器我们应该掌握并理解调度框架这种方式。</p>
<h2 id="调度器调优"><a href="#调度器调优" class="headerlink" title="调度器调优"></a>调度器调优</h2><p>作为 kubernetes 集群的默认调度器，kube-scheduler 主要负责将 Pod 调度到集群的 Node 上。在一个集群中，满足一个 Pod 调度请求的所有节点称之为 <code>可调度 Node</code>，调度器先在集群中找到一个 Pod 的可调度 Node，然后根据一系列函数对这些可调度 Node 进行打分，之后选出其中得分最高的 Node 来运行 Pod，最后，调度器将这个调度决定告知 <code>kube-apiserver</code>，这个过程叫做<strong>绑定</strong>。</p>
<p>在 Kubernetes 1.12 版本之前，kube-scheduler 会检查集群中所有节点的可调度性，并且给可调度节点打分。Kubernetes 1.12 版本添加了一个新的功能，允许调度器在找到一定数量的可调度节点之后就停止继续寻找可调度节点。该功能能提高调度器在大规模集群下的调度性能，这个数值是集群规模的百分比，这个百分比通过 <code>percentageOfNodesToScore</code> 参数来进行配置，其值的范围在 1 到 100 之间，最大值就是 100%，如果设置为 0 就代表没有提供这个参数配置。Kubernetes 1.14 版本又加入了一个特性，在该参数没有被用户配置的情况下，调度器会根据集群的规模自动设置一个集群比例，然后通过这个比例筛选一定数量的可调度节点进入打分阶段。该特性使用<strong>线性公式</strong>计算出集群比例，比如 100 个节点的集群下会取 50%，在 5000 节点的集群下取 10%，这个自动设置的参数的最低值是 5%，换句话说，调度器至少会对集群中 5% 的节点进行打分，除非用户将该参数设置的低于 5。</p>
<p>!!! warning “注意”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当集群中的可调度节点少于 50 个时，调度器仍然会去检查所有节点，因为可调度节点太少，不足以停止调度器最初的过滤选择。如果我们想要关掉这个范围参数，可以将 `percentageOfNodesToScore` 值设置成 100。</span><br></pre></td></tr></table></figure>



<p><code>percentageOfNodesToScore</code> 的值必须在 1 到 100 之间，而且其默认值是通过集群的规模计算得来的，另外 <strong>50</strong> 个 Node 的数值是硬编码在程序里面的，设置这个值的作用在于：<strong>当集群的规模是数百个节点并且 percentageOfNodesToScore 参数设置的过低的时候，调度器筛选到的可调度节点数目基本不会受到该参数影响</strong>。当集群规模较小时，这个设置对调度器性能提升并不明显，但是在超过 1000 个 Node 的集群中，将调优参数设置为一个较低的值可以很明显的提升调度器性能。</p>
<p>不过值得注意的是，该参数设置后可能会导致只有集群中少数节点被选为可调度节点，很多 Node 都没有进入到打分阶段，这样就会造成一种后果，一个本来可以在打分阶段得分很高的 Node 甚至都不能进入打分阶段，由于这个原因，所以这个参数不应该被设置成一个很低的值，通常的做法是不会将这个参数的值设置的低于 10，很低的参数值一般在调度器的吞吐量很高且对 Node 的打分不重要的情况下才使用。换句话说，只有当你更倾向于在可调度节点中任意选择一个 Node 来运行这个 Pod 时，才使用很低的参数设置。</p>
<p>如果你的集群规模只有数百个节点或者更少，实际上并不推荐你将这个参数设置得比默认值更低，因为这种情况下不太会有效的提高调度器性能。</p>
<h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><p>与前面所讲的调度优选策略中的优先级（Priorities）不同，前面所讲的优先级指的是节点优先级，而我们这里所说的优先级指的是 Pod 的优先级，高优先级的 Pod 会优先被调度，或者在资源不足的情况牺牲低优先级的 Pod，以便于重要的 Pod 能够得到资源部署。</p>
<p>要定义 Pod 优先级，就需要先定义 <code>PriorityClass</code> 对象，该对象没有 Namespace 的限制：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">high-priority</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">1000000</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;This priority class should be used for XYZ service pods only.&#x27;</span></span><br></pre></td></tr></table></figure>



<p>其中：</p>
<ul>
<li>value 为 32 位整数的优先级，该值越大，优先级越高</li>
<li>globalDefault 用于未配置 PriorityClassName 的 Pod，整个集群中应该只有一个 <code>PriorityClass</code> 将其设置为 true</li>
</ul>
<p>然后通过在 Pod 的 <code>spec.priorityClassName</code> 中指定已定义的 <code>PriorityClass</code> 名称即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">priorityClassName:</span> <span class="string">high-priority</span></span><br></pre></td></tr></table></figure>



<p>另外一个值得注意的是当节点没有足够的资源供调度器调度 Pod，导致 Pod 处于 pending 时，抢占（preemption）逻辑就会被触发，抢占会尝试从一个节点删除低优先级的 Pod，从而释放资源使高优先级的 Pod 得到节点资源进行部署。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">路由算法与协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:14:52" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>路由协议 (Routing Protocols) 和路由选择算法 (Routing Algorithms) 是网络路由领域紧密相关但又截然不同的两个概念。理解它们之间的区别对于掌握网络路由的精髓至关重要。</p>
<h3 id="路由选择算法-Routing-Algorithms"><a href="#路由选择算法-Routing-Algorithms" class="headerlink" title="路由选择算法 (Routing Algorithms)"></a>路由选择算法 (Routing Algorithms)</h3><p><strong>核心：</strong> 路由选择算法是决定数据包在网络中从源到目的地最佳路径的逻辑或计算过程。它关注的是“<strong>如何计算出最佳路径</strong>”。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>数学模型&#x2F;逻辑：</strong> 它们是一套定义了如何根据特定度量（如跳数、延迟、带宽、成本等）来计算最优路径的数学模型或逻辑步骤。</li>
<li><strong>通用性：</strong> 许多路由算法是通用的计算机科学概念，不局限于特定的网络设备或协议。</li>
<li><strong>独立于实现：</strong> 算法本身只是一套理论，它不关心具体如何被实现或在哪个设备上运行。</li>
<li><strong>输入：</strong> 它们通常需要网络拓扑信息（节点和链路）以及链路成本&#x2F;度量作为输入。</li>
<li><strong>输出：</strong> 输出是到达网络中各个目的地的最佳路径。</li>
</ol>
<p><strong>常见的路由选择算法：</strong></p>
<ul>
<li><strong>Dijkstra (迪克斯特拉) 算法：</strong> 经典的<strong>最短路径算法</strong>，常用于<strong>链路状态路由</strong>（如 OSPF）。它计算从单个源到所有其他节点的单源最短路径。</li>
<li><strong>Bellman-Ford (贝尔曼-福特) 算法：</strong> 用于计算从单个源到所有其他节点的最短路径，能够处理负权重边（尽管在路由中不常见）。它是<strong>距离向量路由</strong>（如 RIP）的基础。</li>
<li><strong>Floyd-Warshall (弗洛伊德-沃沙尔) 算法：</strong> 计算所有节点对之间的最短路径。</li>
<li><strong>链路状态算法 (Link-State Algorithms)：</strong> 每个路由器维护网络完整的拓扑图，然后独立地运行 Dijkstra 算法计算最短路径树。</li>
<li><strong>距离向量算法 (Distance-Vector Algorithms)：</strong> 每个路由器只知道其邻居可达的目的地和到这些目的地的距离向量，通过与邻居交换信息，迭代地更新自己的距离向量。</li>
</ul>
<h3 id="路由协议-Routing-Protocols"><a href="#路由协议-Routing-Protocols" class="headerlink" title="路由协议 (Routing Protocols)"></a>路由协议 (Routing Protocols)</h3><p><strong>核心：</strong> 路由协议是一种在路由器之间交换路由信息（即网络可达性信息）的规则和消息格式。它关注的是“<strong>如何交换信息以便应用路由算法</strong>”。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>通信机制：</strong> 它们定义了路由器之间如何发现彼此、如何通告它们所知道的网络、如何发现变化（如链路故障）、以及如何同步它们的路由表。</li>
<li><strong>协议栈的一部分：</strong> 路由协议是网络协议栈的一部分，它们有自己的消息格式、报文类型、定时器、状态机等。</li>
<li><strong>实现算法：</strong> 路由协议是路由选择算法的<strong>具体实现</strong>。协议负责收集算法所需的输入（如链路状态信息或距离向量），并根据算法的输出（最佳路径）来更新和维护路由表。</li>
<li><strong>分类：</strong><ul>
<li><strong>内部网关协议 (IGPs - Interior Gateway Protocols)：</strong> 在同一个自治系统 (AS - Autonomous System) 内部运行，例如 OSPF, EIGRP, RIP。</li>
<li><strong>外部网关协议 (EGPs - Exterior Gateway Protocols)：</strong> 在不同自治系统之间运行，最主要的就是 BGP。</li>
</ul>
</li>
<li><strong>路由信息库 (RIB&#x2F;Routing Table)：</strong> 路由协议将计算出的最佳路由条目存储在路由信息库 (RIB) 或路由表 (Routing Table) 中，这些路由条目最终会被安装到转发表 (Forwarding Information Base - FIB) 中，用于实际的数据包转发。</li>
</ol>
<p><strong>常见的路由协议：</strong></p>
<ul>
<li><strong>RIP (Routing Information Protocol)：</strong> 经典的距离向量协议，使用 Bellman-Ford 算法的某种变体，度量通常是跳数。</li>
<li><strong>OSPF (Open Shortest Path First)：</strong> 链路状态协议，使用 Dijkstra 算法计算最短路径树，度量基于链路带宽或成本。</li>
<li><strong>EIGRP (Enhanced Interior Gateway Routing Protocol)：</strong> 思科私有（现已开放），混合型协议（先进距离向量），使用 Diffusing Update Algorithm (DUAL)。</li>
<li><strong>IS-IS (Intermediate System to Intermediate System)：</strong> 链路状态协议，功能与 OSPF 类似，常用于大型 ISP 网络。</li>
<li><strong>BGP (Border Gateway Protocol)：</strong> 路径向量协议，是互联网的“骨干”协议，用于不同自治系统之间的路由，主要基于策略进行路由选择，而非简单的最短路径。</li>
</ul>
<h3 id="核心区别总结："><a href="#核心区别总结：" class="headerlink" title="核心区别总结："></a>核心区别总结：</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">路由选择算法 (Routing Algorithms)</th>
<th align="left">路由协议 (Routing Protocols)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>做什么</strong></td>
<td align="left"><strong>决策过程</strong>：计算网络中的最佳路径。</td>
<td align="left"><strong>通信与实现</strong>：在路由器之间交换路由信息，并实现路由算法。</td>
</tr>
<tr>
<td align="left"><strong>本质</strong></td>
<td align="left"><strong>逻辑、方法、计算过程</strong>。</td>
<td align="left"><strong>规则、消息格式、通信机制</strong>。</td>
</tr>
<tr>
<td align="left"><strong>关注点</strong></td>
<td align="left">如何找到最佳路径。</td>
<td align="left">如何收集数据、如何通告路径、如何维护路由表。</td>
</tr>
<tr>
<td align="left"><strong>是理论还是产物</strong></td>
<td align="left">一套理论或数学模型。</td>
<td align="left">具体的网络协议软件，在路由器上运行。</td>
</tr>
<tr>
<td align="left"><strong>输出</strong></td>
<td align="left">到达所有目的地的“最短路径”。</td>
<td align="left">已更新的路由表条目（包含下一跳、出接口、度量等）。</td>
</tr>
<tr>
<td align="left"><strong>例子</strong></td>
<td align="left">Dijkstra, Bellman-Ford, 链路状态，距离向量。</td>
<td align="left">OSPF, RIP, BGP, EIGRP, IS-IS。</td>
</tr>
<tr>
<td align="left"><strong>依赖关系</strong></td>
<td align="left">协议实现算法，算法是协议的基础。</td>
<td align="left">协议需要实现特定的算法来计算路由。</td>
</tr>
</tbody></table>
<p>简而言之，<strong>路由选择算法是“大脑”</strong>，它决定了如何思考和得出决策；而<strong>路由协议是“语言和交流工具”</strong>，它定义了路由器之间如何沟通和分享信息，以便每个路由器都能运用算法来构建自己的网络地图并做出转发决策。没有路由协议，路由算法就无法获得所需的信息；没有路由算法，路由协议交换的信息就无法被有效地利用来指导数据包转发。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">运算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:19:53" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/Query-PromQL/" itemprop="url" rel="index"><span itemprop="name">Query PromQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><p>Prometheus 的查询语言支持基本的逻辑运算和算术运算。</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>在 Prometheus 系统中支持下面的二元算术运算符：</p>
<ul>
<li><code>+</code> 加法</li>
<li><code>-</code> 减法</li>
<li><code>*</code> 乘法</li>
<li><code>/</code> 除法</li>
<li><code>%</code> 模</li>
<li><code>^</code> 幂等</li>
</ul>
<p>最简单的我们可以将一个数字计算当做一个 PromQL 语句，用于<strong>标量与标量</strong>之间计算，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(2 + 3 / 6) * 2^2</span><br></pre></td></tr></table></figure>



<p>可以得到如下所示的结果：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/o7woia.png" alt="标量计算"></p>
<p>图形中返回的是一个值为 10 的标量（<code>scalar</code>）类型的数据。</p>
<p>二元运算同样适用于<strong>向量和标量</strong>之间，例如我们可以将一个字节数除以两次 1024 来转换为 MiB，如下查询语句：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo_batch_last_run_processed_bytes&#123;job=&quot;demo&quot;&#125; / 1024 / 1024</span><br></pre></td></tr></table></figure>



<p>最后计算的结果就是 MiB 单位的了：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20210416163824.png" alt="向量和标量运算"></p>
<p>另外 PromQL 的一个强大功能就是可以让我们在<strong>向量与向量</strong>之间进行二元运算。</p>
<p>例如 <code>demo_api_request_duration_seconds_sum</code> 的数据包含了在 <code>path</code>、<code>method</code>、<code>status</code> 等不同维度上花费的总时间，指标 <code>demo_api_request_duration_seconds_count</code> 包含了上面同维度下的请求总次数。则我们可以用下面的语句来查询过去 5 分钟的平均请求持续时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rate(demo_api_request_duration_seconds_sum&#123;job=&quot;demo&quot;&#125;[5m])</span><br><span class="line">/</span><br><span class="line">rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m])</span><br></pre></td></tr></table></figure>



<p>PromQL 会通过相同的标签集自动匹配操作符左边和右边的元素，并将二元运算应用到它们身上。由于上面两个指标的标签集合都是一致的，所有可以得到相同标签集的平均请求延迟结果：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/jjwh6v.png" alt="向量与向量运算"></p>
<h2 id="向量匹配"><a href="#向量匹配" class="headerlink" title="向量匹配"></a>向量匹配</h2><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>上面的示例其实就是一对一的向量匹配，但是一对一向量匹配也有两种情况，就是是否按照所有标签匹配进行计算，下图是匹配所有标签的情况：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/lmxgli.png" alt="onetoone"></p>
<p>图中我们两个指标 foo 和 bar，分别生成了 3 个序列：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TYPE foo gauge</span></span><br><span class="line">foo&#123;color=&quot;red&quot;, size=&quot;small&quot;&#125; 4</span><br><span class="line">foo&#123;color=&quot;green&quot;, size=&quot;medium&quot;&#125; 8</span><br><span class="line">foo&#123;color=&quot;blue&quot;, size=&quot;large&quot;&#125; 16</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TYPE bar gauge</span></span><br><span class="line">bar&#123;color=&quot;green&quot;, size=&quot;xlarge&quot;&#125; 2</span><br><span class="line">bar&#123;color=&quot;blue&quot;, size=&quot;large&quot;&#125; 7</span><br><span class="line">bar&#123;color=&quot;red&quot;, size=&quot;small&quot;&#125; 5</span><br></pre></td></tr></table></figure>



<p>当我们执行查询语句 <code>foo&#123;&#125; + bar&#123;&#125;</code> 的时候，对于向量左边的每一个元素，操作符都会尝试在右边里面找到一个匹配的元素，匹配是通过比较所有的标签来完成的，没有匹配的元素会被丢弃，我们可以看到其中的 <code>foo&#123;color=&quot;green&quot;, size=&quot;medium&quot;&#125;</code> 与 <code>bar&#123;color=&quot;green&quot;, size=&quot;xlarge&quot;&#125;</code> 两个序列的标签是不匹配的，其余两个序列标签匹配，所以计算结果会抛弃掉不匹配的序列，得到的结果为其余序列的值相加。</p>
<p>上面例子中其中不匹配的标签主要是因为第二个 <code>size</code> 标签不一致造成的，那么如果我们在计算的时候忽略掉这个标签可以吗？如下图所示：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/pv679o.png" alt="onetoone"></p>
<p>同样针对上面的两个指标，我们在进行计算的时候可以使用 <code>on</code> 或者 <code>ignoring</code> 修饰符来指定用于匹配的标签进行计算，由于示例中两边的标签都具有 <code>color</code> 标签，所以在进行计算的时候我们可以基于该标签（<code>on (color)</code>）或者忽略其他的标签（<code>ignoring (size)</code>）进行计算，这样得到的结果就是所以匹配的标签序列相加的结果，要注意结果中的标签也是匹配的标签。</p>
<h3 id="一对多与多对一"><a href="#一对多与多对一" class="headerlink" title="一对多与多对一"></a>一对多与多对一</h3><p>上面讲解的一对一的向量计算是最直接的方式，在多数情况下，<code>on</code> 或者 <code>ignoring</code> 修饰符有助于是查询返回合理的结果，但通常情况用于计算的两个向量之间并不是一对一的关系，更多的是一对多或者多对一的关系，对于这种场景我们就不能简单使用上面的方式进行处理了。</p>
<p>多对一和一对多两种匹配模式指的是<code>一</code>侧的每一个向量元素可以与<code>多</code>侧的多个元素匹配的情况，在这种情况下，必须使用 group 修饰符：<code>group_left</code> 或者 <code>group_right</code> 来确定哪一个向量具有更高的基数（充当<code>多</code>的角色）。多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况，因此同样需要使用 <code>ignoring</code> 和 <code>on</code> 修饰符来排除或者限定匹配的标签列表。</p>
<p>例如 <code>demo_num_cpus</code> 指标告诉我们每个实例的 CPU 核心数量，只有 <code>instance</code> 和 <code>job</code> 这两个标签维度。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20210416171427.png" alt="demo_num_cpus 指标"></p>
<p>而 <code>demo_cpu_usage_seconds_total</code> 指标则多了一个 <code>mode</code> 标签的维度，将每个 <code>mode</code> 模式（<code>idle</code>、<code>system</code>、<code>user</code>）的 CPU 使用情况分开进行了统计。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20210416171541.png" alt="demo_cpu_usage_seconds_total 指标"></p>
<p>如果要计算每个模式的 CPU 使用量除以核心数，我们需要告诉除法运算符按照 <code>demo_cpu_usage_seconds_total</code> 指标上额外的 <code>mode</code> 标签维度对结果进行分组，我们可以使用 <code>group_left</code>（表示左边的向量具有更高的基数）修饰符来实现。同时，我们还需要通过 <code>on()</code> 修饰符明确将所考虑的标签集减少到需要匹配的标签列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rate(demo_cpu_usage_seconds_total&#123;job=&quot;demo&quot;&#125;[5m])</span><br><span class="line">/ on(job, instance) group_left</span><br><span class="line">demo_num_cpus&#123;job=&quot;demo&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>上面的表达式可以正常得到结果：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/yb6sef.png" alt="group_left 模式"></p>
<p>除了 <code>on()</code> 之外，还可以使用相反的 <code>ignoring()</code> 修饰符，可以用来将一些标签维度从二元运算操作匹配中忽略掉，如果在操作符的右侧有额外的维度，则应该使用 <code>group_right</code>（表示右边的向量具有更高的基数）修饰符。</p>
<p>比如上面的查询语句同样可以用 <code>ignoring</code> 关键字来完成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rate(demo_cpu_usage_seconds_total&#123;job=&quot;demo&quot;&#125;[5m])</span><br><span class="line">/ ignoring(mode) group_left</span><br><span class="line">demo_num_cpus&#123;job=&quot;demo&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>得到的结果和前面用 <code>on()</code> 查询的结果是一致的。</p>
<p>到这里我们就知道了如何在 PromQL 中进行标量和向量之间的运算了。不过我们在使用 PromQL 查询数据的时候还行要避免使用关联查询，先想想能不能通过 Relabel（后续会详细介绍）的方式给原始数据多加个 Label，一条语句能查出来的何必用 Join 呢？时序数据库不是关系数据库。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1.计算过去 5 分钟所有 POST 请求平均数的总和相对于所有请求平均数总和的百分比。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(rate(demo_api_request_duration_seconds_count&#123;method=&quot;POST&quot;&#125;[5m]))</span><br><span class="line">/</span><br><span class="line">sum(rate(demo_api_request_duration_seconds_count[5m])) * 100</span><br></pre></td></tr></table></figure>



<p>2.计算过去 5 分钟内每个实例的 user 和 system 的模式（<code>demo_cpu_usage_seconds_total</code> 指标）下 CPU 使用量平均值总和。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum by(instance, job) (rate(demo_cpu_usage_seconds_total&#123;mode=~&quot;user|system&quot;&#125;[5m]))</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum without(mode) (rate(demo_cpu_usage_seconds_total&#123;mode=~&quot;user|system&quot;&#125;[5m]))</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rate(demo_cpu_usage_seconds_total&#123;mode=&quot;user&quot;&#125;[5m]) + ignoring(mode)</span><br><span class="line">rate(demo_cpu_usage_seconds_total&#123;mode=&quot;system&quot;&#125;[5m])</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E9%87%8D%E5%AE%9A%E5%90%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E9%87%8D%E5%AE%9A%E5%90%91/" class="post-title-link" itemprop="url">Nginx重定向</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:20:58" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nginx-中如何实现请求的重定向"><a href="#Nginx-中如何实现请求的重定向" class="headerlink" title="Nginx 中如何实现请求的重定向"></a>Nginx 中如何实现请求的重定向</h1><p>请求重定向是 Nginx 中一项非常常用且重要的功能，主要用于：</p>
<ol>
<li><strong>URL 规范化：</strong> 例如，将 <code>http://example.com</code> 重定向到 <code>https://example.com</code>，或将 <code>example.com</code> 重定向到 <code>www.example.com</code>。</li>
<li><strong>网站结构调整：</strong> 当你更改了网站某些页面的 URL 路径，需要将旧 URL 重定向到新 URL，以避免用户遇到 <code>404 Not Found</code> 错误，并保持搜索引擎排名。</li>
<li><strong>负载均衡或维护：</strong> 在特定情况下将所有请求重定向到另一个域名或一个维护页面。</li>
<li><strong>强制添加&#x2F;移除斜杠：</strong> 规范 URL 格式。</li>
</ol>
<p>Nginx 中实现重定向主要通过以下两个指令：<code>return</code> 和 <code>rewrite</code>。</p>
<hr>
<h3 id="1-return-指令-简单重定向"><a href="#1-return-指令-简单重定向" class="headerlink" title="1. return 指令 (简单重定向)"></a>1. <code>return</code> 指令 (简单重定向)</h3><p><code>return</code> 指令是实现简单重定向最直接、最高效的方式。它会立即停止处理请求，并向客户端发送指定的 HTTP 状态码及其对应的 URL。</p>
<p><strong>语法：</strong> <code>return code [text];</code><br>或 <code>return code URL;</code></p>
<p><strong>常用状态码：</strong></p>
<ul>
<li><strong><code>301 Moved Permanently</code>：</strong> 永久重定向。最常用，告诉浏览器和搜索引擎这个资源已经永久移动到新的 URL。对 SEO 非常重要。</li>
<li><strong><code>302 Found</code>：</strong> 临时重定向。告诉浏览器和搜索引擎这个资源暂时移动到新的 URL。不常用，因为搜索引擎可能不传递权重。</li>
<li><strong><code>307 Temporary Redirect</code>：</strong> 临时重定向。与 <code>302</code> 类似，但更明确地指示客户端在重定向时不改变请求方法（POST 请求仍然是 POST）。</li>
<li><strong><code>308 Permanent Redirect</code>：</strong> 永久重定向。与 <code>301</code> 类似，但更明确地指示客户端在重定向时不改变请求方法。</li>
</ul>
<p><strong>配置位置：</strong> <code>server</code>、<code>location</code> 块。</p>
<hr>
<h4 id="示例-1-1-HTTP-强制跳转-HTTPS-最常见场景"><a href="#示例-1-1-HTTP-强制跳转-HTTPS-最常见场景" class="headerlink" title="示例 1.1: HTTP 强制跳转 HTTPS (最常见场景)"></a>示例 1.1: HTTP 强制跳转 HTTPS (最常见场景)</h4><p>通常我们的网站都会强制使用 HTTPS。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment"># 监听 HTTP 端口</span></span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com; <span class="comment"># 监听的域名</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>; <span class="comment"># 强制跳转到 HTTPS，并保留原路径和查询参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl; <span class="comment"># 监听 HTTPS 端口</span></span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置 SSL 证书和密钥，省略...</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/certs/example.com.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/certs/example.com.key;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... 其他 HTTPS 站点的配置 (如动静分离、API 代理等)</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong> 任何通过 HTTP (端口 80) 访问 <code>example.com</code> 或 <code>www.example.com</code> 的请求，都会被 <code>301</code> 永久重定向到对应的 HTTPS 地址。<code>$host</code> 变量会是请求中的 Host 头（<code>example.com</code> 或 <code>www.example.com</code>），<code>$request_uri</code> 包含完整的路径和查询参数。</p>
<hr>
<h4 id="示例-1-2-强制跳转到带-www-的域名"><a href="#示例-1-2-强制跳转到带-www-的域名" class="headerlink" title="示例 1.2: 强制跳转到带 www 的域名"></a>示例 1.2: 强制跳转到带 <code>www</code> 的域名</h4><p>许多网站习惯将非 <code>www</code> 域名重定向到 <code>www</code> 域名，或反之，以规范 URL。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com; <span class="comment"># 监听没有 www 的域名</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> http://www.example.com<span class="variable">$request_uri</span>; <span class="comment"># 重定向到 www 域名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com; <span class="comment"># 监听带 www 的域名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... www.example.com 网站的配置</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong> 当用户访问 <code>http://example.com/path</code> 时，会被 <code>301</code> 重定向到 <code>http://www.example.com/path</code>。这种配置通常与 HTTPS 跳转结合使用，形成以下组合：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. HTTP -&gt; HTTPS (no-www -&gt; www)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 优先处理 no-www 到 www 的跳转，通常先跳 HTTPS</span></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$host</span> = <span class="string">&#x27;example.com&#x27;</span>) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 已经带 www 的 HTTP 请求跳 HTTPS</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. HTTPS (no-www -&gt; www)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com; <span class="comment"># 监听没有 www 的 HTTPS 域名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># SSL 配置...</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/certs/example.com.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/certs/example.com.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>; <span class="comment"># 将 https://example.com 重定向到 https://www.example.com</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 目标 HTTPS 站点</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SSL 配置...</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/certs/example.com.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/certs/example.com.key;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：<code>if</code> 指令的滥用在 Nginx 中不被推荐，但对于简单的 <code>$host</code> 判断，其副作用有限。更健壮的做法是为 <code>example.com</code> 和 <code>www.example.com</code> 定义不同的 <code>server</code> 块。</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server block for example.com (HTTP) redirects to www.example.com (HTTPS)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># server block for www.example.com (HTTP) redirects to www.example.com (HTTPS)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># server block for example.com (HTTPS) redirects to www.example.com (HTTPS)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/certs/example.com.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/certs/example.com.key;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># server block for official www.example.com (HTTPS)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/certs/www.example.com.crt; <span class="comment"># 最好使用匹配 www 的证书</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/certs/www.example.com.key;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种多 <code>server</code> 块的写法更清晰且符合 Nginx 的设计哲学。</p>
<hr>
<h3 id="2-rewrite-指令-高级重定向-URL-重写"><a href="#2-rewrite-指令-高级重定向-URL-重写" class="headerlink" title="2. rewrite 指令 (高级重定向&#x2F;URL 重写)"></a>2. <code>rewrite</code> 指令 (高级重定向&#x2F;URL 重写)</h3><p><code>rewrite</code> 指令更为强大和灵活，它可以使用正则表达式来匹配 URL，并根据匹配结果修改 URL。它不仅可以实现重定向，还可以进行 URL 重写（URL 内部跳转到代理）。</p>
<p><strong>语法：</strong> <code>rewrite regex replacement [flag];</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>regex</code>：用于匹配 URL 的正则表达式。</li>
<li><code>replacement</code>：重写后的 URL 或要重定向到的 URL。</li>
<li><code>flag</code>：控制重写行为的标志。<ul>
<li><code>last</code>：停止当前 <code>location</code> 块的 <code>rewrite</code> 指令，继续在新的 URI 下面进行其他 <code>location</code> 的匹配。</li>
<li><code>break</code>：停止当前 <code>location</code> 块的所有 <code>rewrite</code> 指令，并停止处理当前 <code>location</code> 块的请求，但不会在新的 URI 下面进行其他 <code>location</code> 的匹配。</li>
<li><code>redirect</code>：返回 <code>302 Temporary Redirect</code> 响应码。</li>
<li><code>permanent</code>：返回 <code>301 Moved Permanently</code> 响应码。</li>
</ul>
</li>
</ul>
<p><strong>执行顺序：</strong></p>
<ol>
<li>首先在 <code>server</code> 块中按顺序执行 <code>rewrite</code> 指令。</li>
<li>然后根据 <code>server</code> 块中重写后的 URI 寻找匹配的 <code>location</code> 块。</li>
<li>如果在 <code>location</code> 块中还有 <code>rewrite</code> 指令，则按顺序执行。</li>
</ol>
<p><strong>配置位置：</strong> <code>server</code>、<code>location</code> 块。</p>
<hr>
<h4 id="示例-2-1-重定向旧-URL-到新-URL-使用-permanent-flag"><a href="#示例-2-1-重定向旧-URL-到新-URL-使用-permanent-flag" class="headerlink" title="示例 2.1: 重定向旧 URL 到新 URL (使用 permanent flag)"></a>示例 2.1: 重定向旧 URL 到新 URL (使用 <code>permanent</code> flag)</h4><p>假设你的网站结构调整，旧产品详情页的 URL 格式是 <code>/product?id=123</code>，现在变成了 <code>/products/item-123.html</code>。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 重定向旧格式的 /product?id=N 到新格式 /products/item-N.html</span></span><br><span class="line">        <span class="comment"># (?&lt;id&gt;\d+) 是捕获组，名为 id，匹配一个或多个数字</span></span><br><span class="line">        <span class="comment"># $arg_id 获取 URL query string 中的 id 参数</span></span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$arg_id</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/product$</span> /products/item-<span class="variable">$arg_id</span>.html <span class="literal">permanent</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 另一种写法，更推荐在 location 块中使用</span></span><br><span class="line">        <span class="comment"># location = /product &#123; # 精确匹配 /product</span></span><br><span class="line">        <span class="comment">#     if ($arg_id) &#123;</span></span><br><span class="line">        <span class="comment">#         rewrite ^ /products/item-$arg_id.html permanent;</span></span><br><span class="line">        <span class="comment">#     &#125;</span></span><br><span class="line">        <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 或者如果旧 URL 是 /old-product-page.html</span></span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/old-product-page.html$</span> /new-product-page.html <span class="literal">permanent</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ... 其他网站的配置</span></span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>当请求 <code>http://example.com/product?id=123</code> 时，由于 <code>id</code> 参数存在，Nginx 会执行 <code>rewrite</code> 规则，将请求 <code>301</code> 重定向到 <code>http://example.com/products/item-123.html</code>。</li>
<li>当请求 <code>http://example.com/old-product-page.html</code> 时，会被 <code>301</code> 重定向到 <code>http://example.com/new-product-page.html</code>。</li>
</ul>
<hr>
<h4 id="示例-2-2-实现伪静态（URL-重写，内部跳转）"><a href="#示例-2-2-实现伪静态（URL-重写，内部跳转）" class="headerlink" title="示例 2.2: 实现伪静态（URL 重写，内部跳转）"></a>示例 2.2: 实现伪静态（URL 重写，内部跳转）</h4><p>许多 PHP 框架（如 WordPress、Laravel）会把所有请求都通过一个入口文件 <code>index.php</code> 来处理。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="attribute">root</span> /var/www/html; <span class="comment"># 网站的根目录</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 尝试查找对应的文件或目录</span></span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ =<span class="number">404</span>; <span class="comment"># 如果找不到，返回 404</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于所有不匹配现有文件或目录的请求（非静态文件），重写到 index.php</span></span><br><span class="line">        <span class="comment"># 如果你的应用要求所有请求都通过 index.php 处理，可以这样配置 (WordPress 常用)</span></span><br><span class="line">        <span class="comment"># rewrite ^/(.*)$ /index.php/$1 last; # 将 /abc/xyz 重写为 /index.php/abc/xyz</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更常见的单入口应用配置 (例如 Laravel, Symfony)</span></span><br><span class="line">        <span class="comment"># try_files $uri $uri/ /index.php?$query_string;</span></span><br><span class="line">        <span class="comment"># 这里的 try_files 如果找不到文件或目录，会尝试将请求内部转发给 /index.php，</span></span><br><span class="line">        <span class="comment"># 并带上原始的查询参数。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># PHP-FPM 配置</span></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">        <span class="comment"># root /var/www/html; # 与 server 块的 root 一致</span></span><br><span class="line">        <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; <span class="comment"># PHP-FPM 地址和端口</span></span><br><span class="line">        <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>当请求 <code>http://example.com/posts/hello-world</code> 时，<code>try_files</code> 会先检查 <code>/var/www/html/posts/hello-world</code> 文件和 <code>/var/www/html/posts/hello-world/</code> 目录是否存在。</li>
<li>如果都不存在，它会将请求内部转发到 <code>/index.php</code>，并把原始的 <code>$query_string</code>（如果有）传递过去。Nginx 不会向浏览器发送重定向响应，浏览器仍认为自己访问的是 <code>/posts/hello-world</code>。</li>
<li>然后 <code>location ~ \.php$</code> 块会捕获 <code>/index.php</code> 的请求，并将其转发给 PHP-FPM 处理。</li>
</ul>
<hr>
<h4 id="示例-2-3-添加或移除-URL-尾部斜杠"><a href="#示例-2-3-添加或移除-URL-尾部斜杠" class="headerlink" title="示例 2.3: 添加或移除 URL 尾部斜杠"></a>示例 2.3: 添加或移除 URL 尾部斜杠</h4><p>统一 URL 格式有时需要处理尾部斜杠。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="attribute">root</span> /var/www/html;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 移除 URL 结尾的斜杠 (如果不是目录)</span></span><br><span class="line">    <span class="comment"># /path/ -&gt; /path</span></span><br><span class="line">    <span class="comment"># 但不移除根目录 / 的斜杠</span></span><br><span class="line">    <span class="comment"># 注意：这个通常适用于文件，对于目录，保留斜杠更好。</span></span><br><span class="line">    <span class="comment"># rewrite ^/(.*)/$ /$1 permanent; # 这会把 / 重定向到空，不建议这样用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更安全的方式，只处理文件请求，确保没有斜杠</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 确保所有以 .html 结尾的文件没有尾部斜杠</span></span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$uri</span> <span class="regexp">~ ^(.*)\.html/$)</span>&#123;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">301</span> <span class="variable">$1</span>.html;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 添加尾部斜杠到非文件、非根路径的目录，让搜索引擎识别为目录</span></span><br><span class="line">        <span class="comment"># 但是，try_files $uri $uri/ 已经能很好地处理这个问题，通常不需要此 rewrite</span></span><br><span class="line">        <span class="comment"># if (-d $request_filename) &#123; # 如果请求的是目录</span></span><br><span class="line">        <span class="comment">#    rewrite ^/(.*)([^/])$ /$1$2/ permanent;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 常见的强制为目录添加尾部斜杠的写法</span></span><br><span class="line">        <span class="comment"># 如果不是文件，且 URI 不以 / 结尾，则添加斜杠</span></span><br><span class="line">        <span class="comment"># 需配合 try_files 确保文件不被误判</span></span><br><span class="line">        <span class="comment"># rewrite ^(/.*[^/])$ $1/ permanent; # 简单粗暴，但可能影响文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 推荐使用 try_files 配合默认行为，更稳健</span></span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 尾部斜杠的处理比较复杂，因为文件的 URL 通常不带斜杠，而目录的 URL 通常带斜杠。滥用 <code>rewrite</code> 可能导致无限重定向或错误。通常 <code>try_files</code> 指令能更好地处理目录和文件的匹配逻辑。如果你需要强制规范，建议精细化匹配。</p>
<hr>
<h3 id="选择-return-还是-rewrite？"><a href="#选择-return-还是-rewrite？" class="headerlink" title="选择 return 还是 rewrite？"></a>选择 <code>return</code> 还是 <code>rewrite</code>？</h3><ul>
<li><strong>使用 <code>return</code>：</strong><ul>
<li><strong>首选！</strong> 当你只需要将请求从一个 URL <strong>重定向到另一个完整的 URL</strong>（包括协议、域名、路径）时。</li>
<li>处理规则简单，不涉及复杂的正则表达式匹配或内部 URL 转换。</li>
<li>性能更好，因为 Nginx 会立即停止处理，并发送响应。</li>
</ul>
</li>
<li><strong>使用 <code>rewrite</code>：</strong><ul>
<li>当你需要基于请求的 URL <strong>进行复杂的模式匹配和替换</strong>，以生成新的 URL 时。</li>
<li>当你需要进行 <strong>URL 重写</strong>（即内部跳转到另一个文件或 URL，而不向客户端发送重定向响应）时，通常结合 <code>last</code> 或 <code>break</code> 标志，或者 <code>try_files</code> 指令。</li>
<li>涉及到变量和正则表达式的捕获。</li>
</ul>
</li>
</ul>
<p><strong>一般原则：</strong> 优先使用 <code>return</code> 解决重定向问题。只有当 <code>return</code> 无法满足需求时，才考虑使用 <code>rewrite</code>，并谨慎使用 <code>last</code> 或 <code>break</code> 标志，因为它们的行为可能比较复杂，容易导致非预期的结果。</p>
<p>通过这些示例，你应该能理解 Nginx 中重定向的工作原理和配置方法了。记住，每次修改 Nginx 配置后，都要进行语法检查 (<code>nginx -t</code>) 并重载服务 (<code>systemctl reload nginx</code>)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">闭包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:09:49" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Go语言中闭包的实现"><a href="#Go语言中闭包的实现" class="headerlink" title="Go语言中闭包的实现"></a>Go语言中闭包的实现</h3><p>在Go语言中，闭包（Closure）是指一个函数值，它引用了其函数体之外的变量。<strong>Go语言通过匿名函数（或称为函数字面量）结合对外层变量的引用来实现闭包。</strong></p>
<p>让我们通过一个具体的例子来理解：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createCounter</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 这是一个外部变量，被内部函数捕获</span></span><br><span class="line">	count := <span class="number">0</span> </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回一个匿名函数，这个匿名函数就是闭包</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		count++ <span class="comment">// 内部函数引用并修改了外部变量 count</span></span><br><span class="line">		<span class="keyword">return</span> count</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 每次调用 createCounter 都会创建一个独立的闭包实例</span></span><br><span class="line">	counter1 := createCounter() </span><br><span class="line">	fmt.Println(<span class="string">&quot;Counter 1:&quot;</span>, counter1()) <span class="comment">// 输出：Counter 1: 1</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Counter 1:&quot;</span>, counter1()) <span class="comment">// 输出：Counter 1: 2</span></span><br><span class="line">	</span><br><span class="line">	counter2 := createCounter() <span class="comment">// 创建另一个独立的闭包</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Counter 2:&quot;</span>, counter2()) <span class="comment">// 输出：Counter 2: 1</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Counter 1:&quot;</span>, counter1()) <span class="comment">// 输出：Counter 1: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<ol>
<li><strong><code>createCounter()</code> 函数：</strong> 它定义了一个局部变量 <code>count</code> 并返回一个匿名函数。</li>
<li><strong>匿名函数：</strong> 这个匿名函数引用了它外部作用域中的 <code>count</code> 变量。即使 <code>createCounter()</code> 函数执行完毕，<code>count</code> 变量也不会被销毁，因为匿名函数（闭包）仍然需要访问它。</li>
<li><strong>引用环境：</strong> 当 <code>createCounter()</code> 被调用时，会创建<code>count</code>变量的一个新实例。返回的匿名函数“捕获”了该实例的<code>count</code>变量。</li>
<li><strong>独立性：</strong> 每次调用 <code>createCounter()</code> 都会创建一个新的 <code>count</code> 变量和新的闭包实例。所以 <code>counter1</code> 和 <code>counter2</code> 各自维护着独立的 <code>count</code> 状态。</li>
</ol>
<h3 id="闭包的主要应用场景"><a href="#闭包的主要应用场景" class="headerlink" title="闭包的主要应用场景"></a>闭包的主要应用场景</h3><p>闭包在后端开发中具有非常广泛和强大的应用，它们能够帮助我们编写更简洁、更模块化、更具状态管理能力的程序。以下是几个主要的场景：</p>
<ol>
<li><p><strong>封装状态（State Encapsulation）</strong></p>
<ul>
<li><strong>场景：</strong> 当你需要创建一个带有私有状态（内部变量）的对象或模块，并且只通过特定的方法（闭包）来操作这些状态时。</li>
<li><strong>例子：</strong> 上述的 <code>createCounter()</code> 函数就是一个典型的例子，<code>count</code> 变量被封装在闭包内部，外部只能通过调用返回的函数来递增它，而不能直接访问或修改 <code>count</code>。这类似于面向对象中的私有成员。</li>
<li><strong>后端应用：</strong> 用户会话管理、数据缓存、连接池管理（每个连接对象可能封装其自身的状态）。</li>
</ul>
</li>
<li><p><strong>函数工厂 &#x2F; 生成器（Function Factory &#x2F; Generator）</strong></p>
<ul>
<li><strong>场景：</strong> 根据某些输入参数动态地生成不同的函数。</li>
<li><strong>例子：</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeMultiplier</span><span class="params">(factor <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * factor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数中：</span></span><br><span class="line">multiplyBy2 := makeMultiplier(<span class="number">2</span>)</span><br><span class="line">multiplyBy5 := makeMultiplier(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(multiplyBy2(<span class="number">10</span>)) <span class="comment">// 输出：20</span></span><br><span class="line">fmt.Println(multiplyBy5(<span class="number">10</span>)) <span class="comment">// 输出：50</span></span><br></pre></td></tr></table></figure></li>
<li><strong>后端应用：</strong><ul>
<li><strong>路由处理：</strong> 根据不同的路由前缀或参数生成不同的HTTP处理函数。</li>
<li><strong>日志级别：</strong> 创建不同日志级别的日志记录器（如 <code>DebugLogger(&quot;msg&quot;)</code>, <code>ErrorLogger(&quot;msg&quot;)</code>）。</li>
<li><strong>数据库查询构建：</strong> 根据条件生成特定的查询构造器函数。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>延迟执行 &#x2F; 回调函数（Deferred Execution &#x2F; Callbacks）</strong></p>
<ul>
<li><strong>场景：</strong> 将一个函数及其所需的环境变量一起传递，以便在稍后的某个时间点执行。</li>
<li><strong>例子：</strong> Go语言中的 <code>defer</code> 语句虽然本身不是闭包，但其内部的工作机制涉及捕获匿名函数及其环境。更典型的例子是事件处理。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventHandler <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHandler</span><span class="params">(name <span class="type">string</span>, handler EventHandler)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Registering handler for %s\n&quot;</span>, name)</span><br><span class="line">    <span class="comment">// 假设这里是一个事件派发器，在某个事件发生时调用handler</span></span><br><span class="line">    <span class="comment">// Simulate event trigger</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// do some async work</span></span><br><span class="line">        handler(fmt.Sprintf(<span class="string">&quot;Event triggered for %s!&quot;</span>, name))</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    userName := <span class="string">&quot;Alice&quot;</span></span><br><span class="line">    registerHandler(<span class="string">&quot;user_login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 这个闭包捕获了 userName 变量</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;User %s logged in. Message: %s\n&quot;</span>, userName, msg) </span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ... 其他操作</span></span><br><span class="line">    <span class="keyword">select</span>&#123;&#125; <span class="comment">// 阻止main函数退出，以便goroutine有时间执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>后端应用：</strong><ul>
<li><strong>异步任务处理：</strong> 将带有特定上下文的任务作为闭包提交给 Goroutine 池或消息队列。</li>
<li><strong>定时任务：</strong> 在特定时间执行需要访问特定数据的函数。</li>
<li><strong>中间件：</strong> HTTP中间件链条中，一个中间件可能会返回一个闭包来处理下一个请求。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>迭代器模式（Iterator Pattern）</strong></p>
<ul>
<li><strong>场景：</strong> 用于遍历复杂数据结构，并在每次迭代时保持内部状态（如当前位置）。</li>
<li><strong>例子：</strong> 虽然Go语言通常使用通道或结构体方法实现迭代器，但概念上，闭包也可以用于构建简单的迭代器。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNumberGenerator</span><span class="params">(start, end <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    current := start</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> current &lt;= end &#123;</span><br><span class="line">            val := current</span><br><span class="line">            current++</span><br><span class="line">            <span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span> <span class="comment">// 表示结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    generator := getNumberGenerator(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        num, ok := generator()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>后端应用：</strong> 在处理大型数据集时，需要分批次读取或处理数据，闭包可以记住上次处理的位置。</li>
</ul>
</li>
<li><p><strong>装饰器模式（Decorator Pattern）</strong></p>
<ul>
<li><strong>场景：</strong> 在不修改原有函数代码的情况下，给函数添加额外的功能（如日志、性能监控、权限检查等）。</li>
<li><strong>例子：</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器：添加日志功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loggingDecorator</span><span class="params">(f HandlerFunc)</span></span> HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Calling function with arg: %s\n&quot;</span>, arg)</span><br><span class="line">        result := f(arg) <span class="comment">// 调用原始函数</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;Function returned: %s\n&quot;</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    decoratedGreet := loggingDecorator(greet)</span><br><span class="line">    fmt.Println(decoratedGreet(<span class="string">&quot;World&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>后端应用：</strong><ul>
<li><strong>API请求处理：</strong> 对所有的API请求添加认证、授权、请求日志记录、错误处理等逻辑。</li>
<li><strong>服务调用：</strong> 封装对外部服务的调用，添加重试、熔断等机制。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>闭包是函数式编程中的一个重要概念，它允许函数“记住”并访问其被创建时的环境。在Go语言中，通过匿名函数捕获外部变量来实现闭包。其核心价值在于：</p>
<ul>
<li><strong>实现数据封装：</strong> 隐藏内部状态。</li>
<li><strong>创建高阶函数：</strong> 能够返回或接收其他函数作为参数。</li>
<li><strong>构建灵活且可复用的代码：</strong> 适用于各种动态场景。</li>
<li><strong>支持并发编程：</strong> 在 Goroutine 中传递带有上下文信息的任务。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E9%98%88%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E9%98%88%E5%80%BC/" class="post-title-link" itemprop="url">阈值</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:19:42" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/Query-PromQL/" itemprop="url" rel="index"><span itemprop="name">Query PromQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="阈值"><a href="#阈值" class="headerlink" title="阈值"></a>阈值</h1><p>PromQL 通过提供一组过滤的二元运算符（<code>&gt;</code>、<code>&lt;</code>、<code>==</code> 等），允许根据其样本值过滤一组序列，这种过滤最常见的场景就是在报警规则中使用的阈值。比如我们想查找在过去 15 分钟内的 <code>status=&quot;500&quot;</code> 错误率大于 20% 的所有 HTTP 路径，我们在 <code>rate</code> 表达式后面添加一个 <code>&gt;0.2</code> 的过滤运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(demo_api_request_duration_seconds_count&#123;status=&quot;500&quot;,job=&quot;demo&quot;&#125;[15m]) &gt; 0.2</span><br></pre></td></tr></table></figure>



<p>这个查询只会将错误率大于 20% 的数据过滤出来。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/9pz7ds.png" alt="&gt;20%"></p>
<blockquote>
<p>注意：由于在图形中的每个步长都是完全独立评估表达式的，因此根据每个步骤的过滤条件，某些比率会出现或消失（因此存在间隙）。 一般来说，二元过滤运算符在图形中并不常见，大多数在报警条件中出现，用来表示阈值。</p>
</blockquote>
<p>这种过滤方式不仅适用于单个数字，PromQL 还允许你用一组时间序列过滤另一组序列。与上面的二元运算一样，比较运算符会自动应用于比较左侧和右侧具有相同标签集的序列之间。 <code>on() / ignoring()</code> 和 <code>group_left() / group_right()</code> 修饰符的作用也与我们前面学习的二元算术运算符一样。</p>
<p>以下示例是选择所有具有 500 错误率且至少比同一路径的总请求率大 50 倍的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  rate(demo_api_request_duration_seconds_count&#123;status=&quot;500&quot;,job=&quot;demo&quot;&#125;[5m]) * 50</span><br><span class="line">&gt; ignoring(status)</span><br><span class="line">  sum without(status) (rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]))</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是我们必须忽略匹配中的 status 标签，因为在左边一直有这个标签，而右边没有这个标签。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/slgfc3.png" alt="错误率"></p>
<p>比如我们还可以计算 demo 演示服务实例在一小时内的预测磁盘使用量，但要过滤只有那些预测磁盘已满的实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(demo_disk_usage_bytes&#123;job=&quot;demo&quot;&#125;[1h], 3600) &gt;= demo_disk_total_bytes&#123;job=&quot;demo&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Prometheus 支持以下过滤操作：</p>
<ul>
<li><code>==</code></li>
<li><code>!=</code></li>
<li><code>&lt;</code></li>
<li><code>&lt;=</code></li>
<li><code>&gt;</code></li>
<li><code>&gt;=</code></li>
</ul>
<p>有时你可能想知道比较运算符的结果而不实际删除任何输出系列。要实现这一点，我们可以向运算符添加一个 bool 修饰符来保留所有的序列，但是把输出样本值设置为 1（比较为真）或 0（比较为假）。</p>
<p>例如，要简单地显示一组数据中哪些请求率高于或低于 <code>0.2/s</code>，我们可以这样查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]) &gt; bool 0.2</span><br></pre></td></tr></table></figure>

<p>我们可以看到输入序列的结果为 0 或 1，把数字条件转换为了布尔输出值。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/9r5plv.png" alt="bool修饰符"></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1.构建一个查询，显示使用少于 20MB 内存的目标（<code>process_resident_memory_bytes</code> 指标）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process_resident_memory_bytes / 1024^2 &lt; 20</span><br></pre></td></tr></table></figure>

<p>2.构建一个查询，显示 Prometheus 服务内部所有在过去 5 分钟内没有收到任何查询的 HTTP 处理器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(prometheus_http_requests_total[5m]) == 0</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/26/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/28/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
