<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hui&#39;s Blog">
<meta property="og:url" content="http://example.com/page/23/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="六一">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/23/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" class="post-title-link" itemprop="url">基于文件的服务发现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:13:33" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">服务发现</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基于文件的服务发现"><a href="#基于文件的服务发现" class="headerlink" title="基于文件的服务发现"></a>基于文件的服务发现</h1><p>除了基于 Consul 的服务发现之外，Prometheus 也允许我们进行自定义的发现集成，可以通过 watch 一组本地文件来获取抓取目标以及标签信息，也就是我们常说的基于文件的服务发现方式。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/298gpd.png" alt="file"></p>
<p>基于文件的服务发现提供了一种更通用的方式来配置静态目标，并作为一个接口插入自定义服务发现机制。</p>
<p>它读取一组包含零个或多个 <code>&lt;static_config&gt;</code> 列表的文件，对所有定义的文件的变更通过磁盘监视被检测到并立即应用，文件可以以 YAML 或 JSON 格式提供。文件必须包含一个静态配置的列表:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSON json [ &#123; &quot;targets&quot;: [ &quot;&lt;host&gt;&quot;, ... ], &quot;labels&quot;: &#123; &quot;&lt;labelname&gt;&quot;: &quot;&lt;labelvalue&gt;&quot;, ... &#125; &#125;, ... ]</span><br><span class="line"></span><br><span class="line">YAML yaml - targets: [ - &#x27;&lt;host&gt;&#x27; ] labels: [ &lt;labelname&gt;: &lt;labelvalue&gt; ... ]</span><br></pre></td></tr></table></figure>

<p>文件内容也会在指定的刷新间隔时间内定期重新读取。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Patterns for files from which target groups are extracted.</span></span><br><span class="line"><span class="attr">files:</span></span><br><span class="line">  [ <span class="bullet">-</span> <span class="string">&lt;filename_pattern&gt;</span> <span class="string">...</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Refresh interval to re-read the files.</span></span><br><span class="line">[ <span class="attr">refresh_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">5m</span> ]</span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;filename*pattern&gt;</code> 可以是一个以 <code>.json</code>、<code>.yml</code> 或 <code>.yaml</code> 结尾的路径，最后一个路径段可以包含一个匹配任何字符序列的 <code>*</code>，例如：<code>my/path/tg_*.json</code>。</p>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>接下来我们来创建一个用于服务发现的目标文件，在与 <code>prometheus.yml</code> 文件相同目录下面创建一个名为 <code>targets.yml</code> 的文件，内容如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;192.168.31.46:10000&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;192.168.31.46:10001&#x27;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">production</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;192.168.31.46:10002&#x27;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">staging</span></span><br></pre></td></tr></table></figure>

<p>该文件中我们列举了 3 个 demo 服务实例，给前两个实例添加上了 <code>env=production</code> 的标签，后面一个加上了 <code>env=staging</code> 的标签，当然该文件也可以使用 JSON 格式进行配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;targets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;&lt;host&gt;&quot;</span><span class="punctuation">,</span> ... <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;&lt;labelname&gt;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;labelvalue&gt;&quot;</span><span class="punctuation">,</span> ...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>如果是 YAML 文件则格式为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">  [ <span class="bullet">-</span> <span class="string">&#x27;&lt;host&gt;&#x27;</span> ]</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    [ <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">...</span> ]</span><br></pre></td></tr></table></figure>

<h2 id="配置文件服务发现"><a href="#配置文件服务发现" class="headerlink" title="配置文件服务发现"></a>配置文件服务发现</h2><p>用于发现的目标文件创建完成后，要让 Prometheus 能够从上面的 <code>targets.yml</code> 文件中自动读取抓取目标，需要在 <code>prometheus.yml</code> 配置文件中的 <code>scrape_configs</code> 部分添加如下所示的抓取配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;file-sd-demo&#x27;</span></span><br><span class="line">  <span class="attr">file_sd_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">files:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;targets.yml&#x27;</span></span><br></pre></td></tr></table></figure>

<p>重新 reload 或者重启下 Prometheus 让其重新读取配置文件信息，然后同样前往 Prometheus UI 的 <code>targets</code> 页面下面查看是否有上面定义的抓取目标。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/dv7j9h.png" alt="targets"></p>
<p>然后我们可以尝试改变 <code>targets.yml</code> 的内容，比如为第三个实例增加一个 <code>role: sd</code> 的标签，不用重新加载 Prometheus 配置，Prometheus 将 watch 该文件，并自动接收任何变化。</p>
<p>注意</p>
<p>当在生产环境 Prometheus 服务器中改变 <code>file_sd</code> 目标文件时，确保改变是原子的，以避免重新加载出现错误，最好的方法是在一个单独的位置创建更新的文件，然后将其重命名为目标文件名（使用 <code>mv</code> 命令或 <code>rename()</code> 系统调用）。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/3q4yqa.png" alt="change targets"></p>
<p>这样我们就完成了基于文件的通用服务发现机制，可以让我们动态地改变 Prometheus 的监控目标，而不需要重新启动或重新加载 Prometheus 服务。当然除了基于 Consul 和文件的服务发现之外，更多的时候我们会在 Kubernetes 环境下面使用 Prometheus，由于这部分内容比较独立，后续我们再进行单独讲解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5/" class="post-title-link" itemprop="url">处理阶段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:10:24" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Nginx-处理-HTTP-请求的核心模型"><a href="#Nginx-处理-HTTP-请求的核心模型" class="headerlink" title="Nginx 处理 HTTP 请求的核心模型"></a>Nginx 处理 HTTP 请求的核心模型</h3><p>Nginx 采用<strong>事件驱动（Event-Driven）</strong>、<strong>异步非阻塞（Asynchronous Non-Blocking I&#x2F;O）</strong>的架构。这意味着 Nginx 不会为每个新连接创建一个新的进程或线程。相反，它使用少量的工作进程 (worker processes) 通过事件循环（event loop）来监听和处理大量的并发连接。</p>
<p>当一个客户端连接接入时，Nginx 并不会立即为它分配一个长时间运行的资源。相反，它注册一个事件（例如“有数据可读”），然后回去处理其他连接。当那个事件发生时，Nginx 才回来处理相应的数据。这种模型使得 Nginx 在高并发场景下表现出色，内存消耗低，CPU 利用率高。</p>
<h3 id="Nginx-请求处理过程包含的阶段"><a href="#Nginx-请求处理过程包含的阶段" class="headerlink" title="Nginx 请求处理过程包含的阶段"></a>Nginx 请求处理过程包含的阶段</h3><p>Nginx 的请求处理是一个多阶段的管道（pipeline）过程。当一个请求到达 Nginx 后，它会依次经过一系列内部定义好的处理阶段。这些阶段允许 Nginx 在不同时间点执行不同的模块和指令。理解这些阶段有助于我们知道何时何地的配置指令会生效。</p>
<p>以下是 Nginx 请求处理的主要阶段（大致顺序）：</p>
<ol>
<li><p><strong>初始化阶段 (Initialization Phase)</strong></p>
<ul>
<li><strong>作用：</strong> Nginx 接收到新的客户端连接，解析连接请求头，初始化一些请求相关的内部数据结构。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li>建立 TCP 连接，完成三次握手。</li>
<li>接收并解析 HTTP 请求行（方法、URI、协议版本）和请求头。</li>
<li>Nginx 为这个请求创建一个内部 <code>ngx_http_request_t</code> 结构体，存储请求的所有信息。</li>
<li>执行 <code>server_name</code> 匹配，确定由哪个 <code>server</code> 块来处理请求。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>URI 匹配阶段 (Server&#x2F;Location Selection Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 根据请求的 URI（统一资源标识符），Nginx 查找最匹配的 <code>location</code> 块来处理请求。这是 Nginx 路由请求的核心。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li><strong><code>server_name</code>：</strong> 在初始化阶段之后，根据请求的 Host 头选择一个 <code>server</code> 块。</li>
<li><strong><code>location</code> 匹配：</strong> Nginx 按照特定的优先级顺序（精确匹配 <code>location =</code> &gt; 最长前缀匹配 <code>location ^~</code> &gt; 正则表达式匹配 <code>location ~</code> 或 <code>location ~*</code> &gt; 普通前缀匹配 <code>location /prefix</code> &gt; 通用匹配 <code>location /</code>）来匹配 <code>URI</code>。</li>
<li><strong><code>alias</code> &#x2F; <code>root</code>：</strong> 确定静态文件的根目录。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>请求头处理阶段 (Request Header Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 处理请求头信息。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li>执行一些与请求头相关的模块。</li>
<li>处理 <code>if</code> 块中与 <code>$uri</code>、<code>$args</code>、<code>$request_method</code> 等变量相关的条件判断。</li>
<li>处理 <code>set</code> 指令，设置新的 Nginx 变量。</li>
<li>进行 <code>rewrite</code> 指令（<code>server</code> 块中的 <code>rewrite</code> 会在这里执行）。如果 <code>rewrite</code> 导致 URI 改变，会重新进入 URI 匹配阶段。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>访问控制阶段 (Access Restriction Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 检查客户端是否有权限访问请求的资源。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li><strong><code>allow</code> &#x2F; <code>deny</code>：</strong> 基于 IP 地址的访问控制。</li>
<li><strong><code>auth_basic</code> &#x2F; <code>auth_basic_user_file</code>：</strong> HTTP Basic Authentication 用户密码认证。</li>
<li>其他自定义认证模块。</li>
<li>如果访问被拒绝，Nginx 会返回 <code>403 Forbidden</code> 或 <code>401 Unauthorized</code> 错误。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>认证&#x2F;授权阶段 (Authentication&#x2F;Authorization Phase)</strong></p>
<ul>
<li>这个阶段与访问控制阶段紧密相连，主要处理用户身份验证和权限判断。虽然 <code>auth_basic</code> 可以看作是访问控制的一部分，但更复杂的认证（如 OAuth2、JWT）可能会通过第三方模块在此阶段进行。</li>
</ul>
</li>
<li><p><strong>内容处理阶段 (Content Processing Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 这是请求处理的核心，根据请求的类型和 <code>location</code> 块的配置，Nginx 会决定如何生成响应内容。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li><strong><code>root</code> &#x2F; <code>alias</code>：</strong> 如果是静态文件，Nginx 会从文件系统读取文件并发送给客户端。</li>
<li><strong><code>try_files</code>：</strong> 尝试按顺序查找文件或目录，如果找不到则执行内部重定向。</li>
<li><strong><code>proxy_pass</code>：</strong> 将请求代理转发到后端服务器（如 Tomcat, Node.js）。</li>
<li><strong><code>fastcgi_pass</code> &#x2F; <code>uwsgi_pass</code> &#x2F; <code>scgi_pass</code>：</strong> 将请求转发给 FastCGI&#x2F;uWSGI&#x2F;SCGI 进程（如 PHP-FPM, Python Gunicorn）。</li>
<li><strong><code>return</code>：</strong> 直接返回一个 HTTP 状态码或重定向。</li>
<li><strong><code>index</code>：</strong> 如果请求的是目录，查找默认的索引文件。</li>
<li>执行 <code>rewrite</code> 指令（<code>location</code> 块中的 <code>rewrite</code> 会在这里执行）。如果 <code>rewrite</code> 导致 URI 改变，会重新进入 URI 匹配阶段。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>内容过滤阶段 (Filter Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 在将响应发送给客户端之前，对响应内容进行处理。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li><strong><code>gzip</code>：</strong> 启用 Gzip 压缩，减少传输大小。</li>
<li><strong><code>sub_filter</code>：</strong> 替换响应体中的字符串。</li>
<li><strong><code>chunked_transfer_encoding</code>：</strong> 启用 HTTP&#x2F;1.1 分块传输编码。</li>
<li>其他响应头修改（如 <code>add_header</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>日志记录阶段 (Log Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 记录请求处理的结果。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li><strong><code>access_log</code>：</strong> 将请求信息写入访问日志文件。</li>
<li><strong><code>log_format</code>：</strong> 定义日志格式。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="总结-HTTP-请求处理过程"><a href="#总结-HTTP-请求处理过程" class="headerlink" title="总结 HTTP 请求处理过程"></a>总结 HTTP 请求处理过程</h3><p>一个 HTTP 请求在 Nginx 中的处理流程大致可以概括为：</p>
<ol>
<li><strong>接收连接并解析请求头。</strong></li>
<li><strong>根据 <code>server_name</code> 匹配到合适的 <code>server</code> 块。</strong></li>
<li><strong>在 <code>server</code> 块中执行 <code>rewrite</code> 和 <code>if</code> 等指令 (如果 URI 改变，可能回到第 2 步)。</strong></li>
<li><strong>根据请求的 URI 匹配到合适的 <code>location</code> 块。</strong></li>
<li><strong>在 <code>location</code> 块中进行访问控制和认证。</strong></li>
<li><strong>在 <code>location</code> 块中执行 <code>rewrite</code> 和 <code>try_files</code> 等指令 (如果 URI 改变，可能回到第 4 步)。</strong></li>
<li><strong>确定内容处理方式：</strong><ul>
<li><strong>静态文件：</strong> 直接从文件系统读取并发送。</li>
<li><strong>反向代理：</strong> 将请求转发到后端服务器，等待响应。</li>
<li><strong>FastCGI&#x2F;uWSGI&#x2F;SCGI：</strong> 将请求转发到应用服务器进程。</li>
<li><strong>直接返回：</strong> 通过 <code>return</code> 指令直接响应。</li>
</ul>
</li>
<li><strong>对响应内容进行过滤（如 Gzip 压缩）。</strong></li>
<li><strong>发送响应头和响应体给客户端。</strong></li>
<li><strong>记录访问日志。</strong></li>
<li><strong>关闭连接。</strong></li>
</ol>
<h3 id="理解阶段的重要性"><a href="#理解阶段的重要性" class="headerlink" title="理解阶段的重要性"></a>理解阶段的重要性</h3><ul>
<li><strong>配置生效范围：</strong> 不同的指令在不同的阶段执行。例如，<code>add_header</code> 指令会在内容过滤阶段生效，而 <code>rewrite</code> 则可能在多个阶段执行。</li>
<li><strong>性能优化：</strong> 尽可能避免在每个请求中进行复杂的 <code>if</code> 和 <code>rewrite</code> 逻辑，尤其是在 <code>location /</code> 这种泛匹配块中。优先使用 <code>return</code> 命令进行简单重定向，因为它会立即终止请求处理。</li>
<li><strong>故障排查：</strong> 当请求行为不符合预期时，理解这些阶段有助于缩小问题范围，例如是 <code>location</code> 匹配有问题？还是访问控制配置不正确？或者是 <code>proxy_pass</code> 转发失败？</li>
<li><strong>自定义模块开发：</strong> 对于 Nginx 模块开发者，深入理解这些阶段是编写正确且高效模块的基础。</li>
</ul>
<p>Nginx 的请求处理流程是其高性能和灵活性的基石。作为运维工程师，熟练掌握这些概念能帮助我们更好地管理和维护 Nginx 服务器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E5%A4%9A%E5%80%BC%E8%BF%94%E5%9B%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E5%A4%9A%E5%80%BC%E8%BF%94%E5%9B%9E/" class="post-title-link" itemprop="url">多值返回</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:11:54" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>多值返回 (Multiple Return Values)</strong> 是其最独特且强大的特性之一，它深刻影响了 Go 程序的风格、错误处理机制和 API 设计。它的“意义”在于解决了传统编程语言中一些常见的痛点，并带来了诸多便利。</p>
<p>作为一名后端开发专家，我将为您详细阐述 Go 语言多值返回的用途和其背后的设计哲学。</p>
<h3 id="1-核心理念：显式的错误处理"><a href="#1-核心理念：显式的错误处理" class="headerlink" title="1. 核心理念：显式的错误处理"></a>1. 核心理念：显式的错误处理</h3><p>这是 Go 语言多值返回最常见、也最重要的用途。</p>
<p>在许多其他语言中，错误处理通常依赖于异常（Exceptions）：当发生错误时，函数会抛出异常，中止当前执行流程，并将控制权转移到最近的 <code>try-catch</code> 块。虽然这在某些情况下很方便，但也可能导致：</p>
<ul>
<li><strong>隐藏的控制流：</strong> 调用者可能不知道某个函数会抛出异常，或者忘记捕获。</li>
<li><strong>性能开销：</strong> 异常处理机制通常伴随着性能开销。</li>
<li><strong>不明确的 API：</strong> 函数签名无法直接体现它可能抛出的所有异常。</li>
</ul>
<p>Go 语言拒绝了异常机制，转而采用<strong>显式的、基于返回值的错误处理</strong>。一个函数通常会返回两个值：</p>
<ul>
<li><strong>结果值 (Result Value):</strong> 如果操作成功，这是您期望得到的值。</li>
<li><strong>错误值 (Error Value):</strong> 如果操作失败，这是一个 <code>error</code> 类型的接口值（通常为 <code>nil</code> 表示成功，非 <code>nil</code> 表示错误）。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// simulateFileRead 模拟文件读取，可能返回数据或错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simulateFileRead</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> filename == <span class="string">&quot;error.txt&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to read %s: file not found&quot;</span>, filename)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">&quot;Hello Go!&quot;</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 成功的例子</span></span><br><span class="line">	data, err := simulateFileRead(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Error reading data.txt: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Successfully read data: %s\n&quot;</span>, data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 失败的例子</span></span><br><span class="line">	data, err = simulateFileRead(<span class="string">&quot;error.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Error reading error.txt: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Successfully read data: %s\n&quot;</span>, data) <span class="comment">// 此行不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>意义：</strong></p>
<ul>
<li><strong>强制开发者处理错误：</strong> 编译器会强制你接收所有返回值，包括错误。这意味着你不能“假装没看见”错误，必须显式地进行检查和处理。</li>
<li><strong>清晰的函数签名：</strong> 从函数签名 (<code>(resultType, error)</code>) 就能清楚地知道这个函数可能返回一个错误。</li>
<li><strong>避免隐藏的副作用：</strong> 控制流不再被隐藏的异常打断，代码的执行路径更加线性、可预测。</li>
<li><strong>Go 惯用法：</strong> <code>if err != nil &#123; return ..., err &#125;</code> 成为 Go 编程中最常见的模式。</li>
</ul>
<h3 id="2-返回操作状态或成功与否-value-ok-模式"><a href="#2-返回操作状态或成功与否-value-ok-模式" class="headerlink" title="2. 返回操作状态或成功与否 (value, ok 模式)"></a>2. 返回操作状态或成功与否 (<code>value, ok</code> 模式)</h3><p>除了错误处理，多值返回也常用于指示某个操作是否成功，或者某个值是否存在，而这种“失败”不属于严格意义上的错误。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong><code>map</code> 的键查找：</strong> 当从 <code>map</code> 中获取一个值时，它会返回两个值：第一个是对应键的值，第二个是一个布尔值 <code>ok</code>，指示键是否存在。这避免了将零值与真实值混淆。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line">val, ok := m[<span class="string">&quot;age&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;age exists:&quot;</span>, val) <span class="comment">// age exists: 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val, ok = m[<span class="string">&quot;height&quot;</span>] <span class="comment">// height 不存在</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;height does not exist, value is its zero value:&quot;</span>, val) <span class="comment">// height does not exist, value is its zero value: 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>类型断言 (<code>Type Assertion</code>):</strong> 当将接口转换为具体类型时，多值返回用于检查转换是否成功。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s, ok := i.(<span class="type">string</span>) <span class="comment">// 尝试将接口 i 断言为 string 类型</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;s is a string:&quot;</span>, s)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;s is not a string&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>从 <code>channel</code> 读取：</strong> 从缓冲或非缓冲 <code>channel</code> 中读取数据时，如果 <code>channel</code> 已关闭且没有更多数据，<code>ok</code> 值为 <code>false</code>。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">val, ok := &lt;-ch <span class="comment">// val=10, ok=true</span></span><br><span class="line">fmt.Println(val, ok)</span><br><span class="line">val, ok = &lt;-ch <span class="comment">// val=0, ok=false (channel closed, no more data)</span></span><br><span class="line">fmt.Println(val, ok)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>意义：</strong> 提供了一种简洁、清晰的方式来指示操作的状态，而无需额外的错误码或复杂的数据结构。</p>
<h3 id="3-返回多个相关联但不同类型的数据"><a href="#3-返回多个相关联但不同类型的数据" class="headerlink" title="3. 返回多个相关联但不同类型的数据"></a>3. 返回多个相关联但不同类型的数据</h3><p>在其他语言中，如果一个函数需要返回多个不同类型的值，通常需要：</p>
<ul>
<li>定义一个结构体 (<code>struct</code>) 或类来封装这些值。</li>
<li>使用输出参数（通过指针或引用）。</li>
</ul>
<p>Go 的多值返回直接支持这种需求，使得代码更简洁。</p>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculateStats 返回一个切片中的最小值、最大值和总和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateStats</span><span class="params">(nums []<span class="type">int</span>)</span></span> (min, max, sum <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> <span class="comment">// 或者返回错误，这里简化处理</span></span><br><span class="line">	&#125;</span><br><span class="line">	min, max, sum = nums[<span class="number">0</span>], nums[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">if</span> num &lt; min &#123;</span><br><span class="line">			min = num</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> num &gt; max &#123;</span><br><span class="line">			max = num</span><br><span class="line">		&#125;</span><br><span class="line">		sum += num</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="comment">// 使用命名返回值，可以进行“裸返回”</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numbers := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">15</span>&#125;</span><br><span class="line">	minVal, maxVal, totalSum := calculateStats(numbers)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Min: %d, Max: %d, Sum: %d\n&quot;</span>, minVal, maxVal, totalSum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>意义：</strong></p>
<ul>
<li><strong>避免不必要的结构体定义：</strong> 对于简单地返回两三个相关值的情况，无需为了封装这些值而专门定义一个新的 <code>struct</code>，减少了样板代码。</li>
<li><strong>提高函数签名的表达力：</strong> 函数签名可以直接展示其返回的所有有用信息。</li>
<li><strong>简洁的变量接收：</strong> 可以直接将返回的多个值赋给多个变量，语法直观。</li>
<li><strong>避免输出参数的复杂性：</strong> 不像 C&#x2F;C++ 中需要传递指针作为输出参数，Go 的多值返回更自然且易于理解。</li>
</ul>
<h3 id="4-其它细微用途"><a href="#4-其它细微用途" class="headerlink" title="4. 其它细微用途"></a>4. 其它细微用途</h3><ul>
<li><strong>零值初始化：</strong> 当声明一个变量并使用函数的单值返回来初始化时，该变量会得到返回的值。当使用多值返回来初始化多个变量时，这些变量也会分别得到对应的返回值。</li>
<li><strong>简化接口设计：</strong> 标准库中大量使用了多值返回，使得接口设计更加简洁和一致。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Go 语言的多值返回不是一个简单的语法糖，它是 Go 编程范式和哲学中<strong>至关重要</strong>的一部分：</p>
<ol>
<li><strong>强制显式错误处理：</strong> 确保错误被识别并处理，而不是被忽略或隐藏。</li>
<li><strong>清晰表达函数意图：</strong> 函数签名能明确表明它可能返回操作结果、状态或多个相关数据。</li>
<li><strong>简洁有效的 API 设计：</strong> 减少了为简单数据对创建额外结构体的必要性，也避免了使用复杂的输出参数模式。</li>
<li><strong>提高代码可读性和可靠性：</strong> 代码的执行流程更线性，副作用更少，决策点更清晰。</li>
</ol>
<p>正是由于多值返回，Go 语言在并发编程、网络服务和系统工具等领域能够提供一套独特且高效的解决方案。理解并善用多值返回，将是您精通 Go 语言的关键一步。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%20Kubernetes%20%E8%8A%82%E7%82%B9%20IP%20%E5%9C%B0%E5%9D%80?/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%20Kubernetes%20%E8%8A%82%E7%82%B9%20IP%20%E5%9C%B0%E5%9D%80?/" class="post-title-link" itemprop="url">如何修改 Kubernetes 节点 IP 地址?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:15:52" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="如何修改-Kubernetes-节点-IP-地址"><a href="#如何修改-Kubernetes-节点-IP-地址" class="headerlink" title="如何修改 Kubernetes 节点 IP 地址?"></a>如何修改 Kubernetes 节点 IP 地址?</h1><p>昨天网络环境出了点问题，本地的虚拟机搭建的 Kubernetes 环境没有固定 IP，结果节点 IP 变了，当然最简单的方式是将节点重新固定回之前的 IP 地址，但是自己头铁想去修改下集群的 IP 地址，结果一路下来踩了好多坑，压根就没那么简单~</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>首先看下之前的环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /etc/hosts</span><br><span class="line">192.168.0.111 master1</span><br><span class="line">192.168.0.109 node1</span><br><span class="line">192.168.0.110 node2</span><br></pre></td></tr></table></figure>

<p>新的 IP 地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /etc/hosts</span><br><span class="line">192.168.0.106 master1</span><br><span class="line">192.168.0.101 node1</span><br><span class="line">192.168.0.105 node2</span><br></pre></td></tr></table></figure>

<p>所以我们需要修改所有节点的 IP 地址。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>首先将所有节点的 <code>/etc/hosts</code> 更改为新的地址。</p>
<blockquote>
<p>提示：在操作任何文件之前<strong>强烈建议先备份</strong>。</p>
</blockquote>
<h3 id="master-节点"><a href="#master-节点" class="headerlink" title="master 节点"></a>master 节点</h3><p>1.备份 <code>/etc/kubernetes</code> 目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ cp -Rf /etc/kubernetes/ /etc/kubernetes-bak</span><br></pre></td></tr></table></figure>

<p>2.替换 <code>/etc/kubernetes</code> 中所有配置文件的 APIServer 地址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ oldip=192.168.0.111</span><br><span class="line">➜ newip=192.168.0.106</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看之前的</span></span><br><span class="line">➜ find . -type f | xargs grep $oldip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">替换IP地址</span></span><br><span class="line">➜ find . -type f | xargs sed -i &quot;s/$oldip/$newip/&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查更新后的</span></span><br><span class="line">➜ find . -type f | xargs grep $newip</span><br></pre></td></tr></table></figure>

<p>3.识别 <code>/etc/kubernetes/pki</code> 中以旧的 IP 地址作为 <code>alt name</code> 的证书。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ cd /etc/kubernetes/pki</span><br><span class="line">➜ for f in $(find -name &quot;*.crt&quot;); do</span><br><span class="line">  openssl x509 -in $f -text -noout &gt; $f.txt;</span><br><span class="line">done</span><br><span class="line">➜ grep -Rl $oldip .</span><br><span class="line">➜ for f in $(find -name &quot;*.crt&quot;); do rm $f.txt; done</span><br></pre></td></tr></table></figure>

<p>4.找到 <code>kube-system</code> 命名空间中引用旧 IP 的 ConfigMap。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取所有的 kube-system 命名空间下面所有的 ConfigMap</span></span><br><span class="line">➜ configmaps=$(kubectl -n kube-system get cm -o name | \</span><br><span class="line">  awk &#x27;&#123;print $1&#125;&#x27; | \</span><br><span class="line">  cut -d &#x27;/&#x27; -f 2)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取所有的ConfigMap资源清单</span></span><br><span class="line">➜ dir=$(mktemp -d)</span><br><span class="line">➜ for cf in $configmaps; do</span><br><span class="line">  kubectl -n kube-system get cm $cf -o yaml &gt; $dir/$cf.yaml</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到所有包含旧 IP 的 ConfigMap</span></span><br><span class="line">➜ grep -Hn $dir/* -e $oldip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后编辑这些 ConfigMap，将旧 IP 替换成新的 IP</span></span><br><span class="line">➜ kubectl -n kube-system edit cm kubeadm-config</span><br><span class="line">➜ kubectl -n kube-system edit cm kube-proxy</span><br></pre></td></tr></table></figure>

<p>这一步非常非常重要，我在操作的时候忽略了这一步，导致 Flannel CNI 启动不起来，一直报错，类似下面的日志信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl logs -f kube-flannel-ds-pspzf -n kube-system</span><br><span class="line">I0512 14:46:26.044229       1 main.go:205] CLI flags config: &#123;etcdEndpoints:http://127.0.0.1:4001,http://127.0.0.1:2379 etcdPrefix:/coreos.com/network etcdKeyfile: etcdCertfile: etcdCAFile: etcdUsername: etcdPassword: version:false kubeSubnetMgr:true kubeApiUrl: kubeAnnotationPrefix:flannel.alpha.coreos.com kubeConfigFile: iface:[ens33] ifaceRegex:[] ipMasq:true subnetFile:/run/flannel/subnet.env publicIP: publicIPv6: subnetLeaseRenewMargin:60 healthzIP:0.0.0.0 healthzPort:0 iptablesResyncSeconds:5 iptablesForwardRules:true netConfPath:/etc/kube-flannel/net-conf.json setNodeNetworkUnavailable:true&#125;</span><br><span class="line">W0512 14:46:26.044617       1 client_config.go:614] Neither --kubeconfig nor --master was specified.  Using the inClusterConfig.  This might not work.</span><br><span class="line">E0512 14:46:56.142921       1 main.go:222] Failed to create SubnetManager: error retrieving pod spec for &#x27;kube-system/kube-flannel-ds-pspzf&#x27;: Get &quot;https://10.96.0.1:443/api/v1/namespaces/kube-system/pods/kube-flannel-ds-pspzf&quot;: dial tcp 10.96.0.1:443: i/o timeout</span><br></pre></td></tr></table></figure>

<p>其实就是连不上 apiserver，排查了好久才想起来查看 <code>kube-proxy</code> 的日志，其中出现了如下所示的错误信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E0512 14:53:03.260817       1 reflector.go:138] k8s.io/client-go/informers/factory.go:134: Failed to watch *v1.EndpointSlice: failed to list *v1.EndpointSlice: Get &quot;https://192.168.0.111:6443/apis/discovery.k8s.io/v1/endpointslices?labelSelector=%21service.kubernetes.io%2Fheadless%2C%21service.kubernetes.io%2Fservice-proxy-name&amp;limit=500&amp;resourceVersion=0&quot;: dial tcp 192.168.0.111:6443: connect: no route to host</span><br></pre></td></tr></table></figure>

<p>这就是因为 kube-proxy 的 ConfigMap 中配置的 apiserver 地址是旧的 IP 地址，所以一定要将其替换成新的。</p>
<p>5.删除第 3 步中 grep 出的证书和私钥，重新生成这些证书。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ cd /etc/kubernetes/pki</span><br><span class="line">➜ rm apiserver.crt apiserver.key</span><br><span class="line">➜ kubeadm init phase certs apiserver</span><br><span class="line"></span><br><span class="line">➜ rm etcd/peer.crt etcd/peer.key</span><br><span class="line">➜ kubeadm init phase certs etcd-peer</span><br></pre></td></tr></table></figure>

<p>当然也可以全部重新生成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ kubeadm init phase certs all</span><br></pre></td></tr></table></figure>

<p>6.生成新的 kubeconfig 文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜ cd /etc/kubernetes</span><br><span class="line">➜ rm -f admin.conf kubelet.conf controller-manager.conf scheduler.conf</span><br><span class="line">➜ kubeadm init phase kubeconfig all</span><br><span class="line">I0513 15:33:34.404780   52280 version.go:255] remote version is much newer: v1.24.0; falling back to: stable-1.22</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">覆盖默认的 kubeconfig 文件</span></span><br><span class="line">➜ cp /etc/kubernetes/admin.conf $HOME/.kube/config</span><br></pre></td></tr></table></figure>

<p>7.重启 kubelet。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl restart containerd</span><br><span class="line">➜ systemctl restart kubelet</span><br></pre></td></tr></table></figure>

<p>正常现在可以访问的 Kubernetes 集群了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get nodes</span><br><span class="line">NAME      STATUS     ROLES                  AGE   VERSION</span><br><span class="line">master1   Ready      control-plane,master   48d   v1.22.8</span><br><span class="line">node1     NotReady   &lt;none&gt;                 48d   v1.22.8</span><br><span class="line">node2     NotReady   &lt;none&gt;                 48d   v1.22.8</span><br></pre></td></tr></table></figure>

<h3 id="node-节点"><a href="#node-节点" class="headerlink" title="node 节点"></a>node 节点</h3><p>虽然现在可以访问集群了，但是我们可以看到 Node 节点现在处于 <code>NotReady</code> 状态，我们可以去查看 node2 节点的 kubelet 日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ journalctl -u kubelet -f</span><br><span class="line">......</span><br><span class="line">May 13 15:47:55 node2 kubelet[1194]: E0513 15:47:55.470896    1194 kubelet.go:2412] &quot;Error getting node&quot; err=&quot;node \&quot;node2\&quot; not found&quot;</span><br><span class="line">May 13 15:47:55 node2 kubelet[1194]: E0513 15:47:55.531695    1194 reflector.go:138] k8s.io/client-go/informers/factory.go:134: Failed to watch *v1.Service: failed to list *v1.Service: Get &quot;https://192.168.0.111:6443/api/v1/services?limit=500&amp;resourceVersion=0&quot;: dial tcp 192.168.0.111:6443: connect: no route to host</span><br><span class="line">May 13 15:47:55 node2 kubelet[1194]: E0513 15:47:55.571958    1194 kubelet.go:2412] &quot;Error getting node&quot; err=&quot;node \&quot;node2\&quot; not found&quot;</span><br><span class="line">May 13 15:47:55 node2 kubelet[1194]: E0513 15:47:55.673379    1194 kubelet.go:2412] &quot;Error getting node&quot; err=&quot;node \&quot;node2\&quot; not found&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到仍然是在访问之前的 APIServer 地址，那么在什么地方会明确使用 APIServer 的地址呢？我们可以通过下面的命令来查看 kubelet 的启动参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl status kubelet</span><br><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/kubelet.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line">           └─10-kubeadm.conf</span><br><span class="line">   Active: active (running) since Fri 2022-05-13 14:37:31 CST; 1h 13min ago</span><br><span class="line">     Docs: https://kubernetes.io/docs/</span><br><span class="line"> Main PID: 1194 (kubelet)</span><br><span class="line">    Tasks: 15</span><br><span class="line">   Memory: 126.9M</span><br><span class="line">   CGroup: /system.slice/kubelet.service</span><br><span class="line">           └─1194 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kub...</span><br><span class="line"></span><br><span class="line">May 13 15:51:08 node2 kubelet[1194]: E0513 15:51:08.787677    1194 kubelet.go:2412] &quot;Error getting node&quot; err=&quot;node \&quot;node2... found&quot;</span><br><span class="line">May 13 15:51:08 node2 kubelet[1194]: E0513 15:51:08.888194    1194 kubelet.go:2412] &quot;Error getting node&quot; err=&quot;node \&quot;node2... found&quot;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>其核心配置文件为 <code>/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</code>，内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜ cat /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Note: This dropin only works with kubeadm and kubelet v1.11+</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf&quot;</span><br><span class="line">Environment=&quot;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is a file that <span class="string">&quot;kubeadm init&quot;</span> and <span class="string">&quot;kubeadm join&quot;</span> generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically</span></span><br><span class="line">EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is a file that the user can use <span class="keyword">for</span> overrides of the kubelet args as a last resort. Preferably, the user should use</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the .NodeRegistration.KubeletExtraArgs object <span class="keyword">in</span> the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.</span></span><br><span class="line">EnvironmentFile=-/etc/sysconfig/kubelet</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS</span><br></pre></td></tr></table></figure>

<p>其中有一个配置 <code>KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf</code>，这里提到了两个配置文件 <code>bootstrap-kubelet.conf</code> 与 <code>kubelet.conf</code>，其中第一个文件不存在：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ cat /etc/kubernetes/bootstrap-kubelet.conf</span><br><span class="line">cat: /etc/kubernetes/bootstrap-kubelet.conf: No such file or directory</span><br></pre></td></tr></table></figure>

<p>而第二个配置文件就是一个 kubeconfig 文件的格式，这个文件中就指定了 APIServer 的地址，可以看到还是之前的 IP 地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜ cat /etc/kubernetes/kubelet.conf</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: &lt;......&gt;</span><br><span class="line">    server: https://192.168.0.111:6443</span><br><span class="line">  name: default-cluster</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: default-cluster</span><br><span class="line">    namespace: default</span><br><span class="line">    user: default-auth</span><br><span class="line">  name: default-context</span><br><span class="line">current-context: default-context</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: default-auth</span><br><span class="line">  user:</span><br><span class="line">    client-certificate: /var/lib/kubelet/pki/kubelet-client-current.pem</span><br><span class="line">    client-key: /var/lib/kubelet/pki/kubelet-client-current.pem</span><br></pre></td></tr></table></figure>

<p>所以我们最先想到的肯定就是去将这里的 APIServer 地址修改成新的 IP 地址，但是这显然是有问题的，因为相关证书还是以前的，需要重新生成，那么要怎样重新生成该文件呢？</p>
<p>首先备份 kubelet 工作目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ cp /etc/kubernetes/kubelet.conf /etc/kubernetes/kubelet.conf.bak</span><br><span class="line">➜ cp -rf /var/lib/kubelet/ /var/lib/kubelet-bak</span><br></pre></td></tr></table></figure>

<p>删除 kubelet 客户端证书：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ rm /var/lib/kubelet/pki/kubelet-client*</span><br></pre></td></tr></table></figure>

<p>然后在 master1 节点（具有 <code>/etc/kubernetes/pki/ca.key</code> 文件的节点）去生成 kubelet.conf 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在master1节点</span></span><br><span class="line">➜ kubeadm kubeconfig user --org system:nodes --client-name system:node:node2 --config kubeadm.yaml &gt; kubelet.conf</span><br></pre></td></tr></table></figure>

<p>然后将 kubelet.conf 文件复制到 node2 节点 <code>/etc/kubernetes/kubelet.conf</code>，然后重新启动 node2 节点上的 kubelet，并等待 <code>/var/lib/kubelet/pki/kubelet-client-current.pem</code> 重新创建。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl restart kubelet</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启后等待重新生成 kubelet 客户端证书</span></span><br><span class="line">➜ ll /var/lib/kubelet/pki/</span><br><span class="line">total 12</span><br><span class="line">-rw------- 1 root root 1106 May 13 16:32 kubelet-client-2022-05-13-16-32-35.pem</span><br><span class="line">lrwxrwxrwx 1 root root   59 May 13 16:32 kubelet-client-current.pem -&gt; /var/lib/kubelet/pki/kubelet-client-2022-05-13-16-32-35.pem</span><br><span class="line">-rw-r--r-- 1 root root 2229 Mar 26 14:39 kubelet.crt</span><br><span class="line">-rw------- 1 root root 1675 Mar 26 14:39 kubelet.key</span><br></pre></td></tr></table></figure>

<p>最好我们可以通过手动编辑 <code>kubelet.conf</code> 的方式来指向轮转的 kubelet 客户端证书，将文件中的 <code>client-certificate-data</code> 和 <code>client-key-data</code> 替换为 <code>/var/lib/kubelet/pki/kubelet-client-current.pem</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client-certificate: /var/lib/kubelet/pki/kubelet-client-current.pem</span><br><span class="line">client-key: /var/lib/kubelet/pki/kubelet-client-current.pem</span><br></pre></td></tr></table></figure>

<p>再次重启 kubelet，正常现在 node2 节点就会变成 <code>Ready</code> 状态了，用同样的方法再次去配置 node1 节点即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES                  AGE   VERSION</span><br><span class="line">master1   Ready    control-plane,master   48d   v1.22.8</span><br><span class="line">node1     Ready    &lt;none&gt;                 48d   v1.22.8</span><br><span class="line">node2     Ready    &lt;none&gt;                 48d   v1.22.8</span><br></pre></td></tr></table></figure>

<h2 id="推荐操作"><a href="#推荐操作" class="headerlink" title="推荐操作"></a>推荐操作</h2><p>上面的操作方式虽然可以正常完成我们的需求，但是需要我们对相关证书有一定的了解。除了这种方式之外还有一种更简单的操作。</p>
<p>首先停止 kubelet 并备份要操作的目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ systemctl stop kubelet</span><br><span class="line">➜ mv /etc/kubernetes /etc/kubernetes-bak</span><br><span class="line">➜ mv /var/lib/kubelet/ /var/lib/kubelet-bak</span><br></pre></td></tr></table></figure>

<p>将 pki 证书目录保留下来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ mkdir -p /etc/kubernetes</span><br><span class="line">➜ cp -r /etc/kubernetes-bak/pki /etc/kubernetes</span><br><span class="line">➜ rm /etc/kubernetes/pki/&#123;apiserver.*,etcd/peer.*&#125;</span><br><span class="line">rm: remove regular file ‘/etc/kubernetes/pki/apiserver.crt’? y</span><br><span class="line">rm: remove regular file ‘/etc/kubernetes/pki/apiserver.key’? y</span><br><span class="line">rm: remove regular file ‘/etc/kubernetes/pki/etcd/peer.crt’? y</span><br><span class="line">rm: remove regular file ‘/etc/kubernetes/pki/etcd/peer.key’? y</span><br></pre></td></tr></table></figure>

<p>现在我们使用下面的命令来重新初始化控制平面节点，但是最重要的一点是要<strong>使用 etcd 的数据目录</strong>，可以通过 <code>--ignore-preflight-errors=DirAvailable--var-lib-etcd</code> 标志来告诉 kubeadm 使用预先存在的 etcd 数据。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">➜ kubeadm init --config kubeadm.yaml --ignore-preflight-errors=DirAvailable--var-lib-etcd</span><br><span class="line">[init] Using Kubernetes version: v1.22.8</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING DirAvailable--var-lib-etcd]: /var/lib/etcd is not empty</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;</span><br><span class="line">[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[certs] Using existing ca certificate authority</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [api.k8s.local kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local master1] and IPs [10.96.0.1 192.168.0.106]</span><br><span class="line">[certs] Using existing apiserver-kubelet-client certificate and key on disk</span><br><span class="line">[certs] Using existing front-proxy-ca certificate authority</span><br><span class="line">[certs] Using existing front-proxy-client certificate and key on disk</span><br><span class="line">[certs] Using existing etcd/ca certificate authority</span><br><span class="line">[certs] Using existing etcd/server certificate and key on disk</span><br><span class="line">[certs] Generating &quot;etcd/peer&quot; certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [localhost master1] and IPs [192.168.0.106 127.0.0.1 ::1]</span><br><span class="line">[certs] Using existing etcd/healthcheck-client certificate and key on disk</span><br><span class="line">[certs] Using existing apiserver-etcd-client certificate and key on disk</span><br><span class="line">[certs] Using the existing &quot;sa&quot; key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 12.003599 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config-1.22&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node master1 as control-plane by adding the labels: [node-role.kubernetes.io/master(deprecated) node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers]</span><br><span class="line">[mark-control-plane] Marking the node master1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: abcdef.0123456789abcdef</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.0.106:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:27993cae9c76d18a1b82b800182c4c7ebc7a704ba1093400ed886f65e709ec04</span><br></pre></td></tr></table></figure>

<p>上面的操作和我们平时去初始化集群的时候几乎是一样的，唯一不同的地方是加了一个 <code>--ignore-preflight-errors=DirAvailable--var-lib-etcd</code> 参数，意思就是使用之前 etcd 的数据。然后我们可以验证下 APIServer 的 IP 地址是否变成了新的地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">cp: overwrite ‘/root/.kube/config’? y</span><br><span class="line">➜ kubectl cluster-info</span><br><span class="line">Kubernetes control plane is running at https://192.168.0.106:6443</span><br><span class="line">CoreDNS is running at https://192.168.0.106:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use &#x27;kubectl cluster-info dump&#x27;.</span><br></pre></td></tr></table></figure>

<p>对于 node 节点我们可以 reset 后重新加入到集群即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在node节点操作</span></span><br><span class="line">➜ kubeadm reset</span><br></pre></td></tr></table></figure>

<p>重置后重新 join 集群即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在node节点操作</span></span><br><span class="line">➜ kubeadm join 192.168.0.106:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:27993cae9c76d18a1b82b800182c4c7ebc7a704ba1093400ed886f65e709ec04</span><br></pre></td></tr></table></figure>

<p>这种方式比上面的方式要简单很多。正常操作后集群也正常了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES                  AGE     VERSION</span><br><span class="line">master1   Ready    control-plane,master   48d     v1.22.8</span><br><span class="line">node1     Ready    &lt;none&gt;                 48d     v1.22.8</span><br><span class="line">node2     Ready    &lt;none&gt;                 4m50s   v1.22.8</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 Kubernetes 集群节点的 IP 地址最好使用静态 IP，避免 IP 变动对业务产生影响，如果不是静态 IP，也强烈建议增加一个自定义域名进行签名，这样当 IP 变化后还可以直接重新映射下这个域名即可，只需要在 kubeadm 配置文件中通过 <code>ClusterConfiguration</code> 配置 <code>apiServer.certSANs</code> 即可，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">  <span class="attr">timeoutForControlPlane:</span> <span class="string">4m0s</span></span><br><span class="line">  <span class="attr">certSANs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">api.k8s.local</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">master1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.106</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<p>将需要进行前面的地址加入到 <code>certSANs</code> 中，比如这里我们额外添加了一个 <code>api.k8s.local</code> 的地址，这样即使以后 IP 变了可以直接将这个域名映射到新的 IP 地址即可，同样如果你想通过外网访问 IP 访问你的集群，那么你也需要将你的外网 IP 地址加进来进行签名认证。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E7%BB%84%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E7%BB%84%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F/" class="post-title-link" itemprop="url">字面量和组合字面量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:21:18" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>字面量（Literals）和组合字面量（Composite Literals）</p>
<hr>
<h3 id="一、字面量-Literals"><a href="#一、字面量-Literals" class="headerlink" title="一、字面量 (Literals)"></a>一、字面量 (Literals)</h3><p><strong>定义：</strong> 字面量是直接写在代码中的、表示固定值的符号。它们是编译器可以直接从中识别其类型和值的原始数据。你可以把字面量想象成编程语言中最基本的“砖块”。</p>
<p>Go 语言支持多种类型的字面量：</p>
<h4 id="1-整数字面量-Integer-Literals"><a href="#1-整数字面量-Integer-Literals" class="headerlink" title="1. 整数字面量 (Integer Literals)"></a>1. 整数字面量 (Integer Literals)</h4><p>表示整数值，可以有不同的进制表示：</p>
<ul>
<li><strong>十进制 (Decimal):</strong> 默认，直接写数字，如 <code>100</code>, <code>0</code>, <code>-5</code></li>
<li><strong>八进制 (Octal):</strong> 以 <code>0o</code> 或 <code>0O</code> 开头（Go 1.13+），旧版本以 <code>0</code> 开头，如 <code>0o123</code> (等同于十进制 83)</li>
<li><strong>十六进制 (Hexadecimal):</strong> 以 <code>0x</code> 或 <code>0X</code> 开头，如 <code>0xFF</code> (等同于十进制 255)</li>
<li><strong>二进制 (Binary):</strong> 以 <code>0b</code> 或 <code>0B</code> 开头（Go 1.13+），如 <code>0b1011</code> (等同于十进制 11)</li>
</ul>
<p><strong>自 Go 1.13 起，可以使用下划线 <code>_</code> 作为数字分隔符，提高可读性，但这不会改变数值。</strong></p>
<ul>
<li>示例: <code>1_000_000</code>, <code>0xFF_FF_FF_FF</code></li>
</ul>
<h4 id="2-浮点数字面量-Floating-Point-Literals"><a href="#2-浮点数字面量-Floating-Point-Literals" class="headerlink" title="2. 浮点数字面量 (Floating-Point Literals)"></a>2. 浮点数字面量 (Floating-Point Literals)</h4><p>表示带有小数部分的数字，可以是普通形式或科学计数法：</p>
<ul>
<li><code>3.14</code></li>
<li><code>1.</code> (等于 1.0)</li>
<li><code>.5</code> (等于 0.5)</li>
<li>科学计数法：<code>1e5</code> (1 * 10^5), <code>2.3E-4</code> (2.3 * 10^-4)</li>
</ul>
<h4 id="3-复数字面量-Complex-Literals"><a href="#3-复数字面量-Complex-Literals" class="headerlink" title="3. 复数字面量 (Complex Literals)"></a>3. 复数字面量 (Complex Literals)</h4><p>表示复数，由实部和虚部组成：</p>
<ul>
<li><code>1 + 2i</code> (实部 1，虚部 2)</li>
<li><code>3.14 - 5i</code> (实部 3.14，虚部 -5)</li>
</ul>
<h4 id="4-布尔字面量-Boolean-Literals"><a href="#4-布尔字面量-Boolean-Literals" class="headerlink" title="4. 布尔字面量 (Boolean Literals)"></a>4. 布尔字面量 (Boolean Literals)</h4><p>只有两个值：</p>
<ul>
<li><code>true</code></li>
<li><code>false</code></li>
</ul>
<h4 id="5-符文字面量-Rune-Literals"><a href="#5-符文字面量-Rune-Literals" class="headerlink" title="5. 符文字面量 (Rune Literals)"></a>5. 符文字面量 (Rune Literals)</h4><p>用单引号 <code>&#39;</code> 包裹的字符。它代表一个 Unicode 码点（<code>int32</code> 类型）。</p>
<ul>
<li>普通字符: <code>&#39;a&#39;</code>, <code>&#39;中&#39;</code>, <code>&#39;😀&#39;</code></li>
<li>转义序列: <code>&#39;\n&#39;</code> (换行), <code>&#39;\t&#39;</code> (制表符), <code>&#39;\\&#39;</code> (反斜杠), <code>&#39;\&#39;&#39;</code> (单引号)</li>
<li>Unicode 码点:<ul>
<li><code>&#39;\u0041&#39;</code> (表示 Unicode 码点 U+0041，即字符 ‘A’)</li>
<li><code>&#39;\U00004E2D&#39;</code> (表示 Unicode 码点 U+4E2D，即汉字 ‘中’)</li>
</ul>
</li>
</ul>
<h4 id="6-字符串字面量-String-Literals"><a href="#6-字符串字面量-String-Literals" class="headerlink" title="6. 字符串字面量 (String Literals)"></a>6. 字符串字面量 (String Literals)</h4><p>Go 语言支持两种类型的字符串字面量：</p>
<ul>
<li><p><strong>解释型字符串字面量 (Interpreted String Literals):</strong></p>
<ul>
<li>用双引号 <code>&quot;</code> 包裹。</li>
<li>支持转义序列，如 <code>\n</code>, <code>\t</code>, <code>\&quot;</code>, <code>\\</code> 等。</li>
<li>示例: <code>&quot;Hello, World!\n&quot;</code></li>
</ul>
</li>
<li><p><strong>原生字符串字面量 (Raw String Literals):</strong></p>
<ul>
<li>用反引号 <code>`</code> (键盘上数字 1 左边的键) 包裹。</li>
<li>字符串内容会原封不动地保留，<strong>不进行任何转义</strong>。</li>
<li>可以跨多行，包括其中的换行符也会被保留。</li>
<li>常用于正则表达式、HTML&#x2F;XML 片段、SQL 语句等。</li>
<li>示例:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`这是</span></span><br><span class="line"><span class="string">一个多行字符串，</span></span><br><span class="line"><span class="string">\n 不会被转义。`</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、组合字面量-Composite-Literals"><a href="#二、组合字面量-Composite-Literals" class="headerlink" title="二、组合字面量 (Composite Literals)"></a>二、组合字面量 (Composite Literals)</h3><p><strong>定义：</strong> 组合字面量用于构造复杂数据类型（如结构体、数组、切片、映射）的值。它结合了类型名称和用花括号 <code>&#123;&#125;</code> 包裹的元素列表，这些元素本身可以是字面量或其他表达式。你可以把它想象成使用前面提到的“砖块”来搭建一个“预制件”或“组件”。</p>
<p>基本语法格式是：<code>TypeName&#123;element1, element2, ...&#125;</code> 或 <code>TypeName&#123;Key1: Value1, Key2: Value2, ...&#125;</code></p>
<h4 id="1-结构体字面量-Struct-Literals"><a href="#1-结构体字面量-Struct-Literals" class="headerlink" title="1. 结构体字面量 (Struct Literals)"></a>1. 结构体字面量 (Struct Literals)</h4><p>用于创建结构体类型的值。你可以通过字段名或按字段顺序指定值。</p>
<ul>
<li><p><strong>按字段名指定 (推荐):</strong> 清晰明了，不依赖字段顺序，即使结构体定义改变字段顺序也安全。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1 := Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">30</span>&#125;</span><br><span class="line">p2 := Person&#123;Age: <span class="number">25</span>, Name: <span class="string">&quot;Bob&quot;</span>&#125; <span class="comment">// 顺序不重要</span></span><br><span class="line">p3 := Person&#123;Name: <span class="string">&quot;Charlie&quot;</span>&#125;      <span class="comment">// 未指定的字段会被初始化为零值 (Age: 0)</span></span><br><span class="line">fmt.Println(p1, p2, p3) <span class="comment">// &#123;Alice 30&#125; &#123;Bob 25&#125; &#123;Charlie 0&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>按字段顺序指定 (不推荐，但合法):</strong> 值必须严格按照结构体字段的声明顺序。如果结构体定义被修改，代码可能出错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p4 := Person&#123;<span class="string">&quot;David&quot;</span>, <span class="number">28</span>&#125; <span class="comment">// Name=&quot;David&quot;, Age=28</span></span><br><span class="line">fmt.Println(p4)           <span class="comment">// &#123;David 28&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建结构体指针：</strong> 在结构体字面量前加上 <code>&amp;</code>，会创建一个结构体实例并返回其指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pPtr := &amp;Person&#123;Name: <span class="string">&quot;Eve&quot;</span>, Age: <span class="number">35</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type of pPtr: %T, Value: %+v\n&quot;</span>, pPtr, pPtr) <span class="comment">// Type of pPtr: *main.Person, Value: &amp;&#123;Name:Eve Age:35&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-数组字面量-Array-Literals"><a href="#2-数组字面量-Array-Literals" class="headerlink" title="2. 数组字面量 (Array Literals)"></a>2. 数组字面量 (Array Literals)</h4><p>用于创建一个固定大小的数组。</p>
<ul>
<li><strong>完整初始化:</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125; <span class="comment">// 长度为3的int数组</span></span><br><span class="line">fmt.Println(arr1)          <span class="comment">// [10 20 30]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>省略号推断长度 <code>...</code> (常用):</strong> 编译器会根据提供的元素数量自动推断数组的长度。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2 := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// 长度为5的int数组</span></span><br><span class="line">fmt.Println(arr2, <span class="built_in">len</span>(arr2))    <span class="comment">// [1 2 3 4 5] 5</span></span><br></pre></td></tr></table></figure></li>
<li><strong>指定索引初始化:</strong> 可以在初始化时指定特定索引的值，未指定的索引会被初始化为零值。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr3 := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">3</span>: <span class="number">30</span>&#125; <span class="comment">// 索引1为10，索引3为30，其他为0</span></span><br><span class="line">fmt.Println(arr3)            <span class="comment">// [0 10 0 30 0]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-切片字面量-Slice-Literals"><a href="#3-切片字面量-Slice-Literals" class="headerlink" title="3. 切片字面量 (Slice Literals)"></a>3. 切片字面量 (Slice Literals)</h4><p>用于创建一个切片。它的语法看起来和数组字面量很相似，但<strong>没有指定长度</strong>。实际上，切片字面量会隐式地创建一个底层数组，然后返回一个引用该底层数组的切片。</p>
<ul>
<li><strong>常见用法:</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;       <span class="comment">// 创建一个包含1,2,3的切片</span></span><br><span class="line">fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1)) <span class="comment">// [1 2 3] 3 3</span></span><br><span class="line"></span><br><span class="line">s2 := []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>&#125; <span class="comment">// 字符串切片</span></span><br><span class="line">fmt.Println(s2) <span class="comment">// [apple banana]</span></span><br></pre></td></tr></table></figure></li>
<li>切片字面量是初始化切片最常用的方式。</li>
</ul>
<h4 id="4-映射字面量-Map-Literals"><a href="#4-映射字面量-Map-Literals" class="headerlink" title="4. 映射字面量 (Map Literals)"></a>4. 映射字面量 (Map Literals)</h4><p>用于创建映射（哈希表）类型的值。需要指定键和值。</p>
<ul>
<li><strong>常见用法:</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(m1) <span class="comment">// map[one:1 three:3 two:2] (map的输出顺序不确定)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以只初始化部分，后续添加</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>&#123;<span class="string">&quot;active&quot;</span>: <span class="literal">true</span>&#125;</span><br><span class="line">fmt.Println(m2) <span class="comment">// map[active:true]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="组合字面量的通用规则和注意事项："><a href="#组合字面量的通用规则和注意事项：" class="headerlink" title="组合字面量的通用规则和注意事项："></a>组合字面量的通用规则和注意事项：</h4><ul>
<li><strong>类型前缀：</strong> 组合字面量必须以其所代表的类型名称开始（除了在某些上下文可以省略类型名，如 <code>var s []int = &#123;1, 2, 3&#125;</code> 中省略 <code>[]int</code>，但这不是字面量本身的特性，而是 Go 的类型推断）。</li>
<li><strong>末尾逗号：</strong> 如果组合字面量的元素列表是多行的，<strong>最后一个元素后面也必须有逗号</strong>。这是 Go 语言的一个惯例，有助于 <code>go fmt</code> 工具的正确格式化和版本控制合并。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p := Person&#123;</span><br><span class="line">    Name: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    Age:  <span class="number">30</span>, <span class="comment">// 即使是最后一个元素，如果多行也加上逗号</span></span><br><span class="line">&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="comment">// 最后一个元素后的逗号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>零值初始化：</strong> 如果某些元素或字段在组合字面量中没有被显式指定，它们将被自动初始化为对应类型的零值（例如，<code>int</code> 为 <code>0</code>，<code>string</code> 为 <code>&quot;&quot;</code>，引用类型为 <code>nil</code>）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6/" class="post-title-link" itemprop="url">存储插件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:10:54" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">存储</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="存储插件"><a href="#存储插件" class="headerlink" title="存储插件"></a>存储插件</h1><p>前面的章节中我们介绍了在 Kubernetes 中的持久化存储的使用，了解了 PV、PVC 以及 StorageClass 的使用方法，从本地存储到 NFS 共享存储都有学习，到这里我们其实已经可以完成应用各种场景的数据持久化了，但是难免在实际的使用过程中会遇到各种各样的问题，要解决这些问题最好的方式就是来了解下 Kubernetes 中存储的实现原理。</p>
<p>Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 <code>kubectl explain pod.spec.volumes</code> 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存储服务接入到 Kubernetes 系统中来，在 Kubernetes 中就对应 <code>In-Tree</code> 和 <code>Out-Of-Tree</code> 两种方式，<code>In-Tree</code> 就是在 Kubernetes 源码内部实现的，和 Kubernetes 一起发布、管理的，但是更新迭代慢、灵活性比较差，<code>Out-Of-Tree</code> 是独立于 Kubernetes 的，目前主要有 <code>CSI</code> 和 <code>FlexVolume</code> 两种机制，开发者可以根据自己的存储类型实现不同的存储插件接入到 Kubernetes 中去，其中 <code>CSI</code> 是现在也是以后主流的方式，所以当然我们的重点也会是 <code>CSI</code> 的使用介绍。</p>
<h2 id="FlexVolume"><a href="#FlexVolume" class="headerlink" title="FlexVolume"></a>FlexVolume</h2><p>FlexVolume 提供了一种扩展 Kubernetes 存储插件的方式，用户可以自定义自己的存储插件。要使用 FlexVolume 需要在每个节点上安装存储插件二进制文件，该二进制需要实现 FlexVolume 的相关接口，默认存储插件的存放路径为 <code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/&lt;vendor~driver&gt;/&lt;driver&gt;</code>，<code>VolumePlugins</code> 组件会不断 watch 这个目录来实现插件的添加、删除等功能。</p>
<p>其中 <code>vendor~driver</code> 的名字需要和 Pod 中<code>flexVolume.driver</code> 的字段名字匹配，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/kubernetes/kubelet-plugins/volume/exec/foo~cifs/cifs</span><br></pre></td></tr></table></figure>



<p>对应的 Pod 中的 <code>flexVolume.driver</code> 属性为：<code>foo/cifs</code>。</p>
<p>在我们实现自定义存储插件的时候，需要实现 FlexVolume 的部分接口，因为要看实际需求，并不一定所有接口都需要实现。比如对于类似于 NFS 这样的存储就没必要实现 <code>attach/detach</code> 这些接口了，因为不需要，只需要实现 <code>init/mount/umount</code> 3 个接口即可。</p>
<ul>
<li>init: <code>&lt;driver executable&gt; init</code> - <code>kubelet/kube-controller-manager</code> 初始化存储插件时调用，插件需要返回是否需要要 attach 和 detach 操作</li>
<li>attach: <code>&lt;driver executable&gt; attach &lt;json options&gt; &lt;node name&gt;</code> - 将存储卷挂载到 Node 节点上</li>
<li>detach: <code>&lt;driver executable&gt; detach &lt;mount device&gt; &lt;node name&gt;</code> - 将存储卷从 Node 上卸载</li>
<li>waitforattach: <code>&lt;driver executable&gt; waitforattach &lt;mount device&gt; &lt;json options&gt;</code> - 等待 attach 操作成功（超时时间为 10 分钟）</li>
<li>isattached: <code>&lt;driver executable&gt; isattached &lt;json options&gt; &lt;node name&gt;</code> - 检查存储卷是否已经挂载</li>
<li>mountdevice: <code>&lt;driver executable&gt; mountdevice &lt;mount dir&gt; &lt;mount device&gt; &lt;json options&gt;</code> - 将设备挂载到指定目录中以便后续 bind mount 使用</li>
<li>unmountdevice: <code>&lt;driver executable&gt; unmountdevice &lt;mount device&gt;</code> - 将设备取消挂载</li>
<li>mount: <code>&lt;driver executable&gt; mount &lt;mount dir&gt; &lt;json options&gt;</code> - 将存储卷挂载到指定目录中</li>
<li>unmount: <code>&lt;driver executable&gt; unmount &lt;mount dir&gt;</code> - 将存储卷取消挂载</li>
</ul>
<p>实现上面的这些接口需要返回如下所示的 JSON 格式的数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;Success/Failure/Not supported&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;Reason for success/failure&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;device&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;Path to the device attached. This field is valid only for attach &amp; waitforattach call-outs&gt;&quot;</span></span><br><span class="line">    <span class="attr">&quot;volumeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;Cluster wide unique name of the volume. Valid only for getvolumename call-out&gt;&quot;</span></span><br><span class="line">    <span class="attr">&quot;attached&quot;</span><span class="punctuation">:</span> &lt;True/False (Return <span class="literal"><span class="keyword">true</span></span> if volume is attached on the node. Valid only for isattached call-out)&gt;</span><br><span class="line">    <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> &lt;Only included as part of the Init response&gt;</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attach&quot;</span><span class="punctuation">:</span> &lt;True/False (Return <span class="literal"><span class="keyword">true</span></span> if the driver implements attach and detach)&gt;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>比如我们来实现一个 NFS 的 FlexVolume 插件，最简单的方式就是写一个脚本，然后实现 init、mount、unmount 3 个命令即可，然后按照上面的 JSON 格式返回数据，最后把这个脚本放在节点的 FlexVolume 插件目录下面即可。</p>
<p>下面就是官方给出的一个 NFS 的 FlexVolume 插件示例，可以从 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/examples/blob/master/staging/volumes/flexvolume/nfs">https://github.com/kubernetes/examples/blob/master/staging/volumes/flexvolume/nfs</a> 获取脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> - 在使用插件之前需要先安装 jq。</span></span><br><span class="line">usage() &#123;</span><br><span class="line">    err &quot;Invalid usage. Usage: &quot;</span><br><span class="line">    err &quot;\t$0 init&quot;</span><br><span class="line">    err &quot;\t$0 mount &lt;mount dir&gt; &lt;json params&gt;&quot;</span><br><span class="line">    err &quot;\t$0 unmount &lt;mount dir&gt;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err() &#123;</span><br><span class="line">    echo -ne $* 1&gt;&amp;2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log() &#123;</span><br><span class="line">    echo -ne $* &gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ismounted() &#123;</span><br><span class="line">    MOUNT=`findmnt -n $&#123;MNTPATH&#125; 2&gt;/dev/null | cut -d&#x27; &#x27; -f1`</span><br><span class="line">    if [ &quot;$&#123;MOUNT&#125;&quot; == &quot;$&#123;MNTPATH&#125;&quot; ]; then</span><br><span class="line">        echo &quot;1&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;0&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">domount() &#123;</span><br><span class="line">    MNTPATH=$1</span><br><span class="line"></span><br><span class="line">    NFS_SERVER=$(echo $2 | jq -r &#x27;.server&#x27;)</span><br><span class="line">    SHARE=$(echo $2 | jq -r &#x27;.share&#x27;)</span><br><span class="line"></span><br><span class="line">    if [ $(ismounted) -eq 1 ] ; then</span><br><span class="line">        log &#x27;&#123;&quot;status&quot;: &quot;Success&quot;&#125;&#x27;</span><br><span class="line">        exit 0</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    mkdir -p $&#123;MNTPATH&#125; &amp;&gt; /dev/null</span><br><span class="line"></span><br><span class="line">    mount -t nfs $&#123;NFS_SERVER&#125;:/$&#123;SHARE&#125; $&#123;MNTPATH&#125; &amp;&gt; /dev/null</span><br><span class="line">    if [ $? -ne 0 ]; then</span><br><span class="line">        err &quot;&#123; \&quot;status\&quot;: \&quot;Failure\&quot;, \&quot;message\&quot;: \&quot;Failed to mount $&#123;NFS_SERVER&#125;:$&#123;SHARE&#125; at $&#123;MNTPATH&#125;\&quot;&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">    log &#x27;&#123;&quot;status&quot;: &quot;Success&quot;&#125;&#x27;</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unmount() &#123;</span><br><span class="line">    MNTPATH=$1</span><br><span class="line">    if [ $(ismounted) -eq 0 ] ; then</span><br><span class="line">        log &#x27;&#123;&quot;status&quot;: &quot;Success&quot;&#125;&#x27;</span><br><span class="line">        exit 0</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    umount $&#123;MNTPATH&#125; &amp;&gt; /dev/null</span><br><span class="line">    if [ $? -ne 0 ]; then</span><br><span class="line">        err &quot;&#123; \&quot;status\&quot;: \&quot;Failed\&quot;, \&quot;message\&quot;: \&quot;Failed to unmount volume at $&#123;MNTPATH&#125;\&quot;&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    log &#x27;&#123;&quot;status&quot;: &quot;Success&quot;&#125;&#x27;</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">op=$1</span><br><span class="line"></span><br><span class="line">if ! command -v jq &gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">    err &quot;&#123; \&quot;status\&quot;: \&quot;Failure\&quot;, \&quot;message\&quot;: \&quot;&#x27;jq&#x27; binary not found. Please install jq package before using this driver\&quot;&#125;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$op&quot; = &quot;init&quot; ]; then</span><br><span class="line">    log &#x27;&#123;&quot;status&quot;: &quot;Success&quot;, &quot;capabilities&quot;: &#123;&quot;attach&quot;: false&#125;&#125;&#x27;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $# -lt 2 ]; then</span><br><span class="line">    usage</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">shift</span><br><span class="line"></span><br><span class="line">case &quot;$op&quot; in</span><br><span class="line">    mount)</span><br><span class="line">        domount $*</span><br><span class="line">        ;;</span><br><span class="line">    unmount)</span><br><span class="line">        unmount $*</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        log &#x27;&#123;&quot;status&quot;: &quot;Not supported&quot;&#125;&#x27;</span><br><span class="line">        exit 0</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 1</span><br></pre></td></tr></table></figure>



<p>将上面脚本命名成 nfs，放置到 node1 节点对应的插件下面： <code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs</code>，并设置权限为 700：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ chmod 700 /usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 jq 工具</span></span><br><span class="line">➜ yum -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line">➜ yum install jq -y</span><br></pre></td></tr></table></figure>



<p>这个时候我们部署一个应用到 node1 节点上，并用 <code>flexVolume</code> 来持久化容器中的数据（当然也可以通过定义 flexvolume 类型的 PV、PVC 来使用），如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test-flexvolume.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-flexvolume</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="string">node1</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">flexVolume:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">&#x27;ydzs/nfs&#x27;</span> <span class="comment"># 定义插件类型，根据这个参数在对应的目录下面找到插件的可执行文件</span></span><br><span class="line">        <span class="attr">fsType:</span> <span class="string">&#x27;nfs&#x27;</span> <span class="comment"># 定义存储卷文件系统类型</span></span><br><span class="line">        <span class="attr">options:</span> <span class="comment"># 定义所有与存储相关的一些具体参数</span></span><br><span class="line">          <span class="attr">server:</span> <span class="string">&#x27;192.168.31.31&#x27;</span></span><br><span class="line">          <span class="attr">share:</span> <span class="string">&#x27;var/lib/k8s/data/&#x27;</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">testflexvolume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br></pre></td></tr></table></figure>



<p>其中 <code>flexVolume.driver</code> 就是插件目录 <code>ydzs~nfs</code> 对应的 <code>ydzs/nfs</code> 名称，<code>flexVolume.options</code> 中根据上面的 nfs 脚本可以得知里面配置的是 NFS 的 Server 地址和挂载目录路径，直接创建上面的资源对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl apply -f test-flexvolume.yaml</span><br><span class="line">➜ kubectl get pods</span><br><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">test-flexvolume                           1/1     Running   0          13h</span><br><span class="line">......</span><br><span class="line">➜ kubectl exec -it test-flexvolume mount |grep test</span><br><span class="line">192.168.31.31:/var/lib/k8s/data/testflexvolume on /usr/share/nginx/html type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.31.108,local_lock=none,addr=192.168.31.31)</span><br><span class="line">➜ mount |grep test # node1节点上执行</span><br><span class="line">192.168.31.31:/var/lib/k8s/data on /var/lib/kubelet/pods/d1b108d8-2640-4f2b-a08c-14392e163b97/volumes/ydzs~nfs/test type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.31.108,local_lock=none,addr=192.168.31.31)</span><br><span class="line">192.168.31.31:/var/lib/k8s/data/testflexvolume on /var/lib/kubelet/pods/d1b108d8-2640-4f2b-a08c-14392e163b97/volume-subpaths/test/web/0 type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.31.108,local_lock=none,addr=192.168.31.31)</span><br></pre></td></tr></table></figure>



<p>同样我们可以查看到 Pod 的本地持久化目录是被 mount 到了 NFS 上面，证明上面我们的 FlexVolume 插件是正常的。</p>
<p>!!! info “调用”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们要去真正的 mount NFS 的时候，就是通过 kubelet 调用 `VolumePlugin`，然后直接执行命令`/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs mount &lt;mount dir&gt; &lt;json param&gt;` 来完成的，就相当于平时我们在宿主机上面手动挂载 NFS 的方式一样的，所以存储插件 nfs 是一个可执行的二进制文件或者 shell 脚本都是可以的。</span><br></pre></td></tr></table></figure>



<h2 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h2><p>既然已经有了 <code>FlexVolume</code> 插件了，为什么还需要 <code>CSI</code> 插件呢？上面我们使用 FlexVolume 插件的时候可以看出 FlexVolume 插件实际上相当于就是一个普通的 shell 命令，类似于平时我们在 Linux 下面执行的 <code>ls</code> 命令一样，只是返回的信息是 JSON 格式的数据，并不是我们通常认为的一个常驻内存的进程，而 CSI 是一个更加完善、编码更加方便友好的一种存储插件扩展方式。</p>
<p><a target="_blank" rel="noopener" href="https://kubernetes-csi.github.io/docs/">CSI</a> 是 <code>Container Storage Interface</code> 的简称，旨在能为容器编排引擎和存储系统间建立一套标准的存储调用接口，通过该接口能为容器编排引擎提供存储服务。在 CSI 之前，K8S 里提供存储服务基本上是通过 <code>in-tree</code> 的方式来提供，如下图：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/bwszp4.png" alt="without csi"></p>
<p>这种方式需要将存储提供者的代码逻辑放到 K8S 的代码库中运行，调用引擎与插件间属于强耦合，这种方式会带来一些问题：</p>
<ul>
<li>存储插件需要一同随 K8S 发布</li>
<li>K8S 社区需要对存储插件的测试、维护负责</li>
<li>存储插件的问题有可能会影响 K8S 部件正常运行</li>
<li>存储插件享有 K8S 部件同等的特权存在安全隐患</li>
<li>存储插件开发者必须遵循 K8S 社区的规则开发代码</li>
</ul>
<p>基于这些问题和挑战，CO（Container Orchestrator） 厂商提出 Container Storage Interface 用来定义容器存储标准，它独立于 Kubernetes Storage SIG，由 Kubernetes、Mesos、Cloud Foundry 三家一起推动。CSI 规范定义了存储提供商实现 CSI 兼容插件的最小操作集合和部署建议，CSI 规范的主要焦点是声明插件必须实现的接口。</p>
<p>在 Kubernetes 上整合 CSI 插件的整体架构如下图所示：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/q1am9u.png" alt="kubernetes csi structrue"></p>
<p>Kubernetes CSI 存储体系主要由两部分组成：</p>
<ul>
<li><p>Kubernetes 外部组件：包含 <code>Driver registrar</code>、<code>External provisioner</code>、<code>External attacher</code> 三部分，这三个组件是从 Kubernetes 原本的 in-tree 存储体系中剥离出来的存储管理功能，实际上是 Kubernetes 中的一种外部 controller，它们 watch kubernetes 的 API 资源对象，根据 watch 到的状态来调用下面提到的第二部分的 CSI 插件来实现存储的管理和操作。这部分是 Kubernetes 团队维护的，插件开发者完全不必关心其实现细节。</p>
<ul>
<li><code>Driver registra</code>：一个 Sidecar 容器，向 Kubernetes 注册 CSI Driver，添加 Drivers 的一些信息</li>
<li><code>External provisioner</code>：也是一个 Sidecar 容器，watch Kubernetes 的 PVC 对象，调用对应 CSI 的 Volum e 创建、删除等操作</li>
<li><code>External attacher</code>：一个 Sidecar 容器，watch Kubernetes 系统里的 <code>VolumeAttachment</code> 对象，调用对应 CSI 的 ControllerPublish 和 ControllerUnpublish 操作来完成对应的 Volume 的 Attach&#x2F;Detach。而 Volume 的 Mount&#x2F;Unmount 阶段并不属于外部组件，当真正需要执行 Mount 操作的时候，kubelet 会去直接调用下面的 CSI Node 服务来完成 Volume 的 Mount&#x2F;UnMount 操作。</li>
</ul>
</li>
<li><p>CSI 存储插件: 这部分正是开发者需要实现的 CSI 插件部分，都是通过 gRPC 实现的服务，一般会用一个二进制文件对外提供服务，主要包含三部分：<code>CSI Identity</code>、<code>CSI Controller</code>、<code>CSI Node</code>。</p>
<ul>
<li><p><code>CSI Identity</code> — 主要用于负责对外暴露这个插件本身的信息，确保插件的健康状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service Identity &#123;</span><br><span class="line">    <span class="comment">// 返回插件的名称和版本</span></span><br><span class="line">    rpc GetPluginInfo(GetPluginInfoRequest)</span><br><span class="line">        returns (GetPluginInfoResponse) &#123;&#125;</span><br><span class="line">    <span class="comment">// 返回这个插件的包含的功能，比如非块存储类型的 CSI 插件不需要实现 Attach 功能，GetPluginCapabilities 就可以在返回中标注这个 CSI 插件不包含 Attach 功能</span></span><br><span class="line">    rpc GetPluginCapabilities(GetPluginCapabilitiesRequest)</span><br><span class="line">        returns (GetPluginCapabilitiesResponse) &#123;&#125;</span><br><span class="line">    <span class="comment">// 插件插件是否正在运行</span></span><br><span class="line">    rpc Probe (ProbeRequest)</span><br><span class="line">        returns (ProbeResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>CSI Controller</code> - 主要实现 Volume 管理流程当中的 Provision 和 Attach 阶段，Provision 阶段是指创建和删除 Volume 的流程，而 Attach 阶段是指把存储卷附着在某个节点或脱离某个节点的流程，另外只有块存储类型的 CSI 插件才需要 Attach 功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">service Controller &#123;</span><br><span class="line">    <span class="comment">// 创建存储卷，包括云端存储介质以及PV对象</span></span><br><span class="line">    rpc CreateVolume (CreateVolumeRequest)</span><br><span class="line">        returns (CreateVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  删除存储卷</span></span><br><span class="line">    rpc DeleteVolume (DeleteVolumeRequest)</span><br><span class="line">        returns (DeleteVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载存储卷，将存储介质挂载到目标节点</span></span><br><span class="line">    rpc ControllerPublishVolume (ControllerPublishVolumeRequest)</span><br><span class="line">        returns (ControllerPublishVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载存储卷</span></span><br><span class="line">    rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)</span><br><span class="line">        returns (ControllerUnpublishVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例如：是否可以同时用于多个节点的读/写</span></span><br><span class="line">    rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)</span><br><span class="line">        returns (ValidateVolumeCapabilitiesResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回所有可用的 volumes</span></span><br><span class="line">    rpc ListVolumes (ListVolumesRequest)</span><br><span class="line">        returns (ListVolumesResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可用存储池的总容量</span></span><br><span class="line">    rpc GetCapacity (GetCapacityRequest)</span><br><span class="line">        returns (GetCapacityResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例如. 插件可能未实现 GetCapacity、Snapshotting</span></span><br><span class="line">    rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest)</span><br><span class="line">        returns (ControllerGetCapabilitiesResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建快照</span></span><br><span class="line">    rpc CreateSnapshot (CreateSnapshotRequest)</span><br><span class="line">        returns (CreateSnapshotResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定的快照</span></span><br><span class="line">    rpc DeleteSnapshot (DeleteSnapshotRequest)</span><br><span class="line">        returns (DeleteSnapshotResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有的快照</span></span><br><span class="line">    rpc ListSnapshots (ListSnapshotsRequest)</span><br><span class="line">        returns (ListSnapshotsResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>CSI Node</code> — 负责控制 Kubernetes 节点上的 Volume 的相关功能。其中 Volume 的挂载被分成了 NodeStageVolume 和 NodePublishVolume 两个阶段。NodeStageVolume 接口主要是针对块存储类型的 CSI 插件而提供的，块设备在 “Attach” 阶段被附着在 Node 上后，需要挂载至 Pod 对应目录上，但因为块设备在 linux 上只能 mount 一次，而在 kubernetes volume 的使用场景中，一个 volume 可能被挂载进同一个 Node 上的多个 Pod 实例中，所以这里提供了 NodeStageVolume 这个接口，使用这个接口把块设备格式化后先挂载至 Node 上的一个临时全局目录，然后再调用 NodePublishVolume 使用 linux 中的 <code>bind mount</code> 技术把这个全局目录挂载进 Pod 中对应的目录上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">service Node &#123;</span><br><span class="line">    <span class="comment">// 在节点上初始化存储卷（格式化），并执行挂载到Global目录</span></span><br><span class="line">    rpc NodeStageVolume (NodeStageVolumeRequest)</span><br><span class="line">        returns (NodeStageVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// umount 存储卷在节点上的 Global 目录</span></span><br><span class="line">    rpc NodeUnstageVolume (NodeUnstageVolumeRequest)</span><br><span class="line">        returns (NodeUnstageVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在节点上将存储卷的 Global 目录挂载到 Pod 的实际挂载目录</span></span><br><span class="line">    rpc NodePublishVolume (NodePublishVolumeRequest)</span><br><span class="line">        returns (NodePublishVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unmount 存储卷在节点上的 Pod 挂载目录</span></span><br><span class="line">    rpc NodeUnpublishVolume (NodeUnpublishVolumeRequest)</span><br><span class="line">        returns (NodeUnpublishVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取节点上Volume挂载文件系统统计信息（总空间、可用空间等）</span></span><br><span class="line">    rpc NodeGetVolumeStats (NodeGetVolumeStatsRequest)</span><br><span class="line">        returns (NodeGetVolumeStatsResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取节点的唯一 ID</span></span><br><span class="line">    rpc NodeGetId (NodeGetIdRequest)</span><br><span class="line">        returns (NodeGetIdResponse) &#123;</span><br><span class="line">        option deprecated = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回节点插件的能力</span></span><br><span class="line">    rpc NodeGetCapabilities (NodeGetCapabilitiesRequest)</span><br><span class="line">        returns (NodeGetCapabilitiesResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取节点的一些信息</span></span><br><span class="line">    rpc NodeGetInfo (NodeGetInfoRequest)</span><br><span class="line">        returns (NodeGetInfoResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>只需要实现上面的接口就可以实现一个 CSI 插件了。虽然 Kubernetes 并未规定 CSI 插件的打包安装，但是提供了以下建议来简化我们在 Kubernetes 上容器化 CSI Volume 驱动程序的部署方案，具体的方案介绍可以查看 CSI 规范介绍文档 <a target="_blank" rel="noopener" href="https://github.com/container-storage-interface/spec/blob/master/spec.md">https://github.com/container-storage-interface/spec/blob/master/spec.md</a></p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/1oaqhg.png" alt="container storage interface deploy"></p>
<p>按照上图的推荐方案，<code>CSI Controller</code> 负责 Volumes 的创建删除等操作，整个集群只需要部署一个，以 StatefulSet 或者 Deployment 方式部署均可，<code>CSI Node</code> 部分负责 Volumes 的 attach、detach 等操作，需要在每个节点部署一个，所以用 DaemonSet 方式部署，因为这两部分实现在同一个 CSI 插件程序中，因此只需要把这个 CSI 插件与 <code>External Components</code> 以容器方式部署在同一个 Pod 中，把这个 CSI 插件与 <code>Driver registrar</code> 以容器方式部署在 DaemonSet 的 Pod 中，即可完成 CSI 的部署。</p>
<p>比如在训练营第一期中我们使用的 Rook 部署的 Ceph 集群就实现了 CSI 插件的:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods -n rook-ceph |grep plugin</span><br><span class="line">csi-cephfsplugin-2s9d5                                 3/3     Running     0          21d</span><br><span class="line">csi-cephfsplugin-fgp4v                                 3/3     Running     0          17d</span><br><span class="line">csi-cephfsplugin-fv5nx                                 3/3     Running     0          21d</span><br><span class="line">csi-cephfsplugin-mn8q4                                 3/3     Running     0          17d</span><br><span class="line">csi-cephfsplugin-nf6h8                                 3/3     Running     0          21d</span><br><span class="line">csi-cephfsplugin-provisioner-56c8b7ddf4-68h6d          4/4     Running     0          21d</span><br><span class="line">csi-cephfsplugin-provisioner-56c8b7ddf4-rq4t6          4/4     Running     0          21d</span><br><span class="line">csi-cephfsplugin-xwnl4                                 3/3     Running     0          21d</span><br><span class="line">csi-rbdplugin-7r88w                                    3/3     Running     0          21d</span><br><span class="line">csi-rbdplugin-95g5j                                    3/3     Running     0          21d</span><br><span class="line">csi-rbdplugin-bnzpr                                    3/3     Running     0          21d</span><br><span class="line">csi-rbdplugin-dvftb                                    3/3     Running     0          21d</span><br><span class="line">csi-rbdplugin-jzmj2                                    3/3     Running     0          17d</span><br><span class="line">csi-rbdplugin-provisioner-6ff4dd4b94-bvtss             5/5     Running     0          21d</span><br><span class="line">csi-rbdplugin-provisioner-6ff4dd4b94-lfn68             5/5     Running     0          21d</span><br><span class="line">csi-rbdplugin-trxb4                                    3/3     Running     0          17d</span><br></pre></td></tr></table></figure>



<p>这里其实是实现了 RBD 和 CephFS 两种 CSI，用 DaemonSet 在每个节点上运行了一个包含 <code>Driver registra</code> 容器的 Pod，当然和节点相关的操作比如 Mount&#x2F;Unmount 也是在这个 Pod 里面执行的，其他的比如 Provision、Attach 都是在另外的 <code>csi-rbdplugin-provisioner-xxx</code> Pod 中执行的。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在我们来测试通过 CSI 的形式使用 NFS 存储，当然首先我们需要在 Kubernetes 集群中安装 NFS CSI 的驱动，<a target="_blank" rel="noopener" href="https://github.com/kubernetes-csi/csi-driver-nfs">https://github.com/kubernetes-csi/csi-driver-nfs</a> 就是一个 NFS 的 CSI 驱动实现的项目。</p>
<p>如果能访问 github 则可以直接使用下面的命令一键安装 NFS CSI 驱动程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -skSL https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/deploy/install-driver.sh | bash -s master --</span><br></pre></td></tr></table></figure>



<p>也可以本地安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ git clone https://github.com/kubernetes-csi/csi-driver-nfs.git</span><br><span class="line">➜ cd csi-driver-nfs</span><br><span class="line">➜ ./deploy/install-driver.sh master local</span><br></pre></td></tr></table></figure>



<p>和上面介绍的部署方式基本上也是一致的，首先会用 DaemonSet 的形式在每个节点上运行了一个包含 <code>Driver registra</code> 容器的 Pod，当然和节点相关的操作比如 Mount&#x2F;Unmount 也是在这个 Pod 里面执行的，其他的比如 Provision、Attach 都是在另外的 <code>csi-nfs-controller-xxx</code> Pod 中执行的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl -n kube-system get pod -o wide -l app=csi-nfs-controller</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE     IP               NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">csi-nfs-controller-bd6dbb598-fx4hj   3/3     Running   0          6m20s   192.168.31.108   node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">➜ kubectl -n kube-system get pod -o wide -l app=csi-nfs-node</span><br><span class="line">NAME                 READY   STATUS    RESTARTS   AGE     IP               NODE      NOMINATED NODE   READINESS GATES</span><br><span class="line">csi-nfs-node-bx5rc   3/3     Running   0          6m13s   192.168.31.108   node1     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">csi-nfs-node-llwqz   3/3     Running   0          6m20s   192.168.31.46    node2     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">csi-nfs-node-rkcpm   3/3     Running   0          6m15s   192.168.31.31    master1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>



<p>当 csi 的驱动安装完成后我们就可以通过 csi 的方式来使用我们的 nfs 存储了。</p>
<p>比如我们创建</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv-nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">mountOptions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hard</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nfsvers=4.1</span></span><br><span class="line">  <span class="attr">csi:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">nfs.csi.k8s.io</span></span><br><span class="line">    <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">volumeHandle:</span> <span class="string">unique-volumeid</span> <span class="comment"># make sure it&#x27;s a unique id in the cluster</span></span><br><span class="line">    <span class="attr">volumeAttributes:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.31</span></span><br><span class="line">      <span class="attr">share:</span> <span class="string">/var/lib/k8s/data</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc-nfs-static</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">pv-nfs</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<p>直接创建上面的资源对象后我们的 PV 和 PVC 就绑定在一起了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pv pv-nfs</span><br><span class="line">NAME     CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                    STORAGECLASS   REASON   AGE</span><br><span class="line">pv-nfs   10Gi       RWX            Retain           Bound    default/pvc-nfs-static                           15s</span><br><span class="line">➜ kubectl get pvc pvc-nfs-static</span><br><span class="line">NAME             STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc-nfs-static   Bound    pv-nfs   10Gi       RWX                           30s</span><br></pre></td></tr></table></figure>



<p>这里的核心配置是 PV 中的 <code>csi</code> 属性的配置，需要通过 <code>csi.driver</code> 来指定我们要使用的驱动名称，比如我们这里使用 nfs 的名称为 <code>nfs.csi.k8s.io</code>，然后就是根据具体的驱动配置相关的参数。</p>
<p>同样还可以创建一个用于动态创建 PV 的 StorageClass 对象：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-csi</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">nfs.csi.k8s.io</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.31</span></span><br><span class="line">  <span class="attr">share:</span> <span class="string">/var/lib/k8s/data</span></span><br><span class="line">  <span class="comment"># csi.storage.k8s.io/provisioner-secret is only needed for providing mountOptions in DeleteVolume</span></span><br><span class="line">  <span class="comment"># csi.storage.k8s.io/provisioner-secret-name: &quot;mount-options&quot;</span></span><br><span class="line">  <span class="comment"># csi.storage.k8s.io/provisioner-secret-namespace: &quot;default&quot;</span></span><br><span class="line"><span class="attr">reclaimPolicy:</span> <span class="string">Delete</span></span><br><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">Immediate</span></span><br><span class="line"><span class="attr">mountOptions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hard</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nfsvers=4.1</span></span><br></pre></td></tr></table></figure>



<p>对于我们普通用户来说使用起来都是一样的，只需要管理员提供何时的 PV 或 StorageClass 即可，这里我们就使用的 CSI 的形式来提供 NFS 的存储。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E5%AE%89%E8%A3%85%20prometheus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E5%AE%89%E8%A3%85%20prometheus/" class="post-title-link" itemprop="url">安装 prometheus</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:09:46" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="在-Kubernetes-上部署-Prometheus"><a href="#在-Kubernetes-上部署-Prometheus" class="headerlink" title="在 Kubernetes 上部署 Prometheus"></a>在 Kubernetes 上部署 Prometheus</h1><p>前面我们已经了解了 Prometheus 的基本使用方式，主要是使用的二进制方式进行部署的，在实际生产环境来说，Prometheus 更适合用来部署在 Kubernetes 集群中，本节我们将介绍如何用手动方式在 Kubernetes 集群上部署 Prometheus，关于 Kubernetes 本身的使用可以参考我们的另外课程<a target="_blank" rel="noopener" href="https://youdianzhishi.com/web/course/1030">《Kubernetes 进阶训练营》</a>。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于我们这里是要运行在 Kubernetes 系统中，所以我们直接用 Docker 镜像的方式运行。这里我们使用的实验环境是基于 Kubernetes v1.22 版本，一共 3 个节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES                  AGE   VERSION</span><br><span class="line">master1   Ready    control-plane,master   49d   v1.22.2</span><br><span class="line">node1     Ready    &lt;none&gt;                 49d   v1.22.2</span><br><span class="line">node2     Ready    &lt;none&gt;                 49d   v1.22.2</span><br></pre></td></tr></table></figure>

<p>为了方便管理，我们将监控相关的所有资源对象都安装在 <code>kube-mon</code> 这个 namespace 下面，没有的话可以提前创建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl create ns kube-mon</span><br></pre></td></tr></table></figure>

<p>为了能够方便的管理配置文件，我们这里将 <code>prometheus.yml</code> 配置文件用 <code>ConfigMap</code> 的形式进行管理：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">prometheus.yml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    global:</span></span><br><span class="line"><span class="string">      scrape_interval: 15s</span></span><br><span class="line"><span class="string">      scrape_timeout: 15s</span></span><br><span class="line"><span class="string">    scrape_configs:</span></span><br><span class="line"><span class="string">    - job_name: &#x27;prometheus&#x27;</span></span><br><span class="line"><span class="string">      static_configs:</span></span><br><span class="line"><span class="string">      - targets: [&#x27;localhost:9090&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>我们这里暂时只配置了对 prometheus 本身的监控，直接创建该资源对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl apply -f https://p8s.io/docs/k8s/manifests/prometheus/config-1.yaml</span><br><span class="line">configmap &quot;prometheus-config&quot; created</span><br></pre></td></tr></table></figure>

<p>配置文件创建完成了，以后如果我们有新的资源需要被监控，我们只需要将上面的 ConfigMap 对象更新即可。现在我们来创建 prometheus 的 Pod 资源：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prometheus-deploy.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">prometheus</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">prom/prometheus:v2.31.1</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;--config.file=/etc/prometheus/prometheus.yml&#x27;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;--storage.tsdb.path=/prometheus&#x27;</span> <span class="comment"># 指定tsdb数据路径</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;--storage.tsdb.retention.time=24h&#x27;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;--web.enable-admin-api&#x27;</span> <span class="comment"># 控制对admin HTTP API的访问，其中包括删除时间序列等功能</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;--web.enable-lifecycle&#x27;</span> <span class="comment"># 支持热更新，直接执行localhost:9090/-/reload立即生效</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9090</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&#x27;/etc/prometheus&#x27;</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&#x27;/prometheus&#x27;</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">prometheus-data</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">config-volume</span></span><br></pre></td></tr></table></figure>

<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>另外为了 prometheus 的性能和数据持久化我们这里是直接将通过一个 LocalPV 来进行数据持久化的，<strong>注意一定不能使用 nfs 来持久化数据</strong>，通过 <code>--storage.tsdb.path=/prometheus</code> 指定数据目录，创建如下所示的一个 PVC 资源对象，注意是一个 LocalPV，和 node2 节点具有亲和性：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">local-storage</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/no-provisioner</span></span><br><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">WaitForFirstConsumer</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-local</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-storage</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/k8s/prometheus</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">node2</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-data</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-storage</span></span><br></pre></td></tr></table></figure>

<p>由于 prometheus 可以访问 Kubernetes 的一些资源对象，所以需要配置 rbac 相关认证，这里我们使用了一个名为 prometheus 的 serviceAccount 对象：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rbac.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nodes/proxy</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;extensions&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ingresses</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nodes/metrics</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nonResourceURLs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/metrics</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br></pre></td></tr></table></figure>

<p>由于我们要获取的资源信息，在每一个 namespace 下面都有可能存在，所以我们这里使用的是 <code>ClusterRole</code> 的资源对象，值得一提的是我们这里的权限规则声明中有一个 <code>nonResourceURLs</code> 的属性，是用来对非资源型 metrics 进行操作的权限声明，这个在以前我们很少遇到过，然后直接创建上面的资源对象即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl apply -f https://p8s.io/docs/k8s/manifests/prometheus/rbac.yaml</span><br><span class="line">serviceaccount &quot;prometheus&quot; created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io &quot;prometheus&quot; created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io &quot;prometheus&quot; created</span><br></pre></td></tr></table></figure>

<p>现在我们就可以添加 promethues 的资源对象了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl apply -f https://p8s.io/docs/k8s/manifests/prometheus/deploy.yaml</span><br><span class="line">deployment.apps/prometheus created</span><br><span class="line">☸ ➜ kubectl get pods -n kube-mon</span><br><span class="line">NAME                         READY   STATUS             RESTARTS   AGE</span><br><span class="line">prometheus-df4f47d95-vksmc   0/1     CrashLoopBackOff   3          98s</span><br><span class="line">☸ ➜ kubectl logs -f prometheus-df4f47d95-vksmc -n kube-mon</span><br><span class="line">level=info ts=2019-12-12T03:08:49.424Z caller=main.go:332 msg=&quot;Starting Prometheus&quot; version=&quot;(version=2.14.0, branch=HEAD, revision=edeb7a44cbf745f1d8be4ea6f215e79e651bfe19)&quot;</span><br><span class="line">level=info ts=2019-12-12T03:08:49.424Z caller=main.go:333 build_context=&quot;(go=go1.13.4, user=root@df2327081015, date=20191111-14:27:12)&quot;</span><br><span class="line">level=info ts=2019-12-12T03:08:49.425Z caller=main.go:334 host_details=&quot;(Linux 3.10.0-1062.4.1.el7.x86_64 #1 SMP Fri Oct 18 17:15:30 UTC 2019 x86_64 prometheus-df4f47d95-vksmc (none))&quot;</span><br><span class="line">level=info ts=2019-12-12T03:08:49.425Z caller=main.go:335 fd_limits=&quot;(soft=1048576, hard=1048576)&quot;</span><br><span class="line">level=info ts=2019-12-12T03:08:49.425Z caller=main.go:336 vm_limits=&quot;(soft=unlimited, hard=unlimited)&quot;</span><br><span class="line">level=error ts=2019-12-12T03:08:49.425Z caller=query_logger.go:85 component=activeQueryTracker msg=&quot;Error opening query log file&quot; file=/prometheus/queries.active err=&quot;open /prometheus/queries.active: permission denied&quot;</span><br><span class="line">panic: Unable to create mmap-ed active query log</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">github.com/prometheus/prometheus/promql.NewActiveQueryTracker(0x7ffd8cf6ec5d, 0xb, 0x14, 0x2b4f400, 0xc0006f33b0, 0x2b4f400)</span><br><span class="line">        /app/promql/query_logger.go:115 +0x48c</span><br><span class="line">main.main()</span><br><span class="line">        /app/cmd/prometheus/main.go:364 +0x5229</span><br></pre></td></tr></table></figure>

<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>创建 Pod 后，我们可以看到并没有成功运行，出现了 <code>open /prometheus/queries.active: permission denied</code> 这样的错误信息，这是因为我们的 prometheus 的镜像中是使用的 nobody 这个用户，然后现在我们通过 LocalPV 挂载到宿主机上面的目录的 <code>ownership</code> 却是 <code>root</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ ls -la /data/k8s</span><br><span class="line">total 36</span><br><span class="line">drwxr-xr-x   6 root root  4096 Dec 12 11:07 .</span><br><span class="line">dr-xr-xr-x. 19 root root  4096 Nov  9 23:19 ..</span><br><span class="line">drwxr-xr-x   2 root root  4096 Dec 12 11:07 prometheus</span><br></pre></td></tr></table></figure>

<p>所以当然会出现操作权限问题了，这个时候我们就可以通过 <code>securityContext</code> 来为 Pod 设置下 volumes 的权限，通过设置 <code>runAsUser=0</code> 指定运行的用户为 root，也可以通过设置一个 initContainer 来修改数据目录权限：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">initContainers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fix-permissions</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">chown</span>, <span class="string">-R</span>, <span class="string">&quot;nobody:nobody&quot;</span>, <span class="string">/prometheus</span>]</span><br><span class="line">  <span class="attr">volumeMounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/prometheus</span></span><br></pre></td></tr></table></figure>

<p>这个时候我们重新更新下 prometheus：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl apply -f https://p8s.io/docs/k8s/manifests/prometheus/deploy-fixed.yaml</span><br><span class="line">deployment.apps/prometheus configured</span><br><span class="line">☸ ➜ kubectl get pods -n kube-mon</span><br><span class="line">NAME                          READY   STATUS    RESTARTS      AGE</span><br><span class="line">prometheus-649968556c-t4prd   1/1     Running   1 (14m ago)   27h</span><br><span class="line">☸ ➜ kubectl logs -f prometheus-649968556c-t4prd -n kube-mon</span><br><span class="line">ts=2021-12-15T06:55:25.752Z caller=main.go:444 level=info msg=&quot;Starting Prometheus&quot; version=&quot;(version=2.31.1, branch=HEAD, revision=411021ada9ab41095923b8d2df9365b632fd40c3)&quot;</span><br><span class="line">ts=2021-12-15T06:55:25.752Z caller=main.go:449 level=info build_context=&quot;(go=go1.17.3, user=root@9419c9c2d4e0, date=20211105-20:35:02)&quot;</span><br><span class="line">ts=2021-12-15T06:55:25.752Z caller=main.go:450 level=info host_details=&quot;(Linux 3.10.0-1160.25.1.el7.x86_64 #1 SMP Wed Apr 28 21:49:45 UTC 2021 x86_64 prometheus-649968556c-t4prd (none))&quot;</span><br><span class="line">ts=2021-12-15T06:55:25.752Z caller=main.go:451 level=info fd_limits=&quot;(soft=1048576, hard=1048576)&quot;</span><br><span class="line">ts=2021-12-15T06:55:25.752Z caller=main.go:452 level=info vm_limits=&quot;(soft=unlimited, hard=unlimited)&quot;</span><br><span class="line">ts=2021-12-15T06:55:25.756Z caller=web.go:542 level=info component=web msg=&quot;Start listening for connections&quot; address=0.0.0.0:9090</span><br><span class="line">ts=2021-12-15T06:55:26.150Z caller=main.go:839 level=info msg=&quot;Starting TSDB ...&quot;</span><br><span class="line">......</span><br><span class="line">ts=2021-12-15T06:55:27.048Z caller=main.go:869 level=info msg=&quot;TSDB started&quot;</span><br><span class="line">ts=2021-12-15T06:55:27.048Z caller=main.go:996 level=info msg=&quot;Loading configuration file&quot; filename=/etc/prometheus/prometheus.yml</span><br><span class="line">ts=2021-12-15T06:55:27.050Z caller=main.go:1033 level=info msg=&quot;Completed loading of configuration file&quot; filename=/etc/prometheus/prometheus.yml totalDuration=1.555486ms db_storage=754ns remote_storage=38.847µs web_handler=433ns query_engine=852ns scrape=1.030952ms scrape_sd=73.933µs notify=894ns notify_sd=2.504µs rules=19.359µs</span><br><span class="line">ts=2021-12-15T06:55:27.050Z caller=main.go:811 level=info msg=&quot;Server is ready to receive web requests.&quot;</span><br></pre></td></tr></table></figure>

<p>Pod 创建成功后，为了能够在外部访问到 prometheus 的 webui 服务，我们还需要创建一个 Service 对象：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prometheus-svc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure>

<p>为了方便测试，我们这里创建一个 <code>NodePort</code> 类型的服务，当然我们可以创建一个 <code>Ingress</code>对象，通过域名来进行访问：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl apply -f https://p8s.io/docs/k8s/manifests/prometheus/svc.yaml</span><br><span class="line">service &quot;prometheus&quot; created</span><br><span class="line">☸ ➜ kubectl get svc -n kube-mon</span><br><span class="line">NAME         TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">prometheus   NodePort   10.111.160.152   &lt;none&gt;        9090:30407/TCP   4m33s</span><br></pre></td></tr></table></figure>

<p>现在我们就可以通过 <code>http://任意节点IP:30407</code> 访问 prometheus 的 webui 服务了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/w5nh70.png" alt="prometheus webui"></p>
<p>现在我们可以查看当前监控系统中的一些监控目标（Status -&gt; Targets）：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/qhxvpc.png" alt="prometheus webui targets"></p>
<p>由于我们现在还没有配置任何的报警信息，所以 <code>Alerts</code> 菜单下面现在没有任何数据，隔一会儿，我们可以去 <code>Graph</code> 菜单下面查看我们抓取的 prometheus 本身的一些监控数据了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/x9l56z.png" alt="prometheus webui metrics"></p>
<p>比如我们这里就选择 <code>scrape_duration_seconds</code> 这个指标，然后点击 <code>Execute</code>，就可以看到类似于下面的图表数据了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/yenyl6.png" alt="prometheus webui query"></p>
<p><a target="_blank" rel="noopener" href="https://docs.youdianzhishi.com/prometheus/grafana/alerts/">
</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">容器监控</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:15:42" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h1><p>说到容器监控我们自然会想到 <code>cAdvisor</code>，我们前面也说过 cAdvisor 已经内置在了 kubelet 组件之中，所以我们不需要单独去安装，<code>cAdvisor</code> 的数据路径为 <code>/api/v1/nodes/&lt;node&gt;/proxy/metrics</code>，但是我们不推荐使用这种方式，因为这种方式是通过 APIServer 去代理访问的，对于大规模的集群会对 APIServer 造成很大的压力，所以我们可以直接通过访问 kubelet 的 <code>/metrics/cadvisor</code> 这个端点来获取 cAdvisor 的数据。</p>
<h2 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h2><p>我们这里使用 node 的服务发现模式，因为每一个节点下面都有 kubelet，自然都有 <code>cAdvisor</code> 采集到的数据指标，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;cadvisor&#x27;</span></span><br><span class="line">  <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">node</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">  <span class="attr">tls_config:</span></span><br><span class="line">    <span class="attr">ca_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span></span><br><span class="line">    <span class="attr">insecure_skip_verify:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">bearer_token_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/token</span></span><br><span class="line">  <span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">__meta_kubernetes_node_label_(.+)</span></span><br><span class="line">      <span class="attr">replacement:</span> <span class="string">$1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">replacement:</span> <span class="string">/metrics/cadvisor</span> <span class="comment"># &lt;nodeip&gt;/metrics -&gt; &lt;nodeip&gt;/metrics/cadvisor</span></span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">  <span class="comment"># 下面的方式不推荐使用</span></span><br><span class="line">  <span class="comment"># - target_label: __address__</span></span><br><span class="line">  <span class="comment">#   replacement: kubernetes.default.svc:443</span></span><br><span class="line">  <span class="comment"># - target_label: __metrics_path__</span></span><br><span class="line">  <span class="comment">#   replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics/cadvisor</span></span><br></pre></td></tr></table></figure>

<p>上面的配置和我们之前配置 <code>node-exporter</code> 的时候几乎是一样的，区别是我们这里使用了 https 的协议，另外需要注意的是配置了 ca.cart 和 token 这两个文件，这两个文件是 Prometheus 的 Pod 启动后自动注入进来的，然后加上 <code>__metrics_path__</code> 的访问路径 <code>/metrics/cadvisor</code>，现在同样更新下配置，然后查看 Targets 路径：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/kke3a3.png" alt="prometheus webui cadvisor"></p>
<h2 id="指标查询"><a href="#指标查询" class="headerlink" title="指标查询"></a>指标查询</h2><p>我们可以切换到 Graph 路径下面查询容器相关数据，比如我们这里来查询集群中所有 Pod 的 CPU 使用情况，kubelet 中的 cAdvisor 采集的指标和含义，可以查看 <a target="_blank" rel="noopener" href="https://github.com/google/cadvisor/blob/master/docs/storage/prometheus.md">Monitoring cAdvisor with Prometheus</a> 说明，比如其中有一项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_cpu_usage_seconds_total   Counter     Cumulative cpu time consumed    seconds</span><br></pre></td></tr></table></figure>

<p><code>container_cpu_usage_seconds_total</code> 是容器累计使用的 CPU 时间，用它除以 CPU 的总时间，就可以得到容器的 CPU 使用率了。</p>
<p>首先计算容器的 CPU 占用时间，由于节点上的 CPU 有多个，所以需要将容器在每个 CPU 上占用的时间累加起来，Pod 在 1m 内累积使用的 CPU 时间为：(根据 pod 和 namespace 进行分组查询)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(rate(container_cpu_usage_seconds_total&#123;image!=&quot;&quot;,pod!=&quot;&quot;&#125;[1m])) by (namespace, pod)</span><br></pre></td></tr></table></figure>

<p>然后计算 CPU 的总时间，这里的 CPU 数量是容器分配到的 CPU 数量，<code>container_spec_cpu_quota</code> 这个指标就是容器的 CPU 配额，它的值是容器指定的 <code>CPU 个数 * 100000</code>，所以 Pod 在 1s 内 CPU 的总时间为：Pod 的 CPU 核数 <code>*</code> 1s：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(container_spec_cpu_quota&#123;image!=&quot;&quot;, pod!=&quot;&quot;&#125;) by(namespace, pod) / 100000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于 <code>container_spec_cpu_quota</code> 是容器的 CPU 配额，所以只有配置了 <code>resource-limit</code> CPU 的 Pod 才可以获得该指标数据。</p>
</blockquote>
<p>将上面这两个语句的结果相除，就得到了容器的 CPU 使用率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(sum(rate(container_cpu_usage_seconds_total&#123;image!=&quot;&quot;,pod!=&quot;&quot;&#125;[1m])) by (namespace, pod))</span><br><span class="line">/</span><br><span class="line">(sum(container_spec_cpu_quota&#123;image!=&quot;&quot;, pod!=&quot;&quot;&#125;) by(namespace, pod) / 100000) * 100</span><br></pre></td></tr></table></figure>

<p>在 promethues 里面执行上面的 promQL 语句可以得到下面的结果：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/39v28n.png" alt="prometheus cadvisor cpu rate"></p>
<p>Pod 内存使用率的计算就简单多了，不过我们也要想了解几个和 Pod 内存使用率相关的指标：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20211222144547.png" alt="Pod内存相关指标"></p>
<p>整体来说 <code>container_memory_max_usage_bytes &gt; container_memory_usage_bytes &gt;= container_memory_working_set_bytes &gt; container_memory_rss</code>，从上面的指标描述来看似乎 <code>container_memory_usage_bytes</code> 指标可以更容易用来跟踪内存使用率，但是该指标还包括在内存压力下可能被驱逐的缓存（比如文件系统缓存），更好的指标是使用 <code>container_memory_working_set_bytes</code>，因为 kubelet 也是根据该指标来判断是否 OOM 的，所以用 working set 指标来评估内存使用率更加科学，对应的 PromQL 语句如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(container_memory_working_set_bytes&#123;image!=&quot;&quot;&#125;) by(namespace, pod) / sum(container_spec_memory_limit_bytes&#123;image!=&quot;&quot;&#125;) by(namespace, pod) * 100 != +inf</span><br></pre></td></tr></table></figure>

<p>在 Promethues 里面执行上面的 promQL 语句可以得到下面的结果：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/wwca5z.png" alt="prometheus cadvisor memory rate"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/" class="post-title-link" itemprop="url">局部变量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:14:35" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>您好！这是一个非常核心且有深度的 Go 语言问题。作为后端开发专家，我来为您详细解析。</p>
<p><strong>简短的答案是：Go 语言中的局部变量分配在哪里（栈或堆），不是由开发者决定的，而是由 Go 编译器在编译时通过“逃逸分析”（Escape Analysis）来决定的。</strong></p>
<p>开发者编写代码时，可以认为所有局部变量都优先分配在<strong>栈（Stack）</strong>上。只有在编译器证明一个变量的生命周期需要在其声明的函数返回后依然有效时，这个变量才会“逃逸”（escape）到<strong>堆（Heap）</strong>上。</p>
<hr>
<h3 id="1-为什么优先分配在栈上？"><a href="#1-为什么优先分配在栈上？" class="headerlink" title="1. 为什么优先分配在栈上？"></a>1. 为什么优先分配在栈上？</h3><p>栈是为函数调用而设计的一种内存区域，具有以下显著优势：</p>
<ul>
<li><strong>极高的分配和回收效率：</strong> 栈内存的分配和回收仅仅是移动栈指针（SP），这是一个非常快速的 CPU 指令。当函数调用时，栈帧（stack frame）被压入栈；函数返回时，栈帧被弹出。整个过程无需复杂的内存管理和垃圾回收（GC）介入。</li>
<li><strong>低 GC 压力：</strong> 因为栈上的内存在函数返回时自动回收，所以垃圾回收器不需要扫描栈上的对象，这大大减轻了 GC 的负担，提升了程序性能。</li>
<li><strong>更好的缓存局部性：</strong> 栈内存通常是连续的，更容易被 CPU 缓存命中，从而提高访问速度。</li>
</ul>
<h3 id="2-什么是逃逸分析（Escape-Analysis）？"><a href="#2-什么是逃逸分析（Escape-Analysis）？" class="headerlink" title="2. 什么是逃逸分析（Escape Analysis）？"></a>2. 什么是逃逸分析（Escape Analysis）？</h3><p>逃逸分析是 Go 编译器在编译期间进行的一种静态代码分析。它的目标是确定一个变量的内存地址是否可能会被传递到其声明函数之外。如果一个变量的引用（地址）“逃逸”出了它的函数作用域，那么这个变量就不能安全地分配在栈上，因为它所在的栈帧在函数返回后就会被销毁。</p>
<p><strong>如果变量不逃逸，它就会被分配在栈上。如果变量逃逸了，它就会被分配在堆上。</strong></p>
<h3 id="3-变量在哪些情况下会逃逸到堆上？"><a href="#3-变量在哪些情况下会逃逸到堆上？" class="headerlink" title="3. 变量在哪些情况下会逃逸到堆上？"></a>3. 变量在哪些情况下会逃逸到堆上？</h3><p>以下是一些常见的导致局部变量逃逸到堆上的场景：</p>
<h4 id="场景一：返回局部变量的指针"><a href="#场景一：返回局部变量的指针" class="headerlink" title="场景一：返回局部变量的指针"></a>场景一：返回局部变量的指针</h4><p>这是最典型的逃逸场景。如果函数返回一个指向其内部局部变量的指针，那么这个变量必须在堆上分配，否则函数返回后，该指针将指向一个无效的内存区域。</p>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// User 在 createAdmin 函数内被创建，但其指针被返回</span></span><br><span class="line"><span class="comment">// 它的生命周期必须超过 createAdmin 函数，所以它会逃逸到堆上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAdmin</span><span class="params">()</span></span> *User &#123;</span><br><span class="line">	admin := User&#123;Name: <span class="string">&quot;Admin&quot;</span>, Age: <span class="number">99</span>&#125; <span class="comment">// &quot;admin&quot; escapes to heap</span></span><br><span class="line">	<span class="keyword">return</span> &amp;admin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_ = createAdmin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景二：被闭包引用"><a href="#场景二：被闭包引用" class="headerlink" title="场景二：被闭包引用"></a>场景二：被闭包引用</h4><p>如果一个局部变量被一个异步执行的 goroutine（通过闭包）或者一个延迟执行的 <code>defer</code> 语句引用，并且该 goroutine 或 <code>defer</code> 的生命周期可能超过当前函数，那么该变量会逃逸。</p>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 变量 s 在 main 函数中定义</span></span><br><span class="line">	s := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这个 goroutine 会在 main 函数结束后才可能执行完毕</span></span><br><span class="line">	<span class="comment">// 为了保证 goroutine 能安全访问 s，s 会逃逸到堆上</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// s escapes to heap</span></span><br><span class="line">		<span class="built_in">println</span>(s)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second) <span class="comment">// 等待 goroutine 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景三：被切片（Slice）或映射（Map）间接引用"><a href="#场景三：被切片（Slice）或映射（Map）间接引用" class="headerlink" title="场景三：被切片（Slice）或映射（Map）间接引用"></a>场景三：被切片（Slice）或映射（Map）间接引用</h4><p>如果一个局部变量的指针被存储在切片或映射中，而这个切片或映射本身可能会逃逸，那么这个局部变量也会逃逸。</p>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// a 和 b 是局部变量</span></span><br><span class="line">	a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将 a 和 b 的指针存入 slice 中</span></span><br><span class="line">    <span class="comment">// 由于 slice 的底层数组可能会在堆上分配，或者 slice 本身会逃逸</span></span><br><span class="line">    <span class="comment">// 编译器通常会保守地将 a 和 b 移到堆上</span></span><br><span class="line">	_ = []*<span class="type">int</span>&#123;&amp;a, &amp;b&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景四：发送指针到通道（Channel）"><a href="#场景四：发送指针到通道（Channel）" class="headerlink" title="场景四：发送指针到通道（Channel）"></a>场景四：发送指针到通道（Channel）</h4><p>将一个局部变量的指针发送到一个通道中，因为接收方可能在任何时间、任何 goroutine 中接收这个指针，所以该变量必须存活在堆上。</p>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> *<span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	</span><br><span class="line">	val := <span class="number">10</span> <span class="comment">// &quot;val&quot; 将被发送到通道</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 当 &amp;val 被发送到通道后，它的生命周期就不可预测了</span></span><br><span class="line">	<span class="comment">// 因此它必须逃逸到堆上</span></span><br><span class="line">	ch &lt;- &amp;val <span class="comment">// &amp;val escapes to heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景五：动态大小的变量"><a href="#场景五：动态大小的变量" class="headerlink" title="场景五：动态大小的变量"></a>场景五：动态大小的变量</h4><p>如果一个变量的大小在编译时无法确定（例如，一个切片的底层数组大小依赖于运行时输入），编译器通常会选择在堆上分配它，以避免栈溢出的风险。</p>
<h3 id="4-如何查看变量是否逃逸？"><a href="#4-如何查看变量是否逃逸？" class="headerlink" title="4. 如何查看变量是否逃逸？"></a>4. 如何查看变量是否逃逸？</h3><p>你可以使用 Go 的编译器标志 <code>-gcflags=&quot;-m&quot;</code> 来查看逃逸分析的结果。</p>
<p><strong>使用方法：</strong><br>在你的项目目录下运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=<span class="string">&quot;-m&quot;</span> .</span><br></pre></td></tr></table></figure>
<p>或针对单个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags=<span class="string">&quot;-m&quot;</span> your_file.go</span><br></pre></td></tr></table></figure>

<p><strong>示例分析：</strong><br>对于上面的<strong>场景一</strong>代码，你会看到类似这样的输出：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># command-<span class="type">line</span>-arguments</span><br><span class="line">./main.go:<span class="number">6</span>:<span class="number">9</span>: &amp;<span class="keyword">admin</span> escapes <span class="keyword">to</span> heap        // 明确指出 &amp;<span class="keyword">admin</span> 逃逸了</span><br><span class="line">./main.go:<span class="number">5</span>:<span class="number">2</span>: moved <span class="keyword">to</span> heap: <span class="keyword">admin</span>         // 编译器决定将 <span class="keyword">admin</span> 移动到堆上</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">何时分配</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>栈（Stack）</strong></td>
<td align="left"><strong>默认情况</strong>。当编译器通过<strong>逃逸分析</strong>确定一个变量的生命周期不会超过其声明的函数时。</td>
</tr>
<tr>
<td align="left"><strong>堆（Heap）</strong></td>
<td align="left">当编译器发现一个变量的引用被传递到了函数作用域之外（即<strong>变量逃逸</strong>），导致其需要在函数返回后依然存活时。</td>
</tr>
</tbody></table>
<p>这种自动化的内存分配策略是 Go 语言的一大优势。它既能获得栈分配的高性能，又能保证堆分配的内存安全，而开发者无需像在 C&#x2F;C++ 中那样手动管理内存。作为 Go 开发者，理解逃逸分析的原理有助于写出更高性能、更低 GC 压力的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">常见的消息队列模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:10:11" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>两种主要的模型：<strong>点对点模式（Point-to-Point, PTP）</strong> 和 <strong>发布&#x2F;订阅模式（Publish&#x2F;Subscribe, Pub&#x2F;Sub）</strong>，并介绍现代消息队列是如何融合它们，以及一些重要的扩展模型。</p>
<hr>
<h3 id="一、-点对点模式（Point-to-Point-PTP）-队列模型（Queue-Model）"><a href="#一、-点对点模式（Point-to-Point-PTP）-队列模型（Queue-Model）" class="headerlink" title="一、 点对点模式（Point-to-Point, PTP） &#x2F; 队列模型（Queue Model）"></a>一、 点对点模式（Point-to-Point, PTP） &#x2F; 队列模型（Queue Model）</h3><h4 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h4><p>点对点模式基于队列（Queue）的概念。生产者将消息发送到一个特定的队列，消费者从该队列中接收消息。</p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul>
<li><strong>一对一消费：</strong> 一条消息只能被一个消费者接收。当有多个消费者订阅同一个队列时，它们之间是<strong>竞争关系</strong>，消息会由这些消费者中的一个进行消费（通常是轮询、随机或其它负载均衡策略）。</li>
<li><strong>消息删除：</strong> 消息一旦被消费者消费并确认（Ack），就会从队列中移除，不会再被其他消费者接收。</li>
<li><strong>负载均衡：</strong> 适用于需要将任务分发给多个处理者并行处理的场景，每个任务只处理一次。</li>
<li><strong>持久性：</strong> 队列通常会持久化消息，即使消费者宕机，消息也不会丢失，待消费者恢复后仍可继续消费。</li>
</ul>
<h4 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h4><ul>
<li><strong>异步任务处理：</strong> 例如，订单系统将创建订单的任务发送到队列，支付服务或订单处理服务从队列中取走任务并处理。</li>
<li><strong>工作流：</strong> 多个步骤串联处理，每个步骤由一个特定的消费者完成。</li>
<li><strong>流量削峰：</strong> 高并发场景下，将瞬时大量请求放入队列，后端服务按自身处理能力从队列中拉取请求。</li>
</ul>
<h4 id="4-优点"><a href="#4-优点" class="headerlink" title="4. 优点"></a>4. 优点</h4><ul>
<li>简单直观，易于理解和实现。</li>
<li>保证每条消息只被消费一次。</li>
<li>适用于处理需要负载均衡的场景。</li>
</ul>
<h4 id="5-缺点"><a href="#5-缺点" class="headerlink" title="5. 缺点"></a>5. 缺点</h4><ul>
<li>不适合广播消息，因为消息一旦被消费其他消费者就无法收到。</li>
</ul>
<hr>
<h3 id="二、-发布-订阅模式（Publish-Subscribe-Pub-Sub）-主题模型（Topic-Model）"><a href="#二、-发布-订阅模式（Publish-Subscribe-Pub-Sub）-主题模型（Topic-Model）" class="headerlink" title="二、 发布&#x2F;订阅模式（Publish&#x2F;Subscribe, Pub&#x2F;Sub） &#x2F; 主题模型（Topic Model）"></a>二、 发布&#x2F;订阅模式（Publish&#x2F;Subscribe, Pub&#x2F;Sub） &#x2F; 主题模型（Topic Model）</h3><h4 id="1-核心思想-1"><a href="#1-核心思想-1" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h4><p>发布&#x2F;订阅模式基于主题（Topic）的概念。生产者将消息发布到一个特定的主题，所有订阅了这个主题的消费者都会接收到这条消息。</p>
<h4 id="2-特点-1"><a href="#2-特点-1" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul>
<li><strong>一对多消费：</strong> 一条消息可以被多个不同的消费者（订阅者）同时接收。</li>
<li><strong>消息广播：</strong> 适用于需要将一类消息通知给所有关注该类消息的服务或应用。</li>
<li><strong>持久性：</strong> 与队列类似，消息通常会持久化，确保订阅者在订阅后能接收到消息（即使在发布消息时消费者不在线）。</li>
<li><strong>松耦合：</strong> 生产者和订阅者之间高度解耦，生产者不需要知道谁在消费消息，订阅者也不需要知道消息由谁产生。</li>
</ul>
<h4 id="3-适用场景-1"><a href="#3-适用场景-1" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h4><ul>
<li><strong>事件通知：</strong> 例如，用户注册成功后，发送注册事件到“用户事件”主题，积分服务、营销服务、邮件服务等都可以订阅此主题并各自处理。</li>
<li><strong>日志收集：</strong> 各个服务将日志发布到“应用日志”主题，日志分析、监控、存储服务等可以订阅并处理。</li>
<li><strong>数据同步&#x2F;缓存更新：</strong> 数据库数据变更后发布事件，缓存服务订阅并更新缓存。</li>
</ul>
<h4 id="4-优点-1"><a href="#4-优点-1" class="headerlink" title="4. 优点"></a>4. 优点</h4><ul>
<li>强大的广播能力。</li>
<li>高度解耦，易于扩展新服务。</li>
<li>适用于事件驱动架构。</li>
</ul>
<h4 id="5-缺点-1"><a href="#5-缺点-1" class="headerlink" title="5. 缺点"></a>5. 缺点</h4><ul>
<li>消息可能会被多次复制和投递，对存储和网络带宽有一定压力。</li>
<li>需要复杂的过滤机制来避免无关消息的接收（如果消费者只关心主题中的一部分消息）。</li>
</ul>
<hr>
<h3 id="三、-现代消息队列的融合与演进：消费组（Consumer-Group）"><a href="#三、-现代消息队列的融合与演进：消费组（Consumer-Group）" class="headerlink" title="三、 现代消息队列的融合与演进：消费组（Consumer Group）"></a>三、 现代消息队列的融合与演进：消费组（Consumer Group）</h3><p>许多现代的消息队列（如 <strong>Apache Kafka</strong> 和 <strong>Apache RocketMQ</strong>）在实现上巧妙地融合了点对点和发布&#x2F;订阅两种模式的优点，尤其通过引入<strong>消费组（Consumer Group）</strong>的概念。</p>
<p>在这些 MQ 中，消息通常发布到<strong>主题（Topic）</strong>。</p>
<ul>
<li><strong>在同一个消费组内：</strong> 消息采取点对点模式。主题中的一条消息，只会投递给该消费组内的<strong>一个消费者实例</strong>。这实现了组内的负载均衡和避免重复消费，相当于在一个消费组内模拟了队列的语义。</li>
<li><strong>在不同的消费组之间：</strong> 消息采取发布&#x2F;订阅模式。主题中的一条消息会投递给<strong>每个不同的消费组</strong>。这实现了广播效果，每个消费组都可以独立地、完整地消费到所有消息。</li>
</ul>
<p><strong>示例：</strong><br>一个 <code>OrderTopic</code>，有订单创建消息：</p>
<ul>
<li><strong>消费组 A (订单处理服务)：</strong> 内有 3 个消费者实例。消息 <code>Order_1</code> 会被 A 组的某个实例消费，<code>Order_2</code> 被 A 组的另一个实例消费，等等。</li>
<li><strong>消费组 B (库存服务)：</strong> 内有 2 个消费者实例。消息 <code>Order_1</code> 和 <code>Order_2</code> 也分别被 B 组的某个实例消费。</li>
<li><strong>消费组 C (短信通知服务)：</strong> 内有 1 个消费者实例。消息 <code>Order_1</code> 和 <code>Order_2</code> 也分别被 C 组的该实例消费。</li>
</ul>
<p>这样，<code>OrderTopic</code> 的消息既可以被不同业务（A、B、C）独立消费（发布&#x2F;订阅），又能在每个业务内部进行并行处理和负载均衡（点对点）。</p>
<hr>
<h3 id="四、-其他重要的消息队列模型-特性"><a href="#四、-其他重要的消息队列模型-特性" class="headerlink" title="四、 其他重要的消息队列模型&#x2F;特性"></a>四、 其他重要的消息队列模型&#x2F;特性</h3><p>除了上述两种基本模型，现代消息队列还支持一些高级特性：</p>
<ol>
<li><strong>顺序消息（Ordered Messages）：</strong> 保证消息严格按照发送的顺序进行消费。这对于需要保证事件发生顺序的业务场景至关重要（例如，订单的状态流转：创建 -&gt; 支付 -&gt; 发货，必须顺序消费）。</li>
<li><strong>延时消息（Delayed Messages）：</strong> 生产者将消息发送到 MQ 后，不立即投递，而是等待指定的时间后才对消费者可见。常用于订单超时未支付自动取消、定时任务驱动等场景。</li>
<li><strong>事务消息（Transactional Messages）：</strong> 确保生产者发送消息与本地事务执行的原子性，解决分布式系统中的数据最终一致性问题（如我们之前讨论的 RocketMQ 事务消息）。</li>
<li><strong>消息过滤（Message Filtering）：</strong> 允许消费者只接收其感兴趣的消息。这可以通过主题标签（Tag）、SQL 表达式或消息属性实现。</li>
<li><strong>死信队列（Dead Letter Queue, DLQ）：</strong> 当消息无法被正常消费（例如，多次重试失败、格式错误等）时，将消息转移到死信队列，以便后续人工干预或分析。</li>
<li><strong>批量发送&#x2F;消费（Batch Sending&#x2F;Consumption）：</strong> 提高消息处理效率，减少网络开销。</li>
</ol>
<hr>
<p>总结来说，理解点对点和发布&#x2F;订阅这两种基础模型是掌握消息队列的关键。而现代 MQ 如 Kafka 和 RocketMQ 通过引入消费组的概念，完美地将这两种模型的优势结合起来，为构建高吞吐量、高可用、可扩展的分布式系统提供了强大的支持。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/22/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/24/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
