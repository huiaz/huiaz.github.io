<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hui&#39;s Blog">
<meta property="og:url" content="http://example.com/page/14/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="六一">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%20%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%20%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">TCP 的拥塞控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:07:02" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP 拥塞控制的目的在于<strong>防止过多的数据注入到网络中，避免或减轻网络的拥塞</strong>，从而提高网络利用率，同时保证主机间的有效通信。它不是为了防止发送方发送数据过快淹没接收方（那是流量控制），而是为了防止发送方发送数据过快淹没<strong>整个网络</strong>。</p>
<p>TCP 的拥塞控制主要包括以下四个核心算法（通常被称为<strong>拥塞控制的“四大家族”</strong>）：</p>
<ol>
<li><strong>慢启动 (Slow Start)</strong></li>
<li><strong>拥塞避免 (Congestion Avoidance)</strong></li>
<li><strong>快速重传 (Fast Retransmit)</strong></li>
<li><strong>快速恢复 (Fast Recovery)</strong></li>
</ol>
<p>这些算法协同工作，共同管理发送方的发送速率，即调整<strong>拥塞窗口 (cwnd)</strong> 的大小。</p>
<hr>
<h3 id="1-慢启动-Slow-Start"><a href="#1-慢启动-Slow-Start" class="headerlink" title="1. 慢启动 (Slow Start)"></a>1. 慢启动 (Slow Start)</h3><p><strong>目标：</strong> 在连接刚建立或长时间中断后，逐步探测网络的承载能力，快速找到一个合适的发送速率，避免一开始就对网络造成冲击。</p>
<p><strong>过程：</strong></p>
<ul>
<li><strong>初始状态：</strong> 连接建立时，拥塞窗口 (cwnd) 被初始化为一个较小的值（通常是 1-10 MSS，具体取决于操作系统和TCP版本，RFC 2581 最初建议 1 MSS，现在通常是 10 MSS）。</li>
<li><strong>指数增长：</strong> 发送方每收到一个**确认 (ACK)**，<code>cwnd</code> 的大小就增加一个 MSS（最大报文段大小）。这意味着在每个 RTT（往返时间）内，<code>cwnd</code> 会翻倍。</li>
<li><strong>退出条件：</strong> 当 <code>cwnd</code> 达到<strong>慢启动门限 (ssthresh)</strong> 时，慢启动阶段结束，进入拥塞避免阶段。<code>ssthresh</code> 的初始值通常非常大，或者与接收窗口大小相同。</li>
</ul>
<p><strong>特点：</strong> 窗口增长速度快，呈指数级。</p>
<hr>
<h3 id="2-拥塞避免-Congestion-Avoidance"><a href="#2-拥塞避免-Congestion-Avoidance" class="headerlink" title="2. 拥塞避免 (Congestion Avoidance)"></a>2. 拥塞避免 (Congestion Avoidance)</h3><p><strong>目标：</strong> 在探测到网络承载能力后，以更谨慎的方式逐步增加发送速率，避免再次引起拥塞。</p>
<p><strong>过程：</strong></p>
<ul>
<li><strong>线性增长：</strong> 当 <code>cwnd</code> 达到 <code>ssthresh</code> 后，<code>cwnd</code> 的增长方式从指数级变为线性级。发送方每收到<strong>一个 RTT 内的 ACK 集合</strong> (<code>cwnd</code> 个 ACK)，<code>cwnd</code> 才增加一个 MSS 大小。<ul>
<li>更精确地说：<code>cwnd = cwnd + MSS * (MSS / cwnd)</code>，或者 <code>cwnd = cwnd + 1/cwnd</code> MSS。这意味着只有当收到足够多的 ACK 确认后，<code>cwnd</code> 才会增加一个 MSS。</li>
</ul>
</li>
<li><strong>退出条件：</strong> 拥塞避免阶段会持续，直到发生丢包事件（无论是超时还是收到重复 ACK）。</li>
</ul>
<p><strong>特点：</strong> 窗口增长速度慢，呈线性级。这个阶段旨在平稳地利用网络带宽。</p>
<hr>
<h3 id="3-快速重传-Fast-Retransmit"><a href="#3-快速重传-Fast-Retransmit" class="headerlink" title="3. 快速重传 (Fast Retransmit)"></a>3. 快速重传 (Fast Retransmit)</h3><p><strong>目标：</strong> 在不等待超时的情况下，通过接收方发送的重复 ACK 提前发现丢包，并立即重传丢失的数据包，提高重传效率。</p>
<p><strong>过程：</strong></p>
<ul>
<li><strong>信号：</strong> 当发送方收到<strong>三个或更多的对同一个数据包的重复 ACK</strong> 时，就认为这个数据包已经丢失。</li>
<li><strong>操作：</strong><ol>
<li><strong>立即重传：</strong> 不等待定时器超时，而是立即重传丢失的报文段。</li>
<li><strong>调整 <code>ssthresh</code>：</strong> 将 <code>ssthresh</code> 设置为当前 <code>cwnd</code> 的一半。</li>
<li><strong>调整 <code>cwnd</code>：</strong> 将 <code>cwnd</code> 设置为 <code>ssthresh</code> 加上 3 个 MSS（这 3 个 MSS 是为了弥补已经收到的 3 个重复 ACK 确认了后续数据）。这个 <code>cwnd</code> 的值会将连接带入快速恢复状态。</li>
</ol>
</li>
</ul>
<p><strong>特点：</strong> 是一种基于快速反馈的丢包发现机制，比超时重传更快。</p>
<hr>
<h3 id="4-快速恢复-Fast-Recovery"><a href="#4-快速恢复-Fast-Recovery" class="headerlink" title="4. 快速恢复 (Fast Recovery)"></a>4. 快速恢复 (Fast Recovery)</h3><p><strong>目标：</strong> 与快速重传配合，在检测到少量丢包时，保持较高的发送速率，避免将 <code>cwnd</code> 降到 1 MSS，从而更快地恢复到拥塞避免状态。</p>
<p><strong>过程：</strong></p>
<ul>
<li><strong>进入条件：</strong> 当快速重传被触发后（即收到三个重复 ACK），TCP 会进入快速恢复阶段。</li>
<li><strong>临时增加 <code>cwnd</code>：</strong> 发送方每收到一个额外的重复 ACK，<code>cwnd</code> 就会再增加一个 MSS。这是因为每个重复 ACK 都表明一个数据包离开了网络，从而释放了网络中的一个缓冲空间。</li>
<li><strong>发送新数据：</strong> 在快速恢复期间，发送方可以发送新的数据（如果拥塞窗口和接收窗口允许）。</li>
<li><strong>退出条件：</strong><ul>
<li><strong>收到对丢失报文段的 ACK：</strong> 当发送方收到对最初触发快速重传的那个丢失报文段的 ACK 时，表明该数据已经成功重传并被接收方确认。此时，拥塞窗口 <code>cwnd</code> 会被设置回 <code>ssthresh</code> 的值，然后重新进入<strong>拥塞避免</strong>阶段。</li>
<li><strong>超时：</strong> 如果在快速恢复阶段发生了超时（表明情况比之前想的更糟，可能有更多丢包），则 TCP 会回退到慢启动阶段，将 <code>ssthresh</code> 设置为当前 <code>cwnd</code> 的一半，<code>cwnd</code> 设置为 1 MSS。</li>
</ul>
</li>
</ul>
<p><strong>特点：</strong> 在丢包不严重的情况下，保持较高的 <code>cwnd</code>，避免剧烈地降低发送速率。</p>
<hr>
<h3 id="拥塞控制状态机概览："><a href="#拥塞控制状态机概览：" class="headerlink" title="拥塞控制状态机概览："></a>拥塞控制状态机概览：</h3><table>
<thead>
<tr>
<th align="left">事件触发</th>
<th align="left"><code>ssthresh</code></th>
<th align="left"><code>cwnd</code></th>
<th align="left">进入状态</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">连接建立</td>
<td align="left">大值&#x2F;Max</td>
<td align="left">1 MSS</td>
<td align="left">慢启动</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">收到 ACK</td>
<td align="left"></td>
<td align="left"><code>+1 MSS</code></td>
<td align="left">慢启动</td>
<td align="left">每次收到一个 ACK</td>
</tr>
<tr>
<td align="left"><code>cwnd &gt;= ssthresh</code></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">拥塞避免</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">收到 ACK</td>
<td align="left"></td>
<td align="left"><code>+1/cwnd MSS</code></td>
<td align="left">拥塞避免</td>
<td align="left">每个 RTT 增加 1 MSS</td>
</tr>
<tr>
<td align="left"><strong>3个重复 ACK</strong></td>
<td align="left"><code>cwnd / 2</code></td>
<td align="left"><code>ssthresh + 3 MSS</code></td>
<td align="left"><strong>快速恢复</strong></td>
<td align="left"><em>重要</em>，表示轻微丢包</td>
</tr>
<tr>
<td align="left"><strong>超时</strong></td>
<td align="left"><code>cwnd / 2</code></td>
<td align="left"><code>1 MSS</code></td>
<td align="left"><strong>慢启动</strong></td>
<td align="left"><em>重要</em>，表示严重丢包（网络状况恶化）</td>
</tr>
<tr>
<td align="left">快速恢复中收到新 ACK</td>
<td align="left"></td>
<td align="left"><code>ssthresh</code></td>
<td align="left">拥塞避免</td>
<td align="left">恢复完成，继续线性增长</td>
</tr>
<tr>
<td align="left">快速恢复中收到重复 ACK</td>
<td align="left"></td>
<td align="left"><code>+1 MSS</code></td>
<td align="left">快速恢复</td>
<td align="left">继续补偿在途的确认</td>
</tr>
</tbody></table>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>TCP 的拥塞控制是一个动态调整发送速率的过程，旨在高效利用网络资源的同时避免网络拥塞。它通过慢启动、拥塞避免、快速重传和快速恢复这四个核心算法，根据网络反馈（ACK、重复 ACK、超时）来实时调整拥塞窗口 <code>cwnd</code>，从而达到平衡的目标。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">TCP 滑动窗口的作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:07:07" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP 滑动窗口（Sliding Window）是 TCP 协议中一个核心且关键的机制，它主要实现了以下几个重要的作用：</p>
<ol>
<li><p><strong>实现流量控制 (Flow Control):</strong></p>
<ul>
<li><strong>问题：</strong> 发送方发送数据的速度如果远超接收方的处理速度，接收方的缓冲区最终会被填满，导致数据溢出丢失。</li>
<li><strong>解决方案：</strong> 接收方会通过 TCP 报文段中的<strong>窗口大小字段</strong>（Window size）告诉发送方，其当前还有多少接收缓冲区是可用的。发送方收到的窗口大小就是它当前可以发送的最大数据量，它绝对不能发送超过这个窗口大小的数据。</li>
<li><strong>动态调整：</strong> 随着接收方处理数据的速度和可用缓冲区空间的变化，窗口大小会动态调整。如果接收方处理得慢，窗口就会变小；如果处理得快，窗口就会变大。这确保了发送方的发送速率能与接收方的处理速率相匹配，避免接收方缓冲区溢出。</li>
</ul>
</li>
<li><p><strong>实现可靠传输 (Reliable Transmission):</strong></p>
<ul>
<li><strong>问题：</strong> 网络传输可能导致数据包丢失、乱序或错误。TCP 需要确保所有数据在发送方和接收方之间都能完整、按序地到达。</li>
<li><strong>解决方案：</strong> 滑动窗口机制与确认（ACK）和重传机制紧密结合。<ul>
<li><strong>发送窗口：</strong> 发送窗口维护着一系列允许发送的、尚未得到确认的数据段的序列号范围。只有在窗口内的数据才能被发送出去。</li>
<li><strong>接收窗口：</strong> 接收窗口维护着一系列允许接收的、期望到达的数据段的序列号范围。接收方只会接受窗口内的数据。</li>
<li><strong>累积确认 (Cumulative ACK):</strong> 接收方发送的 ACK 报文会指明它期望收到的下一个字节的序列号。这意味着这个序列号之前的所有数据都已经按序收到并确认。</li>
<li><strong>超时重传&#x2F;快速重传&#x2F;SACK：</strong> 如果发送方在指定时间内没有收到对某个数据段的确认，它就会认为这个数据段已经丢失（或 SACK 明确指出），并将其重传。当接收方收到乱序数据时，它会发送重复 ACK，配合快速重传和 SACK 机制，可以更高效地发现和重传丢失的数据。</li>
</ul>
</li>
<li><strong>滑动：</strong> 当发送方收到对数据段的 ACK 后，发送窗口就会向前滑动，允许发送新的数据。当接收方将数据交付给应用程序后，接收窗口也会向前滑动，告知发送方可以发送更多数据。</li>
</ul>
</li>
<li><p><strong>提高传输效率 (Efficiency&#x2F;Pipelining):</strong></p>
<ul>
<li><strong>问题：</strong> 如果每次发送一个数据包，就必须等待它的 ACK 才能发送下一个（停止-等待协议），那么网络延迟（RTT）会严重限制吞吐量，尤其是在高延迟网络中。</li>
<li><strong>解决方案：</strong> 滑动窗口允许发送方在收到确认之前，连续发送多个数据包。这就像一个“流水线”或“管道”：<ul>
<li><strong>窗口大小 &gt; 1：</strong> 当窗口大小大于 1 (即 <code>发送窗口 &gt; 1 MSS</code>) 时，发送方可以一次性发送多个报文段，填充整个网络传输路径上的“在途”数据。</li>
<li><strong>充分利用带宽：</strong> 这样可以充分利用网络带宽，即使 RTT 很高，只要接收方有足够的缓冲区和处理能力，发送方也能持续发送数据，从而显著提高吞吐量。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="总结三个核心作用："><a href="#总结三个核心作用：" class="headerlink" title="总结三个核心作用："></a>总结三个核心作用：</h3><ul>
<li><strong>流量控制 (Flow Control)：</strong> 通过接收方的通告窗口，防止发送方淹没接收方，保证接收方有能力处理接收到的数据。</li>
<li><strong>可靠传输 (Reliable Transmission)：</strong> 结合确认、重传机制，确保所有数据都能可靠、按序地从发送方到达接收方。</li>
<li><strong>提高效率 (Pipelining)：</strong> 允许发送方在等待确认时持续发送数据，从而充分利用网络带宽，提高数据传输的吞吐量。</li>
</ul>
<p>TCP 的滑动窗口机制是其高效率和可靠性的基石，它巧妙地平衡了流量控制、可靠性和传输效率之间的关系。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%20%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%20%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F/" class="post-title-link" itemprop="url">TCP 的三次握手？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:06:58" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img data-src="https://mudutestmenu.mudu.tv/upload/dn1c70.png" alt="image-20250717154315630"></p>
<p>好的，我们来详细解释 TCP 的三次握手（Three-Way Handshake）过程。这是 TCP 协议建立连接的关键步骤，确保客户端和服务器都准备好进行数据传输。</p>
<h3 id="1-TCP-三次握手的目的"><a href="#1-TCP-三次握手的目的" class="headerlink" title="1. TCP 三次握手的目的"></a>1. TCP 三次握手的目的</h3><p>三次握手的核心目的是：</p>
<ol>
<li><strong>确认双方的发送和接收能力正常：</strong> 确保客户端能够发送数据，也能接收数据；服务器也能发送数据，也能接收数据。</li>
<li><strong>为会话同步初始序列号 (ISN)：</strong> TCP 会为发送的每一个字节数据编号。为了实现可靠传输和乱序重排，需要一个起始的序列号。双方需要知道对方的起始序列号，并在此基础上进行数据传输的确认和管理。</li>
<li><strong>防止已失效的连接请求报文段（SYN）突然又传送到了服务器，从而产生错误：</strong> 后面会详细解释这一点。</li>
</ol>
<h3 id="2-TCP-三次握手的过程"><a href="#2-TCP-三次握手的过程" class="headerlink" title="2. TCP 三次握手的过程"></a>2. TCP 三次握手的过程</h3><p>假设客户端是发起连接的一方，服务器是等待连接的一方。</p>
<h4 id="第一次握手：客户端-服务器-SYN"><a href="#第一次握手：客户端-服务器-SYN" class="headerlink" title="第一次握手：客户端 -&gt; 服务器 (SYN)"></a>第一次握手：客户端 -&gt; 服务器 (SYN)</h4><ul>
<li><strong>客户端发送：</strong><ul>
<li><strong>SYN (Synchronize) 标志位设置为 1：</strong> 表示这是一个连接请求报文。</li>
<li><strong>seq (Sequence Number) &#x3D; 客户端的初始序列号 (client_ISN)：</strong> 客户端随机选择一个初始序列号。</li>
<li><strong>MSS (Maximum Segment Size) 选项：</strong> 客户端告知服务器它能接收的最大段大小。</li>
</ul>
</li>
<li><strong>目的：</strong> 客户端告诉服务器：“我想要和你建立连接，我的初始序列号是 <code>client_ISN</code>。”</li>
</ul>
<h4 id="第二次握手：服务器-客户端-SYN-ACK"><a href="#第二次握手：服务器-客户端-SYN-ACK" class="headerlink" title="第二次握手：服务器 -&gt; 客户端 (SYN + ACK)"></a>第二次握手：服务器 -&gt; 客户端 (SYN + ACK)</h4><ul>
<li><strong>服务器接收：</strong> 收到客户端的 SYN 报文后，服务器确认收到。</li>
<li><strong>服务器发送：</strong><ul>
<li><strong>SYN (Synchronize) 标志位设置为 1：</strong> 表示这是一个连接请求回复报文，也表示服务器同意建立连接并请求客户端确认自己的序列号。</li>
<li><strong>ACK (Acknowledgement) 标志位设置为 1：</strong> 表示确认报文。</li>
<li><strong>ack (Acknowledgement Number) &#x3D; <code>client_ISN + 1</code>：</strong> 服务器确认已经收到了客户端的 <code>client_ISN</code>，并预期客户端下一个发送的字节序列号是 <code>client_ISN + 1</code>。</li>
<li><strong>seq (Sequence Number) &#x3D; 服务器的初始序列号 (server_ISN)：</strong> 服务器也随机选择一个初始序列号。</li>
<li><strong>MSS 选项：</strong> 服务器告知客户端它能接收的最大段大小。</li>
</ul>
</li>
<li><strong>目的：</strong> 服务器告诉客户端：“我收到了你的连接请求（并确认你的 <code>client_ISN</code>），我同意建立连接，我的初始序列号是 <code>server_ISN</code>，请你确认。”</li>
</ul>
<h4 id="第三次握手：客户端-服务器-ACK"><a href="#第三次握手：客户端-服务器-ACK" class="headerlink" title="第三次握手：客户端 -&gt; 服务器 (ACK)"></a>第三次握手：客户端 -&gt; 服务器 (ACK)</h4><ul>
<li><strong>客户端接收：</strong> 收到服务器的 SYN + ACK 报文后，客户端确认收到。</li>
<li><strong>客户端发送：</strong><ul>
<li><strong>ACK (Acknowledgement) 标志位设置为 1：</strong> 表示确认报文。</li>
<li><strong>ack (Acknowledgement Number) &#x3D; <code>server_ISN + 1</code>：</strong> 客户端确认收到了服务器的 <code>server_ISN</code>，并预期服务器下一个发送的字节序列号是 <code>server_ISN + 1</code>。</li>
<li><strong>seq (Sequence Number) &#x3D; <code>client_ISN + 1</code>：</strong> 这是客户端在向服务器发送<strong>数据</strong>时将使用的序列号。此时报文中不携带数据，所以序列号与第一次握手的 <code>client_ISN</code> 相关。</li>
</ul>
</li>
<li><strong>目的：</strong> 客户端告诉服务器：“我收到了你的确认和同意建立连接的回复（并确认你的 <code>server_ISN</code>），好的，连接已建立，我们可以开始通信了。”</li>
</ul>
<p><strong>至此，三次握手完成，TCP 连接建立成功。双方都可以开始发送和接收数据。</strong></p>
<hr>
<h3 id="3-每个步骤确认的能力："><a href="#3-每个步骤确认的能力：" class="headerlink" title="3. 每个步骤确认的能力："></a>3. 每个步骤确认的能力：</h3><ul>
<li><strong>第一次握手 (SYN)<strong>：客户端发出 SYN，服务器收到。服务器得知：客户端的</strong>发送能力</strong>正常（它能发送 SYN），客户端的<strong>接收能力</strong>可能正常（它能收到服务器的 SYN+ACK）。</li>
<li><strong>第二次握手 (SYN+ACK)<strong>：服务器发出 SYN+ACK，客户端收到。客户端得知：服务器的</strong>发送能力</strong>正常（它能发送 SYN+ACK），服务器的<strong>接收能力</strong>正常（它能收到客户端的 SYN）。</li>
<li><strong>第三次握手 (ACK)<strong>：客户端发出 ACK，服务器收到。服务器得知：客户端的</strong>接收能力</strong>正常（它能收到服务器的 SYN+ACK 并发出 ACK），客户端的<strong>发送能力</strong>正常（它能发送 ACK）。</li>
</ul>
<p>通过这三个步骤，客户端和服务器都确认了对方的发送和接收能力是正常的。</p>
<h3 id="4-为什么是“三”次？而不是两次或四次？"><a href="#4-为什么是“三”次？而不是两次或四次？" class="headerlink" title="4. 为什么是“三”次？而不是两次或四次？"></a>4. 为什么是“三”次？而不是两次或四次？</h3><h4 id="为何不能是“两次握手”？"><a href="#为何不能是“两次握手”？" class="headerlink" title="为何不能是“两次握手”？"></a>为何不能是“两次握手”？</h4><p>如果只有两次握手，即：</p>
<ol>
<li>客户端 -&gt; 服务器 (SYN, seq&#x3D;client_ISN)</li>
<li>服务器 -&gt; 客户端 (SYN+ACK, seq&#x3D;server_ISN, ack&#x3D;client_ISN+1)</li>
</ol>
<p>此时，客户端知道服务器能收发，自己也能收发。<strong>但服务器不知道自己的 ACK (第二次握手) 客户端是否收到，也不知道客户端的接收能力是否正常。</strong></p>
<p><strong>更重要的是，无法防止“已失效的连接请求报文段”：</strong><br>假设在网络中某个时刻，客户端发送了一个连接请求 SYN 报文（报文一），但因为网络延迟，这个报文在网络上滞留了很长时间。客户端等不及，重传了另一个 SYN 报文（报文二），并成功建立了连接，数据传输完毕后又断开了连接。</p>
<p>如果只有两次握手：</p>
<ul>
<li><strong>第一次发送 (报文一)：</strong> 客户端 SYN</li>
<li><strong>一段时间后 (报文一抵达服务器)：</strong> 服务器接收到报文一，认为是新的连接请求，立即响应 SYN+ACK。此时客户端可能已经关闭了之前的连接，或者根本不期望这个报文。</li>
<li>如果服务器响应 SYN+ACK 后，就认为连接建立成功，并开始等待客户端数据。而客户端根本不会发送数据，因为它没有发起这个连接，或者已经关闭了。这会导致服务器一直等待，浪费资源。</li>
</ul>
<p><strong>三次握手如何解决？</strong><br>在三次握手中，服务器收到旧的 SYN 报文（报文一）并发送 SYN+ACK 后，它会等待客户端的第三次 ACK。如果客户端没有发送过这个 SYN（或者已经关闭了），它就不会发出第三次 ACK。服务器在等待超时后，会认为连接建立失败，从而关闭连接。这样就避免了服务器资源的浪费。<strong>第三次握手是为了防止“历史连接”的 SYN 报文对服务器造成资源浪费。</strong></p>
<h4 id="为何不需要“四次握手”？"><a href="#为何不需要“四次握手”？" class="headerlink" title="为何不需要“四次握手”？"></a>为何不需要“四次握手”？</h4><p>三次握手已经足以确认双方的发送和接收能力，并同步初始序列号。第四次握手没有新增必要的确认或信息交换。<br>在第二次握手时，服务器可以将 SYN 和 ACK（对客户端 SYN 的确认）合并在一个报文段中发送。这称为捎带确认 (Piggybacking ACK)。因为服务器在接收到客户端的 SYN 时，它也需要向客户端发送自己的 SYN 请求建立连接。将这两者合二为一，既节省了报文数量，又提高了效率。<br><strong>简洁就是效率。</strong></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>TCP 三次握手是一个精巧的设计，它在效率和可靠性之间取得了很好的平衡。它的主要目标是确保双方都已准备就绪，并同步起始序列号，同时避免了不必要的资源占用，是 TCP 协议健壮性的基石。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/" class="post-title-link" itemprop="url">TCP 的粘包和拆包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:07:05" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好的，我们来深入讨论 TCP 的“粘包”和“拆包”问题。这两个概念是 TCP 编程中非常基础但又极其重要的，理解它们是正确处理 TCP 数据流的关键。</p>
<hr>
<h3 id="1-为什么会出现粘包和拆包？"><a href="#1-为什么会出现粘包和拆包？" class="headerlink" title="1. 为什么会出现粘包和拆包？"></a>1. 为什么会出现粘包和拆包？</h3><p><strong>根本原因在于 TCP 是一个“面向字节流”（Byte Stream）的协议，而不是“面向消息&#x2F;数据报”（Message&#x2F;Datagram Oriented）的协议。</strong></p>
<ul>
<li><p><strong>TCP 的特性：</strong></p>
<ul>
<li><strong>缓冲区：</strong> TCP 有自己的发送缓冲区和接收缓冲区。</li>
<li><strong>全双工：</strong> 数据可以双向独立传输。</li>
<li><strong>可靠的、按序的、无界限的字节流：</strong> TCP 传输的只是字节序列，它不关心你在应用层发送了多少次数据，每次发送了多少字节，或者每次发送的内容之间有什么逻辑边界。</li>
</ul>
</li>
<li><p><strong>发送方：</strong> 当应用程序调用 <code>send()</code> 或 <code>write()</code> 发送数据时，数据首先被复制到 TCP 的发送缓冲区。TCP 协议栈会根据自身的拥塞控制、流量控制以及发送缓冲区的大小，<strong>决定何时、发送多少数据到网络上</strong>。它可能会：</p>
<ul>
<li>将多次小的发送请求合并成一个大的 TCP 段发送（<strong>粘包</strong>）。</li>
<li>将一次大的发送请求拆分成多个小的 TCP 段发送（<strong>拆包</strong>）。</li>
<li>将不同应用程序的发送请求（如果它们使用同一个 TCP 连接）合并发送（<strong>粘包</strong>）。</li>
</ul>
</li>
<li><p><strong>接收方：</strong> 当 TCP 接收到数据时，它会将其放入接收缓冲区，并按照序列号重新排序，然后将其交付给应用程序。应用程序调用 <code>recv()</code> 或 <code>read()</code> 从这个缓冲区读取数据。一次 <code>recv()</code> 调用可能：</p>
<ul>
<li>读取到单个完整的数据包。</li>
<li>读取到多个粘连在一起的数据包（<strong>粘包</strong>）。</li>
<li>只读取到单个数据包的一部分内容（<strong>拆包</strong>）。</li>
<li>读取到单个数据包的开头一部分和前一个数据包的末尾一部分（<strong>粘包</strong>）。</li>
</ul>
</li>
</ul>
<p><strong>核心问题：TCP 不保留消息边界。</strong> 应用程序发送的“消息”概念在 TCP 层被抹平了，只剩下一串无结构的字节。</p>
<hr>
<h3 id="2-什么是粘包？"><a href="#2-什么是粘包？" class="headerlink" title="2. 什么是粘包？"></a>2. 什么是粘包？</h3><p><strong>粘包 (Nagle’s Algorithm and Delayed ACKs):</strong><br>当发送方发送的多个数据包很小，或者发送方和接收方的发送&#x2F;接收速度不匹配时，TCP 可能会将多个小的数据包封装成一个大的 TCP 段（Segment）进行发送。</p>
<p><strong>图示示例（发送方行为）：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用程序发送： <span class="selector-attr">[Msg A]</span> <span class="selector-attr">[Msg B]</span> <span class="selector-attr">[Msg C]</span></span><br><span class="line"></span><br><span class="line">TCP 发送缓冲区：</span><br><span class="line"><span class="selector-attr">[Msg A]</span> <span class="selector-attr">[Msg B]</span> <span class="selector-attr">[Msg C]</span></span><br><span class="line"></span><br><span class="line">TCP 实际发送（可能合并）：</span><br><span class="line"><span class="selector-attr">[            Msg A Msg B Msg C             ]</span>  -&gt; 一个TCP段</span><br></pre></td></tr></table></figure>

<p><strong>图示示例（接收方行为）：</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TCP 接收缓冲区：</span><br><span class="line"><span class="selector-attr">[Msg A_part1 Msg A_part2 Msg B_part1 Msg B_part2 Msg C]</span></span><br><span class="line"></span><br><span class="line">应用程序一次 <span class="built_in">recv</span>() 读取：</span><br><span class="line"><span class="selector-attr">[Msg A_part1 Msg A_part2]</span> -&gt; 第一次 <span class="built_in">recv</span>() (拆包)</span><br><span class="line"><span class="selector-attr">[Msg B_part1 Msg B_part2 Msg C]</span> -&gt; 第二次 <span class="built_in">recv</span>() (粘包 + 剩余部分)</span><br></pre></td></tr></table></figure>

<p><strong>触发粘包的常见情况：</strong></p>
<ol>
<li><strong>Nagle算法：</strong> TCP 默认会启用 Nagle 算法（通常用于优化网络利用率）。该算法会延迟发送小数据包，直到确认收到前一个数据包，或者缓冲器达到最大段大小（MSS），或者达到一定的延迟时间。这会导致多个小数据包被“粘”在一起发送。</li>
<li><strong>发送&#x2F;接收缓冲区：</strong> 如果发送端数据很小，而发送缓冲区还有空间，TCP 可能不会立即发送，而是等待更多数据“填满”缓冲区或达到一定条件再发送。同样，接收方可能一次性从缓冲区读取多个完整的逻辑消息。</li>
<li><strong>MSS（最大段大小）：</strong> TCP 会将大于 MSS 的数据拆分，但小于 MSS 的数据可能会被整合。</li>
</ol>
<hr>
<h3 id="3-什么是拆包？"><a href="#3-什么是拆包？" class="headerlink" title="3. 什么是拆包？"></a>3. 什么是拆包？</h3><p><strong>拆包 (Fragmentation):</strong><br>当发送的数据包比较大，或者一次发送的数据量超过了 TCP 的最大段大小（MSS），或者网络条件不佳时，TCP 可能会将一个大的数据包拆分成多个小的 TCP 段进行发送。</p>
<p><strong>图示示例（发送方行为）：</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">应用程序发送： [                  Big Msg A                         ]</span><br><span class="line"></span><br><span class="line">TCP 发送缓冲区：</span><br><span class="line">[                  Big Msg A                         ]</span><br><span class="line"></span><br><span class="line">TCP 实际发送（拆分）：</span><br><span class="line">[       B<span class="function"><span class="title">ig</span> Msg A part 1       ] -&gt;</span> 第<span class="number">1</span>个TCP段</span><br><span class="line">[       B<span class="function"><span class="title">ig</span> Msg A part 2       ] -&gt;</span> 第<span class="number">2</span>个TCP段</span><br><span class="line">[       B<span class="function"><span class="title">ig</span> Msg A part 3       ] -&gt;</span> 第<span class="number">3</span>个TCP段</span><br></pre></td></tr></table></figure>

<p><strong>图示示例（接收方行为）：</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCP 接收缓冲区：</span><br><span class="line"><span class="selector-attr">[Big Msg A part 1 Big Msg A part 2 Big Msg A part 3]</span></span><br><span class="line"></span><br><span class="line">应用程序一次 <span class="built_in">recv</span>() 读取：</span><br><span class="line"><span class="selector-attr">[Big Msg A part 1]</span> -&gt; 第一次 <span class="built_in">recv</span>()</span><br><span class="line"><span class="selector-attr">[Big Msg A part 2]</span> -&gt; 第二次 <span class="built_in">recv</span>()</span><br><span class="line"><span class="selector-attr">[Big Msg A part 3]</span> -&gt; 第三次 <span class="built_in">recv</span>()</span><br></pre></td></tr></table></figure>

<p><strong>触发拆包的常见情况：</strong></p>
<ol>
<li><strong>MSS（最大段大小）：</strong> 这是最常见的原因。TCP 会将大于 MSS 的数据拆分成 MSS 大小的数据段进行传输。</li>
<li><strong>发送缓冲区不足（极端情况）：</strong> 虽然不常见，但如果应用程序写入的数据量非常大，超出了发送缓冲区当前可用的空间，发送操作可能会被阻塞或部分写入，后续再写入剩下的部分，导致数据被动拆分。</li>
<li><strong>网络拥塞或拥塞窗口限制：</strong> TCP 的拥塞控制机制可能会限制一次能发送的数据量，导致即使发送缓冲区有足够数据，也只能分批发送。</li>
</ol>
<hr>
<h3 id="4-如何处理粘包和拆包问题？"><a href="#4-如何处理粘包和拆包问题？" class="headerlink" title="4. 如何处理粘包和拆包问题？"></a>4. 如何处理粘包和拆包问题？</h3><p>由于 TCP 不提供消息边界，应用程序必须自己定义和处理消息边界。这是 TCP 编程中最关键的一步。</p>
<p>主要的处理策略是在应用层为数据添加“消息边界”信息：</p>
<h4 id="4-1-1-定长消息法-Fixed-Length-Message"><a href="#4-1-1-定长消息法-Fixed-Length-Message" class="headerlink" title="4.1. 1. 定长消息法 (Fixed Length Message)"></a>4.1. 1. 定长消息法 (Fixed Length Message)</h4><ul>
<li><strong>原理：</strong> 约定每个逻辑消息的长度都是固定的。</li>
<li><strong>发送方：</strong> 即使数据不足固定长度，也要填充到固定长度再发送。</li>
<li><strong>接收方：</strong> 每次从缓冲区中读取固定长度字节的数据，认为是一个完整的消息。如果读取到的不足固定长度，则等待直到足够数据。</li>
<li><strong>优点：</strong> 实现简单。</li>
<li><strong>缺点：</strong><ul>
<li>灵活性差：所有消息必须是固定长度。</li>
<li>效率低：如果实际消息很小，会浪费带宽用于填充。</li>
<li>不适合：消息长度经常变化或数据量很大的场景。</li>
</ul>
</li>
</ul>
<h4 id="4-2-2-特殊字符-分隔符法-Delimiter-Based-Message"><a href="#4-2-2-特殊字符-分隔符法-Delimiter-Based-Message" class="headerlink" title="4.2. 2. 特殊字符&#x2F;分隔符法 (Delimiter Based Message)"></a>4.2. 2. 特殊字符&#x2F;分隔符法 (Delimiter Based Message)</h4><ul>
<li><strong>原理：</strong> 在每个消息的末尾添加一个特殊的字符或字符串作为消息的结束标志。</li>
<li><strong>发送方：</strong> 在每个消息后面添加分隔符。</li>
<li><strong>接收方：</strong> 持续从缓冲区读取数据，直到检测到分隔符。</li>
<li><strong>优点：</strong> 实现相对简单，无需固定长度。</li>
<li><strong>缺点：</strong><ul>
<li><strong>数据中不能包含分隔符：</strong> 这是最大的缺陷，如果消息内容中也包含了分隔符，就会导致错误解析。</li>
<li>效率相对较低：需要逐字节处理查找分隔符。</li>
<li>如果分隔符丢失或损坏，数据会无法正确解析。</li>
</ul>
</li>
</ul>
<h4 id="4-3-3-消息头-消息体法-Header-Body-Message-最常用和推荐"><a href="#4-3-3-消息头-消息体法-Header-Body-Message-最常用和推荐" class="headerlink" title="4.3. 3. 消息头+消息体法 (Header + Body Message) - 最常用和推荐"></a>4.3. 3. 消息头+消息体法 (Header + Body Message) - <strong>最常用和推荐</strong></h4><ul>
<li><strong>原理：</strong> 每个消息由两部分组成：<ul>
<li><strong>消息头 (Header)：</strong> 包含消息的元数据，<strong>最重要的就是消息体的长度</strong>。</li>
<li><strong>消息体 (Body&#x2F;Payload)：</strong> 实际的业务数据。</li>
</ul>
</li>
<li><strong>发送方：</strong><ol>
<li>计算消息体的长度。</li>
<li>将长度信息编码到消息头中（例如，用4个字节表示）。</li>
<li>将消息头和消息体拼接起来发送。</li>
</ol>
</li>
<li><strong>接收方：</strong><ol>
<li>首先尝试读取固定长度的“消息头”（例如，4个字节）。</li>
<li>从消息头中解析出消息体的预期长度。</li>
<li>根据解析出的长度，继续从缓冲区中读取相应数量的字节，直到读取完整个消息体。</li>
<li>如果缓冲区数据不足，则等待，直到数据足够再读取。</li>
</ol>
</li>
<li><strong>优点：</strong><ul>
<li><strong>可靠性高：</strong> 不会受消息内容影响，只要长度字段不被破坏。</li>
<li><strong>效率高：</strong> 可以一次性读取指定长度的数据，减少迭代。</li>
<li><strong>灵活性强：</strong> 消息体长度可以动态变化。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>实现相对复杂，需要状态机管理读取过程。</li>
<li>需要定义消息头的格式（长度字段的位数、字节序等）。</li>
</ul>
</li>
</ul>
<p><strong>示例状态机（消息头+消息体法接收端）：</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">状态<span class="number">1</span>：等待消息头</span><br><span class="line">    尝试读取 <span class="number">4</span> 字节（消息长度）</span><br><span class="line">    如果不足 <span class="number">4</span> 字节，则等待</span><br><span class="line">    读取到 <span class="number">4</span> 字节后，解析出消息体长度 <span class="built_in">N</span></span><br><span class="line">    进入状态<span class="number">2</span></span><br><span class="line"></span><br><span class="line">状态<span class="number">2</span>：等待消息体</span><br><span class="line">    尝试读取 <span class="built_in">N</span> 字节（消息体）</span><br><span class="line">    如果不足 <span class="built_in">N</span> 字节，则等待</span><br><span class="line">    读取到 <span class="built_in">N</span> 字节后，得到完整消息</span><br><span class="line">    处理消息，然后返回状态<span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-关于-Nagle-算法的额外说明"><a href="#5-关于-Nagle-算法的额外说明" class="headerlink" title="5. 关于 Nagle 算法的额外说明"></a>5. 关于 Nagle 算法的额外说明</h3><p>虽然 Nagle 算法会导致粘包，但其目的是为了提高网络利用率，减少小包数量。在某些对延迟非常敏感的场景（如实时游戏），你可能希望禁用 Nagle 算法（通过设置 <code>TCP_NODELAY</code> 选项为 true），但这会增加网络上的小包数量，可能导致网络拥堵或效率下降。即使禁用 Nagle 算法，仍然无法避免所有粘包和拆包问题，因为还有缓冲区和其他因素的影响。因此，<strong>正确的做法始终是在应用层处理消息边界。</strong></p>
<hr>
<p>理解粘包和拆包，以及如何处理它们，是编写健壮、高效的 TCP 网络程序的基础。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">TCP 超时重传机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:06:25" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>除了标准的 TCP 四次挥手，还有一些其他方法或特殊情况可以导致连接断开，但它们通常不如四次挥手那样优雅和受控，可能会伴随数据丢失或异常。</p>
<h3 id="1-RST-报文断开连接-Reset"><a href="#1-RST-报文断开连接-Reset" class="headerlink" title="1. RST 报文断开连接 (Reset)"></a>1. RST 报文断开连接 (Reset)</h3><p><code>RST</code> (Reset) 报文是一种 TCP 错误或异常的指示，它会<strong>立即终止</strong>连接，不会进行标准的四次挥手过程，也不会等待任何未发送或未确认的数据。</p>
<p><strong><code>RST</code> 报文的常见使用场景：</strong></p>
<ul>
<li><strong>连接被拒绝：</strong> 当客户端尝试连接到一个不存在的端口或一个拒绝连接的服务器端口时，服务器通常会回复一个 <code>RST</code> 报文，表示连接无法建立。</li>
<li><strong>中止连接：</strong> 当一方决定突然中止一个连接，而不是通过正常的挥手过程关闭时，会发送 <code>RST</code>。这意味着不再关心对方是否已收到所有数据，也不希望进一步的通信。例如，应用程序调用 <code>SO_LINGER</code> 且 <code>l_onoff</code> 为真，<code>l_linger</code> 为 0 时。</li>
<li><strong>检测半开连接：</strong> 如果一方的连接已经关闭（比如进程崩溃），而另一方在试图向已关闭的连接发送数据时，操作系统会检测到这个异常并回复一个 <code>RST</code> 报文。</li>
<li><strong>端口扫描：</strong> 端口扫描工具通常会向目标端口发送 SYN 包，根据收到的响应（SYN-ACK 或 RST）来判断端口是否开放。</li>
<li><strong>检测连接超时：</strong> 在某些情况下，如果一方长时间没有收到对方的响应，可能会发送一个 <code>RST</code> 来强制关闭连接。</li>
</ul>
<p><strong><code>RST</code> 的特点：</strong></p>
<ul>
<li><strong>立即关闭：</strong> 连接立即被重置，不再有数据传输或等待。</li>
<li><strong>无数据确认：</strong> 不会确认任何未送达的数据，可能会导致数据丢失。</li>
<li><strong>不优雅：</strong> 通常被视为一种异常或错误终止的方式。</li>
</ul>
<h3 id="2-半关闭-Half-close"><a href="#2-半关闭-Half-close" class="headerlink" title="2. 半关闭 (Half-close)"></a>2. 半关闭 (Half-close)</h3><p>TCP 连接是全双工的，这意味着数据可以在两个方向上独立传输。半关闭是指<strong>关闭一个方向的数据传输，而保持另一个方向的开放</strong>。这通常通过调用 <code>shutdown()</code> 函数来实现，而不是 <code>close()</code>。</p>
<ul>
<li><strong><code>shutdown(sockfd, SHUT_WR)</code>：</strong> 表示关闭套接字的写入方向，即不再发送数据。这会发送一个 <code>FIN</code> 报文给对方。对方会收到 <code>FIN</code>，并确认，但自己的写入方向仍然是开放的，可以继续接收数据。</li>
<li><strong><code>shutdown(sockfd, SHUT_RD)</code>：</strong> 表示关闭套接字的读取方向，即不再接收数据。这不会发送 <code>FIN</code> 报文给对方。</li>
<li><strong><code>shutdown(sockfd, SHUT_RDWR)</code>：</strong> 等同于 <code>close()</code>，关闭了读写两个方向，发送 <code>FIN</code> 报文并进行四次挥手。</li>
</ul>
<p><strong>用途：</strong> 允许一方发送完所有数据后，告知对方自己不再发送，但仍然可以接收对方可能发送的剩余数据。例如，FTP 协议的某些数据传输模式会利用半关闭。</p>
<h3 id="3-连接超时或故障"><a href="#3-连接超时或故障" class="headerlink" title="3. 连接超时或故障"></a>3. 连接超时或故障</h3><p>如果一方的连接因为长时间没有活动而超时，或者因为硬件&#x2F;网络故障（如网线拔掉、路由器崩溃、电源故障等）导致无法通信，连接也可能“断开”。</p>
<ul>
<li><strong>TCP Keep-alive：</strong> TCP 有一个 <code>Keep-alive</code> 机制，如果长时间没有数据传输，它会发送小探测包来检查连接是否仍然活跃。如果多次探测没有收到响应，TCP 会认为连接已断开，然后通常会在后台发送一个 <code>RST</code> 或报告错误给应用程序。</li>
<li><strong>应用程序层心跳：</strong> 应用程序自己也可以实现心跳机制，定期发送探测消息来确认对端是否仍然在线，并在超时时主动关闭连接或进行错误处理。</li>
<li><strong>物理链路中断：</strong> 这是最彻底也是最不优雅的断开方式。当物理连接中断时，TCP 协议栈无法正常收发数据，最终会通过超时等机制感知到连接的断开，并通知应用程序。这种情况下，通常不会有 TCP 报文发出（因为链路已经不通）。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>四次挥手：</strong> 最优雅和推荐的连接关闭方式，确保数据完全传输且不发生混乱。</li>
<li><strong>RST 报文：</strong> 强制、立即终止连接，可能导致数据丢失，常用于错误或异常情况。</li>
<li><strong>半关闭 (<code>shutdown</code>)：</strong> 控制关闭单个方向的传输，常用于特定协议或应用场景。</li>
<li><strong>超时&#x2F;故障：</strong> 非协议层面的主动断开，由底层网络或操作系统机制发现并处理，可能也涉及隐式的 <code>RST</code> 或错误报告。</li>
</ul>
<p>在实际应用中，我们总是应该优先使用标准的四次挥手来关闭连接，以确保数据的完整性和连接的可靠性。只有在特定错误处理或特殊协议需求下，才会考虑其他关闭方式。</p>
<p>TCP 超时重传机制是 TCP 可靠性传输的核心组成部分之一，它主要为了解决以下核心问题：</p>
<h3 id="1-网络传输的不可靠性"><a href="#1-网络传输的不可靠性" class="headerlink" title="1. 网络传输的不可靠性"></a>1. 网络传输的不可靠性</h3><p>互联网是一个复杂的、分布式、尽力而为（best-effort）的网络，它不保证数据的可靠传输。在传输过程中，数据包可能会遇到各种问题：</p>
<ul>
<li><strong>丢包 (Packet Loss)：</strong> 这是最常见的问题。数据包可能因为网络拥塞、路由器故障、数据链路层错误（如噪声干扰导致帧损坏被丢弃）等原因，在到达目的地之前就丢失了。</li>
<li><strong>乱序 (Packet Reordering)：</strong> 数据包可能不按发送顺序到达目的地。虽然这不是直接导致重传的原因（因为 TCP 会在接收端进行排序），但如果乱序太严重，或者接收端缓冲区不足，也可能间接导致发送方误判为丢包而重传。</li>
<li><strong>延迟 (Delay)：</strong> 数据包的传输时间不是恒定的。有些包可能会因为网络拥塞或路由选择变化而经历很长的延迟。</li>
</ul>
<h3 id="TCP-超时重传机制如何解决这些问题："><a href="#TCP-超时重传机制如何解决这些问题：" class="headerlink" title="TCP 超时重传机制如何解决这些问题："></a>TCP 超时重传机制如何解决这些问题：</h3><p>TCP 通过以下核心步骤来应对上述不可靠性，实现可靠传输：</p>
<ol>
<li><p><strong>确认机制 (Acknowledgement - ACK)：</strong></p>
<ul>
<li>发送方发送一个 TCP 报文段后，会启动一个定时器。</li>
<li>接收方成功收到数据后，会发送一个 <code>ACK</code> 报文给发送方，确认已经收到的数据（通常是它期望收到的下一个字节的序列号）。</li>
</ul>
</li>
<li><p><strong>超时定时器 (Retransmission Timer)：</strong></p>
<ul>
<li>当发送方发送数据时，它会为这些数据设置一个重传定时器。</li>
<li>如果在定时器到期之前，发送方没有收到该数据的 <code>ACK</code> 确认，发送方就会认为该数据包或其 <code>ACK</code> 包已经丢失了。</li>
</ul>
</li>
<li><p><strong>重传 (Retransmission)：</strong></p>
<ul>
<li>一旦定时器超时，发送方就会<strong>重新发送</strong>之前未被确认的数据包。</li>
<li>同时，通常会调整重传定时器的时间，使得下一次重传的等待时间更长（指数退避算法），以适应网络拥塞等情况。</li>
</ul>
</li>
</ol>
<h3 id="总结-TCP-超时重传机制解决的核心问题："><a href="#总结-TCP-超时重传机制解决的核心问题：" class="headerlink" title="总结 TCP 超时重传机制解决的核心问题："></a>总结 TCP 超时重传机制解决的核心问题：</h3><ul>
<li><strong>数据丢失：</strong> 这是最主要解决的问题。通过定时器和 ACK 机制，TCP 能够发现哪些数据包没有被成功接收，并进行重传，确保所有数据最终都能到达目的地。</li>
<li><strong>连接的可靠性：</strong> 结合序列号和确认号，重传机制保证了数据传输的完整性和顺序性，使得应用程序不必担心网络层的不可靠性，可以假定数据是可靠、按序到达的。</li>
<li><strong>网络效率与拥塞控制的基础：</strong> 超时重传机制不仅仅是简单的重发，它与 TCP 的拥塞控制和流量控制机制紧密结合。当发生重传时，TCP 会降低发送速率（拥塞窗口减小），这有助于缓解网络拥塞，防止情况恶化。重传超时时间（RTO）的动态调整也是关键，它能够适应不断变化的网络条件，避免不必要的重传，同时在真正丢包时又能及时重传。</li>
</ul>
<p><strong>简单来说，TCP 超时重传机制就是 TCP 提供“可靠性”的基石，它让应用程序可以放心地发送数据，因为无论底层网络如何波动，TCP 都会确保数据最终完整且按序地交付。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="post-title-link" itemprop="url">TCP-四次挥手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:07:17" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。</p>
<p>假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。</p>
<h3 id="四次挥手过程详解："><a href="#四次挥手过程详解：" class="headerlink" title="四次挥手过程详解："></a>四次挥手过程详解：</h3><p><strong>第一次挥手：FIN 报文段（客户端 A → 服务器 B）</strong></p>
<ul>
<li><p><strong>客户端 A (主动关闭方)：</strong></p>
<ul>
<li>当客户端 A 的应用层想要关闭连接时（例如调用 <code>close()</code> 或 <code>shutdown()</code>），客户端 A 的 TCP 会发送一个带有 <code>FIN</code> (Finish) 标志的报文段给服务器 B。</li>
<li>这个 FIN 报文段的序列号通常是它发送的最后一个数据字节的序列号的下一个。</li>
<li>发送 <code>FIN</code> 后，客户端 A 进入 <code>FIN_WAIT_1</code> 状态。这意味着客户端 A 不再发送数据，但仍然可以接收数据。</li>
</ul>
<p><strong>状态变化：</strong> <code>ESTABLISHED</code> → <code>FIN_WAIT_1</code></p>
</li>
</ul>
<p><strong>第二次挥手：ACK 报文段（服务器 B → 客户端 A）</strong></p>
<ul>
<li><p><strong>服务器 B (被动关闭方)：</strong></p>
<ul>
<li>当服务器 B 收到客户端 A 的 <code>FIN</code> 报文段时，它会发送一个 <code>ACK</code> (Acknowledgement) 报文段作为回应。</li>
<li>这个 ACK 报文段的确认号是客户端 A 的 FIN 报文段的序列号加 1（<code>Seq(FIN) + 1</code>）。</li>
<li>发送 <code>ACK</code> 后，服务器 B 进入 <code>CLOSE_WAIT</code> 状态。这意味着服务器 B 已经得知客户端 A 不再发送数据了，但服务器 B 可能还有数据要发送给客户端 A，并且会继续接收客户端 A 的 ACK。**<code>CLOSE_WAIT</code> 状态表示服务器正在等待本地应用关闭连接。**</li>
</ul>
<p><strong>状态变化：</strong> <code>ESTABLISHED</code> → <code>CLOSE_WAIT</code></p>
</li>
<li><p><strong>客户端 A：</strong></p>
<ul>
<li>客户端 A 收到服务器 B 的 <code>ACK</code> 后，进入 <code>FIN_WAIT_2</code> 状态。这表示客户端 A 已经确认服务器 B 接收到了它的关闭请求，并且正在等待服务器 B 发送自己的 <code>FIN</code> 报文段。此时客户端 A 仍然可以接收数据。</li>
</ul>
<p><strong>状态变化：</strong> <code>FIN_WAIT_1</code> → <code>FIN_WAIT_2</code></p>
</li>
</ul>
<p><strong>第三次挥手：FIN 报文段（服务器 B → 客户端 A）</strong></p>
<ul>
<li><p><strong>服务器 B (被动关闭方)：</strong></p>
<ul>
<li>当服务器 B 的应用层也决定关闭连接时（例如，其所有待发送的数据都已发送完毕，并调用 <code>close()</code> 或 <code>shutdown()</code>），服务器 B 的 TCP 会发送一个带有 <code>FIN</code> 标志的报文段给客户端 A。</li>
<li>这个 FIN 报文段的序列号是它发送的最后一个数据字节的序列号的下一个。</li>
<li>发送 <code>FIN</code> 后，服务器 B 进入 <code>LAST_ACK</code> 状态。这意味着服务器 B 已经发送了所有数据，正在等待客户端 A 的最终 ACK。</li>
</ul>
<p><strong>状态变化：</strong> <code>CLOSE_WAIT</code> → <code>LAST_ACK</code></p>
</li>
</ul>
<p><strong>第四次挥手：ACK 报文段（客户端 A → 服务器 B）</strong></p>
<ul>
<li><p><strong>客户端 A (主动关闭方)：</strong></p>
<ul>
<li>当客户端 A 收到服务器 B 的 <code>FIN</code> 报文段时，它会发送一个 <code>ACK</code> 报文段作为回应。</li>
<li>这个 ACK 报文段的确认号是服务器 B 的 FIN 报文段的序列号加 1（<code>Seq(FIN) + 1</code>）。</li>
<li>发送 <code>ACK</code> 后，客户端 A 进入 <code>TIME_WAIT</code> 状态。</li>
</ul>
<p><strong>状态变化：</strong> <code>FIN_WAIT_2</code> → <code>TIME_WAIT</code></p>
</li>
<li><p><strong>TIME_WAIT 状态：</strong></p>
<ul>
<li>客户端 A 在进入 <code>TIME_WAIT</code> 状态后，会启动一个定时器，等待 2 * MSL (Maximum Segment Lifetime，最长报文段寿命) 的时间。MSL 是一个 TCP 报文段在网络中能够存活的最长时间。</li>
<li><strong>为什么要等待 2 MSL？</strong><ul>
<li><strong>确保确认报文可靠到达：</strong> 确保客户端 A 发送的最后一个 ACK 报文段能够安全到达服务器 B。如果这个 ACK 丢失，服务器 B 会重传其 FIN 报文段。2 MSL 的时间足以保证客户端 A 能够接收到重传的 FIN 并重新发送 ACK，或者让服务器 B 等待超时并关闭连接。</li>
<li><strong>防止旧连接的迟到报文段：</strong> 确保这个连接上迟到的、旧的（可能是前一个连接的）数据报文段都在网络中消逝，不会被新的、使用相同端口号的连接所接收。这避免了“串线”问题。</li>
</ul>
</li>
<li>在 2 MSL 时间过后，客户端 A 才会真正进入 <code>CLOSED</code> 状态，并释放其端口资源。</li>
</ul>
</li>
<li><p><strong>服务器 B：</strong></p>
<ul>
<li>当服务器 B 收到客户端 A 的最后一个 <code>ACK</code> 报文段后，会立即进入 <code>CLOSED</code> 状态，并释放资源。</li>
</ul>
<p><strong>状态变化：</strong> <code>LAST_ACK</code> → <code>CLOSED</code></p>
</li>
</ul>
<h3 id="四次挥手的必要性："><a href="#四次挥手的必要性：" class="headerlink" title="四次挥手的必要性："></a>四次挥手的必要性：</h3><p>之所以不能像三次握手那样三次挥手，是因为 TCP 是全双工的。当一方发送 <code>FIN</code> 报文时，表示它自己的数据已经发送完毕，不再有数据要发送给对方了。但是：</p>
<ol>
<li>它仍然可以<strong>接收</strong>对方发送的数据。</li>
<li>对方<strong>可能还有数据要发送</strong>给它。</li>
</ol>
<p>所以，收到 <code>FIN</code> 的一方需要先发送一个 <code>ACK</code> 来确认收到对方的关闭请求（第二次挥手），然后等到自己所有的数据都发送完毕，并也准备好关闭自己的发送端时，再发送自己的 <code>FIN</code> 报文（第三次挥手）。这两步（ACK 和 FIN）不能合并发送，因为它们通常发生在不同的时间点（应用程序关闭其写端的时间）。</p>
<p>只有当双方都明确表示不再发送数据并收到对方的确认时，连接才能安全地关闭。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/ue114n.png" alt="image-20250717161147217"></p>
<p>好的，我们来分析一下你提供的 Wireshark 抓包信息，这是典型的 TCP 四次挥手过程：</p>
<p><strong>假设：</strong></p>
<ul>
<li><code>10.20.11.73</code> 是 <strong>客户端</strong> (源端口 64136)</li>
<li><code>10.10.4.3</code> 是 <strong>服务器</strong> (目标端口 80)</li>
</ul>
<p><strong>分析：</strong></p>
<hr>
<p><strong>第 497 行：客户端 → 服务器</strong><br><code>497 16.103047 10.20.11.73 10.10.4.3 TCP 66 64136 → 80 [ACK] Seq=73 Ack=346 Win=131520 Len=0 TSval=3155782880 TSecr=1168528558</code></p>
<ul>
<li><strong>发送方：</strong> 客户端 <code>10.20.11.73</code> (端口 64136)</li>
<li><strong>接收方：</strong> 服务器 <code>10.10.4.3</code> (端口 80)</li>
<li><strong>标志位：</strong> <code>[ACK]</code></li>
<li><strong>Seq&#x3D;73：</strong> 客户端当前发送的序列号是 73。</li>
<li><strong>Ack&#x3D;346：</strong> 客户端确认收到了服务器序列号到 345 的所有数据，期望收到服务器的下一个字节是 346。</li>
<li><strong>Len&#x3D;0：</strong> 这个报文段不包含数据负载，它只是一个纯 ACK。</li>
<li><strong>Timestamp (TSval&#x2F;TSecr):</strong> 时间戳选项，用于计算 RTT 和防止序列号回绕 (PAWS)。</li>
</ul>
<p><strong>解释：</strong> 这个 ACK 包可能是客户端对之前收到的服务器数据的一个确认，或者是一个延迟的 ACK。它本身还不是挥手的一部分，但紧接着就有一个 FIN 包发过来了。</p>
<hr>
<p><strong>第 498 行：客户端 → 服务器 (第一次挥手)</strong><br><code>498 16.103167 10.20.11.73 10.10.4.3 TCP 66 64136 → 80 [FIN, ACK] Seq=73 Ack=346 Win=131520 Len=0 TSval=3155782880 TSecr=1168528558</code></p>
<ul>
<li><strong>发送方：</strong> 客户端 <code>10.20.11.73</code> (端口 64136)</li>
<li><strong>接收方：</strong> 服务器 <code>10.10.4.3</code> (端口 80)</li>
<li><strong>标志位：</strong> <code>[FIN, ACK]</code></li>
<li><strong>Seq&#x3D;73：</strong> 注意，这个 <code>Seq=73</code> 与上一个 ACK 包的 <code>Seq=73</code> 相同，这意味着客户端在发送完上一个 ACK 后，没有再发送任何数据，紧接着就发送了 FIN。FIN 包本身会占用一个序列号。</li>
<li><strong>Ack&#x3D;346：</strong> 客户端依然确认收到了服务器序列号到 345 的数据，期望下一个是 346。</li>
<li><strong>Len&#x3D;0：</strong> 没有数据负载。</li>
</ul>
<p><strong>解释：</strong> <strong>这是四次挥手的第一步。</strong> 客户端 <code>10.20.11.73</code> 发送 <code>FIN</code> 包，表明它已经没有数据要发送了，并请求关闭其发送方向的连接。</p>
<p><strong>客户端状态：</strong> <code>ESTABLISHED</code> → <code>FIN_WAIT_1</code></p>
<hr>
<p><strong>第 499 行：服务器 → 客户端 (第二次挥手 和 第三次挥手)</strong><br><code>499 16.115764 10.10.4.3 10.20.11.73 TCP 66 80 → 64136 [FIN, ACK] Seq=346 Ack=74 Win=29184 Len=0 TSval=1168528571 TSecr=3155782880</code></p>
<ul>
<li><strong>发送方：</strong> 服务器 <code>10.10.4.3</code> (端口 80)</li>
<li><strong>接收方：</strong> 客户端 <code>10.20.11.73</code> (端口 64136)</li>
<li><strong>标志位：</strong> <code>[FIN, ACK]</code></li>
<li><strong>Seq&#x3D;346：</strong> 服务器当前发送的序列号是 346 (与客户端期望的下一个序列号一致)。</li>
<li><strong>Ack&#x3D;74：</strong> 服务器确认收到了客户端的 Seq&#x3D;73 的 FIN 包 (FIN 包占用一个序列号)，所以期望客户端的下一个字节是 74。</li>
<li><strong>Len&#x3D;0：</strong> 没有数据负载。</li>
</ul>
<p><strong>解释：</strong> <strong>这是四次挥手的第二步和第三步的合并。</strong></p>
<ol>
<li><strong>作为第二次挥手：</strong> 服务器发送 <code>ACK</code> (Ack&#x3D;74) 来确认收到了客户端的 <code>FIN</code>。</li>
<li><strong>作为第三次挥手：</strong> 服务器也发送了自己的 <code>FIN</code> (Seq&#x3D;346)，表明它也没有数据要发送了，并请求关闭其发送方向的连接。</li>
</ol>
<p><strong>为什么是合并的？</strong> 这种情况很常见，当服务器收到客户端的 <code>FIN</code> 后，如果没有其他数据需要发送给客户端，它会立即发送一个包含 <code>FIN</code> 和 <code>ACK</code> 的报文段。这节省了一个来回，但在逻辑上仍然是第二步和第三步。</p>
<p><strong>服务器状态：</strong> <code>ESTABLISHED</code> → <code>CLOSE_WAIT</code> (收到客户端FIN并ACK) → <code>LAST_ACK</code> (发送自己的FIN)<br><strong>客户端状态：</strong> <code>FIN_WAIT_1</code> → <code>FIN_WAIT_2</code> (收到服务器的ACK) → (此时客户端还未发送最终ACK)</p>
<hr>
<p><strong>第 500 行：客户端 → 服务器 (第四次挥手)</strong><br><code>500 16.115878 10.20.11.73 10.10.4.3 TCP 66 64136 → 80 [ACK] Seq=74 Ack=347 Win=131520 Len=0 TSval=3155782893 TSecr=1168528571</code></p>
<ul>
<li><strong>发送方：</strong> 客户端 <code>10.20.11.73</code> (端口 64136)</li>
<li><strong>接收方：</strong> 服务器 <code>10.10.4.3</code> (端口 80)</li>
<li><strong>标志位：</strong> <code>[ACK]</code></li>
<li><strong>Seq&#x3D;74：</strong> 客户端新的序列号是 74 (这是客户端发送的最后一个 FIN 包的序列号之后）。</li>
<li><strong>Ack&#x3D;347：</strong> 客户端确认收到了服务器的 Seq&#x3D;346 的 FIN 包，期望服务器的下一个字节是 347。</li>
<li><strong>Len&#x3D;0：</strong> 没有数据负载。</li>
</ul>
<p><strong>解释：</strong> <strong>这是四次挥手的第四步。</strong> 客户端 <code>10.20.11.73</code> 发送最终的 <code>ACK</code> 包，确认收到了服务器的 <code>FIN</code>。</p>
<p><strong>客户端状态：</strong> <code>FIN_WAIT_2</code> → <code>TIME_WAIT</code> (并开始 2MSL 计时)<br><strong>服务器状态：</strong> <code>LAST_ACK</code> → <code>CLOSED</code> (收到客户端的最终ACK后立即关闭)</p>
<hr>
<p><strong>总结整个过程：</strong></p>
<ol>
<li><strong>客户端 10.20.11.73 (64136) 说：“我没东西发了，我想关了。”</strong> (498 行：<code>FIN, ACK</code> from client)</li>
<li><strong>服务器 10.10.4.3 (80) 说：“好的，我知道你没东西发了。我也没东西发了，我也想关了。”</strong> (499 行：<code>FIN, ACK</code> from server - 合并了对客户端 FIN 的 ACK 和自己的 FIN)</li>
<li><strong>客户端 10.20.11.73 (64136) 说：“好的，我也收到你关的请求了。”</strong> (500 行：<code>ACK</code> from client)</li>
</ol>
<p>至此，TCP 连接的双向数据流都已关闭。客户端进入 <code>TIME_WAIT</code> 状态，等待 2 MSL 后彻底关闭；服务器在收到最后一个 ACK 后立即关闭。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCPIP%204%20%E5%B1%82%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCPIP%204%20%E5%B1%82%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">TCPIP 4 层模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:07:24" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP&#x2F;IP 四层模型（也称为 TCP&#x2F;IP 协议栈、TCP&#x2F;IP 参考模型）是计算机网络中最常用和最重要的分层模型之一。它将复杂的网络通信过程划分为若干个逻辑层，每层负责不同的功能。</p>
<p>这个模型与 OSI 七层模型有所不同，虽然它们都致力于解决网络通信的复杂性，但 TCP&#x2F;IP 模型更注重实际应用和协议实现。</p>
<h3 id="TCP-IP-四层模型的构成："><a href="#TCP-IP-四层模型的构成：" class="headerlink" title="TCP&#x2F;IP 四层模型的构成："></a>TCP&#x2F;IP 四层模型的构成：</h3><p>TCP&#x2F;IP 模型通常被划分为以下四层：</p>
<ol>
<li><strong>应用层 (Application Layer)</strong></li>
<li><strong>传输层 (Transport Layer)</strong></li>
<li><strong>网络层 (Internet Layer)</strong></li>
<li><strong>网络接口层 (Network Access Layer) 或 数据链路层&#x2F;物理层</strong></li>
</ol>
<p>让我们逐一详细了解每一层的功能、协议和数据单元。</p>
<hr>
<h3 id="1-应用层-Application-Layer"><a href="#1-应用层-Application-Layer" class="headerlink" title="1. 应用层 (Application Layer)"></a>1. 应用层 (Application Layer)</h3><ul>
<li><strong>功能：</strong> 提供应用程序之间的通信服务。它是用户与网络进行交互的最高层，负责处理特定应用程序的数据，并将其转换为通过网络传输的格式。</li>
<li><strong>代表协议：</strong><ul>
<li><strong>HTTP&#x2F;HTTPS：</strong> (超文本传输协议) 用于网页浏览。</li>
<li><strong>FTP：</strong> (文件传输协议) 用于文件传输。</li>
<li><strong>SMTP&#x2F;POP3&#x2F;IMAP：</strong> (简单邮件传输协议&#x2F;邮局协议&#x2F;互联网邮件访问协议) 用于电子邮件的发送和接收。</li>
<li><strong>DNS：</strong> (域名系统) 用于将域名解析为 IP 地址。</li>
<li><strong>Telnet&#x2F;SSH：</strong> 用于远程登录。</li>
<li><strong>SNMP：</strong> (简单网络管理协议) 用于网络设备管理。</li>
</ul>
</li>
<li><strong>数据单元：</strong> 报文 (Message) 或 数据 (Data)</li>
</ul>
<hr>
<h3 id="2-传输层-Transport-Layer"><a href="#2-传输层-Transport-Layer" class="headerlink" title="2. 传输层 (Transport Layer)"></a>2. 传输层 (Transport Layer)</h3><ul>
<li><strong>功能：</strong> 提供端到端（应用程序到应用程序）的数据传输服务。它负责数据的分段、传输、接收和重组，以及保证数据传输的可靠性（或不可靠性）。</li>
<li><strong>代表协议：</strong><ul>
<li><strong>TCP (Transmission Control Protocol)：</strong> (传输控制协议) 提供<strong>面向连接的、可靠的、基于字节流</strong>的传输服务。它提供流量控制、拥塞控制和错误恢复等机制，确保数据完整无误地到达。</li>
<li><strong>UDP (User Datagram Protocol)：</strong> (用户数据报协议) 提供<strong>无连接的、不可靠的</strong>传输服务。它不保证数据包的顺序、完整性或是否到达，但传输效率高，适用于对实时性要求高、少量丢包可接受的应用（如视频会议、网络游戏）。</li>
</ul>
</li>
<li><strong>数据单元：</strong><ul>
<li><strong>TCP：</strong> 段 (Segment)</li>
<li><strong>UDP：</strong> 用户数据报 (User Datagram)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-网络层-Internet-Layer-互联网层"><a href="#3-网络层-Internet-Layer-互联网层" class="headerlink" title="3. 网络层 (Internet Layer) &#x2F; 互联网层"></a>3. 网络层 (Internet Layer) &#x2F; 互联网层</h3><ul>
<li><strong>功能：</strong> 负责数据包在不同网络（广域网）之间的路由和转发。它定义了数据包的寻址（IP 地址）和路由选择，使得数据可以跨越异构网络到达目标主机。</li>
<li><strong>代表协议：</strong><ul>
<li><strong>IP (Internet Protocol)：</strong> (互联网协议) 核心协议，提供<strong>无连接的、不可靠的</strong>数据包传输服务。它只负责将数据包从源主机转发到目的主机，不关心数据包是否丢失或乱序。</li>
<li><strong>ARP (Address Resolution Protocol)：</strong> (地址解析协议) 将 IP 地址解析为 MAC 地址。</li>
<li><strong>ICMP (Internet Control Message Protocol)：</strong> (互联网控制报文协议) 用于在 IP 主机和路由器之间传递控制消息和错误报告（如 Ping 命令）。</li>
<li><strong>IGMP (Internet Group Management Protocol)：</strong> (互联网组管理协议) 用于管理多播组成员。</li>
</ul>
</li>
<li><strong>数据单元：</strong> 数据包 (Packet) 或 IP 数据报 (IP Datagram)</li>
</ul>
<hr>
<h3 id="4-网络接口层-Network-Access-Layer-主机到网络层-数据链路层与物理层"><a href="#4-网络接口层-Network-Access-Layer-主机到网络层-数据链路层与物理层" class="headerlink" title="4. 网络接口层 (Network Access Layer) &#x2F; 主机到网络层 &#x2F; 数据链路层与物理层"></a>4. 网络接口层 (Network Access Layer) &#x2F; 主机到网络层 &#x2F; 数据链路层与物理层</h3><ul>
<li><strong>功能：</strong> 负责将 IP 数据报封装和解封装成适合物理网络传输的帧，并处理在物理介质上的比特流传输。它包括了数据链路层和物理层的功能。<ul>
<li><strong>数据链路层：</strong> 处理帧的传输、错误检测和纠正、MAC 地址寻址，以及介质访问控制 (MAC)。</li>
<li><strong>物理层：</strong> 定义物理介质（如电缆、光纤、无线电波）的特性、电压、接口形式、数据传输速率等。</li>
</ul>
</li>
<li><strong>代表协议：</strong><ul>
<li><strong>以太网 (Ethernet)：</strong> 最常用的局域网技术。</li>
<li><strong>Wi-Fi (IEEE 802.11)：</strong> 无线局域网标准。</li>
<li><strong>PPP (Point-to-Point Protocol)：</strong> (点对点协议) 用于拨号连接。</li>
</ul>
</li>
<li><strong>数据单元：</strong> 帧 (Frame)</li>
</ul>
<hr>
<h3 id="TCP-IP-模型与-OSI-模型的对比："><a href="#TCP-IP-模型与-OSI-模型的对比：" class="headerlink" title="TCP&#x2F;IP 模型与 OSI 模型的对比："></a>TCP&#x2F;IP 模型与 OSI 模型的对比：</h3><table>
<thead>
<tr>
<th align="left">OSI 七层模型</th>
<th align="left">TCP&#x2F;IP 四层模型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">7. 应用层 (Application)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6. 表示层 (Presentation)</td>
<td align="left"><strong>4. 应用层 (Application)</strong></td>
</tr>
<tr>
<td align="left">5. 会话层 (Session)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4. 传输层 (Transport)</td>
<td align="left"><strong>3. 传输层 (Transport)</strong></td>
</tr>
<tr>
<td align="left">3. 网络层 (Network)</td>
<td align="left"><strong>2. 网络层 (Internet)</strong></td>
</tr>
<tr>
<td align="left">2. 数据链路层 (Data Link)</td>
<td align="left"><strong>1. 网络接口层 (Network Access)</strong></td>
</tr>
<tr>
<td align="left">1. 物理层 (Physical)</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>主要区别：</strong></p>
<ul>
<li><strong>层数：</strong> OSI 模型有 7 层，TCP&#x2F;IP 模型有 4 层。</li>
<li><strong>表示层和会话层：</strong> OSI 模型中独立的表示层和会话层的功能在 TCP&#x2F;IP 模型中被<strong>合并</strong>到应用层中。</li>
<li><strong>数据链路层和物理层：</strong> OSI 模型中独立的这两层在 TCP&#x2F;IP 模型中被<strong>合并</strong>为网络接口层。</li>
<li><strong>重点：</strong> OSI 模型更偏向理论和概念化，旨在提供一个通用的参考标准；TCP&#x2F;IP 模型则更注重实际操作和协议实现，是互联网的核心。</li>
</ul>
<hr>
<h3 id="TCP-IP-模型的封装和解封装过程："><a href="#TCP-IP-模型的封装和解封装过程：" class="headerlink" title="TCP&#x2F;IP 模型的封装和解封装过程："></a>TCP&#x2F;IP 模型的封装和解封装过程：</h3><p>当数据从应用层向下传递时，每一层都会给数据添加自己的<strong>首部 (Header)</strong> 信息，这个过程称为**封装 (Encapsulation)<strong>。当数据到达目标主机后，数据从底层向上层传递时，每一层会剥离相应的首部信息，这个过程称为</strong>解封装 (Decapsulation)**。</p>
<ol>
<li><strong>应用层：</strong> 生成原始数据 (Message)。</li>
<li><strong>传输层：</strong> 将 Message 分割成数据段 (Segment&#x2F;Datagram)，并添加 TCP&#x2F;UDP 首部。</li>
<li><strong>网络层：</strong> 将 Segment&#x2F;Datagram 封装成 IP 数据报 (Datagram)，并添加 IP 首部。</li>
<li><strong>网络接口层：</strong> 将 IP 数据报封装成帧 (Frame)，并添加数据链路层首部（和尾部），然后将帧转换为比特流通过物理介质传输。</li>
</ol>
<p>这个分层的模型使得网络通信具有高度的模块化和灵活性，每一层只需要关注自身的功能，同时也方便协议的开发和维护。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">TCP快速重传机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:07:19" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP 引入快速重传（Fast Retransmit）机制，是为了<strong>弥补仅仅依靠超时重传的不足，提高网络吞吐量和链路利用率，尤其是在数据包丢失不严重但仍存在的情况下</strong>。</p>
<p>让我们来详细了解一下：</p>
<h3 id="超时重传的不足："><a href="#超时重传的不足：" class="headerlink" title="超时重传的不足："></a>超时重传的不足：</h3><p>超时重传是 TCP 可靠性最基本的保障，但它有一个致命的弱点：<strong>等待时间过长</strong>。</p>
<ol>
<li><strong>重传超时时间 (RTO) 的计算：</strong> RTO 是根据网络中的往返时间 (RTT) 动态调整的，通常比 RTT 要长一些。即使网络状况良好，RTO 至少也得几十毫秒甚至几百毫秒。</li>
<li><strong>等待 RTO 的代价：</strong><ul>
<li><strong>吞吐量下降：</strong> 如果一个数据包丢失了，发送方必须一直等到 RTO 到期才能重传。在这漫长的等待期间，发送方可能无法发送新的数据（如果拥塞窗口和接收窗口限制），导致网络带宽得不到充分利用，吞吐量显著下降。</li>
<li><strong>延迟增加：</strong> 对于实时性要求较高的应用，长时间的等待会导致明显的延迟增加。</li>
<li><strong>可能触发不必要的拥塞控制：</strong> 当超时发生时，TCP 会认为发生了一次严重的丢包事件，通常会大幅度降低拥塞窗口（例如，将拥塞窗口降到 1 MSS），这会极大地限制后续的数据发送，加剧吞吐量下降，即便实际上可能只丢失了一个包。</li>
</ul>
</li>
</ol>
<h3 id="快速重传机制的诞生："><a href="#快速重传机制的诞生：" class="headerlink" title="快速重传机制的诞生："></a>快速重传机制的诞生：</h3><p>为了解决超时重传的上述缺点，TCP 引入了快速重传机制。它的核心思想是：<strong>不等到定时器超时，而是根据接收方发送的重复 ACK 报文来提前判断丢包并立即重传。</strong></p>
<p><strong>工作原理：</strong></p>
<ol>
<li><p><strong>重复 ACK：</strong> 当 TCP 接收方收到一个“乱序”的报文段时，它不会立即确认这个乱序的报文段，而是会<strong>立即发送一个重复的 ACK 报文</strong>。这个重复的 ACK 报文确认的是它期望收到的下一个按序的字节序列号。</p>
<ul>
<li>例如：发送方发送了 S1, S2, S3, S4, S5。</li>
<li>接收方收到了 S1，发送 ACK(S2)。</li>
<li>S2 丢失了。</li>
<li>接收方收到了 S3（乱序），它会再次发送 ACK(S2)。</li>
<li>接收方收到了 S4（乱序），它会再次发送 ACK(S2)。</li>
<li>接收方收到了 S5（乱序），它会再次发送 ACK(S2)。</li>
</ul>
</li>
<li><p><strong>触发快速重传：</strong> 当发送方连续收到<strong>三个或更多</strong>个对同一个数据包的重复 ACK 报文时，发送方就会认为这个 ACK 报文所确认的那个数据包（即期望收到的下一个数据包）很可能已经丢失了。<strong>它不会等待 RTO 超时，而是立即重传这个丢失的报文段。</strong></p>
</li>
</ol>
<h3 id="快速重传解决的问题："><a href="#快速重传解决的问题：" class="headerlink" title="快速重传解决的问题："></a>快速重传解决的问题：</h3><ul>
<li><strong>减少不必要的等待时间：</strong> 避免了超时定时器到期才重传的漫长等待，大大缩短了从丢包到重传的响应时间。</li>
<li><strong>提高吞吐量：</strong> 因为能够更快地发现和重传丢失的包，数据流的中断时间大大缩短，从而提高了有效吞吐量。</li>
<li><strong>避免更激进的拥塞控制：</strong> 快速重传通常与快速恢复（Fast Recovery）算法一起使用。当快速重传发生时，TCP 认为这只是一个“轻微”的丢包事件（因为收到了后续的 ACK），因此不会像超时重传那样将拥塞窗口降到很低，而是采取相对温和的拥塞窗口调整策略，从而保持更高的发送速率。这有助于在网络轻度拥塞或偶发丢包时避免性能骤降。</li>
</ul>
<p><strong>总结：</strong></p>
<p><strong>超时重传是确保可靠性的“最终防线”</strong>，它在任何情况下都能保证数据最终会被重传，即使所有后续的 ACK 都丢失了。但它的缺点是响应慢，效率低。</p>
<p><strong>快速重传是提高性能的“优化手段”</strong>，它通过利用重复 ACK 这一额外的信息，在不等待 RTO 的情况下提前发现丢包并迅速重传，从而大大提高了 TCP 在网络状况波动（特别是出现少量丢包）时的吞吐量和响应速度。它们两者是相辅相成，共同确保 TCP 的可靠性和高效性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/TCP%E8%BF%9E%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/TCP%E8%BF%9E%E6%8E%A5/" class="post-title-link" itemprop="url">TCP连接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:07:22" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好的，我们来深入理解一下 TCP 连接。</p>
<p>TCP (Transmission Control Protocol，传输控制协议) 连接是计算机网络中一种<strong>可靠的、面向连接的、基于字节流</strong>的通信方式。它是互联网的基础协议之一，位于 OSI 模型的传输层。</p>
<p>要理解 TCP 连接，首先要明白它解决了哪些问题，以及它是如何解决的。</p>
<hr>
<h3 id="TCP-解决了什么问题？"><a href="#TCP-解决了什么问题？" class="headerlink" title="TCP 解决了什么问题？"></a>TCP 解决了什么问题？</h3><p>想象一下你给朋友寄包裹。如果你想确保包裹<strong>一定能送到</strong>、<strong>顺序不错乱</strong>、<strong>没有丢失</strong>、<strong>没有重复</strong>，并且能知道朋友<strong>是否收到了</strong>，这就是 TCP 试图在数据传输中实现的目标。</p>
<p>具体来说，TCP 针对底层的 IP (Internet Protocol，网际协议) 的局限性，提供了以下关键服务：</p>
<ol>
<li><p><strong>可靠性 (Reliability)：</strong> IP 是不可靠的，它只负责尽力而为地转发数据包，不保证数据包是否到达，也不保证顺序。TCP通过以下机制确保可靠性：</p>
<ul>
<li><strong>确认机制 (Acknowledgements - ACK)：</strong> 接收方收到数据后会发送确认包给发送方。</li>
<li><strong>重传机制 (Retransmission)：</strong> 如果发送方在一定时间内没有收到确认包，它会认为数据包丢失，并重新发送。</li>
<li><strong>校验和 (Checksums)：</strong> 检查数据在传输过程中是否被损坏。</li>
</ul>
</li>
<li><p><strong>顺序性 (In-order Delivery)：</strong> IP 数据包可能乱序到达。TCP 给每个数据包（更准确地说，是每个字节流的段）编号，接收方能根据编号重新排列数据，确保应用程序收到的是按发送顺序排列的完整数据流。</p>
</li>
<li><p><strong>流量控制 (Flow Control)：</strong> 防止发送方发送数据过快，导致接收方来不及处理而缓冲区溢出。TCP 使用滑动窗口 (Sliding Window) 机制，让接收方告知发送方自己还有多少可用缓冲区空间。</p>
</li>
<li><p><strong>拥塞控制 (Congestion Control)：</strong> 防止网络中出现过多的数据，导致网络性能下降甚至崩溃。TCP 会根据网络拥堵情况动态调整发送速率，避免加重拥堵。</p>
</li>
<li><p><strong>面向连接 (Connection-Oriented)：</strong> 在数据传输之前，发送方和接收方之间会建立一个逻辑上的“连接”，完成“握手”过程，协商好各项参数。数据完成后，还会进行“挥手”断开连接。</p>
</li>
</ol>
<hr>
<h3 id="TCP-连接的三个核心阶段："><a href="#TCP-连接的三个核心阶段：" class="headerlink" title="TCP 连接的三个核心阶段："></a>TCP 连接的三个核心阶段：</h3><p>一个 TCP 连接的生命周期可以分为三个主要阶段：</p>
<h4 id="1-连接建立-Connection-Establishment-三次握手-Three-Way-Handshake"><a href="#1-连接建立-Connection-Establishment-三次握手-Three-Way-Handshake" class="headerlink" title="1. 连接建立 (Connection Establishment) - 三次握手 (Three-Way Handshake)"></a>1. 连接建立 (Connection Establishment) - 三次握手 (Three-Way Handshake)</h4><p><img data-src="https://mudutestmenu.mudu.tv/upload/mi0tlx.png" alt="企业微信截图_a8cf363d-e487-4bfb-a444-ee9a9ecd6aa1"></p>
<p>这是建立 TCP 连接的过程，确保双方都准备好进行数据通信。</p>
<ul>
<li><strong>第一次握手：</strong> 客户端发送一个 <code>SYN</code> (Synchronize) 包到服务器，请求建立连接。包中包含客户端的初始序列号 (ISN_c)。</li>
<li><strong>第二次握手：</strong> 服务器收到 <code>SYN</code> 包后，发送一个 <code>SYN-ACK</code> (Synchronize-Acknowledgement) 包作为响应。<code>SYN-ACK</code> 中包含服务器的初始序列号 (ISN_s) 和对客户端 <code>SYN</code> 包的确认号 (ACK_c &#x3D; ISN_c + 1)。</li>
<li><strong>第三次握手：</strong> 客户端收到 <code>SYN-ACK</code> 包后，发送一个 <code>ACK</code> (Acknowledgement) 包作为响应，确认收到服务器的 <code>SYN</code>。包中包含对服务器 <code>SYN</code> 包的确认号 (ACK_s &#x3D; ISN_s + 1)。</li>
</ul>
<p>至此，双方都确认了彼此能够发送和接收数据，连接建立成功。</p>
<h4 id="2-数据传输-Data-Transfer"><a href="#2-数据传输-Data-Transfer" class="headerlink" title="2. 数据传输 (Data Transfer)"></a>2. 数据传输 (Data Transfer)</h4><p>连接建立后，客户端和服务器可以开始互相发送和接收数据。这个阶段涉及到：</p>
<ul>
<li><strong>数据分段：</strong> 应用程序数据被 TCP 分割成较小的数据段 (Segment)。</li>
<li><strong>序列号和确认号：</strong> 每个数据段都有一个序列号，接收方会发送一个确认号，表示它已经收到了哪些数据，并期望接收下一个序列号的数据。</li>
<li><strong>滑动窗口：</strong> 允许发送方在收到所有确认之前发送多个数据段，提高效率。接收方通过窗口大小来告知发送方可以发送多少数据。</li>
<li><strong>重传机制：</strong> 如果数据包丢失或确认超时，发送方会重传。</li>
<li><strong>流量控制和拥塞控制：</strong> 动态调整发送速率以适应接收方处理能力和网络状况。</li>
</ul>
<h4 id="3-连接终止-Connection-Termination-四次挥手-Four-Way-Handshake"><a href="#3-连接终止-Connection-Termination-四次挥手-Four-Way-Handshake" class="headerlink" title="3. 连接终止 (Connection Termination) - 四次挥手 (Four-Way Handshake)"></a>3. 连接终止 (Connection Termination) - 四次挥手 (Four-Way Handshake)</h4><p>当数据传输完成时，双方需要协调关闭连接。由于 TCP 是全双工的（双方都可以独立发送和接收数据），所以它需要四步来确保双方都完成数据发送。</p>
<ul>
<li><strong>第一次挥手：</strong> 客户端发送一个 <code>FIN</code> (Finish) 包，表示它已经没有数据要发送了。</li>
<li><strong>第二次挥手：</strong> 服务器收到 <code>FIN</code> 包后，发送一个 <code>ACK</code> 包，确认收到客户端的关闭请求。此时，客户端到服务器的方向已经关闭，但服务器到客户端的方向仍然可以发送数据。</li>
<li><strong>第三次挥手：</strong> 服务器也发送一个 <code>FIN</code> 包，表示它也没有数据要发送了。</li>
<li><strong>第四次挥手：</strong> 客户端收到服务器的 <code>FIN</code> 包后，发送一个 <code>ACK</code> 包确认。然后进入 <code>TIME_WAIT</code> 状态，等待一段时间以确保服务器收到最后的 ACK。服务器收到最后的 ACK 后，连接彻底关闭。</li>
</ul>
<hr>
<h3 id="为什么说它是“面向连接”？"><a href="#为什么说它是“面向连接”？" class="headerlink" title="为什么说它是“面向连接”？"></a>为什么说它是“面向连接”？</h3><p>“面向连接”意味着在实际数据传输之前，通信双方必须先建立一个逻辑上的通道（连接）。这个通道在传输过程中一直存在，并且在数据传输完成后需要关闭。</p>
<p>这与“无连接”协议（如 UDP - User Datagram Protocol）形成对比。UDP 不需要握手，直接发送数据，不保证可靠性或顺序性，但开销更小，延迟更低。</p>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>TCP 连接可以理解为：通信双方之间建立的一条<strong>可靠的、双向的、经过协商</strong>的数据传输通道。这条通道通过复杂的机制（三次握手、四次挥手、序列号、确认号、滑动窗口、重传、流量控制、拥塞控制等）来保证数据的<strong>完整性、顺序性、不重复和不丢失</strong>，使得上层应用可以放心地进行数据交换，而无需关心底层的网络细节。</p>
<p>HTTP、FTP、SMTP 等许多我们日常使用的应用层协议都是基于 TCP 连接来传输数据的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Thanos%20Compactor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Thanos%20Compactor/" class="post-title-link" itemprop="url">Thanos Compactor</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:07:40" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Thanos/" itemprop="url" rel="index"><span itemprop="name">Thanos</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Compactor-组件"><a href="#Compactor-组件" class="headerlink" title="Compactor 组件"></a>Compactor 组件</h1><p>现在历史监控数据已经上传到对象存储中去了，但是由于监控数据量非常庞大，所以一般情况下我们会去安装一个 Thanos 的 Compactor 组件，用来将对象存储中的数据进行压缩。Compactor 组件只与对象存储交互，是唯一拥有删除对象存储数据权限的组件，主要有两个作用：压缩 block（将多个 block 合并成一个）、降采样（可禁用，5m&#x2F;1h 采样数据）。可设置数据保留时长，原始数据、5m&#x2F;1h 降采样数据可分别设置保留时长。</p>
<h2 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h2><p>Compactor 用于定时对远端对象存储中的历史数据块进行下采样，Compactor 会将小的存储块合并为大的存储块，提升在做大时间跨度查询时的速度。</p>
<p>下采样有三个主要的配置参数：</p>
<ul>
<li><code>--retention.resolution-raw</code>（单位：d，默认 0d）</li>
<li><code>--retention.resolution-5m</code>（单位：d，默认 0d）</li>
<li><code>--retention.resolution-1h</code>（单位：d，默认 0d）</li>
</ul>
<p>当开启 <code>raw</code> 之后，原有的历史数据会以该项所配置的时间长度保留于远端对象存储中，超过该时间的数据会被清理。<code>5m</code> 开启后会为每个存储时长大于 40 小时的块中开辟新的存储区域，将历史数据以 5 分钟为精度进行下采样，以该项所配置的时间长度存储于远端对象存储中。<code>1h</code> 开启后会为每个存储时长大于 10 天的块中开辟新的存储区域，将历史数据以 1 小时为间隔进行下采样，以该项所配置的时间长度存储于远端对象存储中。</p>
<p>下采样的实现方式是以外部标签为分组，以数据块为单位，以采样精度为取值区间在原有的数据块中取指标值保存到新建的下采样数据块中。这三种采样的数据都是独立存储，相当于存了三份数据，因此并不能起到压缩存储空间的作用。默认情况下值为 0d 表示永久保留下采样数据。如果需要关闭下采样，也可以在启动时附加 <code>--debug.disable-downsampling</code> 参数。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于 Compactor 的设计是非并发安全的，因此只能单例部署，一个 Bucket 也只允许运行一个 Compactor，每一个 Store Gateway 都需要配置一个 Bucket 桶，而一个 Bucket 只允许一个 Compactor，可以根据以下维度去划分 Bucket:</p>
<ul>
<li>结算方式</li>
<li>所在区域</li>
<li>所属业务</li>
<li>基础设施层级</li>
<li>单指标的横向拆分</li>
</ul>
<p>Compactor 组件的部署和 Store 非常类似，指定对象存储的配置文件即可，如下所示的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># thanos-compactor.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">thanos-compactor</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">thanos-compactor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">thanos-compactor</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">thanos-compactor</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">thanos-compactor</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">thanos</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">thanosio/thanos:v0.25.1</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;compact&#x27;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;--log.level=debug&#x27;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;--data-dir=/data&#x27;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;--objstore.config-file=/etc/secret/thanos.yaml&#x27;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;--wait&#x27;</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">10902</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">10902</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/-/healthy</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">10902</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/-/ready</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">object-storage-config</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/etc/secret</span></span><br><span class="line">              <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">object-storage-config</span></span><br><span class="line">          <span class="attr">secret:</span></span><br><span class="line">            <span class="attr">secretName:</span> <span class="string">thanos-objectstorage</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">thanos-compactor</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">thanos-compactor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">10902</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">thanos-compactor</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>



<p>最重要的还是提供对象存储的配置文件，然后直接创建上面的资源清单文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl apply -f https://p8s.io/docs/thanos/manifests/thanos-compactor.yaml</span><br><span class="line">☸ ➜ kubectl get pods -n kube-mon -l app=thanos-compactor</span><br><span class="line">NAME                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">thanos-compactor-0   1/1     Running   0          68s</span><br><span class="line">☸ ➜ kubectl get svc -n kube-mon -l app=thanos-compactor</span><br><span class="line">NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)           AGE</span><br><span class="line">thanos-compactor       NodePort    10.97.151.170    &lt;none&gt;        10902:32051/TCP   71s</span><br></pre></td></tr></table></figure>



<p>Compactor 同样也提供了一个 Web 界面，这里我们可以通过 NodePort 进行访问：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20220402152228.png" alt="thanos-compactor"></p>
<p>在页面中还可以对存储块进行管理，在右下角，我们可以标记删除一个存储块，也可以选择不对其进行降采样。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20220402153007.png" alt="thanos-compactor"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
