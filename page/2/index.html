<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hui&#39;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="六一">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Admission%20webhooks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Admission%20webhooks/" class="post-title-link" itemprop="url">Admission webhooks</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:21:26" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E6%8E%A7%E5%88%B6%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">控制器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="准入控制器"><a href="#准入控制器" class="headerlink" title="准入控制器"></a>准入控制器</h1><p>Kubernetes 提供了需要扩展其内置功能的方法，最常用的可能是自定义资源类型和自定义控制器了，除此之外，Kubernetes 还有一些其他非常有趣的功能，比如 <code>admission webhooks</code> 就可以用于扩展 API，用于修改某些 Kubernetes 资源的基本行为。</p>
<p>准入控制器是在<strong>对象持久化之前</strong>用于对 Kubernetes API Server 的请求进行拦截的代码段，在请求经过<strong>身份验证</strong>和<strong>授权之后</strong>放行通过。准入控制器可能正在 <code>validating</code>、<code>mutating</code> 或者都在执行，<code>Mutating</code> 控制器可以修改他们处理的资源对象，<code>Validating</code> 控制器不会，如果任何一个阶段中的任何控制器拒绝了请求，则会立即拒绝整个请求，并将错误返回给最终的用户。</p>
<p>这意味着有一些特殊的控制器可以拦截 Kubernetes API 请求，并根据自定义的逻辑修改或者拒绝它们。Kubernetes 有自己实现的一个控制器列表：<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do%EF%BC%8C%E5%BD%93%E7%84%B6%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%8C%E8%99%BD%E7%84%B6%E8%BF%99%E4%BA%9B%E6%8E%A7%E5%88%B6%E5%99%A8%E5%90%AC%E8%B5%B7%E6%9D%A5%E5%8A%9F%E8%83%BD%E6%AF%94%E8%BE%83%E5%BC%BA%E5%A4%A7%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E4%BA%9B%E6%8E%A7%E5%88%B6%E5%99%A8%E9%9C%80%E8%A6%81%E8%A2%AB%E7%BC%96%E8%AF%91%E8%BF%9B">https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do，当然你也可以编写自己的控制器，虽然这些控制器听起来功能比较强大，但是这些控制器需要被编译进</a> kube-apiserver，并且只能在 apiserver 启动时启动。</p>
<p>也可以直接使用 kube-apiserver 启动参数查看内置支持的控制器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kube-apiserver --help |grep enable-admission-plugins</span><br></pre></td></tr></table></figure>



<p>由于上面的控制器的限制，我们就需要用到<strong>动态</strong>的概念了，而不是和 apiserver 耦合在一起，<code>Admission webhooks</code> 就通过一种动态配置方法解决了这个限制问题。</p>
<h2 id="admission-webhook-是什么"><a href="#admission-webhook-是什么" class="headerlink" title="admission webhook 是什么?"></a>admission webhook 是什么?</h2><p>在 Kubernetes apiserver 中包含两个特殊的准入控制器：<code>MutatingAdmissionWebhook</code> 和<code>ValidatingAdmissionWebhook</code>，这两个控制器将发送准入请求到外部的 HTTP 回调服务并接收一个准入响应。如果启用了这两个准入控制器，Kubernetes 管理员可以在集群中创建和配置一个 admission webhook。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/t38f8v.png" alt="k8s api request lifecycle"></p>
<p>整体的步骤如下所示：</p>
<ul>
<li><ol>
<li>检查集群中是否启用了 admission webhook 控制器，并根据需要进行配置。</li>
</ol>
</li>
<li><ol>
<li>编写处理准入请求的 HTTP 回调，回调可以是一个部署在集群中的简单 HTTP 服务，甚至也可以是一个 <code>serverless</code> 函数。</li>
</ol>
</li>
<li><ol>
<li>通过 <code>MutatingWebhookConfiguration</code> 和 <code>ValidatingWebhookConfiguration</code> 资源配置 admission webhook。</li>
</ol>
</li>
</ul>
<p>这两种类型的 admission webhook 之间的区别是非常明显的：<code>validating webhooks</code> 可以拒绝请求，但是它们却不能修改准入请求中获取的对象，而 <code>mutating webhooks</code> 可以在返回准入响应之前通过创建补丁来修改对象，如果 webhook 拒绝了一个请求，则会向最终用户返回错误。</p>
<p>现在非常火热的 Service Mesh 应用 <code>istio</code> 就是通过 mutating webhooks 来自动将 <code>Envoy</code> 这个 sidecar 容器注入到 Pod 中去的：<a target="_blank" rel="noopener" href="https://istio.io/docs/setup/kubernetes/sidecar-injection/%E3%80%82">https://istio.io/docs/setup/kubernetes/sidecar-injection/。</a></p>
<h2 id="创建配置一个-Admission-Webhook"><a href="#创建配置一个-Admission-Webhook" class="headerlink" title="创建配置一个 Admission Webhook"></a>创建配置一个 Admission Webhook</h2><p>上面我们介绍了 Admission Webhook 的理论知识，接下来我们在一个真实的 Kubernetes 集群中来实际测试使用下，我们将创建一个 webhook 的 webserver，将其部署到集群中，然后创建 webhook 配置查看是否生效。</p>
<p>首先确保在 apiserver 中启用了 <code>MutatingAdmissionWebhook</code> 和 <code>ValidatingAdmissionWebhook</code> 这两个控制器，通过参数 <code>--enable-admission-plugins</code> 进行配置，当前 v1.22 版本已经内置默认开启了，如果没有开启则需要添加上这两个参数，然后重启 apiserver。</p>
<p>然后通过运行下面的命令检查集群中是否启用了准入注册 API：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl api-versions |grep admission</span><br><span class="line">admissionregistration.k8s.io/v1</span><br></pre></td></tr></table></figure>



<h3 id="编写-webhook"><a href="#编写-webhook" class="headerlink" title="编写 webhook"></a>编写 webhook</h3><p>满足了前面的先决条件后，接下来我们就来实现一个 webhook 示例，通过监听两个不同的 HTTP 端点（validate 和 mutate）来进行 <code>validating</code> 和 <code>mutating webhook</code> 验证。</p>
<p>这个 webhook 的完整代码可以在 Github 上获取：<a target="_blank" rel="noopener" href="https://github.com/cnych/admission-webhook-example%EF%BC%8C%E8%AF%A5%E4%BB%93%E5%BA%93">https://github.com/cnych/admission-webhook-example，该仓库</a> Fork 自项目 <a target="_blank" rel="noopener" href="https://github.com/banzaicloud/admission-webhook-example%E3%80%82%E8%BF%99%E4%B8%AA">https://github.com/banzaicloud/admission-webhook-example。这个</a> webhook 是一个简单的带 TLS 认证的 HTTP 服务，用 Deployment 方式部署在我们的集群中。</p>
<p>代码中主要的逻辑在两个文件中：<code>main.go</code> 和 <code>webhook.go</code>，main.go 文件包含创建 HTTP 服务的代码，而 webhook.go 包含 validates 和 mutates 两个 webhook 的逻辑，大部分代码都比较简单，首先查看 main.go 文件，查看如何使用标准 golang 包来启动 HTTP 服务，以及如何从命令行标志中读取 TLS 配置的证书：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag.StringVar(&amp;parameters.certFile, <span class="string">&quot;tlsCertFile&quot;</span>, <span class="string">&quot;/etc/webhook/certs/cert.pem&quot;</span>, <span class="string">&quot;File containing the x509 Certificate for HTTPS.&quot;</span>)</span><br><span class="line">flag.StringVar(&amp;parameters.keyFile, <span class="string">&quot;tlsKeyFile&quot;</span>, <span class="string">&quot;/etc/webhook/certs/key.pem&quot;</span>, <span class="string">&quot;File containing the x509 private key to --tlsCertFile.&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>然后一个比较重要的是 serve 函数，用来处理传入的 mutate 和 validating 函数 的 HTTP 请求。该函数从请求中反序列化 <code>AdmissionReview</code> 对象，执行一些基本的内容校验，根据 URL 路径调用相应的 mutate 和 validate 函数，然后序列化 AdmissionReview 对象：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(whsvr *WebhookServer)</span></span> serve(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">var</span> body []<span class="type">byte</span></span><br><span class="line">    <span class="keyword">if</span> r.Body != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> data, err := ioutil.ReadAll(r.Body); err == <span class="literal">nil</span> &#123;</span><br><span class="line">            body = data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(body) == <span class="number">0</span> &#123;</span><br><span class="line">        glog.Error(<span class="string">&quot;empty body&quot;</span>)</span><br><span class="line">        http.Error(w, <span class="string">&quot;empty body&quot;</span>, http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验 Content-Type</span></span><br><span class="line">    contentType := r.Header.Get(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> contentType != <span class="string">&quot;application/json&quot;</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;Content-Type=%s, expect application/json&quot;</span>, contentType)</span><br><span class="line">        http.Error(w, <span class="string">&quot;invalid Content-Type, expect `application/json`&quot;</span>, http.StatusUnsupportedMediaType)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> admissionResponse *v1beta1.AdmissionResponse</span><br><span class="line">    ar := v1beta1.AdmissionReview&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> _, _, err := deserializer.Decode(body, <span class="literal">nil</span>, &amp;ar); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;Can&#x27;t decode body: %v&quot;</span>, err)</span><br><span class="line">        admissionResponse = &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">            Result: &amp;metav1.Status&#123;</span><br><span class="line">                Message: err.Error(),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.URL.Path == <span class="string">&quot;/mutate&quot;</span> &#123;</span><br><span class="line">            admissionResponse = whsvr.mutate(&amp;ar)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> r.URL.Path == <span class="string">&quot;/validate&quot;</span> &#123;</span><br><span class="line">            admissionResponse = whsvr.validate(&amp;ar)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    admissionReview := v1beta1.AdmissionReview&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> admissionResponse != <span class="literal">nil</span> &#123;</span><br><span class="line">        admissionReview.Response = admissionResponse</span><br><span class="line">        <span class="keyword">if</span> ar.Request != <span class="literal">nil</span> &#123;</span><br><span class="line">            admissionReview.Response.UID = ar.Request.UID</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resp, err := json.Marshal(admissionReview)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;Can&#x27;t encode response: %v&quot;</span>, err)</span><br><span class="line">        http.Error(w, fmt.Sprintf(<span class="string">&quot;could not encode response: %v&quot;</span>, err), http.StatusInternalServerError)</span><br><span class="line">    &#125;</span><br><span class="line">    glog.Infof(<span class="string">&quot;Ready to write reponse ...&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> _, err := w.Write(resp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;Can&#x27;t write response: %v&quot;</span>, err)</span><br><span class="line">        http.Error(w, fmt.Sprintf(<span class="string">&quot;could not write response: %v&quot;</span>, err), http.StatusInternalServerError)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>主要的准入逻辑是 validate 和 mutate 两个函数。validate 函数检查资源对象是否需要校验：不验证 kube-system 和 kube-public 两个命名空间中的资源，如果想要显示的声明不验证某个资源，可以通过在资源对象中添加一个 <code>admission-webhook-example.qikqiak.com/validate=false</code> 的 annotation 进行声明。如果需要验证，则根据资源类型的 kind，和标签与其对应项进行比较，将 service 或者 deployment 资源从请求中反序列化出来。如果缺少某些 label 标签，则响应中的 Allowed 会被设置为 false。如果验证失败，则会在响应中写入失败原因，最终用户在尝试创建资源时会收到失败的信息。validate 函数实现如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// validate deployments and services</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(whsvr *WebhookServer)</span></span> validate(ar *v1beta1.AdmissionReview) *v1beta1.AdmissionResponse &#123;</span><br><span class="line">    req := ar.Request</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        availableLabels                 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">        objectMeta                      *metav1.ObjectMeta</span><br><span class="line">        resourceNamespace, resourceName <span class="type">string</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    glog.Infof(<span class="string">&quot;AdmissionReview for Kind=%v, Namespace=%v Name=%v (%v) UID=%v patchOperation=%v UserInfo=%v&quot;</span>,</span><br><span class="line">        req.Kind, req.Namespace, req.Name, resourceName, req.UID, req.Operation, req.UserInfo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> req.Kind.Kind &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Deployment&quot;</span>:</span><br><span class="line">        <span class="keyword">var</span> deployment appsv1.Deployment</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(req.Object.Raw, &amp;deployment); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">&quot;Could not unmarshal raw object: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">                Result: &amp;metav1.Status&#123;</span><br><span class="line">                    Message: err.Error(),</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resourceName, resourceNamespace, objectMeta = deployment.Name, deployment.Namespace, &amp;deployment.ObjectMeta</span><br><span class="line">        availableLabels = deployment.Labels</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Service&quot;</span>:</span><br><span class="line">        <span class="keyword">var</span> service corev1.Service</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(req.Object.Raw, &amp;service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">&quot;Could not unmarshal raw object: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">                Result: &amp;metav1.Status&#123;</span><br><span class="line">                    Message: err.Error(),</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resourceName, resourceNamespace, objectMeta = service.Name, service.Namespace, &amp;service.ObjectMeta</span><br><span class="line">        availableLabels = service.Labels</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !validationRequired(ignoredNamespaces, objectMeta) &#123;</span><br><span class="line">        glog.Infof(<span class="string">&quot;Skipping validation for %s/%s due to policy check&quot;</span>, resourceNamespace, resourceName)</span><br><span class="line">        <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">            Allowed: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allowed := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> result *metav1.Status</span><br><span class="line">    glog.Info(<span class="string">&quot;available labels:&quot;</span>, availableLabels)</span><br><span class="line">    glog.Info(<span class="string">&quot;required labels&quot;</span>, requiredLabels)</span><br><span class="line">    <span class="keyword">for</span> _, rl := <span class="keyword">range</span> requiredLabels &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := availableLabels[rl]; !ok &#123;</span><br><span class="line">            allowed = <span class="literal">false</span></span><br><span class="line">            result = &amp;metav1.Status&#123;</span><br><span class="line">                Reason: <span class="string">&quot;required labels are not set&quot;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">        Allowed: allowed,</span><br><span class="line">        Result:  result,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>判断是否需要进行校验的方法如下，可以通过 namespace 进行忽略，也可以通过 annotations 设置进行配置：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validationRequired</span><span class="params">(ignoredList []<span class="type">string</span>, metadata *metav1.ObjectMeta)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    required := admissionRequired(ignoredList, admissionWebhookAnnotationValidateKey, metadata)</span><br><span class="line">    glog.Infof(<span class="string">&quot;Validation policy for %v/%v: required:%v&quot;</span>, metadata.Namespace, metadata.Name, required)</span><br><span class="line">    <span class="keyword">return</span> required</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">admissionRequired</span><span class="params">(ignoredList []<span class="type">string</span>, admissionAnnotationKey <span class="type">string</span>, metadata *metav1.ObjectMeta)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// skip special kubernetes system namespaces</span></span><br><span class="line">    <span class="keyword">for</span> _, namespace := <span class="keyword">range</span> ignoredList &#123;</span><br><span class="line">        <span class="keyword">if</span> metadata.Namespace == namespace &#123;</span><br><span class="line">            glog.Infof(<span class="string">&quot;Skip validation for %v for it&#x27;s in special namespace:%v&quot;</span>, metadata.Name, metadata.Namespace)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    annotations := metadata.GetAnnotations()</span><br><span class="line">    <span class="keyword">if</span> annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">        annotations = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> required <span class="type">bool</span></span><br><span class="line">    <span class="keyword">switch</span> strings.ToLower(annotations[admissionAnnotationKey]) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        required = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;n&quot;</span>, <span class="string">&quot;no&quot;</span>, <span class="string">&quot;false&quot;</span>, <span class="string">&quot;off&quot;</span>:</span><br><span class="line">        required = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> required</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>mutate 函数的代码是非常类似的，但不是仅仅比较标签并在响应中设置 Allowed，而是创建一个补丁，将缺失的标签添加到资源中，并将 not_available 设置为标签的值。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main mutation process</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(whsvr *WebhookServer)</span></span> mutate(ar *v1beta1.AdmissionReview) *v1beta1.AdmissionResponse &#123;</span><br><span class="line">    req := ar.Request</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        availableLabels, availableAnnotations <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">        objectMeta                            *metav1.ObjectMeta</span><br><span class="line">        resourceNamespace, resourceName       <span class="type">string</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    glog.Infof(<span class="string">&quot;AdmissionReview for Kind=%v, Namespace=%v Name=%v (%v) UID=%v patchOperation=%v UserInfo=%v&quot;</span>,</span><br><span class="line">        req.Kind, req.Namespace, req.Name, resourceName, req.UID, req.Operation, req.UserInfo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> req.Kind.Kind &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Deployment&quot;</span>:</span><br><span class="line">        <span class="keyword">var</span> deployment appsv1.Deployment</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(req.Object.Raw, &amp;deployment); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">&quot;Could not unmarshal raw object: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">                Result: &amp;metav1.Status&#123;</span><br><span class="line">                    Message: err.Error(),</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resourceName, resourceNamespace, objectMeta = deployment.Name, deployment.Namespace, &amp;deployment.ObjectMeta</span><br><span class="line">        availableLabels = deployment.Labels</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Service&quot;</span>:</span><br><span class="line">        <span class="keyword">var</span> service corev1.Service</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(req.Object.Raw, &amp;service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">&quot;Could not unmarshal raw object: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">                Result: &amp;metav1.Status&#123;</span><br><span class="line">                    Message: err.Error(),</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resourceName, resourceNamespace, objectMeta = service.Name, service.Namespace, &amp;service.ObjectMeta</span><br><span class="line">        availableLabels = service.Labels</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !mutationRequired(ignoredNamespaces, objectMeta) &#123;</span><br><span class="line">        glog.Infof(<span class="string">&quot;Skipping validation for %s/%s due to policy check&quot;</span>, resourceNamespace, resourceName)</span><br><span class="line">        <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">            Allowed: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    annotations := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;admissionWebhookAnnotationStatusKey: <span class="string">&quot;mutated&quot;</span>&#125;</span><br><span class="line">    patchBytes, err := createPatch(availableAnnotations, annotations, availableLabels, addLabels)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">            Result: &amp;metav1.Status&#123;</span><br><span class="line">                Message: err.Error(),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glog.Infof(<span class="string">&quot;AdmissionResponse: patch=%v\n&quot;</span>, <span class="type">string</span>(patchBytes))</span><br><span class="line">    <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">        Allowed: <span class="literal">true</span>,</span><br><span class="line">        Patch:   patchBytes,</span><br><span class="line">        PatchType: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> *v1beta1.PatchType &#123;</span><br><span class="line">            pt := v1beta1.PatchTypeJSONPatch</span><br><span class="line">            <span class="keyword">return</span> &amp;pt</span><br><span class="line">        &#125;(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>其实我们已经将代码打包成一个 docker 镜像了，你可以直接使用，镜像仓库地址为：<code>cnych/admission-webhook-example:v1</code>。当然如果你希望更改部分代码，那就需要重新构建项目了，由于这个项目采用 go 语言开发，包管理工具更改为了 <code>go mod</code>，所以我们需要确保构建环境提前安装好 go 环境，当然 docker 也是必不可少的，因为我们需要的是打包成一个 docker 镜像。</p>
<p>获取项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir admission-webhook &amp;&amp; cd admission-webhook</span><br><span class="line">git clone https://github.com/cnych/admission-webhook-example.git</span><br></pre></td></tr></table></figure>



<p>我们可以看到代码根目录下面有一个 build 的脚本，只需要提供我们自己的 docker 镜像用户名然后直接构建即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_USER=cnych</span><br><span class="line">./build</span><br></pre></td></tr></table></figure>



<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>为了部署 webhook server，我们需要在我们的 Kubernetes 集群中创建一个 service 和 deployment 资源对象，部署是非常简单的，只是需要配置服务的 TLS 配置。我们可以在代码根目录下面的 deployment 文件夹下面查看 <code>deployment.yaml</code> 文件中关于证书的配置声明，会发现从命令行参数中读取的证书和私钥文件是通过一个 secret 对象挂载进来的：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-tlsCertFile=/etc/webhook/certs/cert.pem</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-tlsKeyFile=/etc/webhook/certs/key.pem</span></span><br><span class="line">[<span class="string">...</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">webhook-certs</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/etc/webhook/certs</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">webhook-certs</span></span><br><span class="line">  <span class="attr">secret:</span></span><br><span class="line">  <span class="attr">secretName:</span> <span class="string">admission-webhook-example-certs</span></span><br></pre></td></tr></table></figure>



<p>在生产环境中，对于 TLS 证书（特别是私钥）的处理是非常重要的，我们可以使用类似于 <code>cert-manager</code> 之类的工具来自动处理 TLS 证书，或者将私钥密钥存储在 Vault 中，而不是直接存在 secret 资源对象中。</p>
<p>我们可以使用任何类型的证书，但是需要注意的是我们这里设置的 CA 证书是需要让 apiserver 能够验证的，我们这里可以重用 Istio 项目中的生成的证书签名请求脚本。通过发送请求到 apiserver，获取认证信息，然后使用获得的结果来创建需要的 secret 对象。</p>
<p>首先，<a target="_blank" rel="noopener" href="https://github.com/cnych/admission-webhook-example/blob/master/deployment/webhook-create-signed-cert.sh">运行该脚本</a>检查 secret 对象中是否有证书和私钥信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ./deployment/webhook-create-signed-cert.sh</span><br><span class="line">creating certs in tmpdir /var/folders/x3/wjy_1z155pdf8jg_jgpmf6kc0000gn/T/tmp.IboFfX97</span><br><span class="line">Generating RSA private key, 2048 bit long modulus (2 primes)</span><br><span class="line">..................+++++</span><br><span class="line">........+++++</span><br><span class="line">e is 65537 (0x010001)</span><br><span class="line">certificatesigningrequest.certificates.k8s.io/admission-webhook-example-svc.default created</span><br><span class="line">NAME                                    AGE   REQUESTOR          CONDITION</span><br><span class="line">admission-webhook-example-svc.default   1s    kubernetes-admin   Pending</span><br><span class="line">certificatesigningrequest.certificates.k8s.io/admission-webhook-example-svc.default approved</span><br><span class="line">secret/admission-webhook-example-certs created</span><br><span class="line"></span><br><span class="line">➜  ~ kubectl get secret admission-webhook-example-certs</span><br><span class="line">NAME                              TYPE     DATA   AGE</span><br><span class="line">admission-webhook-example-certs   Opaque   2      28s</span><br></pre></td></tr></table></figure>



<p>一旦 secret 对象创建成功，我们就可以直接创建 deployment 和 service 对象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/rbac.yaml</span><br><span class="line">➜  ~ kubectl apply -f deployment/deployment.yaml</span><br><span class="line">deployment.apps &quot;admission-webhook-example-deployment&quot; created</span><br><span class="line"></span><br><span class="line">➜  ~ kubectl apply -f deployment/service.yaml</span><br><span class="line">service &quot;admission-webhook-example-svc&quot; created</span><br></pre></td></tr></table></figure>



<h3 id="配置-webhook"><a href="#配置-webhook" class="headerlink" title="配置 webhook"></a>配置 webhook</h3><p>现在我们的 webhook 服务运行起来了，它可以接收来自 apiserver 的请求。但是我们还需要在 kubernetes 上创建一些配置资源。首先来配置 validating 这个 webhook，查看 webhook 配置，我们会注意到它里面包含一个 <code>CA_BUNDLE</code> 的占位符：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clientConfig:</span><br><span class="line">  service:</span><br><span class="line">        name: admission-webhook-example-svc</span><br><span class="line">        namespace: default</span><br><span class="line">        path: &quot;/validate&quot;</span><br><span class="line">    caBundle: $&#123;CA_BUNDLE&#125;</span><br></pre></td></tr></table></figure>



<p>CA 证书应提供给 admission webhook 配置，这样 apiserver 才可以信任 webhook server 提供的 TLS 证书。因为我们上面已经使用 Kubernetes API 签署了证书，所以我们可以使用我们的 kubeconfig 中的 CA 证书来简化操作。代码仓库中也提供了一个小脚本用来替换 CA_BUNDLE 这个占位符，创建 <code>validating webhook</code> 之前运行该命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ./deployment/validatingwebhook.yaml | ./deployment/webhook-patch-ca-bundle.sh &gt; ./deployment/validatingwebhook-ca-bundle.yaml</span><br></pre></td></tr></table></figure>



<p>执行完成后可以查看 <code>validatingwebhook-ca-bundle.yaml</code> 文件中的 <code>CA_BUNDLE</code> 占位符的值是否已经被替换掉了。需要注意的是 <code>clientConfig</code> 里面的 path 路径是 <code>/validate</code>，因为我们代码在是将 validate 和 mutate 集成在一个服务中的。</p>
<p>然后就是需要配置一些 RBAC 规则，我们想在 deployment 或 service 创建时拦截 API 请求，所以 apiGroups 和 apiVersions 对应的值分别为 <code>apps/v1</code> 对应 deployment，v1 对应 service。</p>
<p>webhook 的最后一部分是配置一个 <code>namespaceSelector</code>，我们可以为 webhook 工作的命名空间定义一个 selector，这个配置不是必须的，比如我们这里添加了下面的配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespaceSelector:</span><br><span class="line">  matchLabels:</span><br><span class="line">      admission-webhook-example: enabled</span><br></pre></td></tr></table></figure>



<p>则我们的 webhook 会只适用于设置了 <code>admission-webhook-example=enabled</code> 标签的 namespaces。</p>
<p>所以，首先需要在 default 这个 namespace 中添加该标签：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl label namespace default admission-webhook-example=enabled</span><br><span class="line">namespace &quot;default&quot; labeled</span><br></pre></td></tr></table></figure>



<p>最后，创建这个 validating webhook 配置对象，这会动态地将 webhook 添加到 webhook 链上，所以一旦创建资源，就会拦截请求然后调用我们的 webhook 服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/validatingwebhook-ca-bundle.yaml</span><br><span class="line">validatingwebhookconfiguration.admissionregistration.k8s.io &quot;validation-webhook-example-cfg&quot; created</span><br></pre></td></tr></table></figure>



<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>现在让我们创建一个 deployment 资源来验证下是否有效，代码仓库下有一个 <code>sleep.yaml</code> 的资源清单文件，直接创建即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/sleep.yaml</span><br><span class="line">Error from server (required labels are not set): error when creating &quot;deployment/sleep.yaml&quot;: admission webhook &quot;required-labels.qikqiak.com&quot; denied the request: required labels are not set</span><br></pre></td></tr></table></figure>



<p>正常情况下创建的时候会出现上面的错误信息，然后部署另外一个 <code>sleep-with-labels.yaml</code> 的资源清单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/sleep-with-labels.yaml</span><br><span class="line">deployment.apps &quot;sleep&quot; created</span><br></pre></td></tr></table></figure>



<p>可以看到可以正常部署，然后我们将上面的 deployment 删除，然后部署另外一个 <code>sleep-no-validation.yaml</code> 资源清单，该清单中不存在所需的标签，但是配置了 <code>admission-webhook-example.qikqiak.com/validate=false</code> 这样的 annotation，所以正常也是可以正常创建的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl delete deployment sleep</span><br><span class="line">➜  ~ kubectl apply -f deployment/sleep-no-validation.yaml</span><br><span class="line">deployment.apps &quot;sleep&quot; created</span><br></pre></td></tr></table></figure>



<h3 id="部署-mutating-webhook"><a href="#部署-mutating-webhook" class="headerlink" title="部署 mutating webhook"></a>部署 mutating webhook</h3><p>首先，我们将上面的 <code>validating webhook</code> 删除，防止对 mutating 产生干扰，然后部署新的配置。 <code>mutating webhook</code> 与 <code>validating webhook</code> 配置基本相同，但是 webook server 的路径是 <code>/mutate</code>，同样的我们也需要先填充上 <code>CA_BUNDLE</code> 这个占位符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl delete validatingwebhookconfiguration validation-webhook-example-cfg</span><br><span class="line">validatingwebhookconfiguration.admissionregistration.k8s.io &quot;validation-webhook-example-cfg&quot; deleted</span><br><span class="line"></span><br><span class="line">➜  ~ cat ./deployment/mutatingwebhook.yaml | ./deployment/webhook-patch-ca-bundle.sh &gt; ./deployment/mutatingwebhook-ca-bundle.yaml</span><br><span class="line"></span><br><span class="line">➜  ~ kubectl apply -f deployment/mutatingwebhook-ca-bundle.yaml</span><br><span class="line">mutatingwebhookconfiguration.admissionregistration.k8s.io &quot;mutating-webhook-example-cfg&quot; created</span><br></pre></td></tr></table></figure>



<p>现在我们可以再次部署上面的 sleep 应用程序，然后查看是否正确添加 label 标签：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/sleep.yaml</span><br><span class="line">deployment.apps &quot;sleep&quot; created</span><br><span class="line"></span><br><span class="line">➜  ~ kubectl get deploy sleep -o yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    admission-webhook-example.qikqiak.com/status: mutated</span><br><span class="line">    deployment.kubernetes.io/revision: &quot;1&quot;</span><br><span class="line">  creationTimestamp: &quot;2020-06-01T08:10:04Z&quot;</span><br><span class="line">  generation: 1</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/component: not_available</span><br><span class="line">    app.kubernetes.io/instance: not_available</span><br><span class="line">    app.kubernetes.io/managed-by: not_available</span><br><span class="line">    app.kubernetes.io/name: not_available</span><br><span class="line">    app.kubernetes.io/part-of: not_available</span><br><span class="line">    app.kubernetes.io/version: not_available</span><br><span class="line">  name: sleep</span><br><span class="line">  namespace: default</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>最后，我们重新创建 <code>validating webhook</code>，来一起测试。现在，尝试再次创建 sleep 应用。正常是可以创建成功的，我们可以查看下 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-are-they">admission-controllers 的文档</a>。</p>
<p>准入控制分两个阶段进行，第一阶段，运行 <code>mutating admission</code> 控制器，第二阶段运行 <code>validating admission</code> 控制器。</p>
<p>所以 <code>mutating webhook</code> 在第一阶段添加上缺失的 labels 标签，然后 <code>validating webhook</code> 在第二阶段就不会拒绝这个 deployment 了，因为标签已经存在了，用 <code>not_available</code> 设置他们的值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/validatingwebhook-ca-bundle.yaml</span><br><span class="line">validatingwebhookconfiguration.admissionregistration.k8s.io &quot;validation-webhook-example-cfg&quot; created</span><br><span class="line"></span><br><span class="line">➜  ~ kubectl apply -f deployment/sleep.yaml</span><br><span class="line">deployment.apps &quot;sleep&quot; created</span><br></pre></td></tr></table></figure>



<p>但是如果我们有这样的相关需求就单独去开发一个准入控制器的 webhook 是不是就显得非常麻烦，不够灵活了，为了解决这个问题我们可以使用 Kubernetes 提供的一些策略管理引擎，在不需要编写代码的情况也可以来实现我们的这些需求，比如 <code>Kyverno</code>、<code>Gatekeeper</code> 等等，后续我们再进行详细讲解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/BGP%20%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/BGP%20%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">BGP 协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:24:40" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是-BGP-Border-Gateway-Protocol-？"><a href="#什么是-BGP-Border-Gateway-Protocol-？" class="headerlink" title="什么是 BGP (Border Gateway Protocol)？"></a>什么是 BGP (Border Gateway Protocol)？</h3><p>BGP (Border Gateway Protocol)，即<strong>边界网关协议</strong>，是互联网上<strong>路由选择的核心协议</strong>，也被称为“互联网的胶水”或“互联网的骨干”。它是一种<strong>外部网关协议 (EGP)<strong>，用于在</strong>自治系统 (Autonomous System, AS)</strong> 之间交换路由信息，从而实现全球互联网的互联互通。</p>
<p><strong>核心概念：</strong></p>
<ul>
<li><strong>自治系统 (AS)：</strong> 互联网上一个由单一行政实体或组织控制的、拥有统一路由策略的 IP 网络集合。每个 AS 都被分配一个唯一的 16 位或 32 位的数字，称为 **AS 号 (ASN)**。例如，大型的互联网服务提供商 (ISP)、大学网络、大型企业网络等都可能是一个 AS。</li>
<li><strong>路由：</strong> 数据包从源头到达目的地的路径选择过程。</li>
<li><strong>外部网关协议 (EGP)：</strong> 指在不同自治系统之间交换路由信息的协议。</li>
<li><strong>内部网关协议 (IGP)：</strong> 指在同一个自治系统内部交换路由信息的协议，例如 OSPF、EIGRP、RIP 等。</li>
</ul>
<p>BGP 的主要目标是确保数据包能够从全球任何一个 AS 发送到另一个 AS，并找到最佳的（或符合策略的）路径。</p>
<h3 id="BGP-的工作原理概述："><a href="#BGP-的工作原理概述：" class="headerlink" title="BGP 的工作原理概述："></a>BGP 的工作原理概述：</h3><p>BGP 是一种<strong>路径矢量路由协议 (Path-Vector Routing Protocol)<strong>。与距离矢量协议（如 RIP）或链路状态协议（如 OSPF）不同，BGP 在路由更新中不仅包含到达目的地的距离信息，还包含了</strong>到达目的地的完整 AS 路径信息</strong>。</p>
<ol>
<li><p><strong>BGP Peerings (对等体关系)：</strong> BGP 路由器之间需要建立 TCP 连接（端口 179）来交换路由信息。这些相互连接的 BGP 路由器被称为 BGP 对等体 (peers) 或 BGP 发言人 (speakers)。</p>
<ul>
<li><strong>eBGP (external BGP)：</strong> 不同 AS 之间的 BGP 对等体关系。这是 BGP 的主要应用场景，用于在互联网服务提供商之间和客户网络之间交换路由信息。</li>
<li><strong>iBGP (internal BGP)：</strong> 同一 AS 内部的 BGP 对等体关系。用于在 AS 内部的所有路由器之间同步从外部学到的路由信息，确保 AS 内部对外部路由的一致视图。</li>
</ul>
</li>
<li><p><strong>路由信息交换：</strong></p>
<ul>
<li>BGP 路由器会周期性地交换完整的路由表（或在路由发生变化时发送增量更新）。</li>
<li>每个 BGP 更新消息都包含：<ul>
<li><strong>网络前缀：</strong> 目的地网络的 IP 地址范围。</li>
<li><strong>Next-Hop：</strong> 到达该网络前缀的下一跳 IP 地址。</li>
<li><strong>AS Path (AS 路径)：</strong> 这是一个有序的 AS 号列表，表示数据包将经过哪些 AS 才能到达目的地。例如，<code>AS65000 AS64512 AS100</code> 表示数据包将从 AS65000 经过 AS64512 再到达 AS100。</li>
<li><strong>BGP Attributes (BGP 属性)：</strong> 一系列额外的属性，用于影响路由选择过程和策略。例如：<ul>
<li><code>Local Preference</code> (本地优先级)：在 AS 内部选择离开本 AS 的最佳路径。</li>
<li><code>MED (Multi-Exit Discriminator)</code>：向邻居 AS 建议选择进入本 AS 的最佳入口点。</li>
<li><code>Origin</code> (起源)：说明路由信息是如何起源的（IGP、EGP 或不确定）。</li>
<li><code>Community</code> (共同体)：自定义标签，用于共享和应用策略。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>路由选择：</strong> 当 BGP 路由器有多个到达同一个目的地的路径时，它会根据一套复杂的<strong>路由选择算法</strong>（也称为 BGP 决策过程）来选择最佳路径。这个算法考虑了大量的 BGP 属性，包括：</p>
<ul>
<li><code>Next-Hop</code> 可达性（必须可达）</li>
<li><code>Local Preference</code> (越高越好)</li>
<li><code>AS Path</code> 长度（越短越好，经过的 AS 越少）</li>
<li><code>Origin</code> 类型</li>
<li><code>MED</code> (越低越好)</li>
<li>BGP Peerings 类型 (iBGP vs eBGP)</li>
<li>其他更细致的属性和规则。</li>
<li><strong>策略路由：</strong> BGP 的独特之处在于它高度依赖并支持<strong>策略路由</strong>。AS 可以根据自身的商业协议、成本、带宽等因素，而非仅仅基于最短路径，来控制流量的进出。例如，ISP 可能更倾向于将流量发送给其付费客户，而不是免费对等方。</li>
</ul>
</li>
</ol>
<h3 id="BGP-在互联网中的作用："><a href="#BGP-在互联网中的作用：" class="headerlink" title="BGP 在互联网中的作用："></a>BGP 在互联网中的作用：</h3><p>BGP 在互联网中扮演着不可或缺的角色，其作用主要体现在以下几个方面：</p>
<ol>
<li><p><strong>互联网的全球互联互通：</strong> BGP 是互联网得以成为“网络之网络”的基础。它允许全球数万个独立的自治系统相互交换路由信息，确保数据包能够跨越不同的网络边界，从地球的一端到达另一端。没有 BGP，互联网将只是一堆孤立的网络。</p>
</li>
<li><p><strong>实现路由的可靠性和冗余：</strong></p>
<ul>
<li>BGP 允许 AS 拥有多个连接到其他 AS 的路径。当一条路径失效时，BGP 能够快速学习到新的可用路径，从而实现路由的<strong>冗余和故障转移</strong>。</li>
<li>通过 BGP，不同的 ISP 可以互联，即使某个 ISP 的骨干网络出现故障，流量也可以通过其他 ISP 的路径继续传输到目的地。</li>
</ul>
</li>
<li><p><strong>支持大规模路由表：</strong> 互联网的路由表非常庞大（目前包含数十万条路由前缀）。BGP 经过优化，能够高效地处理和维护这种规模的路由信息，避免路由黑洞或环路。</p>
</li>
<li><p><strong>实现路由策略和商业需求：</strong></p>
<ul>
<li>这是 BGP 最核心也是最复杂的功能。BGP 允许 AS 根据其**商业关系 (客户、提供商、对等方)**、成本、带宽、地理位置等因素，对流量的进出进行细粒度的控制。</li>
<li><strong>流量工程：</strong> AS 可以通过操纵 BGP 属性（如 AS Path Prepending, Local Preference, MED），引导流量按照期望的路径通过或离开其网络。例如，一个 ISP 可以选择优先从其“提供商”那里接收免费流量，而不是从“对等方”那里接收同样的数据。</li>
<li><strong>多宿主 (Multihoming)：</strong> 企业或组织可以通过连接到多个 ISP，使用 BGP 实现多宿主。这不仅提供了互联网连接的冗余，还可以根据 BGP 策略选择更优的出口&#x2F;入口（例如，选择延迟更低的 ISP，或根据负载均衡）。</li>
</ul>
</li>
<li><p><strong>防止路由环路：</strong> AS Path 属性是 BGP 防止环路的关键机制。当一个 BGP 路由器收到一个路由更新时，如果 AS Path 中包含了自己的 AS 号，它就会丢弃这条路由，从而有效避免数据包在 AS 之间无限循环。</p>
</li>
</ol>
<p><strong>简而言之，BGP 不仅仅是指导数据包如何从 A 到 B，更是互联网世界中各个“国家”（自治系统）之间进行“外交”和“交通”的桥梁和规则集。它以一种高度可配置和策略驱动的方式，确保了互联网的全球连通性、弹性和商业运作。</strong></p>
<h3 id="BGP-的挑战："><a href="#BGP-的挑战：" class="headerlink" title="BGP 的挑战："></a>BGP 的挑战：</h3><p>尽管 BGP 至关重要，但它也面临一些挑战：</p>
<ul>
<li><strong>配置复杂性：</strong> BGP 的配置非常复杂，需要专业的网络工程师进行管理，错误的配置可能导致严重的网络中断。</li>
<li><strong>路由劫持 (Route Hijacking)：</strong> 错误的或恶意的 BGP 路由通告可能导致特定 IP 地址段的流量被重定向到错误的网络，造成服务中断或数据窃取。这是互联网安全领域的一个重要威胁。</li>
<li><strong>路由膨胀：</strong> 全球路由表持续增长，对路由器内存和处理能力构成挑战。</li>
<li><strong>收敛时间：</strong> 在大规模网络事件发生时，BGP 收敛（即所有路由器都更新到最新的路由信息）可能需要一定时间，期间可能导致流量中断。</li>
</ul>
<p>为了应对这些挑战，社区一直在努力开发和部署 BGP 安全扩展 (如 BGPsec、ROA 等)，以增强 BGP 的信任和安全。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/CGroups%20%E4%B8%8E%20Namespaces/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/CGroups%20%E4%B8%8E%20Namespaces/" class="post-title-link" itemprop="url">CGroups 与 Namespaces</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:25:19" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/" itemprop="url" rel="index"><span itemprop="name">容器运行时</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CGroups-与-Namespaces"><a href="#CGroups-与-Namespaces" class="headerlink" title="CGroups 与 Namespaces"></a>CGroups 与 Namespaces</h1><p>本节我们来一起了解下容器背后的两个核心技术：CGroups 和 Namespace。</p>
<h2 id="CGroups-概述"><a href="#CGroups-概述" class="headerlink" title="CGroups 概述"></a>CGroups 概述</h2><p><code>CGroups</code> 全称为 <code>Linux Control Group</code>，其作用是限制一组进程使用的资源（CPU、内存等）上限，<code>CGroups</code> 也是 Containerd 容器技术的核心实现原理之一，首先我们需要先了解几个 <code>CGroups</code> 的基本概念：</p>
<ul>
<li>Task: 在 cgroup 中，task 可以理解为一个进程，但这里的进程和一般意义上的操作系统进程不太一样，实际上是进程 ID 和线程 ID 列表。</li>
<li>CGroup: 即控制组，一个控制组就是一组按照某种标准划分的 Tasks，可以理解为资源限制是以进程组为单位实现的，一个进程加入到某个控制组后，就会受到相应配置的资源限制。</li>
<li>Hierarchy: cgroup 的层级组织关系，cgroup 以树形层级组织，每个 cgroup 子节点默认继承其父 cgroup 节点的配置属性，这样每个 Hierarchy 在初始化会有 root cgroup。</li>
<li>Subsystem: 即子系统，子系统表示具体的资源配置，如 CPU 使用，内存占用等，Subsystem 附加到 Hierarchy 上后可用。</li>
</ul>
<p><code>CGroups</code> 支持的子系统包含以下几类，即为每种可以控制的资源定义了一个子系统:</p>
<ul>
<li><code>cpuset</code>: 为 cgroup 中的进程分配单独的 CPU 节点，即可以绑定到特定的 CPU</li>
<li><code>cpu</code>: 限制 cgroup 中进程的 CPU 使用份额</li>
<li><code>cpuacct</code>: 统计 cgroup 中进程的 CPU 使用情况</li>
<li><code>memory</code>: 限制 cgroup 中进程的内存使用,并能报告内存使用情况</li>
<li><code>devices</code>: 控制 cgroup 中进程能访问哪些文件设备(设备文件的创建、读写)</li>
<li><code>freezer</code>: 挂起或恢复 cgroup 中的 task</li>
<li><code>net_cls</code>: 可以标记 cgroups 中进程的网络数据包，然后可以使用 tc 模块(traffic contro)对数据包进行控制</li>
<li><code>blkio</code>: 限制 cgroup 中进程的块设备 IO</li>
<li><code>perf_event</code>: 监控 cgroup 中进程的 perf 时间，可用于性能调优</li>
<li><code>hugetlb</code>: hugetlb 的资源控制功能</li>
<li><code>pids</code>: 限制 cgroup 中可以创建的进程数</li>
<li><code>net_prio</code>: 允许管理员动态的通过各种应用程序设置网络传输的优先级</li>
</ul>
<p>通过上面的各个子系统，可以看出使用 <code>CGroups</code> 可以控制的资源有: CPU、内存、网络、IO、文件设备等。<code>CGroups</code> 具有以下几个特点：</p>
<ul>
<li>CGroups 的 API 以一个伪文件系统（&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;）的实现方式，用户的程序可以通过文件系统实现 CGroups 的组件管理</li>
<li>CGroups 的组件管理操作单元可以细粒度到线程级别，用户可以创建和销毁 CGroups，从而实现资源载分配和再利用</li>
<li>所有资源管理的功能都以子系统（cpu、cpuset 这些）的方式实现，接口统一子任务创建之初与其父任务处于同一个 CGroups 的控制组</li>
</ul>
<p>我们可以通过查看 <code>/proc/cgroups</code> 文件来查找当前系统支持的 <code>CGroups</code> 子系统:</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/l9c1gs.png" alt="cgroups subsystem"></p>
<p>在使用 <code>CGroups</code> 时需要先挂载，我们可以使用 <code>df -h | grep cgroup</code> 命令进行查看:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ df -h | grep cgroup</span><br><span class="line">tmpfs                          3.9G     0  3.9G   0% /sys/fs/cgroup</span><br></pre></td></tr></table></figure>

<p>可以看到被挂载到了 cd，cgroup 其实是一种文件系统类型，所有的操作都是通过文件来完成的，我们可以使用 <code>mount --type cgroup</code>命令查看当前系统挂载了哪些 cgroup：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mount --type cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br></pre></td></tr></table></figure>

<p><code>/sys/fs/cgroup</code> 目录下的每个子目录就对应着一个子系统，cgroup 是以目录形式组织的，<code>/</code> 是 cgroup 的根目录，但是这个根目录可以被挂载到任意目录，例如 CGroups 的 memory 子系统的挂载点是 <code>/sys/fs/cgroup/memory</code>，那么 <code>/sys/fs/cgroup/memory/</code> 对应 memory 子系统的根目录，我们可以列出该目录下面的文件：c</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ll /sys/fs/cgroup/memory/</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 cgroup.clone_children</span><br><span class="line">--w--w--w-  1 root root 0 Oct 21 10:10 cgroup.event_control</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 cgroup.procs</span><br><span class="line">-r--r--r--  1 root root 0 Oct 21 10:10 cgroup.sane_behavior</span><br><span class="line">drwxr-xr-x  4 root root 0 Oct 21 10:10 kubepods.slice</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.failcnt</span><br><span class="line">--w-------  1 root root 0 Oct 21 10:10 memory.force_empty</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.kmem.failcnt</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.kmem.limit_in_bytes</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.kmem.max_usage_in_bytes</span><br><span class="line">-r--r--r--  1 root root 0 Oct 21 10:10 memory.kmem.slabinfo</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.kmem.tcp.failcnt</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.kmem.tcp.limit_in_bytes</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.kmem.tcp.max_usage_in_bytes</span><br><span class="line">-r--r--r--  1 root root 0 Oct 21 10:10 memory.kmem.tcp.usage_in_bytes</span><br><span class="line">-r--r--r--  1 root root 0 Oct 21 10:10 memory.kmem.usage_in_bytes</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.limit_in_bytes</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.max_usage_in_bytes</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.memsw.failcnt</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.memsw.limit_in_bytes</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.memsw.max_usage_in_bytes</span><br><span class="line">-r--r--r--  1 root root 0 Oct 21 10:10 memory.memsw.usage_in_bytes</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.move_charge_at_immigrate</span><br><span class="line">-r--r--r--  1 root root 0 Oct 21 10:10 memory.numa_stat</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.oom_control</span><br><span class="line">----------  1 root root 0 Oct 21 10:10 memory.pressure_level</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.soft_limit_in_bytes</span><br><span class="line">-r--r--r--  1 root root 0 Oct 21 10:10 memory.stat</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.swappiness</span><br><span class="line">-r--r--r--  1 root root 0 Oct 21 10:10 memory.usage_in_bytes</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 memory.use_hierarchy</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 notify_on_release</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 release_agent</span><br><span class="line">drwxr-xr-x 65 root root 0 Oct 21 10:25 system.slice</span><br><span class="line">-rw-r--r--  1 root root 0 Oct 21 10:10 tasks</span><br><span class="line">drwxr-xr-x  2 root root 0 Oct 21 10:10 user.slice</span><br></pre></td></tr></table></figure>

<p>上面包含 <code>kubepods.slice</code>、<code>system.slice</code>、<code>user.slice</code> 等目录，这些目录下可能还会有子目录，相当于一颗有层级关系的树来进行组织：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├── kubepods.slice</span><br><span class="line">├── system.slice</span><br><span class="line">└── user.slice</span><br></pre></td></tr></table></figure>

<p>例如我在节点上使用 systemd 管理了一个 Prometheus 的应用，我们可以使用 <code>systemctl status prometheus</code> 命令查看 Prometheus 进程所在的 cgroup 为 <code>/system.slice/prometheus.service</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ systemctl status prometheus</span><br><span class="line">● prometheus.service - prometheus service</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Thu 2021-10-21 10:10:12 CST; 1h 40min ago</span><br><span class="line">     Docs: https://prometheus.io</span><br><span class="line"> Main PID: 1065 (prometheus)</span><br><span class="line">    Tasks: 10</span><br><span class="line">   Memory: 167.4M</span><br><span class="line">   CGroup: /system.slice/prometheus.service</span><br><span class="line">           └─1065 /root/p8strain/prometheus-2.30.2.linux-amd64/prometheus --config.file=/root/p8strain/prometheu...</span><br></pre></td></tr></table></figure>

<p>上面显示的 CGroup 只是一个相对的路径，实际的文件系统目录是在对应的子系统下面，比如 <code>/sys/fs/cgroup/cpu/system.slice/prometheus.service</code>、<code>/sys/fs/cgroup/memory/system.slice/prometheus.service</code> 目录：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/ld20w2.png" alt="prometheus cgroup"></p>
<p>这其实可以理解为 cpu 和 memory 子系统被附加到了 <code>/system.slice/prometheus.service</code> 这个 cgroup 上。</p>
<blockquote>
<p>如果 linux 系统使用 systemd 初始化系统，初始化进程会生成一个 root cgroup，每个 <code>systemd unit</code> 都将会被分配一个 cgroup，同样可以配置容器运行时如 containerd 选择使用 cgroupfs 或 systemd 作为 cgroup 驱动，containerd 默认使用的是 cgroupfs，但对于使用了 systemd 的 linux 发行版来说就同时存在两个 cgroup 管理器，对于该服务器上启动的容器使用的是 cgroupfs，而对于其他 systemd 管理的进程使用的是 systemd，这样在服务器资源负载高的情况下可能会变的不稳定。因此对于使用了 systemd 的 linux 系统，推荐将容器运行时的 cgroup 驱动使用 systemd。</p>
</blockquote>
<h2 id="CGroup-测试"><a href="#CGroup-测试" class="headerlink" title="CGroup 测试"></a>CGroup 测试</h2><p>接下来我们来尝试手动设置下 cgroup，以 CPU 这个子系统为例进行说明，首先我们在 <code>/sys/fs/cgroup/cpu</code> 目录下面创建一个名为 <code>ydzs.test</code> 的目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mkdir -p /sys/fs/cgroup/cpu/ydzs.test</span><br><span class="line">➜  ~ ls /sys/fs/cgroup/cpu/ydzs.test/</span><br><span class="line">cgroup.clone_children  cpuacct.stat          cpu.cfs_period_us  cpu.rt_runtime_us  notify_on_release</span><br><span class="line">cgroup.event_control   cpuacct.usage         cpu.cfs_quota_us   cpu.shares         tasks</span><br><span class="line">cgroup.procs           cpuacct.usage_percpu  cpu.rt_period_us   cpu.stat</span><br></pre></td></tr></table></figure>

<p>我们可以看到目录创建完成后，下面就会已经自动创建 cgroup 的相关文件，这里我们重点关注 <code>cpu.cfs_period_us</code> 和 <code>cpu.cfs_quota_us</code> 这两个文件，前面一个是用来配置 CPU 时间周期长度的，默认为 <code>100000us</code>，后者用来设置在此时间周期长度内所能使用的 CPU 时间数，默认值为-1，表示不受时间限制。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /sys/fs/cgroup/cpu/ydzs.test/cpu.cfs_period_us</span><br><span class="line">100000</span><br><span class="line">➜  ~ cat /sys/fs/cgroup/cpu/ydzs.test/cpu.cfs_quota_us</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>现在我们写一个简单的 Python 脚本来消耗 CPU：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cgroup.py</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>直接执行这个死循环脚本即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ python cgroup.py &amp;</span><br><span class="line">[1] 2113</span><br></pre></td></tr></table></figure>

<p>使用 top 命令可以看到进程号 2113 的 CPU 使用率达到了 100%</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20211021121336.png" alt="cgroup test"></p>
<p>现在我们将这个进程 ID 写入到 <code>/sys/fs/cgroup/cpu/ydzs.test/tasks</code> 文件下面去，然后设置 <code>/sys/fs/cgroup/cpu/ydzs.test/cpu.cfs_quota_us</code> 为 <code>10000us</code>，因为 <code>cpu.cfs_period_us</code> 默认值为 <code>100000us</code>，所以这表示我们要限制 CPU 使用率为 10%：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ echo 2113 &gt; /sys/fs/cgroup/cpu/ydzs.test/tasks</span><br><span class="line">➜  ~ echo 10000 &gt; /sys/fs/cgroup/cpu/ydzs.test/cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>

<p>设置完过后上面我们的测试进程 CPU 就会被限制在 10% 左右了，再次使用 top 命令查看该进程可以验证。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/5hh68b.png" alt="cgroup test valid"></p>
<p>如果要限制内存等其他资源的话，同样去对应的子系统下面设置资源，并将进程 ID 加入 tasks 中即可。如果要删除这个 cgroup，直接删除文件夹是不行的，需要使用 <code>libcgroup</code> 工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ yum install libcgroup libcgroup-tools</span><br><span class="line">➜  ~ cgdelete cpu:ydzs.test</span><br><span class="line">➜  ~ ls /sys/fs/cgroup/cpu/ydzs.test</span><br><span class="line">ls: cannot access /sys/fs/cgroup/cpu/ydzs.test: No such file or directory</span><br></pre></td></tr></table></figure>

<h2 id="在容器中使用-CGroups"><a href="#在容器中使用-CGroups" class="headerlink" title="在容器中使用 CGroups"></a>在容器中使用 CGroups</h2><p>上面我们测试了一个普通应用如何配置 cgroup，接下来我们在 Containerd 的容器中来使用 cgroup，比如使用 nerdctl 启动一个 nginx 容器，并限制其使用内存为 50M:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl run -d -m 50m --name nginx nginx:alpine</span><br><span class="line">8690c7dba4ffe03d63983555c594e2784c146b5f9939de1195a9626339c9129c</span><br><span class="line">➜  ~ nerdctl ps</span><br><span class="line">CONTAINER ID    IMAGE                             COMMAND                   CREATED           STATUS    PORTS    NAMES</span><br><span class="line">8690c7dba4ff    docker.io/library/nginx:alpine    &quot;/docker-entrypoint.…&quot;    53 seconds ago    Up                 nginx</span><br></pre></td></tr></table></figure>

<p>在使用 <code>nerdctl run</code> 启动容器的时候可以使用 <code>-m</code> 或 <code>--memory</code> 参数来现在内存，启动完成后该容器的 cgroup 会出现在 名为 <code>default</code> 的目录下面，比如查看内存子系统的目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ll /sys/fs/cgroup/memory/default/</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root 0 Oct 21 15:01 8690c7dba4ffe03d63983555c594e2784c146b5f9939de1195a9626339c9129c</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 cgroup.clone_children</span><br><span class="line">--w--w--w- 1 root root 0 Oct 21 15:01 cgroup.event_control</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 cgroup.procs</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>上面我们启动的 nginx 容器 ID 的目录会出现在 <code>/sys/fs/cgroup/memory/default/</code> 下面，该文件夹下面有很多和内存相关的 cgroup 配置文件，要进行相关的配置就需要在该目录下对应的文件中去操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ll /sys/fs/cgroup/memory/default/8690c7dba4ffe03d63983555c594e2784c146b5f9939de1195a9626339c9129c</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 cgroup.clone_children</span><br><span class="line">--w--w--w- 1 root root 0 Oct 21 15:01 cgroup.event_control</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 cgroup.procs</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.failcnt</span><br><span class="line">--w------- 1 root root 0 Oct 21 15:01 memory.force_empty</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.kmem.failcnt</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.kmem.limit_in_bytes</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.kmem.max_usage_in_bytes</span><br><span class="line">-r--r--r-- 1 root root 0 Oct 21 15:01 memory.kmem.slabinfo</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.kmem.tcp.failcnt</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.kmem.tcp.limit_in_bytes</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.kmem.tcp.max_usage_in_bytes</span><br><span class="line">-r--r--r-- 1 root root 0 Oct 21 15:01 memory.kmem.tcp.usage_in_bytes</span><br><span class="line">-r--r--r-- 1 root root 0 Oct 21 15:01 memory.kmem.usage_in_bytes</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.limit_in_bytes</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.max_usage_in_bytes</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.memsw.failcnt</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.memsw.limit_in_bytes</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.memsw.max_usage_in_bytes</span><br><span class="line">-r--r--r-- 1 root root 0 Oct 21 15:01 memory.memsw.usage_in_bytes</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.move_charge_at_immigrate</span><br><span class="line">-r--r--r-- 1 root root 0 Oct 21 15:01 memory.numa_stat</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.oom_control</span><br><span class="line">---------- 1 root root 0 Oct 21 15:01 memory.pressure_level</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.soft_limit_in_bytes</span><br><span class="line">-r--r--r-- 1 root root 0 Oct 21 15:01 memory.stat</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.swappiness</span><br><span class="line">-r--r--r-- 1 root root 0 Oct 21 15:01 memory.usage_in_bytes</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 memory.use_hierarchy</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 notify_on_release</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 21 15:01 tasks</span><br></pre></td></tr></table></figure>

<p>我们这里需要关心的是 <code>memory.limit_in_bytes</code> 文件，该文件就是用来设置内存大小的，正常应该是 50M 的内存限制：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /sys/fs/cgroup/memory/default/8690c7dba4ffe03d63983555c594e2784c146b5f9939de1195a9626339c9129c/memory.limit_in_bytes</span><br><span class="line">52428800</span><br></pre></td></tr></table></figure>

<p>同样我们的 nginx 容器进程 ID 也会出现在上面的 <code>tasks</code> 文件中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /sys/fs/cgroup/memory/default/8690c7dba4ffe03d63983555c594e2784c146b5f9939de1195a9626339c9129c/tasks</span><br><span class="line">2686</span><br><span class="line">2815</span><br><span class="line">2816</span><br><span class="line">2817</span><br><span class="line">2818</span><br></pre></td></tr></table></figure>

<p>我们可以通过如下命令过滤该进程号，可以看出第一行的 2686 就是 nginx 进程在主机上的进程 ID，下面几个是这个进程下的线程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ps -ef | grep 2686</span><br><span class="line">root       2686   2656  0 15:01 ?        00:00:00 nginx: master process nginx -g daemon off;</span><br><span class="line">101        2815   2686  0 15:01 ?        00:00:00 nginx: worker process</span><br><span class="line">101        2816   2686  0 15:01 ?        00:00:00 nginx: worker process</span><br><span class="line">101        2817   2686  0 15:01 ?        00:00:00 nginx: worker process</span><br><span class="line">101        2818   2686  0 15:01 ?        00:00:00 nginx: worker process</span><br><span class="line">root       2950   1976  0 15:36 pts/0    00:00:00 grep --color=auto 2686</span><br></pre></td></tr></table></figure>

<p>我们删除这个容器后，<code>/sys/fs/cgroup/memory/default/</code> 目录下的容器 ID 文件夹也会自动删除。</p>
<h2 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h2><p><code>namespace</code> 也称命名空间，是 Linux 为我们提供的用于隔离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用个人 PC 时，我们并没有运行多个完全分离的服务器的需求，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，一旦服务器上的某一个服务被入侵，那么入侵者就能够访问当前机器上的所有服务和文件，这是我们不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。而我们这里的容器其实就通过 Linux 的 Namespaces 技术来实现的对不同的容器进行隔离。</p>
<p>linux 共有 6(7)种命名空间:</p>
<ul>
<li><code>ipc namespace</code>: 管理对 IPC 资源（进程间通信（信号量、消息队列和共享内存）的访问</li>
<li><code>net namespace</code>: 网络设备、网络栈、端口等隔离</li>
<li><code>mnt namespace</code>: 文件系统挂载点隔离</li>
<li><code>pid namespace</code>: 用于进程隔离</li>
<li><code>user namespace</code>: 用户和用户组隔离（3.8 以后的内核才支持）</li>
<li><code>uts namespace</code>: 主机和域名隔离</li>
<li><code>cgroup namespace</code>：用于 cgroup 根目录隔离（4.6 以后版本的内核才支持）</li>
</ul>
<p>我们可以通过 <code>lsns</code> 命令查看当前系统已经创建的命名空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ lsns</span><br><span class="line">        NS TYPE  NPROCS   PID USER    COMMAND</span><br><span class="line">4026531836 pid      143     1 root    /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026531837 user     143     1 root    /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026531838 uts      143     1 root    /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026531839 ipc      143     1 root    /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026531840 mnt      138     1 root    /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026531856 mnt        1    28 root    kdevtmpfs</span><br><span class="line">4026531956 net      143     1 root    /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026532503 mnt        2   728 root    /usr/sbin/NetworkManager --no-daemon</span><br><span class="line">4026532504 mnt        1   745 chrony  /usr/sbin/chronyd</span><br><span class="line">4026532642 mnt        1  1076 grafana /usr/sbin/grafana-server --config=/etc/grafana/grafana.ini --pidfile=/var/run</span><br></pre></td></tr></table></figure>

<p>要查看一个进程所属的命名空间信息，可以到 <code>/proc/&lt;pid&gt;/ns</code> 目录下查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ps -ef | grep prometheus</span><br><span class="line">root       1065      1  0 10:10 ?        00:01:13 /root/p8strain/prometheus-2.30.2.linux-amd64/prometheus --config.file=/root/p8strain/prometheus-2.30.2.linux-amd64/prometheus.yml</span><br><span class="line">➜  ~ ll /proc/1065/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Oct 21 15:58 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Oct 21 15:58 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Oct 21 15:58 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Oct 21 15:58 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Oct 21 15:58 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Oct 21 15:58 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure>

<p>这些 namespace 都是链接文件, 格式为 <code>namespaceType:[inode number]</code>，<code>inode number</code> 用来标识一个 namespace，可以理解为 namespace id，如果两个进程的某个命名空间的链接文件指向同一个，那么其相关资源在同一个命名空间中，也就没有隔离了。比如同样针对上面运行的 nginx 容器，我们查看其命名空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ lsns  |grep nginx</span><br><span class="line">4026532505 mnt        5  3171 root    nginx: master process nginx -g daemon off</span><br><span class="line">4026532506 uts        5  3171 root    nginx: master process nginx -g daemon off</span><br><span class="line">4026532507 ipc        5  3171 root    nginx: master process nginx -g daemon off</span><br><span class="line">4026532508 pid        5  3171 root    nginx: master process nginx -g daemon off</span><br><span class="line">4026532510 net        5  3171 root    nginx: master process nginx -g daemon off</span><br></pre></td></tr></table></figure>

<p>可以看出 nginx 容器启动后，已经为该容器自动创建了单独的 <code>mtn</code>、<code>uts</code>、<code>ipc</code>、<code>pid</code>、<code>net</code> 命名空间，也就是这个容器在这些方面是独立隔离的，其他容器想要和该容器共享某一个命名空间，那么就需要指向同一个命名空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/CRD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/CRD/" class="post-title-link" itemprop="url">CRD</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:26:55" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E6%8E%A7%E5%88%B6%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">控制器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CRD"><a href="#CRD" class="headerlink" title="CRD"></a>CRD</h1><p><code>Custom Resource Define</code> 简称 CRD，是 Kubernetes（v1.7+）为提高可扩展性，让开发者去自定义资源的一种方式。CRD 资源可以动态注册到集群中，注册完毕后，用户可以通过 kubectl 来创建访问这个自定义的资源对象，类似于操作 Pod 一样。不过需要注意的是 CRD 仅仅是资源的定义而已，需要一个 Controller 去监听 CRD 的各种事件来添加自定义的业务逻辑。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果说只是对 CRD 资源本身进行 CRUD 操作的话，不需要 Controller 也是可以实现的，相当于就是只有数据存入了 etcd 中，而没有对这个数据的相关操作而已。比如我们可以定义一个如下所示的 CRD 资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># crd-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiextensions.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CustomResourceDefinition</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># name 必须匹配下面的spec字段：&lt;plural&gt;.&lt;group&gt;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">crontabs.stable.example.com</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># group 名用于 REST API 中的定义：/apis/&lt;group&gt;/&lt;version&gt;</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">stable.example.com</span></span><br><span class="line">  <span class="comment"># 列出自定义资源的所有 API 版本</span></span><br><span class="line">  <span class="attr">versions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1beta1</span> <span class="comment"># 版本名称，比如 v1、v2beta1 等等</span></span><br><span class="line">      <span class="attr">served:</span> <span class="literal">true</span> <span class="comment"># 是否开启通过 REST APIs 访问 `/apis/&lt;group&gt;/&lt;version&gt;/...`</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="literal">true</span> <span class="comment"># 必须将一个且只有一个版本标记为存储版本</span></span><br><span class="line">      <span class="attr">schema:</span> <span class="comment"># 定义自定义对象的声明规范</span></span><br><span class="line">        <span class="attr">openAPIV3Schema:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">Define</span> <span class="string">CronTab</span> <span class="string">YAML</span> <span class="string">Spec</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">object</span></span><br><span class="line">          <span class="attr">properties:</span></span><br><span class="line">            <span class="attr">spec:</span></span><br><span class="line">              <span class="attr">type:</span> <span class="string">object</span></span><br><span class="line">              <span class="attr">properties:</span></span><br><span class="line">                <span class="attr">cronSpec:</span></span><br><span class="line">                  <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">                <span class="attr">image:</span></span><br><span class="line">                  <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">                <span class="attr">replicas:</span></span><br><span class="line">                  <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">  <span class="comment"># 定义作用范围：Namespaced（命名空间级别）或者 Cluster（整个集群）</span></span><br><span class="line">  <span class="attr">scope:</span> <span class="string">Namespaced</span></span><br><span class="line">  <span class="attr">names:</span></span><br><span class="line">    <span class="comment"># kind 是 sigular 的一个驼峰形式定义，在资源清单中会使用</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">CronTab</span></span><br><span class="line">    <span class="comment"># plural 名字用于 REST API 中的定义：/apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</span></span><br><span class="line">    <span class="attr">plural:</span> <span class="string">crontabs</span></span><br><span class="line">    <span class="comment"># singular 名称用于 CLI 操作或显示的一个别名</span></span><br><span class="line">    <span class="attr">singular:</span> <span class="string">crontab</span></span><br><span class="line">    <span class="comment"># shortNames 相当于缩写形式</span></span><br><span class="line">    <span class="attr">shortNames:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ct</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>需要注意的是 v1.16 版本以后已经 GA 了，使用的是 v1 版本，之前都是 v1beta1，定义规范有部分变化，所以要注意版本变化。</p>
</blockquote>
<p>这个地方的定义和我们定义普通的资源对象比较类似，我们说我们可以随意定义一个自定义的资源对象，但是在创建资源的时候，肯定不是任由我们随意去编写 YAML 文件的，当我们把上面的 CRD 文件提交给 Kubernetes 之后，Kubernetes 会对我们提交的声明文件进行校验，从定义可以看出 CRD 是基于 <a target="_blank" rel="noopener" href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject">OpenAPI v3 schem</a> 进行规范的。当然这种校验只是对于字段的类型进行校验，比较初级，如果想要更加复杂的校验，这个时候就需要通过 Kubernetes 的 admission webhook 来实现了。关于校验的更多用法，可以前往<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#validation">官方文档</a>查看。</p>
<p>同样现在我们可以直接使用 kubectl 来创建这个 CRD 资源清单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f crd-demo.yaml</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/crontabs.stable.example.com created</span><br></pre></td></tr></table></figure>



<p>这个时候我们可以查看到集群中已经有我们定义的这个 CRD 资源对象了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get crd |grep example</span><br><span class="line">crontabs.stable.example.com                      2019-12-19T02:37:54Z</span><br></pre></td></tr></table></figure>



<p>这个时候一个新的 namespace 级别的 RESTful API 就会被创建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/apis/stable/example.com/v1beta1/namespaces/*/crontabs/...</span><br></pre></td></tr></table></figure>



<p>然后我们就可以使用这个 API 端点来创建和管理自定义的对象，这些对象的类型就是上面创建的 CRD 对象规范中的 <code>CronTab</code>。</p>
<p>现在在 Kubernetes 集群中我们就多了一种新的资源叫做 <code>crontabs.stable.example.com</code>，我们就可以使用它来定义一个 <code>CronTab</code> 资源对象了，这个自定义资源对象里面可以包含的字段我们在定义的时候通过 <code>schema</code> 进行了规范，比如现在我们来创建一个如下所示的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># crd-crontab-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">stable.example.com/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronTab</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-new-cron-object</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">cronSpec:</span> <span class="string">&#x27;* * * * */5&#x27;</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">my-awesome-cron-image</span></span><br></pre></td></tr></table></figure>



<p>我们可以直接创建这个对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f crd-crontab-demo.yaml</span><br><span class="line">crontab.stable.example.com/my-new-cron-object created</span><br></pre></td></tr></table></figure>



<p>然后我们就可以用 kubectl 来管理我们这里创建 CronTab 对象了，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get ct  # 简写</span><br><span class="line">NAME                 AGE</span><br><span class="line">my-new-cron-object   42s</span><br><span class="line">➜  ~ kubectl get crontab</span><br><span class="line">NAME                 AGE</span><br><span class="line">my-new-cron-object   88s</span><br></pre></td></tr></table></figure>



<p>在使用 kubectl 的时候，资源名称是不区分大小写的，我们可以使用 CRD 中定义的单数或者复数形式以及任何简写。我们也可以查看创建的这个对象的原始 YAML 数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get ct -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">items:</span><br><span class="line">- apiVersion: stable.example.com/v1beta1</span><br><span class="line">  kind: CronTab</span><br><span class="line">  metadata:</span><br><span class="line">    annotations:</span><br><span class="line">      kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">        &#123;&quot;apiVersion&quot;:&quot;stable.example.com/v1beta1&quot;,&quot;kind&quot;:&quot;CronTab&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;name&quot;:&quot;my-new-cron-object&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;spec&quot;:&#123;&quot;cronSpec&quot;:&quot;* * * * */5&quot;,&quot;image&quot;:&quot;my-awesome-cron-image&quot;&#125;&#125;</span><br><span class="line">    creationTimestamp: &quot;2019-12-19T02:52:55Z&quot;</span><br><span class="line">    generation: 1</span><br><span class="line">    name: my-new-cron-object</span><br><span class="line">    namespace: default</span><br><span class="line">    resourceVersion: &quot;12342275&quot;</span><br><span class="line">    selfLink: /apis/stable.example.com/v1beta1/namespaces/default/crontabs/my-new-cron-object</span><br><span class="line">    uid: dace308d-5f54-4232-9c7b-841adf6bab62</span><br><span class="line">  spec:</span><br><span class="line">    cronSpec: &#x27;* * * * */5&#x27;</span><br><span class="line">    image: my-awesome-cron-image</span><br><span class="line">kind: List</span><br><span class="line">metadata:</span><br><span class="line">  resourceVersion: &quot;&quot;</span><br><span class="line">  selfLink: &quot;&quot;</span><br></pre></td></tr></table></figure>



<p>我们可以看到它包含了上面我们定义的 <code>cronSpec</code> 和 <code>image</code> 字段。</p>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>就如上面我们说的，现在我们自定义的资源创建完成了，但是也只是单纯的把资源清单数据存入到了 etcd 中而已，并没有什么其他用处，因为我们没有定义一个对应的 Controller 来处理他。</p>
<p>官方提供了一个自定义 Controller 的示例：<a target="_blank" rel="noopener" href="https://github.com/kubernetes/sample-controller%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BA%86%EF%BC%9A">https://github.com/kubernetes/sample-controller，实现了：</a></p>
<ul>
<li>如何注册资源 Foo</li>
<li>如何创建、删除和查询 Foo 对象</li>
<li>如何监听 Foo 资源对象的变化情况</li>
</ul>
<p>要想了解 Controller 的实现原理和方式，我们就需要了解下 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/client-go/">client-go</a> 这个库的实现，Kubernetes 部分代码也是基于这个库实现的，也包含了开发自定义控制器时可以使用的各种机制，这些机制在 client-go 源码的 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/client-go/tree/master/tools/cache">tools&#x2F;cache</a> 目录下面有定义。</p>
<p>下图显示了 client-go 中的各个组件是如何工作的以及与我们要编写的自定义控制器代码的交互入口：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/sag677.jpg" alt="client-go controller interaction"></p>
<p><strong>client-go 组件</strong>：</p>
<ul>
<li>Reflector：通过 Kubernetes API 监控 Kubernetes 的资源类型 采用 List&#x2F;Watch 机制, 可以 Watch 任何资源包括 CRD 添加 object 对象到 FIFO 队列，然后 Informer 会从队列里面取数据</li>
<li>Informer：controller 机制的基础，循环处理 object 对象 从 Reflector 取出数据，然后将数据给到 Indexer 去缓存，提供对象事件的 handler 接口，只要给 Informer 添加 <code>ResourceEventHandler</code> 实例的回调函数，去实现 <code>OnAdd(obj interface&#123;&#125;)</code>、 <code>OnUpdate(oldObj, newObj interface&#123;&#125;)</code> 和 <code>OnDelete(obj interface&#123;&#125;)</code> 这三个方法，就可以处理好资源的创建、更新和删除操作了。</li>
<li>Indexer：提供 object 对象的索引，是线程安全的，缓存对象信息</li>
</ul>
<p><strong>controller 组件</strong>：</p>
<ul>
<li>Informer reference: controller 需要创建合适的 Informer 才能通过 Informer reference 操作资源对象</li>
<li>Indexer reference: controller 创建 Indexer reference 然后去利用索引做相关处理</li>
<li>Resource Event Handlers：Informer 会回调这些 handlers</li>
<li>Work queue: Resource Event Handlers 被回调后将 key 写到工作队列，这里的 key 相当于事件通知，后面根据取出事件后，做后续的处理</li>
<li>Process Item：从工作队列中取出 key 后进行后续处理，具体处理可以通过 Indexer reference controller 可以直接创建上述两个引用对象去处理，也可以采用工厂模式，官方都有相关示例</li>
</ul>
<p><code>client-go/tool/cache/</code> 和自定义 Controller 的控制流(<a target="_blank" rel="noopener" href="https://itnext.io/how-to-create-a-kubernetes-custom-controller-using-client-go-f36a7a7536cc">图片来源</a>)：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/mpficx.png" alt="client-go controller workflow"></p>
<p>如上图所示主要有两个部分，一个是发生在 <code>SharedIndexInformer</code> 中，另外一个是在自定义控制器中。</p>
<ol>
<li><code>Reflector</code> 通过 Kubernetes APIServer 执行对象（比如 Pod）的 <code>ListAndWatch</code> 查询，记录和对象相关的三种事件类型<code>Added</code>、<code>Updated</code>、<code>Deleted</code>，然后将它们传递到 <code>DeltaFIFO</code> 中去。</li>
<li><code>DeltaFIFO</code> 接收到事件和 watch 事件对应的对象，然后将他们转换为 <code>Delta</code> 对象，这些 <code>Delta</code> 对象被附加到队列中去等待处理，对于已经删除的，会检查线程安全的 store 中是否已经存在该文件，从而可以避免在不存在某些内容时排队执行删除操作。</li>
<li>Cache 控制器（不要和自定义控制器混淆）调用 <code>Pop()</code> 方法从 <code>DeltaFIFO</code> 队列中出队列，<code>Delta</code> 对象将传递到 <code>SharedIndexInformer</code> 的 <code>HandleDelta()</code> 方法中以进行进一步处理。</li>
<li>根据 <code>Delta</code> 对象的操作（事件）类型，首先在 <code>HandleDeltas</code> 方法中通过 <code>indexer</code> 的方法将对对象保存到线程安全的 Store 中，然后，通过 <code>SharedIndexInformer</code> 中的 <code>sharedProcessor</code> 的 <code>distribution()</code> 方法将这些对象发送到事件 handlers，这些事件处理器由自定义控制器通过 <code>SharedInformer</code> 的方法比如 <code>AddEventHandlerWithResyncPeriod()</code> 进行注册。</li>
<li>已注册的事件处理器通过添加或更新时间的 <code>MetaNamespaceKeyFunc()</code> 或删除事件的 <code>DeletionHandingMetaNamespaceKeyFunc()</code> 将对象转换为格式为 <code>namespace/name</code> 或只是 <code>name</code> 的 key，然后将这个 key 添加到自定义控制器的 <code>workqueue</code> 中，<code>workqueues</code> 的实现可以在 <code>util/workqueue</code> 中找到。</li>
<li>自定义的控制器通过调用定义的 handlers 处理器从 workqueue 中 pop 一个 key 出来进行处理，handlers 将调用 indexer 的 <code>GetByKey()</code> 从线程安全的 store 中获取对象，我们的业务逻辑就是在这个 handlers 里面实现。</li>
</ol>
<p><code>client-go</code> 中也有自定义 Controller 的样例代码，位于：<code>k8s.io/client-go/examples/workqueue/main.go</code>。</p>
<h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><p><code>Operator</code> 就可以看成是 CRD 和 Controller 的一种组合特例，Operator 是一种思想，它结合了特定领域知识并通过 CRD 机制扩展了 Kubernetes API 资源，使用户管理 Kubernetes 的内置资源（Pod、Deployment 等）一样创建、配置和管理应用程序，Operator 是一个特定的应用程序的控制器，通过扩展 Kubernetes API 资源以代表 Kubernetes 用户创建、配置和管理复杂应用程序的实例，通常包含资源模型定义和控制器，通过 <code>Operator</code> 通常是为了实现某种特定软件（通常是有状态服务）的自动化运维。</p>
<p>我们完全可以通过上面的方式编写一个 CRD 对象，然后去手动实现一个对应的 Controller 就可以实现一个 Operator，但是我们也发现从头开始去构建一个 CRD 控制器并不容易，需要对 Kubernetes 的 API 有深入了解，并且 RBAC 集成、镜像构建、持续集成和部署等都需要很大工作量。为了解决这个问题，社区就推出了对应的简单易用的 Operator 框架，比较主流的是 <a target="_blank" rel="noopener" href="https://github.com/kubernetes-sigs/kubebuilder">kubebuilder</a> 和 <a target="_blank" rel="noopener" href="https://coreos.com/operators">Operator Framework</a>，这两个框架的使用基本上差别不大，我们可以根据自己习惯选择一个即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Cache/" class="post-title-link" itemprop="url">Nginx Cache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:25:00" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="为什么需要缓存静态文件？"><a href="#为什么需要缓存静态文件？" class="headerlink" title="为什么需要缓存静态文件？"></a>为什么需要缓存静态文件？</h3><ol>
<li><strong>减少服务器负载：</strong> 对于静态文件，Nginx 每次请求都需要从磁盘读取并发送。缓存后，Nginx 可以直接从内存发送，或告诉浏览器文件未修改，无需再次下载。</li>
<li><strong>加速页面加载：</strong> 用户客户端不需要每次都从服务器下载 CSS、JavaScript、图片等文件，可以直接从浏览器本地缓存中获取，从而极大提高网站的响应速度。</li>
<li><strong>节省网络带宽：</strong> 减少了重复传输相同静态文件的次数，从而降低了服务器和客户端的网络带宽消耗。</li>
</ol>
<h3 id="Nginx-中配置静态文件缓存的关键指令"><a href="#Nginx-中配置静态文件缓存的关键指令" class="headerlink" title="Nginx 中配置静态文件缓存的关键指令"></a>Nginx 中配置静态文件缓存的关键指令</h3><p>Nginx 配置静态文件缓存主要涉及到以下几个方面：</p>
<ol>
<li><strong>浏览器缓存 (Expires 和 Cache-Control Header)：</strong> 告诉客户端（浏览器）如何缓存文件。</li>
<li><strong>Nginx 自身缓存 (proxy_cache)：</strong> Nginx 作为反向代理时，缓存来自后端服务器的响应。</li>
<li><strong>ETag 和 If-Modified-Since：</strong> 实现条件请求，进一步优化缓存。</li>
</ol>
<h4 id="1-配置浏览器缓存-Browser-Caching"><a href="#1-配置浏览器缓存-Browser-Caching" class="headerlink" title="1. 配置浏览器缓存 (Browser Caching)"></a>1. 配置浏览器缓存 (Browser Caching)</h4><p>这是最常用也是最直接的静态文件缓存方式。Nginx 通过设置响应头 <code>Expires</code> 和 <code>Cache-Control</code> 来告诉浏览器是否以及如何缓存文件。</p>
<p><strong>a. 使用 <code>expires</code> 指令</strong></p>
<p><code>expires</code> 指令允许你根据文件类型设置缓存时间。它可以用于 <code>http</code>、<code>server</code>、<code>location</code> 块中。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># ... 其他 http 配置 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line">        <span class="attribute">root</span> /var/www/your_website; <span class="comment"># 网站根目录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 针对图片文件设置缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(jpg|jpeg|gif|png|svg|ico)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>; <span class="comment"># 缓存 30 天</span></span><br><span class="line">            <span class="comment"># 可选：禁止访问文件列表（例如禁止访问 .svn、.git 目录）</span></span><br><span class="line">            <span class="comment"># access_log off; # 访问日志也可以关闭，减少IO</span></span><br><span class="line">            <span class="comment"># log_not_found off; # 不记录找不到文件的日志</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 针对 CSS 和 JavaScript 文件设置缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(css|js)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">7d</span>; <span class="comment"># 缓存 7 天</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 针对字体文件设置缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(woff|woff2|ttf|otf|eot)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>; <span class="comment"># 缓存 30 天</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 针对其他静态文件（如PDF, MP3等）</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(pdf|mp3|mp4)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于HTML页面，通常保持不缓存或短时间缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.html$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">1h</span>; <span class="comment"># HTML 通常只缓存 1 小时或更短，因为内容更新频繁</span></span><br><span class="line">            <span class="comment"># 或 expires off; # 不缓存 HTML</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于根目录下的所有文件以及未被上述规则捕获的文件</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 默认的 expires 设置，如果前面没匹配到，就用这个</span></span><br><span class="line">            <span class="comment"># expires 0; 或 expires off; # 表示不缓存或每次都检查</span></span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html; <span class="comment"># 对于动态内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>expires</code> 指令详解：</strong></p>
<ul>
<li><strong><code>expires time;</code></strong>: 设置缓存时间，例如 <code>30d</code> (30天), <code>12h</code> (12小时), <code>30m</code> (30分钟), <code>1s</code> (1秒)。</li>
<li><strong><code>expires epoch;</code></strong>: 设置为 Unix 纪元（GMT 1 Jan 1970 00:00:01），表示立即过期，浏览器不缓存。</li>
<li><strong><code>expires max;</code></strong>: 设置为 GMT 31 Dec 2037 23:59:59，表示浏览器尽可能长时间缓存。</li>
<li><strong><code>expires off;</code></strong>: 禁用 <code>Expires</code> 和 <code>Cache-Control</code> 头。</li>
<li><strong><code>expires -1;</code></strong>: <code>Cache-Control: no-cache</code>，意味着浏览器每次都必须向服务器验证文件是否已修改，但不重新下载内容。</li>
</ul>
<p>Nginx 会根据 <code>expires</code> 的设置，自动生成 <code>Expires</code> 头和 <code>Cache-Control</code> 头。</p>
<p>例如，<code>expires 30d;</code> 会生成：<br><code>Cache-Control: public, max-age=2592000</code> (2592000 秒 &#x3D; 30 天)<br><code>Expires: Thu, 01 Jan 20XX 12:00:00 GMT</code> (具体的过期时间)</p>
<p><strong>b. <code>add_header Cache-Control</code> (更精细的控制)</strong></p>
<p>虽然 <code>expires</code> 已经很方便，但 <code>Cache-Control</code> 提供了更细粒度的控制，例如 <code>no-store</code>、<code>no-cache</code>、<code>private</code> 等。如果你想更精确地控制 <code>Cache-Control</code> 头，可以直接使用 <code>add_header</code> 指令。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~* \.(jpg|png)$</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Cache-Control <span class="string">&quot;public, max-age=2592000&quot;</span>; <span class="comment"># 等同于 expires 30d;</span></span><br><span class="line">    <span class="comment"># add_header Cache-Control &quot;no-cache&quot;; # 每次都验证</span></span><br><span class="line">    <span class="comment"># add_header Cache-Control &quot;no-store&quot;; # 绝对不缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-配置-Nginx-自身缓存-Proxy-Caching"><a href="#2-配置-Nginx-自身缓存-Proxy-Caching" class="headerlink" title="2. 配置 Nginx 自身缓存 (Proxy Caching)"></a>2. 配置 Nginx 自身缓存 (Proxy Caching)</h4><p>当 Nginx 作为反向代理时，它可以缓存后端服务器的响应。这对于动态生成但内容不经常变化的页面或 API 响应非常有用，也可以缓存后端服务器提供的静态文件，避免每次都向后端请求。</p>
<p><strong>a. 定义缓存区域</strong></p>
<p>首先，在 <code>http</code> 块中定义一个缓存区域：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># 定义一个名为 &quot;my_cache_zone&quot; 的缓存区域</span></span><br><span class="line">    <span class="comment"># path: /var/cache/nginx/proxy_cache_dir 是缓存文件存放的路径</span></span><br><span class="line">    <span class="comment"># levels: 定义两级子目录结构，例如 1:2，即 /dir/a/b/filename，有助于提高查找效率</span></span><br><span class="line">    <span class="comment"># keys_zone: 定义共享内存区域，用于存储缓存键和元数据，name:zone_size</span></span><br><span class="line">    <span class="comment"># inactive: 如果一个缓存文件在 60 分钟内没有被使用，即使没有过期也会被清除</span></span><br><span class="line">    <span class="comment"># max_size: 缓存目录的最大大小。当达到上限时，Nginx 会根据 LRU 算法删除旧文件</span></span><br><span class="line">    <span class="attribute">proxy_cache_path</span> /var/cache/nginx/proxy_cache_dir levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache_zone:<span class="number">100m</span> inactive=<span class="number">60m</span> max_size=<span class="number">10g</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://my_backend_server; <span class="comment"># 代理到后端服务器</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 启用前面定义的缓存区域</span></span><br><span class="line">            <span class="attribute">proxy_cache</span> my_cache_zone;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 定义用于生成缓存键的字符串，通常是请求方法和 URI</span></span><br><span class="line">            <span class="attribute">proxy_cache_key</span> <span class="string">&quot;<span class="variable">$request_method</span><span class="variable">$scheme</span><span class="variable">$host</span><span class="variable">$request_uri</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 定义哪些 HTTP 状态码的响应应该被缓存以及缓存多久</span></span><br><span class="line">            <span class="comment"># 200 (OK) 和 304 (Not Modified) 缓存 10 分钟</span></span><br><span class="line">            <span class="comment"># 301 (Moved Permanently) 缓存 1 小时</span></span><br><span class="line">            <span class="comment"># 404 (Not Found) 缓存 1 分钟 (避免频繁请求不存在的资源)</span></span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">304</span> <span class="number">10m</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">301</span> <span class="number">1h</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">404</span> <span class="number">1m</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> any <span class="number">1m</span>; <span class="comment"># 默认所有其他状态码缓存 1 分钟</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 可选：如果后端返回特定的 Cache-Control 头，则可以覆盖或遵循</span></span><br><span class="line">            <span class="comment"># proxy_cache_bypass $http_pragma $http_authorization; # 不缓存的情况</span></span><br><span class="line">            <span class="comment"># proxy_cache_revalidate on; # 使用 If-Modified-Since 和 If-None-Match 验证缓存</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment"># 当缓存失效时，保持后端访问的并发连接数</span></span><br><span class="line">            <span class="attribute">proxy_cache_lock</span> <span class="literal">on</span>; <span class="comment"># 只有一个请求会去后端获取新内容，其他等待</span></span><br><span class="line">            <span class="attribute">proxy_cache_lock_timeout</span> <span class="number">5s</span>; <span class="comment"># 等待时间</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 可选：显示缓存命中状态在响应头中</span></span><br><span class="line">            <span class="attribute">add_header</span> X-Proxy-Cache <span class="variable">$upstream_cache_status</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于直接由 Nginx 服务，而不是代理的静态文件，使用上面浏览器缓存的配置</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(jpg|jpeg|gif|png|svg|ico)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">            <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>proxy_cache</code> 相关指令详解：</strong></p>
<ul>
<li><code>proxy_cache_path</code>：定义缓存区域的路径、大小、结构等。</li>
<li><code>proxy_cache</code>：在 <code>location</code> 块中启用缓存区域。</li>
<li><code>proxy_cache_key</code>：定义缓存条目的键。如果两个请求的键相同，Nginx 就会认为它们是同一个请求，并尝试从缓存中获取响应。</li>
<li><code>proxy_cache_valid</code>：指定不同 HTTP 状态码的响应缓存多久。</li>
<li><code>proxy_cache_bypass</code>：定义在某些条件下不使用缓存（例如当请求包含特定 Header 时）。</li>
<li><code>proxy_cache_revalidate</code>：在缓存过期时，Nginx 会发送条件请求到后端，而不是直接重新获取整个内容。</li>
<li><code>proxy_cache_lock</code>：防止“惊群效应”。当缓存过期时，如果大量请求同时到达，只有一个请求会穿透到后端服务器获取新数据，其他请求会等待缓存更新。</li>
<li><code>$upstream_cache_status</code>：这是一个 Nginx 变量，可以添加到响应头中，显示缓存状态（MISS, HIT, EXPIRED, UPDATING, STALE等），方便调试。</li>
</ul>
<h4 id="3-ETag-和-If-Modified-Since-条件请求"><a href="#3-ETag-和-If-Modified-Since-条件请求" class="headerlink" title="3. ETag 和 If-Modified-Since (条件请求)"></a>3. ETag 和 If-Modified-Since (条件请求)</h4><p>Nginx 默认会生成 <code>Last-Modified</code> 和 <code>ETag</code> 响应头来支持条件请求。</p>
<ul>
<li><strong><code>Last-Modified</code>：</strong> 服务器告诉浏览器文件最后一次修改的时间。</li>
<li><strong><code>ETag</code>：</strong> 服务器生成的一个文件内容的唯一标识符。</li>
</ul>
<p>当浏览器再次请求同一个文件时，它会在请求头中带上 <code>If-Modified-Since</code> (值为 <code>Last-Modified</code> 的时间) 或 <code>If-None-Match</code> (值为 <code>ETag</code>)。</p>
<p>Nginx 接收到这些头后，会进行判断：</p>
<ul>
<li>如果文件未修改 (<code>If-Modified-Since</code> 或 <code>If-None-Match</code> 匹配)，Nginx 会返回 <code>304 Not Modified</code> 响应，不发送文件内容，告知浏览器直接使用本地缓存。</li>
<li>如果文件已修改，Nginx 会发送新的文件内容，并更新 <code>Last-Modified</code> 和 <code>ETag</code> 头。</li>
</ul>
<p>这种机制可以最大限度地减少传输数据量，即使文件缓存过期，也能高效验证。通常情况下，Nginx 默认就已经支持这些特性，你无需额外配置。但如果你希望禁用 ETag 或 <code>Last-Modified</code>，可以使用 <code>etag off;</code> 和 <code>send_lowat off;</code>（不推荐）。</p>
<h3 id="最佳实践总结"><a href="#最佳实践总结" class="headerlink" title="最佳实践总结"></a>最佳实践总结</h3><ol>
<li><strong>明确文件类型和缓存策略：</strong> 不同类型的文件有不同的更新频率和重要性。图片、字体等文件可以长时间缓存，CSS&#x2F;JS 适中，HTML 页面通常短时间缓存或不缓存。</li>
<li><strong>利用版本号或哈希：</strong> 对于可以长时间缓存（如 30 天或一年）的静态资源，为了在更新时强制浏览器重新下载，可以在文件名中加入版本号或文件内容的哈希值（例如 <code>style.v1.css</code> 或 <code>script.abcdef.js</code>）。这样即使 <code>expires max;</code>，新版本的文件路径也不同，浏览器会下载新文件。</li>
<li><strong>禁用对静态文件的日志记录：</strong> <code>access_log off;</code> 和 <code>log_not_found off;</code> 可以减少磁盘 I&#x2F;O，尤其是在高流量的网站上。</li>
<li><strong>Gzip 压缩：</strong> 配合缓存，对静态文件进行 Gzip 压缩 (<code>gzip on;</code>) 可以进一步减少传输大小，提高加载速度。</li>
<li><strong>合理设置缓存路径和大小：</strong> <code>proxy_cache_path</code> 中的 <code>max_size</code> 和 <code>inactive</code> 参数需要根据你的磁盘空间和流量模式进行调整。</li>
<li><strong>监控缓存命中率：</strong> 在生产环境中，通过 Nginx 的 <code>$upstream_cache_status</code> 变量（如果使用了 <code>proxy_cache</code>）以及其他监控工具，监控缓存命中率，以评估缓存配置的效果。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Consule%20%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Consule%20%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" class="post-title-link" itemprop="url">Consule 服务发现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:25:36" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">服务发现</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基于-Consul-的服务发现"><a href="#基于-Consul-的服务发现" class="headerlink" title="基于 Consul 的服务发现"></a>基于 Consul 的服务发现</h1><p><a target="_blank" rel="noopener" href="https://www.consul.io/">Consul</a> 是由 <a target="_blank" rel="noopener" href="https://www.hashicorp.com/">HashiCorp</a> 开发的一个支持多数据中心的分布式服务发现和键值对存储服务的开源软件，是一个通用的服务发现和注册中心工具，被大量应用于基于微服务的软件架构当中。</p>
<p>接下来我们就来尝试使用 Prometheus 基于 Consul 的服务发现来监控前面的 3 个 demo 服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.31.46:10000</span><br><span class="line">192.168.31.46:10001</span><br><span class="line">192.168.31.46:10002</span><br></pre></td></tr></table></figure>

<p>我们将 demo 服务注册到 Consul，然后配置 Prometheus 从 Consul 中发现演示服务实例，并使用 Relabeling 操作来过滤调整目标标签。关于 Consul 本身的使用可以查看官方文档 <a target="_blank" rel="noopener" href="https://learn.hashicorp.com/consul">https://learn.hashicorp.com/consul</a> 了解更多。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/yivzoi.png" alt="consul"></p>
<h2 id="安装配置-Consul"><a href="#安装配置-Consul" class="headerlink" title="安装配置 Consul"></a>安装配置 Consul</h2><p>在页面 <a target="_blank" rel="noopener" href="https://www.consul.io/downloads">https://www.consul.io/downloads</a> 下载符合自己系统的安装文件，比如我们这里是 Linux 系统，使用下面命令下载安装即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ wget https://releases.hashicorp.com/consul/1.10.2/consul_1.10.2_linux_amd64.zip</span><br><span class="line">☸ ➜ unzip consul_1.10.2_linux_amd64.zip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 consul 二进制移动到 PATH 路径下去</span></span><br><span class="line">☸ ➜ mv consul /usr/local/bin</span><br><span class="line">☸ ➜ consul version</span><br><span class="line">Consul v1.10.2</span><br><span class="line">Revision 3cb6eeedb</span><br><span class="line">Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when speaking to compatible agents)</span><br></pre></td></tr></table></figure>

<p>当执行 <code>consul</code> 命令后正常有命令提示，证明已经安装完成。接着创建一个用于注册 demo 服务的 Consul 配置文件 <code>demo-service.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;services&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.31.46&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">10000</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;meta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;production&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;checks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://192.168.31.46:10000/api/foo&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1s&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.31.46&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">10001</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;meta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;production&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;checks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://192.168.31.46:10001/api/foo&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1s&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo3&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.31.46&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">10002</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;meta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;staging&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;checks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://192.168.31.46:10002/api/foo&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1s&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当然一般情况下我们也是在 Consul 中进行动态注册服务，但是这里我们只是简单演示 Prometheus 基于 Consul 的服务发现，这里只使用 Consul 配置文件静态注册服务即可。Consul 允许使用 JSON 中的 <code>meta</code>属性将 key-value 元数据与每个注册的服务实例相关联，比如这里我们配置的 <code>env</code> 属性和部署环境 production 或 staging 进行关联，后面我们可以通过使用 Prometheus 里面的 Relabeling 操作提取该字段并将其映射到每个抓取实例的标签中去。</p>
<p>为了查看更多的日志信息，我们可以在 dev 模式下运行 Consul，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ consul agent -dev -config-file=demo-service.json -client 0.0.0.0</span><br><span class="line">==&gt; Starting Consul agent...</span><br><span class="line">           Version: &#x27;1.10.2&#x27;</span><br><span class="line">           Node ID: &#x27;a4a9418c-7f7d-a2da-c81e-94d3d37601aa&#x27;</span><br><span class="line">         Node name: &#x27;node2&#x27;</span><br><span class="line">        Datacenter: &#x27;dc1&#x27; (Segment: &#x27;&lt;all&gt;&#x27;)</span><br><span class="line">            Server: true (Bootstrap: false)</span><br><span class="line">       Client Addr: [0.0.0.0] (HTTP: 8500, HTTPS: -1, gRPC: 8502, DNS: 8600)</span><br><span class="line">      Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302)</span><br><span class="line">           Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false, Auto-Encrypt-TLS: false</span><br><span class="line"></span><br><span class="line">==&gt; Log data will now stream in as it occurs:</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这里我们在启动命令后面使用 <code>-client</code> 参数指定了客户端绑定的 IP 地址，默认为 <code>127.0.0.1</code>。除了我们注册的 3 个 demo 服务之外，Consul agent 还会将自己注册为一个名为 <code>consul</code> 的服务，我们可以在浏览器中访问 <code>http://&lt;nodeip&gt;:8500</code> 查看注册的服务。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/x2sdnk.png" alt="consul ui"></p>
<p>在 Consul UI 页面中可以看到有 <code>consul</code> 和 <code>demo</code> 两个 Service 服务。</p>
<h2 id="配置-Consul-自动发现"><a href="#配置-Consul-自动发现" class="headerlink" title="配置 Consul 自动发现"></a>配置 Consul 自动发现</h2><p>上面我们通过 Consul 注册了 3 个 demo 服务，接下来我们将配置 Prometheus 通过 Consul 来自动发现 demo 服务。</p>
<p>在 Prometheus 的配置文件 <code>prometheus.yml</code> 文件中的 <code>scrape_configs</code> 部分添加如下所示的抓取配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;consul-sd-demo&#x27;</span></span><br><span class="line">    <span class="attr">consul_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">server:</span> <span class="string">&#x27;localhost:8500&#x27;</span></span><br><span class="line">    <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">        <span class="attr">source_labels:</span> [<span class="string">__meta_consul_service</span>, <span class="string">__meta_consul_health</span>]</span><br><span class="line">        <span class="attr">regex:</span> <span class="string">demo;passing</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">__meta_consul_service_metadata_(.*)</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">consul_$1</span></span><br></pre></td></tr></table></figure>

<p>这里我们添加了一个名为 <code>consul-sd-demo</code> 的抓取任务，通过 <code>consul_sd_configs</code> 配置用于自动发现的 Consul 服务地址，然后使用 <code>relabel_configs</code> 进行了重新标记配置，首先只保留服务名称为 <code>demo</code>，且健康状态为 <code>passing</code> 的，否则也会抓取 Consul Agent 本身，而它自身是不提供 metrics 接口数据的，另外还使用 <code>labelmap</code> 进行了标签映射，将所有 Consul 元标签映射到 Prometheus 中以 <code>consul_</code> 为前缀的标签中。</p>
<p>配置完成后重新启动 Prometheus，然后重新查看 Prometheus 页面上的 <code>targets</code> 页面，验证上面的配置是否存在：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/wazumn.png" alt="targets"></p>
<p>正常情况下是可以看到会有一个 <code>consul-sd-demo</code> 的任务，下面有 3 个自动发现的抓取目标。</p>
<p>我们将鼠标悬停在 Labels 标签区域就可以看到目标任务在重新标记 Relabeling 之前的原始标签。比如我们将查看第一个 demo 实例在 Relabel 之前包含如下所示的这些原始标签：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/v6yw8t.png" alt="raw labels"></p>
<p>通过查看网络请求接口 <code>http://&lt;promtheus addr&gt;/api/v1/targets?state=active</code> 也可以获取对应的原始标签数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;discoveredLabels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;__address__&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.31.46:10000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_dc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dc1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_health&quot;</span><span class="punctuation">:</span> <span class="string">&quot;passing&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_node&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_service_address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.31.46&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_service_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_service_metadata_env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;production&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_service_port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_tagged_address_lan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_tagged_address_lan_ipv4&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_tagged_address_wan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_tagged_address_wan_ipv4&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__meta_consul_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;,,&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__metrics_path__&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/metrics&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;__scheme__&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;consul-sd-demo&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;consul_env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;production&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;instance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.31.46:10000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;consul-sd-demo&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scrapePool&quot;</span><span class="punctuation">:</span> <span class="string">&quot;consul-sd-demo&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scrapeUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://192.168.31.46:10000/metrics&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;globalUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://192.168.31.46:10000/metrics&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lastError&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lastScrape&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-09-28T11:56:01.919216851+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lastScrapeDuration&quot;</span><span class="punctuation">:</span> <span class="number">0.013357276</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;health&quot;</span><span class="punctuation">:</span> <span class="string">&quot;up&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们在 <code>relabel_configs</code> 中首先配置了一个 <code>keep</code> 操作，只保留原始标签 <code>__meta_consul_service</code> 值为 <code>demo</code>，且 <code>__meta_consul_health</code> 为 <code>passing</code> 状态的抓取任务。然后使用 <code>labelmap</code> 进行标签映射，这里我们将匹配 <code>__meta_consul_service_metadata_(.*)</code> 所有标签，这里只有 <code>__meta_consul_service_metadata_env</code> 这个原始标签符合正则表达式，其中的 <code>env</code> 就是匹配的捕获组，在 <code>replacement</code> 中用 <code>$1</code> 代替，替换成标签 <code>consul_$1</code>，也就是 <code>consul_env</code> 这个标签了，所以 Relabeling 过后就只剩下下面的几个目标标签了：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">instance:</span> <span class="string">&#x27;192.168.31.46:10000&#x27;</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">&#x27;consul-sd-demo&#x27;</span></span><br><span class="line"><span class="attr">consul_env:</span> <span class="string">&#x27;production&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其中的 <code>instance</code> 标签是在重新标记之后，自动从 <code>__address__</code> 转变而来的。由于没有重新修改 <code>__metrics_path__</code> 和 <code>__scheme__</code> 标签，所以默认的抓取目标就是通过 HTTP 端点 <code>/metrics</code> 进行抓取。</p>
<p>现在如果我们将 <code>demo1</code> 这个服务杀掉，则在 Consul 中注册的服务就会出现一个不健康的实例：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/olw50h.png" alt="unhealth"></p>
<p>当然此时 Prometheus 中就只剩下两个正常 demo 服务的实例了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/uzar5d.png" alt="targets"></p>
<p>当服务正常后就又可以自动发现对应的服务了。这样我们就完成了 Prometheus 基于 Consul 的一个简单的自动发现配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Containerd%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%20nerdctl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Containerd%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%20nerdctl/" class="post-title-link" itemprop="url">Containerd 命令行工具 nerdctl</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:26:02" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/" itemprop="url" rel="index"><span itemprop="name">容器运行时</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Containerd-命令行工具-nerdctl"><a href="#Containerd-命令行工具-nerdctl" class="headerlink" title="Containerd 命令行工具 nerdctl"></a>Containerd 命令行工具 nerdctl</h1><p>前面我们介绍了可以使用 <code>ctr</code> 操作管理 containerd 镜像容器，但是大家都习惯了使用 docker cli，<code>ctr</code> 使用起来可能还是不太顺手，为了能够让大家更好的转到 containerd 上面来，社区提供了一个新的命令行工具：<a target="_blank" rel="noopener" href="https://github.com/containerd/nerdctl">nerdctl</a>。nerdctl 是一个与 docker cli 风格兼容的 containerd 客户端工具，而且直接兼容 docker compose 的语法的，这就大大提高了直接将 containerd 作为本地开发、测试或者单机容器部署使用的效率。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>同样直接在 GitHub Release 页面下载对应的压缩包解压到 PATH 路径下即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有安装 containerd，则可以下载 nerdctl-full-&lt;VERSION&gt;-linux-amd64.tar.gz 包进行安装</span></span><br><span class="line">➜  ~ wget https://github.com/containerd/nerdctl/releases/download/v0.12.1/nerdctl-0.12.1-linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有限制，也可以替换成下面的 URL 加速下载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget https://download.fastgit.org/containerd/nerdctl/releases/download/v0.12.1/nerdctl-0.12.1-linux-amd64.tar.gz</span></span><br><span class="line">➜  ~ mkdir -p /usr/local/containerd/bin/ &amp;&amp; tar -zxvf nerdctl-0.12.1-linux-amd64.tar.gz nerdctl &amp;&amp; mv nerdctl /usr/local/containerd/bin/</span><br><span class="line">➜  ~ ln -s /usr/local/containerd/bin/nerdctl /usr/local/bin/nerdctl</span><br><span class="line">➜  ~ nerdctl version</span><br><span class="line">Client:</span><br><span class="line"> Version:       v0.12.1</span><br><span class="line"> Git commit:    c802f934791f83dacf20a041cd1c865f8fac954e</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> containerd:</span><br><span class="line">  Version:      v1.5.5</span><br><span class="line">  Revision:     72cec4be58a9eb6b2910f5d10f1c01ca47d231c0</span><br></pre></td></tr></table></figure>

<p>安装完成后接下来学习下 <code>nerdctl</code> 命令行工具的使用。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="Run-Exec"><a href="#Run-Exec" class="headerlink" title="Run&amp;Exec"></a>Run&amp;Exec</h3><p><strong>🐳nerdctl run</strong></p>
<p>和 <code>docker run</code> 类似可以使用 <code>nerdctl run</code> 命令运行容器，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl run -d -p 80:80 --name=nginx --restart=always nginx:alpine</span><br><span class="line">docker.io/library/nginx:alpine:                                                   resolved       |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">index-sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce:    done           |++++++++++++++++++++++++++++++++++++++| manifest-sha256:ce6ca11a3fa7e0e6b44813901e3289212fc2f327ee8b1366176666e8fb470f24: done           |++++++++++++++++++++++++++++++++++++++| config-sha256:7ce0143dee376bfd2937b499a46fb110bda3c629c195b84b1cf6e19be1a9e23b:   done           |++++++++++++++++++++++++++++++++++++++| elapsed: 5.3 s                                                                    total:  3.1 Ki (606.0 B/s)                                       6e489777d2f73dda8a310cdf8da9df38353c1aa2021d3c2270b30eff1806bcf8</span><br></pre></td></tr></table></figure>

<p>可选的参数使用和 <code>docker run</code> 基本一直，比如 <code>-i</code>、<code>-t</code>、<code>--cpus</code>、<code>--memory</code> 等选项，可以使用 <code>nerdctl run --help</code> 获取可使用的命令选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl run --help</span><br><span class="line">NAME:</span><br><span class="line">   nerdctl run - Run a command in a new container</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   nerdctl run [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --help                        show help (default: false)</span><br><span class="line">   --tty, -t                     (Currently -t needs to correspond to -i) (default: false)</span><br><span class="line">   --interactive, -i             Keep STDIN open even if not attached (default: false)</span><br><span class="line">   --detach, -d                  Run container in background and print container ID (default: false)</span><br><span class="line">   --restart value               Restart policy to apply when a container exits (implemented values: &quot;no&quot;|&quot;always&quot;) (default: &quot;no&quot;)</span><br><span class="line">   --rm                          Automatically remove the container when it exits (default: false)</span><br><span class="line">   --pull value                  Pull image before running (&quot;always&quot;|&quot;missing&quot;|&quot;never&quot;) (default: &quot;missing&quot;)</span><br><span class="line">   --network value, --net value  Connect a container to a network (&quot;bridge&quot;|&quot;host&quot;|&quot;none&quot;) (default: &quot;bridge&quot;)</span><br><span class="line">   --dns value                   Set custom DNS servers (default: &quot;8.8.8.8&quot;, &quot;1.1.1.1&quot;)</span><br><span class="line">   --publish value, -p value     Publish a container&#x27;s port(s) to the host</span><br><span class="line">   --hostname value, -h value    Container host name</span><br><span class="line">   --cpus value                  Number of CPUs (default: 0)</span><br><span class="line">   --memory value, -m value      Memory limit</span><br><span class="line">   --pid value                   PID namespace to use</span><br><span class="line">   --pids-limit value            Tune container pids limit (set -1 for unlimited) (default: -1)</span><br><span class="line">   --cgroupns value              Cgroup namespace to use, the default depends on the cgroup version (&quot;host&quot;|&quot;private&quot;) (default: &quot;host&quot;)</span><br><span class="line">   --cpuset-cpus value           CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">   --cpu-shares value            CPU shares (relative weight) (default: 0)</span><br><span class="line">   --device value                Add a host device to the container</span><br><span class="line">   --user value, -u value        Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class="line">   --security-opt value          Security options</span><br><span class="line">   --cap-add value               Add Linux capabilities</span><br><span class="line">   --cap-drop value              Drop Linux capabilities</span><br><span class="line">   --privileged                  Give extended privileges to this container (default: false)</span><br><span class="line">   --runtime value               Runtime to use for this container, e.g. &quot;crun&quot;, or &quot;io.containerd.runsc.v1&quot; (default: &quot;io.containerd.runc.v2&quot;)</span><br><span class="line">   --sysctl value                Sysctl options</span><br><span class="line">   --gpus value                  GPU devices to add to the container (&#x27;all&#x27; to pass all GPUs)</span><br><span class="line">   --volume value, -v value      Bind mount a volume</span><br><span class="line">   --read-only                   Mount the container&#x27;s root filesystem as read only (default: false)</span><br><span class="line">   --rootfs                      The first argument is not an image but the rootfs to the exploded container (default: false)</span><br><span class="line">   --entrypoint value            Overwrite the default ENTRYPOINT of the image</span><br><span class="line">   --workdir value, -w value     Working directory inside the container</span><br><span class="line">   --env value, -e value         Set environment variables</span><br><span class="line">   --env-file value              Set environment variables from file</span><br><span class="line">   --name value                  Assign a name to the container</span><br><span class="line">   --label value, -l value       Set meta data on a container</span><br><span class="line">   --label-file value            Read in a line delimited file of labels</span><br><span class="line">   --cidfile value               Write the container ID to the file</span><br><span class="line">   --shm-size value              Size of /dev/shm</span><br></pre></td></tr></table></figure>

<p><strong>🐳nerdctl exec</strong></p>
<p>同样也可以使用 <code>exec</code> 命令执行容器相关命令，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl exec -it nginx /bin/sh</span><br><span class="line">/ # date</span><br><span class="line">Thu Aug 19 06:43:19 UTC 2021</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>

<h3 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h3><p><strong>🐳nerdctl ps</strong>：列出容器</p>
<p>使用 <code>nerdctl ps</code> 命令可以列出所有容器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl ps</span><br><span class="line">CONTAINER ID    IMAGE                             COMMAND                   CREATED           STATUS    PORTS                 NAMES</span><br><span class="line">6e489777d2f7    docker.io/library/nginx:alpine    &quot;/docker-entrypoint.…&quot;    10 minutes ago    Up        0.0.0.0:80-&gt;80/tcp    nginx</span><br></pre></td></tr></table></figure>

<p>同样可以使用 <code>-a</code> 选项显示所有的容器列表，默认只显示正在运行的容器，不过需要注意的是 <code>nerdctl ps</code> 命令并没有实现 <code>docker ps</code> 下面的 <code>--filter</code>、<code>--format</code>、<code>--last</code>、<code>--size</code> 等选项。</p>
<p><strong>🐳nerdctl inspect</strong>：获取容器的详细信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl inspect nginx</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;6e489777d2f73dda8a310cdf8da9df38353c1aa2021d3c2270b30eff1806bcf8&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-08-19T06:35:46.403464674Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/docker-entrypoint.sh&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;nginx&quot;,</span><br><span class="line">            &quot;-g&quot;,</span><br><span class="line">            &quot;daemon off;&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 2002,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;docker.io/library/nginx:alpine&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/nerdctl/1935db59/containers/default/6e489777d2f73dda8a310cdf8da9df38353c1aa2021d3c2270b30eff1806bcf8/resolv.conf&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/nerdctl/1935db59/containers/default/6e489777d2f73dda8a310cdf8da9df38353c1aa2021d3c2270b30eff1806bcf8/6e489777d2f73dda8a310cdf8da9df38353c1aa2021d3c2270b30eff1806bcf8-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;nginx&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlayfs&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;nerdctl-default&quot;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Ports&quot;: &#123;</span><br><span class="line">                &quot;80/tcp&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;HostIp&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">                        &quot;HostPort&quot;: &quot;80&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;10.4.0.3&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 24,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;f2:b1:8e:a2:fe:18&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;unknown-eth0&quot;: &#123;</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;10.4.0.3&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 24,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;f2:b1:8e:a2:fe:18&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>可以看到显示结果和 <code>docker inspect</code> 也基本一致的。</p>
<p><strong>🐳nerdctl logs</strong>：获取容器日志</p>
<p>查看容器日志是我们平时经常会使用到的一个功能，同样我们可以使用 <code>nerdctl logs</code> 来获取日志数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl logs -f nginx</span><br><span class="line">......</span><br><span class="line">2021/08/19 06:35:46 [notice] 1#1: start worker processes</span><br><span class="line">2021/08/19 06:35:46 [notice] 1#1: start worker process 32</span><br><span class="line">2021/08/19 06:35:46 [notice] 1#1: start worker process 33</span><br></pre></td></tr></table></figure>

<p>同样支持 <code>-f</code>、<code>-t</code>、<code>-n</code>、<code>--since</code>、<code>--until</code> 这些选项。</p>
<p><strong>🐳nerdctl stop</strong>：停止容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl stop nginx</span><br><span class="line">nginx</span><br><span class="line">➜  ~ nerdctl ps</span><br><span class="line">CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS    PORTS    NAMES</span><br><span class="line">➜  ~ nerdctl ps -a</span><br><span class="line">CONTAINER ID    IMAGE                             COMMAND                   CREATED           STATUS    PORTS                 NAMES</span><br><span class="line">6e489777d2f7    docker.io/library/nginx:alpine    &quot;/docker-entrypoint.…&quot;    20 minutes ago    Up        0.0.0.0:80-&gt;80/tcp    nginx</span><br></pre></td></tr></table></figure>

<p><strong>🐳nerdctl rm</strong>：删除容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl rm nginx</span><br><span class="line">You cannot remove a running container f4ac170235595f28bf962bad68aa81b20fc83b741751e7f3355bd77d8016462d. Stop the container before attempting removal or force remove</span><br><span class="line">➜  ~ nerdctl rm -f ginx</span><br><span class="line">nginx</span><br><span class="line">➜  ~ nerdctl ps</span><br><span class="line">CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS    PORTS    NAMES</span><br></pre></td></tr></table></figure>

<p>要强制删除同样可以使用 <code>-f</code> 或 <code>--force</code> 选项来操作。</p>
<h3 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h3><p><strong>🐳nerdctl images</strong>：镜像列表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID        CREATED           SIZE</span><br><span class="line">alpine        latest    eb3e4e175ba6    6 days ago        5.9 MiB</span><br><span class="line">nginx         alpine    bead42240255    29 minutes ago    16.0 KiB</span><br></pre></td></tr></table></figure>

<p>也需要注意的是没有实现 <code>docker images</code> 的一些选项，比如 <code>--all</code>、<code>--digests</code>、<code>--filter</code>、<code>--format</code>。</p>
<p><strong>🐳nerdctl pull</strong>：拉取镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker.io/library/busybox:latest:</span><br><span class="line">resolved       |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">index-sha256:0f354ec1728d9ff32edcd7d1b8bbdfc798277ad36120dc3dc683be44524c8b60:    done           |++++++++++++++++++++++++++++++++++++++| manifest-sha256:dca71257cd2e72840a21f0323234bb2e33fea6d949fa0f21c5102146f583486b: done           |++++++++++++++++++++++++++++++++++++++| config-sha256:69593048aa3acfee0f75f20b77acb549de2472063053f6730c4091b53f2dfb02:   done           |++++++++++++++++++++++++++++++++++++++| layer-sha256:b71f96345d44b237decc0c2d6c2f9ad0d17fde83dad7579608f1f0764d9686f2:    done           |++++++++++++++++++++++++++++++++++++++| elapsed: 5.9 s                                                                    total:  752.8  (127.5 KiB/s)</span><br></pre></td></tr></table></figure>

<p><strong>🐳nerdctl push</strong>：推送镜像</p>
<p>当然在推送镜像之前也可以使用 <code>nerdctl login</code> 命令登录到镜像仓库，然后再执行 push 操作。</p>
<p>可以使用 <code>nerdctl login --username xxx --password xxx</code> 进行登录，使用 <code>nerdctl logout</code> 可以注销退出登录。</p>
<p><strong>🐳nerdctl tag</strong>：镜像标签</p>
<p>使用 <code>tag</code> 命令可以为一个镜像创建一个别名镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl images</span><br><span class="line">REPOSITORY    TAG                  IMAGE ID        CREATED           SIZE</span><br><span class="line">busybox       latest               0f354ec1728d    6 minutes ago     1.3 MiB</span><br><span class="line">nginx         alpine               bead42240255    41 minutes ago    16.0 KiB</span><br><span class="line">➜  ~ nerdctl tag nginx:alpine harbor.k8s.local/course/nginx:alpine</span><br><span class="line">➜  ~ nerdctl images</span><br><span class="line">REPOSITORY                       TAG                  IMAGE ID        CREATED           SIZE</span><br><span class="line">busybox                          latest               0f354ec1728d    7 minutes ago     1.3 MiB</span><br><span class="line">nginx                            alpine               bead42240255    41 minutes ago    16.0 KiB</span><br><span class="line">harbor.k8s.local/course/nginx    alpine               bead42240255    2 seconds ago     16.0 KiB</span><br></pre></td></tr></table></figure>

<p><strong>🐳nerdctl save</strong>：导出镜像</p>
<p>使用 <code>save</code> 命令可以导出镜像为一个 <code>tar</code> 压缩包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl save -o busybox.tar.gz busybox:latest</span><br><span class="line">➜  ~ ls -lh busybox.tar.gz</span><br><span class="line">-rw-r--r-- 1 root root 761K Aug 19 15:19 busybox.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>🐳nerdctl rmi</strong>：删除镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl rmi busybox</span><br><span class="line">Untagged: docker.io/library/busybox:latest@sha256:0f354ec1728d9ff32edcd7d1b8bbdfc798277ad36120dc3dc683be44524c8b60</span><br><span class="line">Deleted: sha256:5b8c72934dfc08c7d2bd707e93197550f06c0751023dabb3a045b723c5e7b373</span><br></pre></td></tr></table></figure>

<p><strong>🐳nerdctl load</strong>：导入镜像</p>
<p>使用 <code>load</code> 命令可以将上面导出的镜像再次导入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl load -i busybox.tar.gz</span><br><span class="line">unpacking docker.io/library/busybox:latest (sha256:0f354ec1728d9ff32edcd7d1b8bbdfc798277ad36120dc3dc683be44524c8b60)...done</span><br></pre></td></tr></table></figure>

<p>使用 <code>-i</code> 或 <code>--input</code> 选项指定需要导入的压缩包。</p>
<h3 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a>镜像构建</h3><p>镜像构建是平时我们非常重要的一个需求，我们知道 <code>ctr</code> 并没有构建镜像的命令，而现在我们又不使用 Docker 了，那么如何进行镜像构建了，幸运的是 <code>nerdctl</code> 就提供了 <code>nerdctl build</code> 这样的镜像构建命令。</p>
<p><strong>🐳nerdctl build</strong>：从 Dockerfile 构建镜像</p>
<p>比如现在我们定制一个 nginx 镜像，新建一个如下所示的 Dockerfile 文件：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;Hello Nerdctl From Containerd&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>

<p>然后在文件所在目录执行镜像构建命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl build -t nginx:nerdctl -f Dockerfile .</span><br><span class="line">FATA[0000] `buildctl` needs to be installed and `buildkitd` needs to be running, see https://github.com/moby/buildkit: exec: &quot;buildctl&quot;: executable file not found in $PATH</span><br></pre></td></tr></table></figure>

<p>可以看到有一个错误提示，需要我们安装 <code>buildctl</code> 并运行 <code>buildkitd</code>，这是因为 <code>nerdctl build</code> 需要依赖 <code>buildkit</code> 工具。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/moby/buildkit">buildkit</a> 项目也是 Docker 公司开源的一个构建工具包，支持 OCI 标准的镜像构建。它主要包含以下部分:</p>
<ul>
<li>服务端 <code>buildkitd</code>：当前支持 runc 和 containerd 作为 worker，默认是 runc，我们这里使用 containerd</li>
<li>客户端 <code>buildctl</code>：负责解析 Dockerfile，并向服务端 buildkitd 发出构建请求</li>
</ul>
<p>buildkit 是典型的 C&#x2F;S 架构，客户端和服务端是可以不在一台服务器上，而 <code>nerdctl</code> 在构建镜像的时候也作为 <code>buildkitd</code> 的客户端，所以需要我们安装并运行 <code>buildkitd</code>。</p>
<p>所以接下来我们先来安装 <code>buildkit</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ wget https://github.com/moby/buildkit/releases/download/v0.9.1/buildkit-v0.9.1.linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有限制，也可以替换成下面的 URL 加速下载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget https://download.fastgit.org/moby/buildkit/releases/download/v0.9.1/buildkit-v0.9.1.linux-amd64.tar.gz</span></span><br><span class="line">➜  ~ tar -zxvf buildkit-v0.9.1.linux-amd64.tar.gz -C /usr/local/containerd/</span><br><span class="line">bin/</span><br><span class="line">bin/buildctl</span><br><span class="line">bin/buildkit-qemu-aarch64</span><br><span class="line">bin/buildkit-qemu-arm</span><br><span class="line">bin/buildkit-qemu-i386</span><br><span class="line">bin/buildkit-qemu-mips64</span><br><span class="line">bin/buildkit-qemu-mips64el</span><br><span class="line">bin/buildkit-qemu-ppc64le</span><br><span class="line">bin/buildkit-qemu-riscv64</span><br><span class="line">bin/buildkit-qemu-s390x</span><br><span class="line">bin/buildkit-runc</span><br><span class="line">bin/buildkitd</span><br><span class="line">➜  ~ ln -s /usr/local/containerd/bin/buildkitd /usr/local/bin/buildkitd</span><br><span class="line">➜  ~ ln -s /usr/local/containerd/bin/buildctl /usr/local/bin/buildctl</span><br></pre></td></tr></table></figure>

<p>这里我们使用 Systemd 来管理 <code>buildkitd</code>，创建如下所示的 <code>systemd unit</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /etc/systemd/system/buildkit.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=BuildKit</span><br><span class="line">Documentation=https://github.com/moby/buildkit</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/bin/buildkitd --oci-worker=false --containerd-worker=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>然后启动 <code>buildkitd</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ systemctl daemon-reload</span><br><span class="line">➜  ~ systemctl enable buildkit --now</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/buildkit.service → /etc/systemd/system/buildkit.service.</span><br><span class="line">➜  ~ systemctl status buildkit</span><br><span class="line">● buildkit.service - BuildKit</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/buildkit.service; enabled; vendor preset: enabled)</span><br><span class="line">     Memory: 8.6M</span><br><span class="line">     CGroup: /system.slice/buildkit.service</span><br><span class="line">             └─5779 /usr/local/bin/buildkitd --oci-worker=false --containerd-worker=true</span><br><span class="line"></span><br><span class="line">Aug 19 16:03:10 ydzsio systemd[1]: Started BuildKit.</span><br><span class="line">Aug 19 16:03:10 ydzsio buildkitd[5779]: time=&quot;2021-08-19T16:03:10+08:00&quot; level=warning msg=&quot;using host network as the default&quot;</span><br><span class="line">Aug 19 16:03:10 ydzsio buildkitd[5779]: time=&quot;2021-08-19T16:03:10+08:00&quot; level=info msg=&quot;found worker \&quot;euznuelxhxb689bc5of7pxmbc\&quot;, labels&gt;</span><br><span class="line">Aug 19 16:03:10 ydzsio buildkitd[5779]: time=&quot;2021-08-19T16:03:10+08:00&quot; level=info msg=&quot;found 1 workers, default=\&quot;euznuelxhxb689bc5of7pxm&gt;</span><br><span class="line">Aug 19 16:03:10 ydzsio buildkitd[5779]: time=&quot;2021-08-19T16:03:10+08:00&quot; level=warning msg=&quot;currently, only the default worker can be used.&quot;</span><br><span class="line">Aug 19 16:03:10 ydzsio buildkitd[5779]: time=&quot;2021-08-19T16:03:10+08:00&quot; level=info msg=&quot;running server on /run/buildkit/buildkitd.sock&quot;</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

<p>现在我们再来重新构建镜像：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/7oga7u.png" alt="nerdctl 构建镜像"></p>
<p>构建完成后查看镜像是否构建成功：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl images</span><br><span class="line">WARN[0000] unparsable image name &quot;overlayfs@sha256:d5b9b9e4c930f30340650cb373f62f97c93ee3b92c83f01c6e00b7b87d62c624&quot;</span><br><span class="line">REPOSITORY    TAG        IMAGE ID        CREATED               SIZE</span><br><span class="line">nginx         latest     4d4d96ac750a    4 minutes ago         16.0 KiB</span><br><span class="line">nginx         nerdctl    d5b9b9e4c930    About a minute ago    24.0 KiB</span><br></pre></td></tr></table></figure>

<p>我们可以看到已经有我们构建的 <code>nginx:nerdctl</code> 镜像了。接下来使用上面我们构建的镜像来启动一个容器进行测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nerdctl run -d -p 80:80 --name=nginx --restart=always nginx:nerdctl</span><br><span class="line">f8f639cb667926023231b13584226b2c7b856847e0a25bd5f686b9a6e7e3cacd</span><br><span class="line">➜  ~ nerdctl ps</span><br><span class="line">CONTAINER ID    IMAGE                              COMMAND                   CREATED         STATUS    PORTS                 NAMES</span><br><span class="line">f8f639cb6679    docker.io/library/nginx:nerdctl    &quot;/docker-entrypoint.…&quot;    1 second ago    Up        0.0.0.0:80-&gt;80/tcp    nginx</span><br><span class="line">➜  ~ curl localhost</span><br><span class="line">This is a nerdctl build&#x27;s nginx image base on containerd</span><br></pre></td></tr></table></figure>

<p>这样我们就使用 <code>nerdctl + buildkitd</code> 轻松完成了容器镜像的构建。</p>
<p>当然如果你还想在单机环境下使用 Docker Compose，在 containerd 模式下，我们也可以使用 <code>nerdctl</code> 来兼容该功能。同样我们可以使用 <code>nerdctl compose</code>、<code>nerdctl compose up</code>、<code>nerdctl compose logs</code>、<code>nerdctl compose build</code>、<code>nerdctl compose down</code> 等命令来管理 Compose 服务。这样使用 containerd、nerdctl 结合 buildkit 等工具就完全可以替代 docker 在镜像构建、镜像容器方面的管理功能了。</p>
<p><a target="_blank" rel="noopener" href="https://docs.youdianzhishi.com/k8s/runtime/usage/">
</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Cookie%E3%80%81Session%20%E5%92%8C%20Token%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Cookie%E3%80%81Session%20%E5%92%8C%20Token%20/" class="post-title-link" itemprop="url">Cookie、Session 和 Token</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:26:20" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Cookie、Session 和 Token 都是在 Web 开发中用于<strong>管理用户状态、实现身份认证和授权</strong>的关键机制，但它们在存储位置、工作原理、安全性、无状态性等方面存在显著差异。</p>
<h3 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h3><ul>
<li><strong>定义：</strong> Cookie 是<strong>存储在用户浏览器（客户端）</strong> 的一小段文本信息。</li>
<li><strong>作用：</strong><ul>
<li><strong>会话管理：</strong> 记录用户的登录状态、购物车内容等。</li>
<li><strong>个性化设置：</strong> 记住用户的偏好（如语言、主题）。</li>
<li><strong>追踪：</strong> 记录用户行为，用于数据分析和广告推送。</li>
</ul>
</li>
<li><strong>工作原理：</strong><ol>
<li>当用户第一次访问服务器时，服务器在响应头中包含 <code>Set-Cookie</code> 字段，将 Cookie 发送给浏览器。</li>
<li>浏览器接收到 Cookie 后，将其存储起来。</li>
<li>之后，浏览器每次向同一个域发送请求时，都会在请求头中自动带上该域相关的所有 Cookie。</li>
<li>服务器接收到请求后，从 Cookie 中读取信息。</li>
</ol>
</li>
<li><strong>特点：</strong><ul>
<li><strong>存储位置：</strong> 客户端（浏览器）。</li>
<li><strong>由谁管理：</strong> 浏览器自动发送，服务器设置。</li>
<li><strong>安全性：</strong><ul>
<li><strong>易受 CSRF 攻击：</strong> 因为浏览器会自动发送 Cookie，攻击者可能利用这一点伪造请求。</li>
<li><strong>易受 XSS 攻击：</strong> 如果未设置 <code>HttpOnly</code> 标志，JS 可以访问 Cookie，攻击者可利用 XSS 窃取 Cookie。</li>
<li><strong>明文传输风险：</strong> 如果不使用 HTTPS，Cookie 内容可能被截获。</li>
</ul>
</li>
<li><strong>大小限制：</strong> 通常每个 Cookie 大小限制在 4KB 左右，且每个域的 Cookie 数量也有限制。</li>
<li><strong>跨域：</strong> 通常不支持跨域共享（除非进行特殊配置如 <code>domain</code> 属性）。</li>
</ul>
</li>
</ul>
<h3 id="2-Session-基于-Cookie-或-URL-重写"><a href="#2-Session-基于-Cookie-或-URL-重写" class="headerlink" title="2. Session (基于 Cookie 或 URL 重写)"></a>2. Session (基于 Cookie 或 URL 重写)</h3><ul>
<li><strong>定义：</strong> Session 是一种<strong>服务器端</strong>的用户会话管理机制。服务器为每个用户创建一个唯一的会话（Session），并将用户的状态信息存储在服务器上。</li>
<li><strong>作用：</strong> 维护用户的会话状态，跟踪用户在一系列请求中的操作。</li>
<li><strong>工作原理：</strong><ol>
<li>当用户第一次访问服务器时，服务器会生成一个唯一的 Session ID。</li>
<li>服务器将这个 Session ID 以 Cookie（最常见的方式，称为 Session Cookie）的形式发送给浏览器。</li>
<li>浏览器接收到 Session ID Cookie 后存储起来。</li>
<li>之后，浏览器每次请求时，都会将这个 Session ID Cookie 发送给服务器。</li>
<li>服务器根据 Session ID 找到对应的 Session 数据，从而识别用户和其会话状态。</li>
<li>（另一种较少用的方式是 URL 重写，将 Session ID 放在 URL 参数中，但安全性、美观性差）</li>
</ol>
</li>
<li><strong>特点：</strong><ul>
<li><strong>存储位置：</strong> 服务器端。客户端只存储 Session ID。</li>
<li><strong>由谁管理：</strong> 服务器生成和管理会话；Cookie（Session ID）由浏览器自动发送。</li>
<li><strong>安全性：</strong> 相对于直接将数据存放在 Cookie 中更安全，因为实际数据在服务器端，攻击者无法直接篡改。但仍依赖于 Cookie 的安全性（CSRF、XSS）。</li>
<li><strong>扩展性（Scalability）：</strong> 存在挑战。在分布式系统中（多台服务器），需要共享 Session 数据（如使用 Redis、Memcached 等集中式存储），否则用户请求可能被路由到不识别其 Session 的服务器。</li>
<li><strong>占用服务器资源：</strong> 每个会话都会占用服务器内存或其他存储资源。</li>
</ul>
</li>
</ul>
<h3 id="3-Token-通常指-JWT-JSON-Web-Token"><a href="#3-Token-通常指-JWT-JSON-Web-Token" class="headerlink" title="3. Token (通常指 JWT - JSON Web Token)"></a>3. Token (通常指 JWT - JSON Web Token)</h3><ul>
<li><strong>定义：</strong> Token 是一种<strong>无状态</strong>的认证机制。与 Session 不同，用户的所有认证信息和授权信息都<strong>编码在 Token 本身</strong>中，并通过签名确保其不可篡改。</li>
<li><strong>作用：</strong> 用户身份认证和授权。它允许服务器在不存储用户状态的情况下，验证用户的身份和权限。</li>
<li><strong>工作原理（JWT 为例）：</strong><ol>
<li>用户通过用户名和密码向服务器认证。</li>
<li>服务器验证凭据，然后生成一个包含用户信息的 Token（如用户ID、角色、过期时间）。</li>
<li>服务器将 Token 返回给客户端。</li>
<li>客户端（通常是浏览器或移动应用）将 Token 存储起来（如在 localStorage、sessionStorage 或 Cookie 中）。</li>
<li>之后，客户端每次向服务器发送请求时，都会在请求头（通常是 <code>Authorization</code> 字段，如 <code>Bearer &lt;token&gt;</code>）中带上这个 Token。</li>
<li>服务器接收到请求后，解析并验证 Token 的签名。如果签名有效且未过期，服务器就认为用户是合法的，并从 Token 中提取用户信息，进行授权操作。</li>
</ol>
</li>
<li><strong>特点：</strong><ul>
<li><strong>存储位置：</strong> 客户端（通常是 localStorage、sessionStorage）。</li>
<li><strong>由谁管理：</strong> Token 由服务器生成和签名，客户端存储和发送，服务器验证。</li>
<li><strong>安全性：</strong><ul>
<li><strong>无状态：</strong> 服务器无需存储会话信息，减轻服务器压力，易于扩展。</li>
<li><strong>减少 CSRF 风险：</strong> 因为 Token 不会自动由浏览器发送，攻击者难以利用。</li>
<li><strong>易受 XSS 攻击：</strong> 如果 Token 存储在 localStorage，仍可能被 XSS 攻击窃取。解决方案是结合 Cookie 和 HttpOnly 使用。</li>
<li><strong>明文传输风险：</strong> Token 内容（Payload）是 Base64 编码的，不是加密的。敏感信息不应直接放入 Token 中。认证必须通过 HTTPS。</li>
<li><strong>无法主动失效：</strong> 一旦 Token 被签发，除非过期，否则服务器无法强制其失效（除非使用黑名单机制）。</li>
</ul>
</li>
<li><strong>扩展性（Scalability）：</strong> 极其适合分布式系统和微服务架构，因为每个服务器都可以独立验证 Token，无需共享会话数据。</li>
<li><strong>大小：</strong> 通常比 Session ID 大，但比完整 Session 数据小。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="对比总结："><a href="#对比总结：" class="headerlink" title="对比总结："></a>对比总结：</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Cookie</th>
<th align="left">Session</th>
<th align="left">Token (JWT)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工作模式</strong></td>
<td align="left">客户端存储少量数据</td>
<td align="left">服务器端存储会话数据，客户端存 ID</td>
<td align="left">客户端存储包含认证授权信息的数据</td>
</tr>
<tr>
<td align="left"><strong>状态</strong></td>
<td align="left">有状态（服务器依赖 Cookie 内容进行决策）</td>
<td align="left">有状态（服务器需要存储会话数据）</td>
<td align="left"><strong>无状态</strong>（服务器无需存储会话信息）</td>
</tr>
<tr>
<td align="left"><strong>存储位置</strong></td>
<td align="left"><strong>客户端（浏览器）</strong></td>
<td align="left"><strong>服务器端</strong>（实际数据）；客户端存 Session ID（通常在 Cookie 中）</td>
<td align="left"><strong>客户端</strong>（通常是 localStorage&#x2F;sessionStorage）</td>
</tr>
<tr>
<td align="left"><strong>发送方式</strong></td>
<td align="left">浏览器自动每次请求都带上</td>
<td align="left">浏览器自动带上 Session ID Cookie</td>
<td align="left">客户端手动添加到请求头（如 <code>Authorization: Bearer &lt;token&gt;</code>）</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">CSRF, XSS (无 HttpOnly) 风险高</td>
<td align="left">对实际数据更安全，但仍依赖 Session ID Cookie 的安全</td>
<td align="left">XSS (localStorage) 风险；无法强制失效；无 CSRF 风险（但需避免 Cookie 传输）</td>
</tr>
<tr>
<td align="left"><strong>可扩展性</strong></td>
<td align="left">中等（依赖于每个请求都带上）</td>
<td align="left">差（分布式需共享 Session）</td>
<td align="left"><strong>好</strong>（无状态，易于分布式部署）</td>
</tr>
<tr>
<td align="left"><strong>资源消耗</strong></td>
<td align="left">客户端资源</td>
<td align="left"><strong>服务器资源</strong>（内存&#x2F;DB 存储会话）</td>
<td align="left">客户端资源（存储 Token）；服务器资源（验证签名）</td>
</tr>
<tr>
<td align="left"><strong>应用场景</strong></td>
<td align="left">少量信息存储，用户偏好，追踪</td>
<td align="left">传统 Web 应用的登录状态管理</td>
<td align="left">RESTful API 认证，移动应用，SSO (单点登录)</td>
</tr>
</tbody></table>
<h3 id="如何选择："><a href="#如何选择：" class="headerlink" title="如何选择："></a>如何选择：</h3><ul>
<li><strong>Session + Cookie：</strong> 适用于传统的<strong>单体应用</strong>，需要维护用户会话状态，且不追求极致的扩展性。优点是实现相对简单，安全性在于服务器端数据。</li>
<li><strong>Token (JWT)：</strong> 适用于<strong>前后端分离</strong>、<strong>微服务架构</strong>、<strong>移动应用</strong>、<strong>跨域认证</strong>以及<strong>单点登录 (SSO)</strong> 场景。优点是无状态、易于扩展、安全性相对较高（尤其是在防范 CSRF 方面）。需要注意 JWT 的过期和刷新机制。</li>
<li><strong>纯 Cookie：</strong> 比较少用于身份认证，更多用于少量非敏感数据的存储和用户行为追踪。因为直接在 Cookie 中存储敏感信息安全性较低。</li>
</ul>
<p>在现代 Web 开发中，由于前后端分离和微服务的流行，<strong>Token (JWT)</strong> 已成为越来越主流的认证授权方式。但很多框架也会结合使用 Cookie 来存储 Token，并利用 HttpOnly 和 Secure 标志来增强安全性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Containerd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Containerd/" class="post-title-link" itemprop="url">Containerd</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:26:11" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/" itemprop="url" rel="index"><span itemprop="name">容器运行时</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Containerd-使用"><a href="#Containerd-使用" class="headerlink" title="Containerd 使用"></a>Containerd 使用</h1><p>我们知道很早之前的 Docker Engine 中就有了 containerd，只不过现在是将 containerd 从 Docker Engine 里分离出来，作为一个独立的开源项目，目标是提供一个更加开放、稳定的容器运行基础设施。分离出来的 containerd 将具有更多的功能，涵盖整个容器运行时管理的所有需求，提供更强大的支持。</p>
<p>containerd 是一个工业级标准的容器运行时，它强调<strong>简单性</strong>、<strong>健壮性</strong>和<strong>可移植性</strong>，containerd 可以负责干下面这些事情：</p>
<ul>
<li>管理容器的生命周期（从创建容器到销毁容器）</li>
<li>拉取&#x2F;推送容器镜像</li>
<li>存储管理（管理镜像及容器数据的存储）</li>
<li>调用 runc 运行容器（与 runc 等容器运行时交互）</li>
<li>管理容器网络接口及网络</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>containerd 可用作 Linux 和 Windows 的守护程序，它管理其主机系统完整的容器生命周期，从镜像传输和存储到容器执行和监测，再到底层存储到网络附件等等。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/y4qwfy.png" alt="containerd 架构"></p>
<p>上图是 containerd 官方提供的架构图，可以看出 containerd 采用的也是 C&#x2F;S 架构，服务端通过 unix domain socket 暴露低层的 gRPC API 接口出去，客户端通过这些 API 管理节点上的容器，每个 containerd 只负责一台机器，Pull 镜像，对容器的操作（启动、停止等），网络，存储都是由 containerd 完成。具体运行容器由 runc 负责，实际上只要是符合 OCI 规范的容器都可以支持。</p>
<p>为了解耦，containerd 将系统划分成了不同的组件，每个组件都由一个或多个模块协作完成（Core 部分），每一种类型的模块都以插件的形式集成到 Containerd 中，而且插件之间是相互依赖的，例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 Service Plugin、Metadata Plugin、GC Plugin、Runtime Plugin 等，其中 Service Plugin 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 Metadata Plugin 依赖 Containers Plugin、Content Plugin 等。比如:</p>
<ul>
<li><code>Content Plugin</code>: 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。</li>
<li><code>Snapshot Plugin</code>: 用来管理容器镜像的文件系统快照，镜像中的每一层都会被解压成文件系统快照，类似于 Docker 中的 graphdriver。</li>
</ul>
<p>总体来看 containerd 可以分为三个大块：Storage、Metadata 和 Runtime。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/ca5ndj.png" alt="containerd 架构2"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里我使用的系统是 <code>CentOS 7.6</code>，首先需要安装 <code>seccomp</code> 依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ rpm -qa |grep libseccomp</span><br><span class="line">libseccomp-2.3.1-4.el7.x86_64</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有安装 libseccomp 包则执行下面的命令安装依赖</span></span><br><span class="line">➜  ~ yum install wget -y</span><br><span class="line">➜  ~ wget http://mirror.centos.org/centos/7/os/x86_64/Packages/libseccomp-2.3.1-4.el7.x86_64.rpm</span><br><span class="line">➜  ~ yum install libseccomp-2.3.1-4.el7.x86_64.rpm -y</span><br></pre></td></tr></table></figure>

<p>由于 containerd 需要调用 runc，所以我们也需要先安装 runc，不过 containerd 提供了一个包含相关依赖的压缩包 <code>cri-containerd-cni-$&#123;VERSION&#125;.$&#123;OS&#125;-$&#123;ARCH&#125;.tar.gz</code>，可以直接使用这个包来进行安装。首先从 <a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/releases">release 页面</a>下载最新版本的压缩包，当前为 1.5.5 版本（最新的 1.5.7 版本在 CentOS7 下面执行 runc 会报错：<a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/issues/6091%EF%BC%89%EF%BC%9A">https://github.com/containerd/containerd/issues/6091）：</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ wget https://github.com/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有限制，也可以替换成下面的 URL 加速下载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget https://download.fastgit.org/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure>

<p>可以通过 tar 的 <code>-t</code> 选项直接看到压缩包中包含哪些文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ tar -tf cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span><br><span class="line">etc/</span><br><span class="line">etc/cni/</span><br><span class="line">etc/cni/net.d/</span><br><span class="line">etc/cni/net.d/10-containerd-net.conflist</span><br><span class="line">etc/crictl.yaml</span><br><span class="line">etc/systemd/</span><br><span class="line">etc/systemd/system/</span><br><span class="line">etc/systemd/system/containerd.service</span><br><span class="line">usr/</span><br><span class="line">usr/local/</span><br><span class="line">usr/local/bin/</span><br><span class="line">usr/local/bin/containerd-shim-runc-v2</span><br><span class="line">usr/local/bin/ctr</span><br><span class="line">usr/local/bin/containerd-shim</span><br><span class="line">usr/local/bin/containerd-shim-runc-v1</span><br><span class="line">usr/local/bin/crictl</span><br><span class="line">usr/local/bin/critest</span><br><span class="line">usr/local/bin/containerd</span><br><span class="line">usr/local/sbin/</span><br><span class="line">usr/local/sbin/runc</span><br><span class="line">opt/</span><br><span class="line">opt/cni/</span><br><span class="line">opt/cni/bin/</span><br><span class="line">opt/cni/bin/vlan</span><br><span class="line">opt/cni/bin/host-local</span><br><span class="line">opt/cni/bin/flannel</span><br><span class="line">opt/cni/bin/bridge</span><br><span class="line">opt/cni/bin/host-device</span><br><span class="line">opt/cni/bin/tuning</span><br><span class="line">opt/cni/bin/firewall</span><br><span class="line">opt/cni/bin/bandwidth</span><br><span class="line">opt/cni/bin/ipvlan</span><br><span class="line">opt/cni/bin/sbr</span><br><span class="line">opt/cni/bin/dhcp</span><br><span class="line">opt/cni/bin/portmap</span><br><span class="line">opt/cni/bin/ptp</span><br><span class="line">opt/cni/bin/static</span><br><span class="line">opt/cni/bin/macvlan</span><br><span class="line">opt/cni/bin/loopback</span><br><span class="line">opt/containerd/</span><br><span class="line">opt/containerd/cluster/</span><br><span class="line">opt/containerd/cluster/version</span><br><span class="line">opt/containerd/cluster/gce/</span><br><span class="line">opt/containerd/cluster/gce/cni.template</span><br><span class="line">opt/containerd/cluster/gce/configure.sh</span><br><span class="line">opt/containerd/cluster/gce/cloud-init/</span><br><span class="line">opt/containerd/cluster/gce/cloud-init/master.yaml</span><br><span class="line">opt/containerd/cluster/gce/cloud-init/node.yaml</span><br><span class="line">opt/containerd/cluster/gce/env</span><br></pre></td></tr></table></figure>

<p>直接将压缩包解压到系统的各个目录中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ tar -C / -xzf cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>当然要记得将 <code>/usr/local/bin</code> 和 <code>/usr/local/sbin</code> 追加到 <code>~/.bashrc</code> 文件的 <code>PATH</code> 环境变量中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/bin:/usr/local/sbin</span><br></pre></td></tr></table></figure>

<p>然后执行下面的命令使其立即生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>containerd 的默认配置文件为 <code>/etc/containerd/config.toml</code>，我们可以通过如下所示的命令生成一个默认的配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mkdir -p /etc/containerd</span><br><span class="line">➜  ~ containerd config default &gt; /etc/containerd/config.toml</span><br></pre></td></tr></table></figure>

<p>由于上面我们下载的 containerd 压缩包中包含一个 <code>etc/systemd/system/containerd.service</code> 的文件，这样我们就可以通过 systemd 来配置 containerd 作为守护进程运行了，内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /etc/systemd/system/containerd.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=containerd container runtime</span><br><span class="line">Documentation=https://containerd.io</span><br><span class="line">After=network.target local-fs.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=-/sbin/modprobe overlay</span><br><span class="line">ExecStart=/usr/local/bin/containerd</span><br><span class="line"></span><br><span class="line">Type=notify</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> the kernel. We recommend using cgroups to <span class="keyword">do</span> container-local accounting.</span></span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Comment TasksMax <span class="keyword">if</span> your systemd version does not supports it.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Only systemd 226 and above support this version.</span></span><br><span class="line">TasksMax=infinity</span><br><span class="line">OOMScoreAdjust=-999</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>这里有两个重要的参数：</p>
<ul>
<li><code>Delegate</code>: 这个选项允许 containerd 以及运行时自己管理自己创建容器的 cgroups。如果不设置这个选项，systemd 就会将进程移到自己的 cgroups 中，从而导致 containerd 无法正确获取容器的资源使用情况。</li>
<li><code>KillMode</code>: 这个选项用来处理 containerd 进程被杀死的方式。默认情况下，systemd 会在进程的 cgroup 中查找并杀死 containerd 的所有子进程。KillMode 字段可以设置的值如下。<ul>
<li><code>control-group</code>（默认值）：当前控制组里面的所有子进程，都会被杀掉</li>
<li><code>process</code>：只杀主进程</li>
<li><code>mixed</code>：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li>
<li><code>none</code>：没有进程会被杀掉，只是执行服务的 stop 命令</li>
</ul>
</li>
</ul>
<p>我们需要将 KillMode 的值设置为 process，这样可以确保升级或重启 containerd 时不杀死现有的容器。</p>
<p>现在我们就可以启动 containerd 了，直接执行下面的命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ systemctl enable containerd --now</span><br></pre></td></tr></table></figure>

<p>启动完成后就可以使用 containerd 的本地 CLI 工具 <code>ctr</code> 了，比如查看版本：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/aipn3f.png" alt="ctr version"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>我们首先来查看下上面默认生成的配置文件 <code>/etc/containerd/config.toml</code>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disabled_plugins</span> = []</span><br><span class="line"><span class="attr">imports</span> = []</span><br><span class="line"><span class="attr">oom_score</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">plugin_dir</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">required_plugins</span> = []</span><br><span class="line"><span class="attr">root</span> = <span class="string">&quot;/var/lib/containerd&quot;</span></span><br><span class="line"><span class="attr">state</span> = <span class="string">&quot;/run/containerd&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="section">[cgroup]</span></span><br><span class="line">  <span class="attr">path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[debug]</span></span><br><span class="line">  <span class="attr">address</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">format</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">gid</span> = <span class="number">0</span></span><br><span class="line">  <span class="attr">level</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">uid</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[grpc]</span></span><br><span class="line">  <span class="attr">address</span> = <span class="string">&quot;/run/containerd/containerd.sock&quot;</span></span><br><span class="line">  <span class="attr">gid</span> = <span class="number">0</span></span><br><span class="line">  <span class="attr">max_recv_message_size</span> = <span class="number">16777216</span></span><br><span class="line">  <span class="attr">max_send_message_size</span> = <span class="number">16777216</span></span><br><span class="line">  <span class="attr">tcp_address</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">tcp_tls_cert</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">tcp_tls_key</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">uid</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[metrics]</span></span><br><span class="line">  <span class="attr">address</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">grpc_histogram</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="section">[plugins]</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.gc.v1.scheduler&quot;]</span></span><br><span class="line">    <span class="attr">deletion_threshold</span> = <span class="number">0</span></span><br><span class="line">    <span class="attr">mutation_threshold</span> = <span class="number">100</span></span><br><span class="line">    <span class="attr">pause_threshold</span> = <span class="number">0.02</span></span><br><span class="line">    <span class="attr">schedule_delay</span> = <span class="string">&quot;0s&quot;</span></span><br><span class="line">    <span class="attr">startup_delay</span> = <span class="string">&quot;100ms&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span></span><br><span class="line">    <span class="attr">disable_apparmor</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">disable_cgroup</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">disable_hugetlb_controller</span> = <span class="literal">true</span></span><br><span class="line">    <span class="attr">disable_proc_mount</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">disable_tcp_service</span> = <span class="literal">true</span></span><br><span class="line">    <span class="attr">enable_selinux</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">enable_tls_streaming</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">ignore_image_defined_volumes</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">max_concurrent_downloads</span> = <span class="number">3</span></span><br><span class="line">    <span class="attr">max_container_log_line_size</span> = <span class="number">16384</span></span><br><span class="line">    <span class="attr">netns_mounts_under_state_dir</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">restrict_oom_score_adj</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">sandbox_image</span> = <span class="string">&quot;k8s.gcr.io/pause:3.5&quot;</span></span><br><span class="line">    <span class="attr">selinux_category_range</span> = <span class="number">1024</span></span><br><span class="line">    <span class="attr">stats_collect_period</span> = <span class="number">10</span></span><br><span class="line">    <span class="attr">stream_idle_timeout</span> = <span class="string">&quot;4h0m0s&quot;</span></span><br><span class="line">    <span class="attr">stream_server_address</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    <span class="attr">stream_server_port</span> = <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="attr">systemd_cgroup</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">tolerate_missing_hugetlb_controller</span> = <span class="literal">true</span></span><br><span class="line">    <span class="attr">unset_seccomp_profile</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.cni]</span></span><br><span class="line">      <span class="attr">bin_dir</span> = <span class="string">&quot;/opt/cni/bin&quot;</span></span><br><span class="line">      <span class="attr">conf_dir</span> = <span class="string">&quot;/etc/cni/net.d&quot;</span></span><br><span class="line">      <span class="attr">conf_template</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">max_conf_num</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</span></span><br><span class="line">      <span class="attr">default_runtime_name</span> = <span class="string">&quot;runc&quot;</span></span><br><span class="line">      <span class="attr">disable_snapshot_annotations</span> = <span class="literal">true</span></span><br><span class="line">      <span class="attr">discard_unpacked_layers</span> = <span class="literal">false</span></span><br><span class="line">      <span class="attr">no_pivot</span> = <span class="literal">false</span></span><br><span class="line">      <span class="attr">snapshotter</span> = <span class="string">&quot;overlayfs&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime]</span></span><br><span class="line">        <span class="attr">base_runtime_spec</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">container_annotations</span> = []</span><br><span class="line">        <span class="attr">pod_annotations</span> = []</span><br><span class="line">        <span class="attr">privileged_without_host_devices</span> = <span class="literal">false</span></span><br><span class="line">        <span class="attr">runtime_engine</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">runtime_root</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">runtime_type</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime.options]</span></span><br><span class="line"></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]</span></span><br><span class="line"></span><br><span class="line">        <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span></span><br><span class="line">          <span class="attr">base_runtime_spec</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="attr">container_annotations</span> = []</span><br><span class="line">          <span class="attr">pod_annotations</span> = []</span><br><span class="line">          <span class="attr">privileged_without_host_devices</span> = <span class="literal">false</span></span><br><span class="line">          <span class="attr">runtime_engine</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="attr">runtime_root</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="attr">runtime_type</span> = <span class="string">&quot;io.containerd.runc.v2&quot;</span></span><br><span class="line"></span><br><span class="line">          <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span></span><br><span class="line">            <span class="attr">BinaryName</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="attr">CriuImagePath</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="attr">CriuPath</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="attr">CriuWorkPath</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="attr">IoGid</span> = <span class="number">0</span></span><br><span class="line">            <span class="attr">IoUid</span> = <span class="number">0</span></span><br><span class="line">            <span class="attr">NoNewKeyring</span> = <span class="literal">false</span></span><br><span class="line">            <span class="attr">NoPivotRoot</span> = <span class="literal">false</span></span><br><span class="line">            <span class="attr">Root</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="attr">ShimCgroup</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="attr">SystemdCgroup</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime]</span></span><br><span class="line">        <span class="attr">base_runtime_spec</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">container_annotations</span> = []</span><br><span class="line">        <span class="attr">pod_annotations</span> = []</span><br><span class="line">        <span class="attr">privileged_without_host_devices</span> = <span class="literal">false</span></span><br><span class="line">        <span class="attr">runtime_engine</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">runtime_root</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">runtime_type</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime.options]</span></span><br><span class="line"></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.image_decryption]</span></span><br><span class="line">      <span class="attr">key_model</span> = <span class="string">&quot;node&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span></span><br><span class="line">      <span class="attr">config_path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.auths]</span></span><br><span class="line"></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs]</span></span><br><span class="line"></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.headers]</span></span><br><span class="line"></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span></span><br><span class="line"></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.x509_key_pair_streaming]</span></span><br><span class="line">      <span class="attr">tls_cert_file</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">tls_key_file</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.internal.v1.opt&quot;]</span></span><br><span class="line">    <span class="attr">path</span> = <span class="string">&quot;/opt/containerd&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.internal.v1.restart&quot;]</span></span><br><span class="line">    <span class="attr">interval</span> = <span class="string">&quot;10s&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.metadata.v1.bolt&quot;]</span></span><br><span class="line">    <span class="attr">content_sharing_policy</span> = <span class="string">&quot;shared&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.monitor.v1.cgroups&quot;]</span></span><br><span class="line">    <span class="attr">no_prometheus</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.runtime.v1.linux&quot;]</span></span><br><span class="line">    <span class="attr">no_shim</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">runtime</span> = <span class="string">&quot;runc&quot;</span></span><br><span class="line">    <span class="attr">runtime_root</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">shim</span> = <span class="string">&quot;containerd-shim&quot;</span></span><br><span class="line">    <span class="attr">shim_debug</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.runtime.v2.task&quot;]</span></span><br><span class="line">    <span class="attr">platforms</span> = [<span class="string">&quot;linux/amd64&quot;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.service.v1.diff-service&quot;]</span></span><br><span class="line">    <span class="attr">default</span> = [<span class="string">&quot;walking&quot;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.snapshotter.v1.aufs&quot;]</span></span><br><span class="line">    <span class="attr">root_path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.snapshotter.v1.btrfs&quot;]</span></span><br><span class="line">    <span class="attr">root_path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.snapshotter.v1.devmapper&quot;]</span></span><br><span class="line">    <span class="attr">async_remove</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">base_image_size</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">pool_name</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">root_path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.snapshotter.v1.native&quot;]</span></span><br><span class="line">    <span class="attr">root_path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.snapshotter.v1.overlayfs&quot;]</span></span><br><span class="line">    <span class="attr">root_path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.snapshotter.v1.zfs&quot;]</span></span><br><span class="line">    <span class="attr">root_path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[proxy_plugins]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[stream_processors]</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar&quot;]</span></span><br><span class="line">    <span class="attr">accepts</span> = [<span class="string">&quot;application/vnd.oci.image.layer.v1.tar+encrypted&quot;</span>]</span><br><span class="line">    <span class="attr">args</span> = [<span class="string">&quot;--decryption-keys-path&quot;</span>, <span class="string">&quot;/etc/containerd/ocicrypt/keys&quot;</span>]</span><br><span class="line">    <span class="attr">env</span> = [<span class="string">&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;</span>]</span><br><span class="line">    <span class="attr">path</span> = <span class="string">&quot;ctd-decoder&quot;</span></span><br><span class="line">    <span class="attr">returns</span> = <span class="string">&quot;application/vnd.oci.image.layer.v1.tar&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar.gzip&quot;]</span></span><br><span class="line">    <span class="attr">accepts</span> = [<span class="string">&quot;application/vnd.oci.image.layer.v1.tar+gzip+encrypted&quot;</span>]</span><br><span class="line">    <span class="attr">args</span> = [<span class="string">&quot;--decryption-keys-path&quot;</span>, <span class="string">&quot;/etc/containerd/ocicrypt/keys&quot;</span>]</span><br><span class="line">    <span class="attr">env</span> = [<span class="string">&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;</span>]</span><br><span class="line">    <span class="attr">path</span> = <span class="string">&quot;ctd-decoder&quot;</span></span><br><span class="line">    <span class="attr">returns</span> = <span class="string">&quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[timeouts]</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.shim.cleanup&quot;</span> = <span class="string">&quot;5s&quot;</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.shim.load&quot;</span> = <span class="string">&quot;5s&quot;</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.shim.shutdown&quot;</span> = <span class="string">&quot;3s&quot;</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.task.state&quot;</span> = <span class="string">&quot;2s&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ttrpc]</span></span><br><span class="line">  <span class="attr">address</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">gid</span> = <span class="number">0</span></span><br><span class="line">  <span class="attr">uid</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这个配置文件比较复杂，我们可以将重点放在其中的 <code>plugins</code> 配置上面，仔细观察我们可以发现每一个顶级配置块的命名都是 <code>plugins.&quot;io.containerd.xxx.vx.xxx&quot;</code> 这种形式，每一个顶级配置块都表示一个插件，其中 <code>io.containerd.xxx.vx</code> 表示插件的类型，<code>vx</code> 后面的 <code>xxx</code> 表示插件的 ID，我们可以通过 <code>ctr</code> 查看插件列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr plugin ls</span><br><span class="line">ctr plugin ls</span><br><span class="line">TYPE                            ID                       PLATFORMS      STATUS</span><br><span class="line">io.containerd.content.v1        content                  -              ok</span><br><span class="line">io.containerd.snapshotter.v1    aufs                     linux/amd64    ok</span><br><span class="line">io.containerd.snapshotter.v1    btrfs                    linux/amd64    skip</span><br><span class="line">io.containerd.snapshotter.v1    devmapper                linux/amd64    error</span><br><span class="line">io.containerd.snapshotter.v1    native                   linux/amd64    ok</span><br><span class="line">io.containerd.snapshotter.v1    overlayfs                linux/amd64    ok</span><br><span class="line">io.containerd.snapshotter.v1    zfs                      linux/amd64    skip</span><br><span class="line">io.containerd.metadata.v1       bolt                     -              ok</span><br><span class="line">io.containerd.differ.v1         walking                  linux/amd64    ok</span><br><span class="line">io.containerd.gc.v1             scheduler                -              ok</span><br><span class="line">io.containerd.service.v1        introspection-service    -              ok</span><br><span class="line">io.containerd.service.v1        containers-service       -              ok</span><br><span class="line">io.containerd.service.v1        content-service          -              ok</span><br><span class="line">io.containerd.service.v1        diff-service             -              ok</span><br><span class="line">io.containerd.service.v1        images-service           -              ok</span><br><span class="line">io.containerd.service.v1        leases-service           -              ok</span><br><span class="line">io.containerd.service.v1        namespaces-service       -              ok</span><br><span class="line">io.containerd.service.v1        snapshots-service        -              ok</span><br><span class="line">io.containerd.runtime.v1        linux                    linux/amd64    ok</span><br><span class="line">io.containerd.runtime.v2        task                     linux/amd64    ok</span><br><span class="line">io.containerd.monitor.v1        cgroups                  linux/amd64    ok</span><br><span class="line">io.containerd.service.v1        tasks-service            -              ok</span><br><span class="line">io.containerd.internal.v1       restart                  -              ok</span><br><span class="line">io.containerd.grpc.v1           containers               -              ok</span><br><span class="line">io.containerd.grpc.v1           content                  -              ok</span><br><span class="line">io.containerd.grpc.v1           diff                     -              ok</span><br><span class="line">io.containerd.grpc.v1           events                   -              ok</span><br><span class="line">io.containerd.grpc.v1           healthcheck              -              ok</span><br><span class="line">io.containerd.grpc.v1           images                   -              ok</span><br><span class="line">io.containerd.grpc.v1           leases                   -              ok</span><br><span class="line">io.containerd.grpc.v1           namespaces               -              ok</span><br><span class="line">io.containerd.internal.v1       opt                      -              ok</span><br><span class="line">io.containerd.grpc.v1           snapshots                -              ok</span><br><span class="line">io.containerd.grpc.v1           tasks                    -              ok</span><br><span class="line">io.containerd.grpc.v1           version                  -              ok</span><br><span class="line">io.containerd.grpc.v1           cri                      linux/amd64    ok</span><br></pre></td></tr></table></figure>

<p>顶级配置块下面的子配置块表示该插件的各种配置，比如 cri 插件下面就分为 containerd、cni 和 registry 的配置，而 containerd 下面又可以配置各种 runtime，还可以配置默认的 runtime。比如现在我们要为镜像配置一个加速器，那么就需要在 cri 配置块下面的 <code>registry</code> 配置块下面进行配置 <code>registry.mirrors</code>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;]</span></span><br><span class="line">      <span class="attr">endpoint</span> = [<span class="string">&quot;https://bqr1dr1n.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;k8s.gcr.io&quot;]</span></span><br><span class="line">      <span class="attr">endpoint</span> = [<span class="string">&quot;https://registry.aliyuncs.com/k8sxio&quot;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>registry.mirrors.&quot;xxx&quot;</code>: 表示需要配置 mirror 的镜像仓库，例如 <code>registry.mirrors.&quot;docker.io&quot;</code> 表示配置 docker.io 的 mirror。</li>
<li><code>endpoint</code>: 表示提供 mirror 的镜像加速服务，比如我们可以注册一个阿里云的镜像服务来作为 docker.io 的 mirror。</li>
</ul>
<p>另外在默认配置中还有两个关于存储的配置路径：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">root</span> = <span class="string">&quot;/var/lib/containerd&quot;</span></span><br><span class="line"><span class="attr">state</span> = <span class="string">&quot;/run/containerd&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>root</code> 是用来保存持久化数据，包括 Snapshots, Content, Metadata 以及各种插件的数据，每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。</p>
<p>而另外的 <code>state</code> 是用来保存运行时的临时数据的，包括 sockets、pid、挂载点、运行时状态以及不需要持久化的插件数据。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们知道 Docker CLI 工具提供了需要增强用户体验的功能，containerd 同样也提供一个对应的 CLI 工具：<code>ctr</code>，不过 ctr 的功能没有 docker 完善，但是关于镜像和容器的基本功能都是有的。接下来我们就先简单介绍下 <code>ctr</code> 的使用。</p>
<p><strong>帮助</strong></p>
<p>直接输入 <code>ctr</code> 命令即可获得所有相关的操作命令使用方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr</span><br><span class="line">NAME:</span><br><span class="line">   ctr -</span><br><span class="line">        __</span><br><span class="line">  _____/ /______</span><br><span class="line"> / ___/ __/ ___/</span><br><span class="line">/ /__/ /_/ /</span><br><span class="line">\___/\__/_/</span><br><span class="line"></span><br><span class="line">containerd CLI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   v1.5.5</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line"></span><br><span class="line">ctr is an unsupported debug and administrative client for interacting</span><br><span class="line">with the containerd daemon. Because it is unsupported, the commands,</span><br><span class="line">options, and operations are not guaranteed to be backward compatible or</span><br><span class="line">stable from release to release of the containerd project.</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   plugins, plugin            provides information about containerd plugins</span><br><span class="line">   version                    print the client and server versions</span><br><span class="line">   containers, c, container   manage containers</span><br><span class="line">   content                    manage content</span><br><span class="line">   events, event              display containerd events</span><br><span class="line">   images, image, i           manage images</span><br><span class="line">   leases                     manage leases</span><br><span class="line">   namespaces, namespace, ns  manage namespaces</span><br><span class="line">   pprof                      provide golang pprof outputs for containerd</span><br><span class="line">   run                        run a container</span><br><span class="line">   snapshots, snapshot        manage snapshots</span><br><span class="line">   tasks, t, task             manage tasks</span><br><span class="line">   install                    install a new package</span><br><span class="line">   oci                        OCI tools</span><br><span class="line">   shim                       interact with a shim directly</span><br><span class="line">   help, h                    Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --debug                      enable debug output in logs</span><br><span class="line">   --address value, -a value    address for containerd&#x27;s GRPC server (default: &quot;/run/containerd/containerd.sock&quot;) [$CONTAINERD_ADDRESS]</span><br><span class="line">   --timeout value              total timeout for ctr commands (default: 0s)</span><br><span class="line">   --connect-timeout value      timeout for connecting to containerd (default: 0s)</span><br><span class="line">   --namespace value, -n value  namespace to use with commands (default: &quot;default&quot;) [$CONTAINERD_NAMESPACE]</span><br><span class="line">   --help, -h                   show help</span><br><span class="line">   --version, -v                print the version</span><br></pre></td></tr></table></figure>

<h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><p><strong>拉取镜像</strong></p>
<p>拉取镜像可以使用 <code>ctr image pull</code> 来完成，比如拉取 Docker Hub 官方镜像 <code>nginx:alpine</code>，需要注意的是镜像地址需要加上 <code>docker.io</code> Host 地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr image pull docker.io/library/nginx:alpine</span><br><span class="line">docker.io/library/nginx:alpine:                                                   resolved       |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">index-sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce:    exists         |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">manifest-sha256:ce6ca11a3fa7e0e6b44813901e3289212fc2f327ee8b1366176666e8fb470f24: done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:9a6ac07b84eb50935293bb185d0a8696d03247f74fd7d43ea6161dc0f293f81f:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:e82f830de071ebcda58148003698f32205b7970b01c58a197ac60d6bb79241b0:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:d7c9fa7589ae28cd3306b204d5dd9a539612593e35df70f7a1d69ff7548e74cf:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:bf2b3ee132db5b4c65432e53aca69da4e609c6cb154e0d0e14b2b02259e9c1e3:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">config-sha256:7ce0143dee376bfd2937b499a46fb110bda3c629c195b84b1cf6e19be1a9e23b:   done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:3c1eaf69ff492177c34bdbf1735b6f2e5400e417f8f11b98b0da878f4ecad5fb:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:29291e31a76a7e560b9b7ad3cada56e8c18d50a96cca8a2573e4f4689d7aca77:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">elapsed: 11.9s                                                                    total:  8.7 Mi (748.1 KiB/s)</span><br><span class="line">unpacking linux/amd64 sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce...</span><br><span class="line">done: 410.86624ms</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>--platform</code> 选项指定对应平台的镜像。当然对应的也有推送镜像的命令 <code>ctr image push</code>，如果是私有镜像则在推送的时候可以通过 <code>--user</code> 来自定义仓库的用户名和密码。</p>
<p><strong>列出本地镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr image ls</span><br><span class="line">REF                            TYPE                                                      DIGEST                                                                  SIZE    PLATFORMS                                                                                LABELS</span><br><span class="line">docker.io/library/nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce 9.5 MiB linux/386,linux/amd64,linux/arm/v6,linux/arm/v7,linux/arm64/v8,linux/ppc64le,linux/s390x -</span><br><span class="line">➜  ~ ctr image ls -q</span><br><span class="line">docker.io/library/nginx:alpine</span><br></pre></td></tr></table></figure>

<p>使用 <code>-q（--quiet）</code> 选项可以只打印镜像名称。</p>
<p><strong>检测本地镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr image check</span><br><span class="line">REF                            TYPE                                                      DIGEST                                                                  STATUS         SIZE            UNPACKED</span><br><span class="line">docker.io/library/nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce complete (7/7) 9.5 MiB/9.5 MiB true</span><br></pre></td></tr></table></figure>

<p>主要查看其中的 <code>STATUS</code>，<code>complete</code> 表示镜像是完整可用的状态。</p>
<p><strong>重新打标签</strong></p>
<p>同样的我们也可以重新给指定的镜像打一个 Tag：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr image tag docker.io/library/nginx:alpine harbor.k8s.local/course/nginx:alpine</span><br><span class="line">harbor.k8s.local/course/nginx:alpine</span><br><span class="line">➜  ~ ctr image ls -q</span><br><span class="line">docker.io/library/nginx:alpine</span><br><span class="line">harbor.k8s.local/course/nginx:alpine</span><br></pre></td></tr></table></figure>

<p><strong>删除镜像</strong></p>
<p>不需要使用的镜像也可以使用 <code>ctr image rm</code> 进行删除：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr image rm harbor.k8s.local/course/nginx:alpine</span><br><span class="line">harbor.k8s.local/course/nginx:alpine</span><br><span class="line">➜  ~ ctr image ls -q</span><br><span class="line">docker.io/library/nginx:alpine</span><br></pre></td></tr></table></figure>

<p>加上 <code>--sync</code> 选项可以同步删除镜像和所有相关的资源。</p>
<p><strong>将镜像挂载到主机目录</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr image mount docker.io/library/nginx:alpine /mnt</span><br><span class="line">sha256:c3554b2d61e3c1cffcaba4b4fa7651c644a3354efaafa2f22cb53542f6c600dc</span><br><span class="line">/mnt</span><br><span class="line">➜  ~ tree -L 1 /mnt</span><br><span class="line">/mnt</span><br><span class="line">├── bin</span><br><span class="line">├── dev</span><br><span class="line">├── docker-entrypoint.d</span><br><span class="line">├── docker-entrypoint.sh</span><br><span class="line">├── etc</span><br><span class="line">├── home</span><br><span class="line">├── lib</span><br><span class="line">├── media</span><br><span class="line">├── mnt</span><br><span class="line">├── opt</span><br><span class="line">├── proc</span><br><span class="line">├── root</span><br><span class="line">├── run</span><br><span class="line">├── sbin</span><br><span class="line">├── srv</span><br><span class="line">├── sys</span><br><span class="line">├── tmp</span><br><span class="line">├── usr</span><br><span class="line">└── var</span><br><span class="line"></span><br><span class="line">18 directories, 1 file</span><br></pre></td></tr></table></figure>

<p><strong>将镜像从主机目录上卸载</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr image unmount /mnt</span><br><span class="line">/mnt</span><br></pre></td></tr></table></figure>

<p><strong>将镜像导出为压缩包</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr image export --all-platforms nginx.tar.gz docker.io/library/nginx:alpine</span><br></pre></td></tr></table></figure>

<p><strong>从压缩包导入镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr image import nginx.tar.gz</span><br></pre></td></tr></table></figure>

<p>直接导入可能会出现类似于 <code>ctr: content digest sha256:xxxxxx not found</code> 的错误，要解决这个办法需要 pull 所有平台镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr i pull --all-platforms docker.io/library/nginx:alpine</span><br><span class="line">➜  ~ ctr i export --all-platforms nginx.tar.gz docker.io/library/nginx:alpine</span><br><span class="line">➜  ~ ctr i rm docker.io/library/nginx:alpine</span><br><span class="line">➜  ~ ctr i import nginx.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p>容器相关操作可以通过 <code>ctr container</code> 获取。</p>
<p><strong>创建容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr container create docker.io/library/nginx:alpine nginx</span><br></pre></td></tr></table></figure>

<p><strong>列出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr container ls</span><br><span class="line">CONTAINER    IMAGE                             RUNTIME</span><br><span class="line">nginx        docker.io/library/nginx:alpine    io.containerd.runc.v2</span><br></pre></td></tr></table></figure>

<p>同样可以加上 <code>-q</code> 选项精简列表内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr container ls -q</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>

<p><strong>查看容器详细配置</strong></p>
<p>类似于 <code>docker inspect</code> 功能。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr container info nginx</span><br><span class="line">&#123;</span><br><span class="line">    &quot;ID&quot;: &quot;nginx&quot;,</span><br><span class="line">    &quot;Labels&quot;: &#123;</span><br><span class="line">        &quot;io.containerd.image.config.stop-signal&quot;: &quot;SIGQUIT&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;Image&quot;: &quot;docker.io/library/nginx:alpine&quot;,</span><br><span class="line">    &quot;Runtime&quot;: &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;io.containerd.runc.v2&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;type_url&quot;: &quot;containerd.runc.v1.Options&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;SnapshotKey&quot;: &quot;nginx&quot;,</span><br><span class="line">    &quot;Snapshotter&quot;: &quot;overlayfs&quot;,</span><br><span class="line">    &quot;CreatedAt&quot;: &quot;2021-08-12T08:23:13.792871558Z&quot;,</span><br><span class="line">    &quot;UpdatedAt&quot;: &quot;2021-08-12T08:23:13.792871558Z&quot;,</span><br><span class="line">    &quot;Extensions&quot;: null,</span><br><span class="line">    &quot;Spec&quot;: &#123;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr container rm nginx</span><br><span class="line">➜  ~ ctr container ls</span><br><span class="line">CONTAINER    IMAGE    RUNTIME</span><br></pre></td></tr></table></figure>

<p>除了使用 <code>rm</code> 子命令之外也可以使用 <code>delete</code> 或者 <code>del</code> 删除容器。</p>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>上面我们通过 <code>container create</code> 命令创建的容器，并没有处于运行状态，只是一个静态的容器。一个 container 对象只是包含了运行一个容器所需的资源及相关配置数据，表示 namespaces、rootfs 和容器的配置都已经初始化成功了，只是用户进程还没有启动。</p>
<p>一个容器真正运行起来是由 Task 任务实现的，Task 可以为容器设置网卡，还可以配置工具来对容器进行监控等。</p>
<p>Task 相关操作可以通过 <code>ctr task</code> 获取，如下我们通过 Task 来启动容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr task start -d nginx</span><br><span class="line">/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration</span><br><span class="line">/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/</span><br></pre></td></tr></table></figure>

<p>启动容器后可以通过 <code>task ls</code> 查看正在运行的容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr task ls</span><br><span class="line">TASK     PID     STATUS</span><br><span class="line">nginx    3630    RUNNING</span><br></pre></td></tr></table></figure>

<p>同样也可以使用 <code>exec</code> 命令进入容器进行操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr task exec --exec-id 0 -t nginx sh</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>

<p>不过这里需要注意必须要指定 <code>--exec-id</code> 参数，这个 id 可以随便写，只要唯一就行。</p>
<p>暂停容器，和 <code>docker pause</code> 类似的功能：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr task pause nginx</span><br></pre></td></tr></table></figure>

<p>暂停后容器状态变成了 <code>PAUSED</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr task ls</span><br><span class="line">TASK     PID     STATUS</span><br><span class="line">nginx    3630    PAUSED</span><br></pre></td></tr></table></figure>

<p>同样也可以使用 <code>resume</code> 命令来恢复容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr task resume nginx</span><br><span class="line">➜  ~ ctr task ls</span><br><span class="line">TASK     PID     STATUS</span><br><span class="line">nginx    3630    RUNNING</span><br></pre></td></tr></table></figure>

<p>不过需要注意 ctr 没有 stop 容器的功能，只能暂停或者杀死容器。杀死容器可以使用 <code>task kill</code> 命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr task kill nginx</span><br><span class="line">➜  ~ ctr task ls</span><br><span class="line">TASK     PID     STATUS</span><br><span class="line">nginx    3630    STOPPED</span><br></pre></td></tr></table></figure>

<p>杀掉容器后可以看到容器的状态变成了 <code>STOPPED</code>。同样也可以通过 <code>task rm</code> 命令删除 Task：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr task rm nginx</span><br><span class="line">➜  ~ ctr task ls</span><br><span class="line">TASK    PID    STATUS</span><br></pre></td></tr></table></figure>

<p>除此之外我们还可以获取容器的 cgroup 相关信息，可以使用 <code>task metrics</code> 命令用来获取容器的内存、CPU 和 PID 的限额与使用量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新启动容器</span></span><br><span class="line">➜  ~ ctr task metrics nginx</span><br><span class="line">ID       TIMESTAMP</span><br><span class="line">nginx    2021-08-12 08:50:46.952769941 +0000 UTC</span><br><span class="line"></span><br><span class="line">METRIC                   VALUE</span><br><span class="line">memory.usage_in_bytes    8855552</span><br><span class="line">memory.limit_in_bytes    9223372036854771712</span><br><span class="line">memory.stat.cache        0</span><br><span class="line">cpuacct.usage            22467106</span><br><span class="line">cpuacct.usage_percpu     [2962708 860891 1163413 1915748 1058868 2888139 6159277 5458062]</span><br><span class="line">pids.current             9</span><br><span class="line">pids.limit               0</span><br></pre></td></tr></table></figure>

<p>还可以使用 <code>task ps</code> 命令查看容器中所有进程在宿主机中的 PID：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr task ps nginx</span><br><span class="line">PID     INFO</span><br><span class="line">3984    -</span><br><span class="line">4029    -</span><br><span class="line">4030    -</span><br><span class="line">4031    -</span><br><span class="line">4032    -</span><br><span class="line">4033    -</span><br><span class="line">4034    -</span><br><span class="line">4035    -</span><br><span class="line">4036    -</span><br><span class="line">➜  ~ ctr task ls</span><br><span class="line">TASK     PID     STATUS</span><br><span class="line">nginx    3984    RUNNING</span><br></pre></td></tr></table></figure>

<p>其中第一个 PID <code>3984</code> 就是我们容器中的 1 号进程。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>另外 Containerd 中也支持命名空间的概念，比如查看命名空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr ns ls</span><br><span class="line">NAME    LABELS</span><br><span class="line">default</span><br></pre></td></tr></table></figure>

<p>如果不指定，ctr 默认使用的是 <code>default</code> 空间。同样也可以使用 <code>ns create</code> 命令创建一个命名空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr ns create test</span><br><span class="line">➜  ~ ctr ns ls</span><br><span class="line">NAME    LABELS</span><br><span class="line">default</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<p>使用 <code>remove</code> 或者 <code>rm</code> 可以删除 namespace：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr ns rm test</span><br><span class="line">test</span><br><span class="line">➜  ~ ctr ns ls</span><br><span class="line">NAME    LABELS</span><br><span class="line">default</span><br></pre></td></tr></table></figure>

<p>有了命名空间后就可以在操作资源的时候指定 namespace，比如查看 test 命名空间的镜像，可以在操作命令后面加上 <code>-n test</code> 选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr -n test image ls</span><br><span class="line">REF TYPE DIGEST SIZE PLATFORMS LABELS</span><br></pre></td></tr></table></figure>

<p>我们知道 Docker 其实也是默认调用的 containerd，事实上 Docker 使用的 containerd 下面的命名空间默认是 <code>moby</code>，而不是 <code>default</code>，所以假如我们有用 docker 启动容器，那么我们也可以通过 <code>ctr -n moby</code> 来定位下面的容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr -n moby container ls</span><br></pre></td></tr></table></figure>

<p>同样 Kubernetes 下使用的 containerd 默认命名空间是 <code>k8s.io</code>，所以我们可以使用 <code>ctr -n k8s.io</code> 来查看 Kubernetes 下面创建的容器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/CoreDNS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/CoreDNS/" class="post-title-link" itemprop="url">CoreDNS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:26:28" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>上面我们讲解了 Service 的用法，我们可以通过 Service 生成的 ClusterIP(VIP) 来访问 Pod 提供的服务，但是在使用的时候还有一个问题：我们怎么知道某个应用的 VIP 呢？比如我们有两个应用，一个是 api 应用，一个是 db 应用，两个应用都是通过 Deployment 进行管理的，并且都通过 Service 暴露出了端口提供服务。api 需要连接到 db 这个应用，我们只知道 db 应用的名称和 db 对应的 Service 的名称，但是并不知道它的 VIP 地址，我们前面的 Service 课程中是不是学习到我们通过 ClusterIP 就可以访问到后面的 Pod 服务，如果我们知道了 VIP 的地址是不是就行了？</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>为了解决上面的问题，在之前的版本中，Kubernetes 采用了环境变量的方法，每个 Pod 启动的时候，会通过环境变量设置所有服务的 IP 和 port 信息，这样 Pod 中的应用可以通过读取环境变量来获取依赖服务的地址信息，这种方法使用起来相对简单，但是有一个很大的问题就是依赖的服务必须在 Pod 启动之前就存在，不然是不会被注入到环境变量中的。比如我们首先创建一个 Nginx 服务：(test-nginx.yaml)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>



<p>创建上面的服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f test-nginx.yaml</span><br><span class="line">deployment.apps &quot;nginx-deploy&quot; created</span><br><span class="line">service &quot;nginx-service&quot; created</span><br><span class="line">➜  ~ kubectl get pods</span><br><span class="line">NAME                                      READY     STATUS    RESTARTS   AGE</span><br><span class="line">...</span><br><span class="line">nginx-deploy-75675f5897-47h4t             1/1       Running   0          53s</span><br><span class="line">nginx-deploy-75675f5897-mmm8w             1/1       Running   0          53s</span><br><span class="line">...</span><br><span class="line">➜  ~ kubectl get svc</span><br><span class="line">NAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">...</span><br><span class="line">nginx-service   ClusterIP   10.107.225.42    &lt;none&gt;        5000/TCP         1m</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>我们可以看到两个 Pod 和一个名为 nginx-service 的服务创建成功了，该 Service 监听的端口是 5000，同时它会把流量转发给它代理的所有 Pod（我们这里就是拥有 <code>app: nginx</code> 标签的两个 Pod）。</p>
<p>现在我们再来创建一个普通的 Pod，观察下该 Pod 中的环境变量是否包含上面的 <code>nginx-service</code> 的服务信息：（test-pod.yaml）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-service-pod</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;env&#x27;</span>]</span><br></pre></td></tr></table></figure>



<p>然后创建该测试的 Pod：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f test-pod.yaml</span><br><span class="line">pod &quot;test-pod&quot; created</span><br></pre></td></tr></table></figure>



<p>等 Pod 创建完成后，我们查看日志信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl logs test-pod</span><br><span class="line">...</span><br><span class="line">KUBERNETES_PORT=tcp://10.96.0.1:443</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br><span class="line">HOSTNAME=test-pod</span><br><span class="line">HOME=/root</span><br><span class="line">NGINX_SERVICE_PORT_5000_TCP_ADDR=10.107.225.42</span><br><span class="line">NGINX_SERVICE_PORT_5000_TCP_PORT=5000</span><br><span class="line">NGINX_SERVICE_PORT_5000_TCP_PROTO=tcp</span><br><span class="line">KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">NGINX_SERVICE_SERVICE_HOST=10.107.225.42</span><br><span class="line">NGINX_SERVICE_PORT_5000_TCP=tcp://10.107.225.42:5000</span><br><span class="line">KUBERNETES_PORT_443_TCP_PORT=443</span><br><span class="line">KUBERNETES_PORT_443_TCP_PROTO=tcp</span><br><span class="line">NGINX_SERVICE_SERVICE_PORT=5000</span><br><span class="line">NGINX_SERVICE_PORT=tcp://10.107.225.42:5000</span><br><span class="line">KUBERNETES_SERVICE_PORT_HTTPS=443</span><br><span class="line">KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br><span class="line">PWD=/</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>我们可以看到打印了很多环境变量信息，其中就包括我们刚刚创建的 nginx-service 这个服务，有 HOST、PORT、PROTO、ADDR 等，也包括其他已经存在的 Service 的环境变量，现在如果我们需要在这个 Pod 里面访问 nginx-service 的服务，我们是不是可以直接通过 <code>NGINX_SERVICE_SERVICE_HOST</code> 和 <code>NGINX_SERVICE_SERVICE_PORT</code> 就可以了，但是如果这个 Pod 启动起来的时候 nginx-service 服务还没启动起来，在环境变量中我们是无法获取到这些信息的，当然我们可以通过 <code>initContainer</code> 之类的方法来确保 nginx-service 启动后再启动 Pod，但是这种方法毕竟增加了 Pod 启动的复杂性，所以这不是最优的方法，局限性太多了。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>由于上面环境变量这种方式的局限性，我们需要一种更加智能的方案，其实我们可以自己思考一种比较理想的方案：那就是可以直接使用 Service 的名称，因为 Service 的名称不会变化，我们不需要去关心分配的 ClusterIP 的地址，因为这个地址并不是固定不变的，所以如果我们直接使用 Service 的名字，然后对应的 ClusterIP 地址的转换能够自动完成就很好了。我们知道名字和 IP 直接的转换是不是和我们平时访问的网站非常类似啊？他们之间的转换功能通过 DNS 就可以解决了，同样的，Kubernetes 也提供了 DNS 的方案来解决上面的服务发现的问题。</p>
<p>DNS 服务不是一个独立的系统服务，而是作为一种 addon 插件而存在，现在比较推荐的两个插件：kube-dns 和 CoreDNS，实际上在比较新点的版本中已经默认是 CoreDNS 了，因为 kube-dns 默认一个 Pod 中需要 3 个容器配合使用，CoreDNS 只需要一个容器即可，我们在前面使用 kubeadm 搭建集群的时候直接安装的就是 CoreDNS 插件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get pods -n kube-system -l k8s-app=kube-dns</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-667f964f9b-sthqq   1/1     Running   0          32m</span><br><span class="line">coredns-667f964f9b-zj4r4   1/1     Running   0          33m</span><br></pre></td></tr></table></figure>



<p>CoreDns 是用 GO 写的高性能，高扩展性的 DNS 服务，基于 HTTP&#x2F;2 Web 服务 Caddy 进行编写的。CoreDns 内部采用插件机制，所有功能都是插件形式编写，用户也可以扩展自己的插件，以下是 Kubernetes 部署 CoreDns 时的默认配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">➜</span>  <span class="string">~</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">cm</span> <span class="string">coredns</span> <span class="string">-n</span> <span class="string">kube-system</span> <span class="string">-o</span> <span class="string">yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">Corefile:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    .:53 &#123;</span></span><br><span class="line"><span class="string">        errors  # 启用错误记录</span></span><br><span class="line"><span class="string">        health  # 启用健康检查检查端点，8080:health</span></span><br><span class="line"><span class="string">        ready</span></span><br><span class="line"><span class="string">        kubernetes cluster.local in-addr.arpa ip6.arpa &#123;  # 处理 k8s 域名解析</span></span><br><span class="line"><span class="string">           pods insecure</span></span><br><span class="line"><span class="string">           fallthrough in-addr.arpa ip6.arpa</span></span><br><span class="line"><span class="string">           ttl 30</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        prometheus :9153  # 启用 metrics 指标，9153:metrics</span></span><br><span class="line"><span class="string">        forward . /etc/resolv.conf  # 通过 resolv.conf 内的 nameservers 解析</span></span><br><span class="line"><span class="string">        cache 30  # 启用缓存，所有内容限制为 30s 的TTL</span></span><br><span class="line"><span class="string">        loop  # 检查简单的转发循环并停止服务</span></span><br><span class="line"><span class="string">        reload  # 运行自动重新加载 corefile，热更新</span></span><br><span class="line"><span class="string">        loadbalance  # 负载均衡，默认 round_robin</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2019-11-08T11:59:49Z&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;188&quot;</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/kube-system/configmaps/coredns</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="number">21966186</span><span class="string">-c2d9-467a-b87f-d061c5c9e4d7</span></span><br></pre></td></tr></table></figure>



<ul>
<li>每个 <code>&#123;&#125;</code> 代表一个 zone,格式是 <code>“Zone:port&#123;&#125;”</code>, 其中<code>&quot;.&quot;</code>代表默认 zone</li>
<li><code>&#123;&#125;</code> 内的每个名称代表插件的名称，只有配置的插件才会启用，当解析域名时，会先匹配 zone（都未匹配会执行默认 zone），然后 zone 内的插件从上到下依次执行(这个顺序并不是配置文件内谁在前面的顺序，而是<code>core/dnsserver/zdirectives.go</code>内的顺序)，匹配后返回处理（执行过的插件从下到上依次处理返回逻辑），不再执行下一个插件</li>
</ul>
<p>CoreDNS 的 Service 地址一般情况下是固定的，类似于 kubernetes 这个 Service 地址一般就是第一个 IP 地址 <code>10.96.0.1</code>，CoreDNS 的 Service 地址就是 <code>10.96.0.10</code>，该 IP 被分配后，kubelet 会将使用 <code>--cluster-dns=&lt;dns-service-ip&gt;</code> 参数配置的 DNS 传递给每个容器。DNS 名称也需要域名，本地域可以使用参数<code>--cluster-domain = &lt;default-local-domain&gt;</code> 在 kubelet 中配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">➜</span>  <span class="string">~</span> <span class="string">cat</span> <span class="string">/var/lib/kubelet/config.yaml</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">clusterDNS:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line"><span class="attr">clusterDomain:</span> <span class="string">cluster.local</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>



<p>我们前面说了如果我们建立的 Service 如果支持域名形式进行解析，就可以解决我们的服务发现的功能，那么利用 kubedns 可以将 Service 生成怎样的 DNS 记录呢？</p>
<ul>
<li>普通的 Service：会生成 <code>servicename.namespace.svc.cluster.local</code> 的域名，会解析到 Service 对应的 ClusterIP 上，在 Pod 之间的调用可以简写成 <code>servicename.namespace</code>，如果处于同一个命名空间下面，甚至可以只写成 <code>servicename</code> 即可访问</li>
<li>Headless Service：无头服务，就是把 clusterIP 设置为 None 的，会被解析为指定 Pod 的 IP 列表，同样还可以通过 <code>podname.servicename.namespace.svc.cluster.local</code> 访问到具体的某一个 Pod。</li>
</ul>
<p>接下来我们来使用一个简单 Pod 来测试下 Service 的域名访问：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl run -it --image busybox:1.28.3 test-dns --restart=Never --rm /bin/sh</span><br><span class="line">If you don&#x27;t see a command prompt, try pressing enter.</span><br><span class="line">/ # cat /etc/resolv.conf</span><br><span class="line">nameserver 10.96.0.10</span><br><span class="line">search default.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line">options ndots:5</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>



<p>我们进入到 Pod 中，查看 <code>/etc/resolv.conf</code> 中的内容，可以看到 <code>nameserver</code> 的地址 <code>10.96.0.10</code>，该 IP 地址即是在安装 CoreDNS 插件的时候集群分配的一个固定的静态 IP 地址，我们可以通过下面的命令进行查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get svc -n kube-system</span><br><span class="line">NAME                      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns                  ClusterIP   10.96.0.10       &lt;none&gt;        53/UDP,53/TCP,9153/TCP   28d</span><br></pre></td></tr></table></figure>



<p>也就是说我们这个 Pod 现在默认的 <code>nameserver</code> 就是 <code>kube-dns</code> 的地址，现在我们来访问下前面我们创建的 nginx-service 服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ # wget -q -O- nginx-service.default.svc.cluster.local</span><br></pre></td></tr></table></figure>



<p>可以看到上面我们使用 wget 命令去访问 nginx-service 服务的域名的时候被 hang 住了，没有得到期望的结果，这是因为上面我们建立 Service 的时候暴露的端口是 5000：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/ # wget -q -O- nginx-service.default.svc.cluster.local:5000</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<p>加上 5000 端口，就正常访问到服务，再试一试访问：<code>nginx-service.default.svc</code>、<code>nginx-service.default</code>、<code>nginx-service</code>，不出意外这些域名都可以正常访问到期望的结果。</p>
<p>到这里我们是不是就实现了在集群内部通过 Service 的域名形式进行互相通信了，大家下去试着看看访问不同 namespace 下面的服务呢？</p>
<h2 id="给-Pod-添加-DNS-记录"><a href="#给-Pod-添加-DNS-记录" class="headerlink" title="给 Pod 添加 DNS 记录"></a>给 Pod 添加 DNS 记录</h2><p>我们都知道 StatefulSet 中的 Pod 是拥有单独的 DNS 记录的，比如一个 StatefulSet 名称为 etcd，而它关联的 Headless SVC 名称为 etcd-headless，那么 CoreDNS 就会为它的每个 Pod 解析如下的记录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">etcd-0.etcd-headless.default.svc.cluster.local</span><br><span class="line">etcd-1.etcd-headless.default.svc.cluster.local</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>那么除了 StatefulSet 管理的 Pod 之外，其他的 Pod 是否也可以生成 DNS 记录呢？</p>
<p>如下所示，我们这里只有一个 Headless 的 SVC，并没有 StatefulSet 管理的 Pod，而是 ReplicaSet 管理的 Pod，我们可以看到貌似也生成了类似于 StatefulSet 中的解析记录。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20201203165518.png" alt="解析记录"></p>
<p>这是怎么做到的呢？按照我们常规的理解会认为这是一个 StatefulSet 管理的 Pod，但其实这里是不同的 ReplicaSet 而已。这里的实现其实是因为 Pod 自己本身也是可以有自己的 DNS 记录的，所以我们是可以去实现一个类似于 StatefulSet 的 Pod 那样的解析记录的。</p>
<p>首先我们来部署一个 Deployment 管理的普通应用，其定义如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<p>部署后创建了两个 Pod：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f nginx.yaml</span><br><span class="line">deployment.apps/nginx created</span><br><span class="line">➜  ~ kubectl get pod -l app=nginx -o wide</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP             NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-5d59d67564-2cwdz   1/1     Running   0          19s   10.244.1.68    node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-5d59d67564-bp5br   1/1     Running   0          19s   10.244.2.209   node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>



<p>然后定义如下的 Headless Service:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure>



<p>创建该 service，并尝试解析 service DNS：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f service.yaml</span><br><span class="line">service/nginx created</span><br><span class="line">➜  ~ kubectl get svc</span><br><span class="line">NAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">kubernetes                 ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP                      38d</span><br><span class="line">nginx                      ClusterIP   None             &lt;none&gt;        80/TCP                       7s</span><br><span class="line">➜  ~ dig @10.96.0.10 nginx.default.svc.cluster.local</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-73.el7_6 &lt;&lt;&gt;&gt; @10.96.0.10 nginx.default.svc.cluster.local</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 2573</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;nginx.default.svc.cluster.local. IN A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">nginx.default.svc.cluster.local. 30 IN A 10.244.2.209</span><br><span class="line">nginx.default.svc.cluster.local. 30 IN A 10.244.1.68</span><br><span class="line"></span><br><span class="line">;; Query time: 19 msec</span><br><span class="line">;; SERVER: 10.96.0.10#53(10.96.0.10)</span><br><span class="line">;; WHEN: Wed Nov 25 11:44:41 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 154</span><br></pre></td></tr></table></figure>



<p>然后我们对 nginx 的 FQDN 域名进行 dig 操作，可以看到返回了多条 A 记录，每一条对应一个 Pod。上面 dig 命令中使用的 10.96.0.10 就是 kube-dns 的 cluster IP，可以在 kube-system namespace 中查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl -n kube-system get svc</span><br><span class="line">NAME                   TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kube-dns               ClusterIP   10.96.0.10     &lt;none&gt;        53/UDP,53/TCP   52m</span><br></pre></td></tr></table></figure>



<p>接下来我们试试在 service 名字前面加上 Pod 名字交给 kube-dns 做解析：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dig @10.96.0.10 nginx-5d59d67564-bp5br.nginx.default.svc.cluster.local</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-73.el7_6 &lt;&lt;&gt;&gt; @10.96.0.10 nginx-5d59d67564-bp5br.nginx.default.svc.cluster.local</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 10485</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;nginx-5d59d67564-bp5br.nginx.default.svc.cluster.local. IN A</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">cluster.local.  30 IN SOA ns.dns.cluster.local. hostmaster.cluster.local. 1606275807 7200 1800 86400 30</span><br><span class="line"></span><br><span class="line">;; Query time: 4 msec</span><br><span class="line">;; SERVER: 10.96.0.10#53(10.96.0.10)</span><br><span class="line">;; WHEN: Wed Nov 25 11:47:31 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 176</span><br></pre></td></tr></table></figure>



<p>可以看到并没有得到解析结果。官方文档中有一段 <code>Pod’s hostname and subdomain fields</code> 说明：</p>
<blockquote>
<p>Pod 规范中包含一个可选的 hostname 字段，可以用来指定 Pod 的主机名。当这个字段被设置时，它将优先于 Pod 的名字成为该 Pod 的主机名。举个例子，给定一个 hostname 设置为 “my-host” 的 Pod， 该 Pod 的主机名将被设置为 “my-host”。Pod 规约还有一个可选的 subdomain 字段，可以用来指定 Pod 的子域名。举个例子，某 Pod 的 hostname 设置为 “foo”，subdomain 设置为 “bar”， 在名字空间 “my-namespace” 中对应的完全限定域名为 “foo.bar.my-namespace.svc.cluster-domain.example”。</p>
</blockquote>
<p>现在我们编辑一下 nginx.yaml 加上 subdomain 测试下看看：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">subdomain:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<p>更新部署再尝试解析 Pod DNS：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f nginx.yaml</span><br><span class="line">➜  ~ kubectl get pod -l app=nginx -o wide</span><br><span class="line">NAME                     READY   STATUS        RESTARTS   AGE     IP             NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-78f58d8bcb-6kctm   1/1     Running       0          8s      10.244.2.210   node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-78f58d8bcb-6tbnv   1/1     Running       0          15s     10.244.1.69    node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">➜  ~ dig @10.96.0.10 nginx-78f58d8bcb-6kctm.nginx.default.svc.cluster.local</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-73.el7_6 &lt;&lt;&gt;&gt; @10.96.0.10 nginx-78f58d8bcb-6kctm.nginx.default.svc.cluster.local</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 34172</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;nginx-78f58d8bcb-6kctm.nginx.default.svc.cluster.local. IN A</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">cluster.local.  30 IN SOA ns.dns.cluster.local. hostmaster.cluster.local. 1606276303 7200 1800 86400 30</span><br><span class="line"></span><br><span class="line">;; Query time: 2 msec</span><br><span class="line">;; SERVER: 10.96.0.10#53(10.96.0.10)</span><br><span class="line">;; WHEN: Wed Nov 25 11:52:18 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 176</span><br></pre></td></tr></table></figure>



<p>可以看到依然不能解析，那就试试官方文档中的例子 ，不用 Deployment 直接创建 Pod 吧。第一步先将 hostname 和 subdomain 注释掉：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># individual-pods-example.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default-subdomain</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span> <span class="comment"># Actually, no port is needed.</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">1234</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">1234</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostname:</span> <span class="string">busybox-1</span></span><br><span class="line">  <span class="attr">subdomain:</span> <span class="string">default-subdomain</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;3600&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox2</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostname:</span> <span class="string">busybox-2</span></span><br><span class="line">  <span class="attr">subdomain:</span> <span class="string">default-subdomain</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;3600&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">busybox</span></span><br></pre></td></tr></table></figure>



<p>部署然后尝试解析 Pod DNS (注意这里 hostname 和 pod 的名字有区别，中间多了减号)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f individual-pods-example.yaml</span><br><span class="line">➜  ~ ➜  ~ dig @10.96.0.10 busybox-1.default-subdomain.default.svc.cluster.local</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.5-Ubuntu &lt;&lt;&gt;&gt; @10.96.0.10 busybox-1.default-subdomain.default.svc.cluster.local</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; WARNING: .local is reserved for Multicast DNS</span><br><span class="line">;; You are currently testing what happens when an mDNS query is leaked to DNS</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 12636</span><br><span class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">; COOKIE: 5499ded915cf1ff2 (echoed)</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;busybox-1.default-subdomain.default.svc.cluster.local. IN A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">busybox-1.default-subdomain.default.svc.cluster.local. 5 IN A 10.44.0.6</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 10.96.0.10#53(10.96.0.10)</span><br><span class="line">;; WHEN: Fri Apr 19 15:27:38 CST 2019</span><br><span class="line">;; MSG SIZE  rcvd: 163</span><br></pre></td></tr></table></figure>



<p>现在我们看到有 ANSWER 记录回来了，hostname 和 subdomain 二者都必须显式指定，缺一不可。一开始我们的截图中的实现方式其实也是这种方式。</p>
<p>现在我们修改一下之前的 nginx deployment 加上 hostname，重新解析：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dig @10.96.0.10 nginx.nginx.default.svc.cluster.local</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-73.el7_6 &lt;&lt;&gt;&gt; @10.96.0.10 nginx.nginx.default.svc.cluster.local</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 21127</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;nginx.nginx.default.svc.cluster.local. IN A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">nginx.nginx.default.svc.cluster.local. 30 IN A 10.244.2.211</span><br><span class="line">nginx.nginx.default.svc.cluster.local. 30 IN A 10.244.1.70</span><br><span class="line"></span><br><span class="line">;; Query time: 1 msec</span><br><span class="line">;; SERVER: 10.96.0.10#53(10.96.0.10)</span><br><span class="line">;; WHEN: Wed Nov 25 11:55:37 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 172</span><br></pre></td></tr></table></figure>



<p>可以看到解析成功了，但是因为 Deployment 中无法给每个 Pod 指定不同的 hostname，所以两个 Pod 有同样的 hostname，解析出来两个 IP，跟我们的本意就不符合了。不过知道了这种方式过后我们就可以自己去写一个 Operator 去直接管理 Pod 了，给每个 Pod 设置不同的 hostname 和一个 Headless SVC 名称的 subdomain，这样就相当于实现了 StatefulSet 中的 Pod 解析。</p>
<h2 id="Pod-的-DNS-策略"><a href="#Pod-的-DNS-策略" class="headerlink" title="Pod 的 DNS 策略"></a>Pod 的 DNS 策略</h2><p>DNS 策略可以单独对 Pod 进行设定，目前 Kubernetes 支持以下特定 Pod 的 DNS 策略。这些策略可以在 Pod 规范中的 <code>dnsPolicy</code> 字段设置：</p>
<ul>
<li>Default: 有人说 Default 的方式，是使用宿主机的方式，这种说法并不准确。这种方式其实是让 kubelet 来决定使用何种 DNS 策略。而 kubelet 默认的方式，就是使用宿主机的 <code>/etc/resolv.conf</code>（可能这就是有人说使用宿主机的 DNS 策略的方式吧），但是，kubelet 是可以灵活来配置使用什么文件来进行 DNS 策略的，我们完全可以使用 kubelet 的参数 <code>–resolv-conf=/etc/resolv.conf</code> 来决定你的 DNS 解析文件地址。</li>
<li>ClusterFirst: 这种方式，表示 Pod 内的 DNS 使用集群中配置的 DNS 服务，简单来说，就是使用 Kubernetes 中 kubedns 或 coredns 服务进行域名解析。如果解析不成功，才会使用宿主机的 DNS 配置进行解析。</li>
<li>ClusterFirstWithHostNet：在某些场景下，我们的 Pod 是用 HostNetwork 模式启动的，一旦用 HostNetwork 模式，表示这个 Pod 中的所有容器，都要使用宿主机的 <code>/etc/resolv.conf</code> 配置进行 DNS 查询，但如果你还想继续使用 Kubernetes 的 DNS 服务，那就将 dnsPolicy 设置为 <code>ClusterFirstWithHostNet</code>。</li>
<li>None: 表示空的 DNS 设置，这种方式一般用于想要自定义 DNS 配置的场景，往往需要和 <code>dnsConfig</code> 配合一起使用达到自定义 DNS 的目的。</li>
</ul>
<blockquote>
<p>需要注意的是 <code>Default</code> 并不是默认的 DNS 策略，如果未明确指定 dnsPolicy，则使用 <code>ClusterFirst</code>。</p>
</blockquote>
<p>下面的示例显示了一个 Pod，其 DNS 策略设置为 <code>ClusterFirstWithHostNet</code>，因为它已将 hostNetwork 设置为 true。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;3600&#x27;</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirstWithHostNet</span></span><br></pre></td></tr></table></figure>



<h2 id="Pod-的-DNS-配置"><a href="#Pod-的-DNS-配置" class="headerlink" title="Pod 的 DNS 配置"></a>Pod 的 DNS 配置</h2><p>Pod 的 DNS 配置可让用户对 Pod 的 DNS 设置进行更多控制。<code>dnsConfig</code> 字段是可选的，它可以与任何 <code>dnsPolicy</code> 设置一起使用。 但是，<strong>当 Pod 的 dnsPolicy 设置为 “None” 时，必须指定 dnsConfig 字段</strong>。</p>
<p>用户可以在 dnsConfig 字段中指定以下属性：</p>
<ul>
<li>nameservers：将用作于 Pod 的 DNS 服务器的 IP 地址列表。 最多可以指定 3 个 IP 地址。当 Pod 的 dnsPolicy 设置为 “None” 时，列表必须至少包含一个 IP 地址，否则此属性是可选的。所列出的服务器将合并到从指定的 DNS 策略生成的基本名称服务器，并删除重复的地址。</li>
<li>searches：用于在 Pod 中查找主机名的 DNS 搜索域的列表。此属性是可选的。 指定此属性时，所提供的列表将合并到根据所选 DNS 策略生成的基本搜索域名中。重复的域名将被删除，Kubernetes 最多允许 6 个搜索域。</li>
<li>options：可选的对象列表，其中每个对象可能具有 name 属性（必需）和 value 属性（可选）。此属性中的内容将合并到从指定的 DNS 策略生成的选项。重复的条目将被删除。</li>
</ul>
<p>以下是具有自定义 DNS 设置的 Pod 示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dns-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">&#x27;None&#x27;</span></span><br><span class="line">  <span class="attr">dnsConfig:</span></span><br><span class="line">    <span class="attr">nameservers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line">    <span class="attr">searches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ns1.svc.cluster-domain.example</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my.dns.search.suffix</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ndots</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">edns0</span></span><br></pre></td></tr></table></figure>



<p>创建上面的 Pod 后，容器 test 会在其 <code>/etc/resolv.conf</code> 文件中获取以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nameserver 1.2.3.4</span><br><span class="line">search ns1.svc.cluster-domain.example my.dns.search.suffix</span><br><span class="line">options ndots:2 edns0</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
