<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hui&#39;s Blog">
<meta property="og:url" content="http://example.com/page/26/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="六一">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/26/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">消息队列推拉模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:18:46" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>您好！在消息队列的设计中，采用“推消息（Push）”还是“拉消息（Pull）”模式是核心考量之一，每种模式都有其独特的优缺点和适用场景。理解这些差异对于我们选择或设计合适的MQ系统至关重要。</p>
<hr>
<h3 id="一、-推消息模式（Push-Mode-Server-Push）"><a href="#一、-推消息模式（Push-Mode-Server-Push）" class="headerlink" title="一、 推消息模式（Push Mode &#x2F; Server Push）"></a>一、 推消息模式（Push Mode &#x2F; Server Push）</h3><h4 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h4><p>Broker（消息队列服务器）主动将消息推送给消费者（Consumer）。一旦有新消息到达，Broker会立即将消息发送给订阅了该消息的消费者。</p>
<h4 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h4><p>Broker维护与消费者的TCP连接，当消息写入Broker后，Broker会检查哪些消费者订阅了该消息，然后将消息数据包通过网络主动发送给这些消费者。</p>
<h4 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h4><ul>
<li><strong>实时性高 &#x2F; 低延迟：</strong> 消息一到达Broker，就能立即被消费者接收和处理，响应速度快。</li>
<li><strong>简化消费者逻辑：</strong> 消费者只需要启动一个监听器或注册一个回调函数来接收消息，处理逻辑相对简单，无需主动发起请求。</li>
<li><strong>适合高实时性、小并发场景：</strong> 例如即时通讯、在线通知等对消息延迟有严格要求的业务。</li>
<li><strong>快速失败反馈：</strong> Broker能更快感知到消费者连接中断或处理异常，便于进行消息重投或错误处理。</li>
</ul>
<h4 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h4><ul>
<li><strong>消费者处理能力瓶颈（Backpressure &#x2F; 背压问题）：</strong> Broker无法准确感知消费者的当前处理能力。如果Broker推送消息的速度远超消费者处理速度，可能导致消费者过载崩溃、内存溢出，甚至影响整个系统的稳定性。 Broker难以实现有效的流量控制和限流。</li>
<li><strong>网络和连接管理复杂：</strong> Broker需要维护所有消费者的连接状态、发送队列，并处理网络抖动、重连等问题，增加了Broker的复杂性和资源消耗。</li>
<li><strong>资源浪费：</strong> 如果消费者处理速度慢，累积的消息会在Broker端堆积，占用Broker资源。如果消费者离线，Broker需要等待其上线才能推送，或将消息持久化在Broker端。</li>
<li><strong>不适合广域网环境：</strong> 在网络延迟高、不稳定的广域网（WAN）环境下，主动推送可能会加剧网络问题，导致消息丢失或传输效率低下。</li>
</ul>
<h4 id="5-典型案例"><a href="#5-典型案例" class="headerlink" title="5. 典型案例"></a>5. 典型案例</h4><ul>
<li>早期的一些MQ系统、某些轻量级通知服务。</li>
<li>ZeroMQ 具备 Push&#x2F;Pull 模式，但多数Push实现都是无状态的，例如通过 TCP 连接直接投递。</li>
</ul>
<hr>
<h3 id="二、-拉消息模式（Pull-Mode-Client-Pull）"><a href="#二、-拉消息模式（Pull-Mode-Client-Pull）" class="headerlink" title="二、 拉消息模式（Pull Mode &#x2F; Client Pull）"></a>二、 拉消息模式（Pull Mode &#x2F; Client Pull）</h3><h4 id="1-核心思想-1"><a href="#1-核心思想-1" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h4><p>消费者主动向Broker请求拉取消息。消费者根据自己的处理能力和需求，决定何时拉取、拉取多少消息。</p>
<h4 id="2-工作原理-1"><a href="#2-工作原理-1" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h4><p>消费者会定期（短轮询）或通过长轮询（Long Polling）机制向Broker发送拉取请求。Broker收到请求后，如果队列中有消息，则返回给消费者；如果没有，则延迟一段时间（长轮询）或立即返回空，等待消费者下一次请求。</p>
<h4 id="3-优点-1"><a href="#3-优点-1" class="headerlink" title="3. 优点"></a>3. 优点</h4><ul>
<li><strong>消费者自主控制流量 &#x2F; 灵活的负载均衡：</strong> 这是Pull模式最大的优势。消费者可以根据自身的CPU、内存、I&#x2F;O资源情况，灵活控制拉取消息的速度和数量，有效避免了过载，实现了流量削峰和自我保护。</li>
<li><strong>易于实现批量拉取：</strong> 消费者可以一次拉取多条消息（Batch Pull），减少网络I&#x2F;O次数和RPC开销，提高消息吞吐量。</li>
<li><strong>对Broker压力小：</strong> Broker只需响应消费者的拉取请求，无需主动推送、无需维护大量消费者连接状态，使得Broker端更轻量、易于扩展。</li>
<li><strong>适合广域网 &#x2F; 弱网络环境：</strong> 消费者可以自行处理拉取失败的重试逻辑，对网络抖动有更好的容忍性。</li>
<li><strong>更容易实现顺序消费：</strong> 在消费者拉取到一批消息后，可以在本地串行处理，从而更好地保证消息的局部有序性。</li>
</ul>
<h4 id="4-缺点-1"><a href="#4-缺点-1" class="headerlink" title="4. 缺点"></a>4. 缺点</h4><ul>
<li><strong>实时性相对较差 &#x2F; 可能存在延迟：</strong> 如果消费者拉取间隔设置过长，消息不能及时被处理，会增加消息的端到端延迟。</li>
<li><strong>频繁轮询可能导致空轮询 &#x2F; 资源浪费：</strong> 如果队列长时间没有新消息，消费者会进行大量的空轮询请求，白白浪费网络带宽和Broker资源。</li>
<li><strong>消费者逻辑相对复杂：</strong> 消费者需要管理拉取间隔、拉取数量、请求超时、拉取失败重试等逻辑。</li>
</ul>
<h4 id="5-典型优化（解决拉模式缺点）"><a href="#5-典型优化（解决拉模式缺点）" class="headerlink" title="5. 典型优化（解决拉模式缺点）"></a>5. 典型优化（解决拉模式缺点）</h4><ul>
<li><strong>长轮询（Long Polling）：</strong> 为了兼顾实时性和避免空轮询，现代MQ系统广泛采用长轮询。消费者发出拉取请求后，如果Broker没有新消息，Broker并不会立即返回，而是会持有该连接一段时间（如几秒钟），直到有新消息到达或等待超时才返回响应。这样既减少了空轮询，又提高了消息的实时性。</li>
</ul>
<h4 id="6-典型案例"><a href="#6-典型案例" class="headerlink" title="6. 典型案例"></a>6. 典型案例</h4><ul>
<li><strong>Apache Kafka：</strong> 典型的、纯粹的拉模式。消费者主动从Broker的特定分区拉取消息。</li>
<li><strong>Apache RocketMQ：</strong> 虽然其客户端SDK提供 <code>DefaultMQPushConsumer</code> 命名为“Push”，但其底层实现原理是基于长轮询的拉模式。命名为Push只是为了使用户编程接口看起来更像Push消费者，简化了用户的拉取逻辑。</li>
<li><strong>RabbitMQ (AMQP协议)：</strong> 支持 Pull (Basic.Get) 和 Push (Basic.Deliver) 两种模式，但默认和推荐使用 Push 模式 (通过 <code>Basic.Consume</code> 注册回调，由 Broker 主动推送)。</li>
</ul>
<hr>
<h3 id="三、-总结与设计决策"><a href="#三、-总结与设计决策" class="headerlink" title="三、 总结与设计决策"></a>三、 总结与设计决策</h3><p>在实际的后端开发实践中，主流的消息队列如 Kafka、RocketMQ、Pulsar，它们在消费者端的设计上，<strong>更倾向于采用拉模式（或结合长轮询的拉模式）</strong>。</p>
<p><strong>原因在于：</strong></p>
<ol>
<li><strong>消费者处理速度的不确定性：</strong> Broker很难精确掌握每个消费者的当前处理能力。如果强制推送，很容易导致消费者过载。而让消费者自己控制拉取节奏，能更好地适应消费者状态的变化。</li>
<li><strong>流量控制与背压：</strong> 拉模式天然地支持消费者端控制流量，从而有效解决分布式系统中的背压问题，避免“雪崩效应”。</li>
<li><strong>批量处理效率：</strong> 拉模式更便于实现批量拉取和批量处理，这对于高吞吐量的场景至关重要。</li>
<li><strong>易于扩展与伸缩：</strong> Broker端只需要存储消息并响应拉取请求，扩展性更好。消费者端也可以根据需求灵活增减实例。</li>
</ol>
<p><strong>何时考虑“推”的API或设计？</strong><br>虽然底层多是拉模式，但为了方便开发者，许多MQ的客户端SDK会提供一个“Push”风格的API。这通常是在SDK内部封装了拉取、长轮询、线程池调度等复杂逻辑，对外提供一个简单的回调接口，让用户感觉像是消息被“推”过来一样。</p>
<p><strong>最终选择：</strong><br>作为后端开发人员，在设计消息队列系统时，我会强烈建议：</p>
<ul>
<li><strong>底层机制：</strong> 采用<strong>拉模式</strong>（配合长轮询）作为消费者与Broker之间的主要交互方式，这能带来更好的稳定性和伸缩性。</li>
<li><strong>API设计：</strong> 可以根据用户场景和开发便利性，在客户端SDK层面提供<strong>“Push”风格的API</strong>来简化消费者的编程模型，但要确保底层机制是能够有效控制流量的拉模式。</li>
</ul>
<p>通过这种结合，我们可以拥有拉模式的稳定性和控制力，同时为开发者提供类似推模式的便捷体验。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">深拷贝与浅拷贝</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:15:58" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>在 Go 语言中，所有的数据传递（包括赋值和函数参数传递）都是按值进行的</strong>。</p>
<hr>
<h3 id="Go-语言中的“值”是什么？"><a href="#Go-语言中的“值”是什么？" class="headerlink" title="Go 语言中的“值”是什么？"></a>Go 语言中的“值”是什么？</h3><p>这取决于变量的类型：</p>
<ol>
<li><p>**值类型 (Value Types)**：</p>
<ul>
<li>基本数据类型：<code>int</code>, <code>float64</code>, <code>bool</code>, <code>string</code>, <code>complex</code> 等。</li>
<li>数组 (Array)：<code>[N]Type</code>。</li>
<li>结构体 (Struct)：如果结构体的所有字段都是值类型。</li>
<li>当传递这些类型时，会创建它们的<strong>完整副本</strong>。</li>
</ul>
</li>
<li><p>**引用类型 (Reference Types)**：</p>
<ul>
<li>切片 (Slice)：<code>[]Type</code></li>
<li>映射 (Map)：<code>map[KeyType]ValueType</code></li>
<li>通道 (Channel)：<code>chan Type</code></li>
<li>接口 (Interface)：<code>interface&#123;&#125;</code></li>
<li>指针 (Pointer)：<code>*Type</code></li>
<li>函数 (Function)：<code>func(...)</code></li>
<li>当传递这些类型时，实际拷贝的是它们的<strong>“头部”（header）或者说“描述符”</strong>, 这个头部包含了指向底层数据结构的指针。<strong>底层数据本身并没有被复制</strong>。</li>
</ul>
</li>
</ol>
<p>理解了这一点，我们就可以区分深拷贝和浅拷贝了。</p>
<hr>
<h3 id="1-浅拷贝-Shallow-Copy"><a href="#1-浅拷贝-Shallow-Copy" class="headerlink" title="1. 浅拷贝 (Shallow Copy)"></a>1. 浅拷贝 (Shallow Copy)</h3><p><strong>定义：</strong> 浅拷贝是指在拷贝一个数据结构时，只拷贝其<strong>顶层（或第一层）的数据值</strong>。如果顶层数据中包含指向其他内存地址的引用（即指针），那么这些引用会被直接复制，而不会去复制它们所指向的实际数据。结果是，<strong>原数据和副本会共享底层的数据</strong>。</p>
<p><strong>在 Go 语言中的表现：</strong><br>当对一个<strong>引用类型</strong>变量进行赋值或作为函数参数传递时，发生的就是浅拷贝。拷贝的是引用，而不是引用指向的实际数据。</p>
<p><strong>浅拷贝的特点：</strong></p>
<ul>
<li><strong>共享底层数据：</strong> 原始数据和新数据引用的是同一块内存区域。</li>
<li><strong>副作用：</strong> 通过新数据修改共享的底层数据，会影响到原始数据。</li>
</ul>
<p><strong>示例：</strong></p>
<h4 id="示例-1-切片-Slice-的浅拷贝"><a href="#示例-1-切片-Slice-的浅拷贝" class="headerlink" title="示例 1: 切片 (Slice) 的浅拷贝"></a>示例 1: 切片 (Slice) 的浅拷贝</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    originalSlice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;原切片地址（header值）: %p, 数据地址: %p, 内容: %v\n&quot;</span>, &amp;originalSlice, originalSlice, originalSlice)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 浅拷贝：copySlice 接收了 originalSlice 的 header 值的副本</span></span><br><span class="line">    <span class="comment">// 这个副本指向和 originalSlice 相同的底层数组</span></span><br><span class="line">    copySlice := originalSlice</span><br><span class="line">    fmt.Printf(<span class="string">&quot;复制切片地址（header值）: %p, 数据地址: %p, 内容: %v\n&quot;</span>, &amp;copySlice, copySlice, copySlice)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 修改 copySlice 的元素</span></span><br><span class="line">    copySlice[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">  </span><br><span class="line">    fmt.Println(<span class="string">&quot;\n修改 copySlice[0] 后:&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;原切片内容: %v\n&quot;</span>, originalSlice) <span class="comment">// originalSlice 也被修改了！</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;复制切片内容: %v\n&quot;</span>, copySlice)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：s = append(s, val) 如果导致底层数组 reallocate，则新的 s 将不再共享底层数组</span></span><br><span class="line">    <span class="comment">// 但在 reallocate 发生之前，它们是共享的。</span></span><br><span class="line">    <span class="comment">// 如果是 copySlice = append(copySlice, 100)，且原capacity不足，则copySlice会指向新数组</span></span><br><span class="line">    <span class="comment">// 此时originalSlice将不会受到后续append操作的影响（除非你修改了原来的共享部分）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong> <code>originalSlice</code> 和 <code>copySlice</code> 的值（即它们的 slice header）虽然是不同的内存地址，但它们内部的底层数组指针却指向同一块内存区域。因此，通过 <code>copySlice[0] = 99</code> 修改元素时，实际上是修改了这块共享的底层内存，<code>originalSlice</code> 也随之改变。</p>
<h4 id="示例-2-映射-Map-的浅拷贝"><a href="#示例-2-映射-Map-的浅拷贝" class="headerlink" title="示例 2: 映射 (Map) 的浅拷贝"></a>示例 2: 映射 (Map) 的浅拷贝</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    originalMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;原 map 地址（header值）: %p, 内容: %v\n&quot;</span>, &amp;originalMap, originalMap)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅拷贝：copyMap 接收了 originalMap 的 header 值的副本</span></span><br><span class="line">    <span class="comment">// 这个副本指向和 originalMap 相同的底层 hash map 结构</span></span><br><span class="line">    copyMap := originalMap</span><br><span class="line">    fmt.Printf(<span class="string">&quot;复制 map 地址（header值）: %p, 内容: %v\n&quot;</span>, &amp;copyMap, copyMap)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 copyMap 的元素</span></span><br><span class="line">    copyMap[<span class="string">&quot;a&quot;</span>] = <span class="number">99</span></span><br><span class="line">    copyMap[<span class="string">&quot;c&quot;</span>] = <span class="number">3</span> <span class="comment">// 添加新元素</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;\n修改 copyMap[&#x27;a&#x27;] 后:&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;原 map 内容: %v\n&quot;</span>, originalMap) <span class="comment">// originalMap 也被修改了！</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;复制 map 内容: %v\n&quot;</span>, copyMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong> <code>map</code> 类型在 Go 中也是引用类型。<code>copyMap = originalMap</code> 实际上只是复制了 <code>map</code> 的描述符，它们都指向内存中的同一个哈希表结构。因此，对 <code>copyMap</code> 进行增删改查操作，都会直接作用于底层哈希表，<code>originalMap</code> 自然也会反映这些变化。</p>
<hr>
<h3 id="2-深拷贝-Deep-Copy"><a href="#2-深拷贝-Deep-Copy" class="headerlink" title="2. 深拷贝 (Deep Copy)"></a>2. 深拷贝 (Deep Copy)</h3><p><strong>定义：</strong> 深拷贝是指在拷贝一个数据结构时，<strong>不仅拷贝顶层的数据值，还会递归地拷贝所有嵌套的引用类型数据</strong>。最终结果是一个与原始数据完全独立的副本，它们之间没有任何共享的底层数据。</p>
<p><strong>在 Go 语言中的表现：</strong><br>Go 语言<strong>没有内置通用的深拷贝机制</strong>。你需要根据数据结构的具体情况，手动编写代码来实现深拷贝，或者利用序列化&#x2F;反序列化库。</p>
<p><strong>深拷贝的特点：</strong></p>
<ul>
<li><strong>完全独立：</strong> 原始数据和新数据互不影响。</li>
<li><strong>无副作用：</strong> 修改新数据不会影响原始数据。</li>
</ul>
<p><strong>示例：</strong></p>
<h4 id="示例-1-切片-Slice-的深拷贝"><a href="#示例-1-切片-Slice-的深拷贝" class="headerlink" title="示例 1: 切片 (Slice) 的深拷贝"></a>示例 1: 切片 (Slice) 的深拷贝</h4><p>要深拷贝切片，你需要创建一个新的底层数组，并将原切片的内容逐个复制过来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    originalSlice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;原切片地址（header值）: %p, 数据地址: %p, 内容: %v\n&quot;</span>, &amp;originalSlice, originalSlice, originalSlice)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 深拷贝切片：</span></span><br><span class="line">    <span class="comment">// 1. 创建一个与原切片长度和容量相同的新切片</span></span><br><span class="line">    deepCopiedSlice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(originalSlice), <span class="built_in">cap</span>(originalSlice))</span><br><span class="line">    <span class="comment">// 2. 使用内置的 copy() 函数将元素从原切片复制到新切片</span></span><br><span class="line">    <span class="built_in">copy</span>(deepCopiedSlice, originalSlice)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;深拷贝切片地址（header值）: %p, 数据地址: %p, 内容: %v\n&quot;</span>, &amp;deepCopiedSlice, deepCopiedSlice, deepCopiedSlice)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 修改深拷贝后的切片元素</span></span><br><span class="line">    deepCopiedSlice[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">  </span><br><span class="line">    fmt.Println(<span class="string">&quot;\n修改 deepCopiedSlice[0] 后:&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;原切片内容: %v\n&quot;</span>, originalSlice)       <span class="comment">// originalSlice 不受影响</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;深拷贝切片内容: %v\n&quot;</span>, deepCopiedSlice) <span class="comment">// deepCopiedSlice 已被修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong> <code>make([]int, len(originalSlice), cap(originalSlice))</code> 创建了一个<strong>新的</strong>底层数组，<code>copy()</code> 函数将 <code>originalSlice</code> 中的元素值逐个复制到这个新数组中。此时，<code>originalSlice</code> 和 <code>deepCopiedSlice</code> 不仅它们的 slice header 值不同，它们指向的底层数组也是完全独立的。</p>
<h4 id="示例-2-映射-Map-的深拷贝"><a href="#示例-2-映射-Map-的深拷贝" class="headerlink" title="示例 2: 映射 (Map) 的深拷贝"></a>示例 2: 映射 (Map) 的深拷贝</h4><p>要深拷贝 Map，你需要创建一个新的 Map，并遍历原始 Map 的所有键值对，逐个将其添加到新 Map 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    originalMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;原 map 地址（header值）: %p, 内容: %v\n&quot;</span>, &amp;originalMap, originalMap)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝 map：</span></span><br><span class="line">    <span class="comment">// 1. 创建一个新 map</span></span><br><span class="line">    deepCopiedMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="built_in">len</span>(originalMap))</span><br><span class="line">    <span class="comment">// 2. 遍历原 map，将键值对逐个复制到新 map</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> originalMap &#123;</span><br><span class="line">        deepCopiedMap[k] = v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;深拷贝 map 地址（header值）: %p, 内容: %v\n&quot;</span>, &amp;deepCopiedMap, deepCopiedMap)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改深拷贝后的 map 元素</span></span><br><span class="line">    deepCopiedMap[<span class="string">&quot;a&quot;</span>] = <span class="number">99</span></span><br><span class="line">    deepCopiedMap[<span class="string">&quot;c&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;\n修改 deepCopiedMap 后:&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;原 map 内容: %v\n&quot;</span>, originalMap)       <span class="comment">// originalMap 不受影响</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;深拷贝 map 内容: %v\n&quot;</span>, deepCopiedMap) <span class="comment">// deepCopiedMap 已被修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例-3-包含引用类型的结构体（最常见的深拷贝需求）"><a href="#示例-3-包含引用类型的结构体（最常见的深拷贝需求）" class="headerlink" title="示例 3: 包含引用类型的结构体（最常见的深拷贝需求）"></a>示例 3: 包含引用类型的结构体（最常见的深拷贝需求）</h4><p>如果结构体中包含切片、Map 或其他指针等引用类型字段，仅仅进行结构体赋值（按值拷贝其顶层结构），<strong>会导致内部引用字段仍是浅拷贝</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID      <span class="type">int</span></span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    Hobbies []<span class="type">string</span> <span class="comment">// 这是一个切片，引用类型</span></span><br><span class="line">    Settings <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="comment">// 这是一个map，引用类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeepCopyUser 手动实现 User 结构体的深拷贝方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> DeepCopy() *User &#123;</span><br><span class="line">    <span class="keyword">if</span> u == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝基本类型字段</span></span><br><span class="line">    newUser := &amp;User&#123;</span><br><span class="line">        ID:      u.ID,</span><br><span class="line">        Name:    u.Name,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝 Hobbies 切片</span></span><br><span class="line">    <span class="keyword">if</span> u.Hobbies != <span class="literal">nil</span> &#123;</span><br><span class="line">        newUser.Hobbies = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(u.Hobbies))</span><br><span class="line">        <span class="built_in">copy</span>(newUser.Hobbies, u.Hobbies)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝 Settings Map</span></span><br><span class="line">    <span class="keyword">if</span> u.Settings != <span class="literal">nil</span> &#123;</span><br><span class="line">        newUser.Settings = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="built_in">len</span>(u.Settings))</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> u.Settings &#123;</span><br><span class="line">            newUser.Settings[k] = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newUser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    originalUser := &amp;User&#123;</span><br><span class="line">        ID:      <span class="number">1</span>,</span><br><span class="line">        Name:    <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        Hobbies: []<span class="type">string</span>&#123;<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;coding&quot;</span>&#125;,</span><br><span class="line">        Settings: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;theme&quot;</span>: <span class="string">&quot;dark&quot;</span>, <span class="string">&quot;locale&quot;</span>: <span class="string">&quot;en&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Original User: %+v, Hobbies addr: %p, Settings addr: %p\n&quot;</span>, originalUser, originalUser.Hobbies, originalUser.Settings)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 尝试浅拷贝 (直接赋值或传指针) - Hobbies 和 Settings 仍是共享的</span></span><br><span class="line">    <span class="comment">// shallowCopyUser := originalUser // 拷贝的是指针值</span></span><br><span class="line">    <span class="comment">// shallowCopyUser.Hobbies[0] = &quot;swimming&quot; // 这会影响 originalUser</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. ✨深拷贝✨</span></span><br><span class="line">    deepCopiedUser := originalUser.DeepCopy()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Deep Copied User: %+v, Hobbies addr: %p, Settings addr: %p\n&quot;</span>, deepCopiedUser, deepCopiedUser.Hobbies, deepCopiedUser.Settings)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改深拷贝后的数据</span></span><br><span class="line">    deepCopiedUser.Name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">    deepCopiedUser.Hobbies[<span class="number">0</span>] = <span class="string">&quot;gaming&quot;</span></span><br><span class="line">    deepCopiedUser.Settings[<span class="string">&quot;theme&quot;</span>] = <span class="string">&quot;light&quot;</span></span><br><span class="line">    deepCopiedUser.Settings[<span class="string">&quot;font_size&quot;</span>] = <span class="string">&quot;large&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;\nModification after deep copy:&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Original User: %+v\n&quot;</span>, originalUser)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Deep Copied User: %+v\n&quot;</span>, deepCopiedUser)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong> 对于包含引用类型字段的结构体，必须为每个引用类型字段<strong>单独进行深拷贝</strong>。上述 <code>DeepCopy()</code> 方法就展示了如何为 <code>Hobbies</code> 切片和 <code>Settings</code> Map 创建独立的副本。</p>
<h4 id="通用深拷贝方法（序列化-反序列化）"><a href="#通用深拷贝方法（序列化-反序列化）" class="headerlink" title="通用深拷贝方法（序列化&#x2F;反序列化）"></a>通用深拷贝方法（序列化&#x2F;反序列化）</h4><p>对于非常复杂或嵌套很深的数据结构，手动实现深拷贝可能非常繁琐且容易出错。此时，可以考虑使用 Go 的序列化&#x2F;反序列化机制，例如 <code>encoding/gob</code> 或 <code>encoding/json</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/gob&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ComplexData <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID      <span class="type">int</span></span><br><span class="line">	Values <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span></span><br><span class="line">	Nested  *ComplexData <span class="comment">// 嵌套自身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeepCopyGob 通过 Gob 序列化/反序列化实现深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepCopyGob</span><span class="params">(src, dst <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> err := gob.NewEncoder(&amp;buf).Encode(src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gob.NewDecoder(&amp;buf).Decode(dst)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	original := ComplexData&#123;</span><br><span class="line">		ID: <span class="number">1</span>,</span><br><span class="line">		Values: <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>&#123;</span><br><span class="line">			<span class="string">&quot;A&quot;</span>: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">			<span class="string">&quot;B&quot;</span>: &#123;<span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		Nested: &amp;ComplexData&#123;</span><br><span class="line">			ID: <span class="number">2</span>,</span><br><span class="line">			Values: <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>&#123;</span><br><span class="line">				<span class="string">&quot;C&quot;</span>: &#123;<span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> deepCopied ComplexData</span><br><span class="line">	err := DeepCopyGob(&amp;original, &amp;deepCopied)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;深拷贝失败:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Original: %+v\n&quot;</span>, original)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Deep Copied: %+v\n&quot;</span>, deepCopied)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改深拷贝后的数据</span></span><br><span class="line">	deepCopied.ID = <span class="number">100</span></span><br><span class="line">	deepCopied.Values[<span class="string">&quot;A&quot;</span>][<span class="number">0</span>] = <span class="number">999</span></span><br><span class="line">	deepCopied.Nested.ID = <span class="number">200</span></span><br><span class="line">    deepCopied.Nested.Values[<span class="string">&quot;C&quot;</span>][<span class="number">0</span>] = <span class="number">888</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\nAfter modification:&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Original: %+v\n&quot;</span>, original)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Deep Copied: %+v\n&quot;</span>, deepCopied)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 简洁、通用，无需手动处理每个字段。<br><strong>缺点：</strong> 性能开销通常比手动拷贝大，且要求数据类型可被序列化（例如，不可导出字段在 JSON 中无法序列化）。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Go 中所有赋值和参数传递都是“传值”</strong>。</li>
<li>对于<strong>值类型</strong>（基本类型、数组、仅含值类型的结构体），”传值“即是<strong>深拷贝</strong>。</li>
<li>对于<strong>引用类型</strong>（切片、Map、通道、指针、函数、接口），”传值“则意味着复制了其<strong>引用（头部）</strong>，但底层数据仍是共享的，这表现为<strong>浅拷贝</strong>。</li>
<li>要实现引用类型的<strong>深拷贝</strong>，需要<strong>手动创建新的底层数据结构并复制内容</strong>，或者利用<strong>序列化&#x2F;反序列化</strong>机制。</li>
<li>理解并正确应用深浅拷贝是避免 Go 语言程序中意外副作用和数据损坏的关键所在。</li>
</ul>
<p>希望这份详细的解释能帮助您彻底理解 Go 语言中的深拷贝和浅拷贝！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E7%9B%91%E6%8E%A7%20APIServer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E7%9B%91%E6%8E%A7%20APIServer/" class="post-title-link" itemprop="url">监控 APIServer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:14:12" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="监控-APIServer"><a href="#监控-APIServer" class="headerlink" title="监控 APIServer"></a>监控 APIServer</h1><p>APIServer 作为 Kubernetes 最核心的组件，当然他的监控也是非常有必要的，对于 APIServer 的监控我们可以直接通过 Kubernetes 的 Service 来获取：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl get svc</span><br><span class="line">NAME             TYPE           CLUSTER-IP       EXTERNAL-IP             PORT(S)          AGE</span><br><span class="line">kubernetes       ClusterIP      10.96.0.1        &lt;none&gt;                  443/TCP          33d</span><br></pre></td></tr></table></figure>

<h2 id="自动发现"><a href="#自动发现" class="headerlink" title="自动发现"></a>自动发现</h2><p>上面这个 Service 就是我们集群的 apiserver 在集群内部的 Service 地址，要自动发现 Service 类型的服务，我们就需要用到 role 为 Endpoints 的 <code>kubernetes_sd_configs</code>，我们可以在 ConfigMap 对象中添加上一个 Endpoints 类型的服务的监控任务：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;apiservers&#x27;</span></span><br><span class="line">  <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br></pre></td></tr></table></figure>

<p>上面这个任务是定义的一个类型为 endpoints 的 <code>kubernetes_sd_configs</code> ，添加到 Prometheus 的 ConfigMap 的配置文件中，然后更新配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl apply -f https://p8s.io/docs/k8s/manifests/prometheus/config-8.yaml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">隔一会儿执行reload操作</span></span><br><span class="line">☸ ➜ curl -X POST &quot;http://10.244.2.46:9090/-/reload&quot;</span><br></pre></td></tr></table></figure>

<p>更新完成后，我们再去查看 Prometheus 的 Dashboard 的 target 页面：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20211223105612.png" alt="prometheus webui apiserver"></p>
<h2 id="relabel"><a href="#relabel" class="headerlink" title="relabel"></a>relabel</h2><p>我们可以看到 <code>apiservers</code> 任务下面出现了很多实例，这是因为这里我们使用的是 Endpoints 类型的服务发现，所以 Prometheus 把所有的 Endpoints 服务都抓取过来了，同样的，上面我们需要的服务名为 <code>kubernetes</code> 这个 apiserver 的服务也在这个列表之中，那么我们应该怎样来过滤出这个服务来呢？同样还是需要使用<code>relabel_configs</code> 这个配置，只是我们这里不是使用 <code>replace</code> 这个动作了，而是 <code>keep</code>，就是只把符合我们要求的给保留下来，哪些才是符合我们要求的呢？我们要过滤的服务是 <code>default</code> 这个 namespace 下面，服务名为 <code>kubernetes</code> 的元数据，所以这里我们就可以根据对应的 <code>__meta_kubernetes_namespace</code> 和 <code>__meta_kubernetes_service_name</code> 这两个元数据来进行过滤，另外由于 kubernetes 这个服务对应的端口是 443，需要使用 https 协议，所以这里我们需要使用 https 的协议，对应的就需要将 ca 证书配置上，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;apiservers&#x27;</span></span><br><span class="line">  <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">  <span class="attr">tls_config:</span></span><br><span class="line">    <span class="attr">ca_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span></span><br><span class="line">  <span class="attr">bearer_token_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/token</span></span><br><span class="line">  <span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span></span><br><span class="line">        [</span><br><span class="line">          <span class="string">__meta_kubernetes_namespace</span>,</span><br><span class="line">          <span class="string">__meta_kubernetes_service_name</span>,</span><br><span class="line">          <span class="string">__meta_kubernetes_endpoint_port_name</span>,</span><br><span class="line">        ]</span><br><span class="line">      <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">default;kubernetes;https</span></span><br></pre></td></tr></table></figure>

<p>现在重新更新配置文件、重新加载 Prometheus，切换到 Prometheus 的 Targets 路径下查看：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20211223105951.png" alt="prometheus apiserver target"></p>
<p>现在可以看到 <code>apiserver</code> 这个任务下面只有 apiserver 这一个实例了，现在我们切换到 Graph 路径下面查看下采集到的数据，比如查询 apiserver 的总的请求数：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20211223110352.png" alt="prometheus apiserver rate"></p>
<p>这样我们就完成了对 Kubernetes APIServer 的监控。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E7%9B%91%E6%8E%A7%20Pod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E7%9B%91%E6%8E%A7%20Pod/" class="post-title-link" itemprop="url">监控 Pod</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:14:17" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="监控-Pod"><a href="#监控-Pod" class="headerlink" title="监控 Pod"></a>监控 Pod</h1><p>前面的 apiserver 实际上就是一种特殊的 Endpoints，现在我们同样来配置一个任务用来专门发现普通类型的 Endpoint，其实就是 Service 关联的 Pod 列表，由于并不是所有的 Endpoints 都会提供 metrics 接口，所以需要我们主动告诉 Prometheus 去发现哪些 Endpoints，当然告诉的方式有很多，不过约定俗成的一种方式是通过 annotations 注解进行通知，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;endpoints&#x27;</span></span><br><span class="line">  <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line">  <span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="comment"># 保留 Service 的注解为 prometheus.io/scrape: true 的 Endpoints</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_scrape</span>]</span><br><span class="line">      <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 指标接口协议通过 prometheus.io/scheme 这个注解获取 http 或 https</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_scheme</span>]</span><br><span class="line">      <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">__scheme__</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">(https?)</span></span><br><span class="line">    <span class="comment"># 指标接口端点路径通过 prometheus.io/path 这个注解获取</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_path</span>]</span><br><span class="line">      <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">    <span class="comment"># 直接接口地址端口通过 prometheus.io/port 注解获取</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span></span><br><span class="line">        [<span class="string">__address__</span>, <span class="string">__meta_kubernetes_service_annotation_prometheus_io_port</span>]</span><br><span class="line">      <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">([^:]+)(?::\d+)?;(\d+)</span> <span class="comment"># RE2 正则规则，+是一次或多次，?是0次或1次，其中?:表示非匹配组(意思就是不获取匹配结果)</span></span><br><span class="line">      <span class="attr">replacement:</span> <span class="string">$1:$2</span></span><br><span class="line">    <span class="comment"># 映射 Service 的 Label 标签</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">__meta_kubernetes_service_label_(.+)</span></span><br><span class="line">    <span class="comment"># 将 namespace 映射成标签</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_namespace</span>]</span><br><span class="line">      <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">kubernetes_namespace</span></span><br><span class="line">    <span class="comment"># 将 Service 名称映射成标签</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_name</span>]</span><br><span class="line">      <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">kubernetes_name</span></span><br><span class="line">    <span class="comment"># 将 Pod 名称映射成标签</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_name</span>]</span><br><span class="line">      <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">kubernetes_pod_name</span></span><br></pre></td></tr></table></figure>



<p>注意我们这里在 <code>relabel_configs</code> 区域做了大量的配置，特别是第一个保留<code>__meta_kubernetes_service_annotation_prometheus_io_scrape</code> 为 true 的才保留下来，这就是说要想自动发现集群中的 Endpoint，就需要我们在 Service 的 <code>annotations</code> 区域添加 <code>prometheus.io/scrape=true</code> 的注解，我们也可以借助 <a target="_blank" rel="noopener" href="https://relabeler.promlabs.com/">https://relabeler.promlabs.com/</a> 这个工具来帮助我们配置 Relabel。现在我们先将上面的配置更新，查看下效果：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20211227150940.png" alt="prometheus k8s endpoints"></p>
<h2 id="自动发现-Service"><a href="#自动发现-Service" class="headerlink" title="自动发现 Service"></a>自动发现 Service</h2><p>我们可以看到 <code>endpoints</code> 这一个任务下面只发现了 5 个任务，这是因为我们在 <code>relabel_configs</code> 中过滤了 <code>annotations</code> 有 <code>prometheus.io/scrape=true</code> 的 Service，而现在我们系统中只有两个这样的服务符合要求，比如 <code>kube-dns</code> 这个 Service 下面有两个实例，所以出现了两个实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl get svc kube-dns -n kube-system -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/port: &quot;9153&quot;  # metrics 接口的端口</span><br><span class="line">    prometheus.io/scrape: &quot;true&quot;  # 这个注解可以让prometheus自动发现</span><br><span class="line">  creationTimestamp: &quot;2021-10-25T12:33:14Z&quot;</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    kubernetes.io/cluster-service: &quot;true&quot;</span><br><span class="line">    kubernetes.io/name: CoreDNS</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>现在我们在之前创建的 redis 这个 Service 中添加上 <code>prometheus.io/scrape=true</code> 这个注解：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-svc.yaml</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/scrape:</span> <span class="string">&#x27;true&#x27;</span> <span class="comment"># 让上面的自动发现能获取该服务</span></span><br><span class="line">    <span class="attr">prometheus.io/port:</span> <span class="string">&#x27;9121&#x27;</span> <span class="comment"># 指定metrics接口访问端口</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">6379</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prom</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9121</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9121</span></span><br></pre></td></tr></table></figure>

<p>由于 redis 服务的 metrics 接口在 9121 这个 <code>redis-exporter</code> 服务上面，所以我们还需要添加一个 <code>prometheus.io/port=9121</code> 这样的 annotations，然后更新这个 Service：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl apply -f https://p8s.io/docs/k8s/manifests/prometheus/redis-svc.yaml</span><br></pre></td></tr></table></figure>

<p>更新完成后，去 Prometheus 查看 Targets 路径，可以看到 redis 服务自动出现在了 <code>endpoints</code> 这个任务下面：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20211227151947.png" alt="prometheus k8s endpoints redis"></p>
<p>这样以后我们有了新的服务，如果服务本身提供了 <code>/metrics</code> 接口，我们就完全不需要用静态的方式去配置了，现在我们就可以将之前配置的 redis 静态配置去掉了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E7%9B%B4%E6%96%B9%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E7%9B%B4%E6%96%B9%E5%9B%BE/" class="post-title-link" itemprop="url">直方图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:20:23" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/Query-PromQL/" itemprop="url" rel="index"><span itemprop="name">Query PromQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h1><p>在这一节中，我们将学习直方图指标，了解如何根据这些指标来计算分位数。Prometheus 中的直方图指标允许一个服务记录一系列数值的分布。直方图通常用于跟踪<strong>请求的延迟或响应大小</strong>等指标值，当然理论上它是可以跟踪任何根据某种分布而产生波动数值的大小。Prometheus 直方图是在客户端对数据进行的采样，它们使用的一些可配置的（例如延迟）bucket 桶对观察到的值进行计数，然后将这些 bucket 作为单独的时间序列暴露出来。</p>
<p>下图是一个非累积直方图的例子：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/xcsmp6.png" alt="非累积直方图"></p>
<p>在 Prometheus 内部，直方图被实现为一组时间序列，每个序列代表指定桶的计数（例如<code>10ms以下的请求数</code>、<code>25ms以下的请求数</code>、<code>50ms以下的请求数</code>等）。 在 Prometheus 中每个 bucket 桶的计数器是累加的，这意味着较大值的桶也包括所有低数值的桶的计数。在作为直方图一部分的每个时间序列上，相应的桶由特殊的 <code>le</code> 标签表示。<code>le</code> 代表的是<strong>小于或等于</strong>。</p>
<p>与上面相同的直方图在 Prometheus 中的累积直方图如下所示：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/ii580b.png" alt="Prometheus 直方图"></p>
<p>可以看到在 Prometheus 中直方图的计数是累计的，这是很奇怪的，因为通常情况下非累积的直方图更容易理解。Prometheus 为什么要这么做呢？想象一下，如果直方图指标中加入了额外的标签，或者划分了更多的 bucket，那么样本数据的分析就会变得越来越复杂，如果直方图是累积的，在抓取指标时就可以根据需要丢弃某些 bucket，这样可以在降低 Prometheus 维护成本的同时，还可以粗略计算样本值的分位数。通过这种方法，用户不需要修改应用代码，便可以动态减少抓取到的样本数量。另外直方图还提供了 <code>_sum</code> 指标和 <code>_count</code> 指标，所以即使你丢弃了所有的 bucket，仍然可以通过这两个指标值来计算请求的平均响应时间。通过累积直方图的方式，还可以很轻松地计算某个 bucket 的样本数占所有样本数的比例。</p>
<p>我们在演示的 demo 服务中暴露了一个直方图指标 <code>demo_api_request_duration_seconds_bucket</code>，用于跟踪 API 请求时长的分布，由于这个直方图为每个跟踪的维度导出了 26 个 bucket，因此这个指标有很多时间序列。我们可以先来看下来自一个服务实例的一个请求维度组合的直方图，查询语句如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo_api_request_duration_seconds_bucket&#123;instance=&quot;demo-service-0:10000&quot;, method=&quot;POST&quot;, path=&quot;/api/bar&quot;, status=&quot;200&quot;, job=&quot;demo&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>正常我们可以看到 26 个序列，每个序列代表一个 bucket，由 <code>le</code> 标签标识：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/gctpxj.png" alt="26个序列"></p>
<p>直方图可以帮助我们了解这样的问题，比如<code>&quot;我有多少个请求超过了100ms的时间？&quot;</code> (当然需要直方图中配置了一个以 100ms 为边界的桶)，又比如<code>&quot;我99%的请求是在多少延迟下完成的？&quot;</code>，这类数值被称为<strong>百分位数</strong>或<strong>分位数</strong>。在 Prometheus 中这两个术语几乎是可以通用，只是百分位数指定在 0-100 范围内，而分位数表示在 0 和 1 之间，所以第 99 个百分位数相当于目标分位数 0.99。</p>
<p>如果你的直方图桶粒度足够小，那么我们可以使用 <code>histogram_quantile(φ scalar, b instant-vector)</code> 函数用于计算历史数据指标一段时间内的分位数。该函数将目标分位数 (<code>0 ≤ φ ≤ 1</code>) 和直方图指标作为输入，就是大家平时讲的 <code>pxx</code>，<code>p50</code> 就是中位数，参数 <code>b</code> 一定是包含 <code>le</code> 这个标签的瞬时向量，不包含就无从计算分位数了，但是计算的分位数是一个预估值，并不完全准确，因为这个函数是假定每个区间内的样本分布是线性分布来计算结果值的，预估的准确度取决于 bucket 区间划分的粒度，粒度越大，准确度越低。</p>
<p>回到我们的演示服务，我们可以尝试计算所有维度在所有时间内的第 90 个百分位数，也就是 90% 的请求的持续时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># BAD!</span><br><span class="line">histogram_quantile(0.9, demo_api_request_duration_seconds_bucket&#123;job=&quot;demo&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>但是这个查询方式是有一点问题的，当单个服务实例重新启动时，bucket 的 Counter 计数器会被重置，而且我们常常想看看<code>现在</code>的延迟是多少（比如在过去 5 分钟内），而不是整个时间内的指标。我们可以使用 <code>rate()</code> 函数应用于底层直方图计数器来实现这一点，该函数会自动处理 Counter 重置，又可以只计算每个桶在指定时间窗口内的平均增长。</p>
<p>我们可以这样去计算过去 5 分钟内第 90 个百分位数的 API 延迟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># GOOD!</span><br><span class="line">histogram_quantile(0.9, rate(demo_api_request_duration_seconds_bucket&#123;job=&quot;demo&quot;&#125;[5m]))</span><br></pre></td></tr></table></figure>

<p>这个查询就好很多了。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/gh5npf.png" alt="API 延迟"></p>
<p>这个查询会显示每个维度（job、instance、path、method 和 status）的第 90 个百分点，但是我们可能对单独的这些维度并不感兴趣，想把他们中的一些指标聚合起来，这个时候我们可以在查询的时候使用 Prometheus 的 <code>sum</code> 运算符与 <code>histogram_quantile()</code> 函数结合起来，计算出聚合的百分位，假设在我们想要聚合的维度之间，直方图桶的配置方式相同（桶的数量相同，上限相同），我们可以将不同维度之间具有相同 <code>le</code> 标签值的桶加在一起，得到一个聚合直方图。然后，我们可以使用该聚合直方图作为 <code>histogram_quantile()</code> 函数的输入。</p>
<blockquote>
<p>注意：这是假设直方图的桶在你要聚合的所有维度之间的配置是相同的，桶的配置也应该是相对静态的配置，不会一直变化，因为这会破坏你使用 <code>histogram_quantile()</code> 查看的时间范围内的结果。</p>
</blockquote>
<p>下面的查询计算了第 90 个百分位数的延迟，但只按 job、instance 和 path 维度进行聚合结果：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/dem2vz.png" alt="90百分位数"></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1.构建一个查询，计算在 0.0001 秒内完成的 demo 服务 API 请求的总百分比，与过去 5 分钟内所有请求总数的平均值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(rate(demo_api_request_duration_seconds_bucket&#123;le=&quot;0.0001&quot;&#125;[5m]))</span><br><span class="line">/</span><br><span class="line">sum(rate(demo_api_request_duration_seconds_bucket&#123;le=&quot;+Inf&quot;&#125;[5m])) * 100</span><br></pre></td></tr></table></figure>

<p>或者可以使用下面的语句查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(rate(demo_api_request_duration_seconds_bucket&#123;le=&quot;0.0001&quot;&#125;[5m]))</span><br><span class="line">/</span><br><span class="line"> sum(rate(demo_api_request_duration_seconds_count[5m])) * 100</span><br></pre></td></tr></table></figure>

<p>2.构建一个查询，计算 demo 服务 API 请求的第 50 个百分位延迟，按 status code 和 method 进行划分，在过去一分钟的平均值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_quantile(0.5, sum by(status, method, le) (rate(demo_api_request_duration_seconds_bucket[1m])))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">磁盘管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:10:46" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Manage/" itemprop="url" rel="index"><span itemprop="name">Manage</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Linux-系统中的磁盘管理"><a href="#Linux-系统中的磁盘管理" class="headerlink" title="Linux 系统中的磁盘管理"></a>Linux 系统中的磁盘管理</h3><hr>
<h3 id="一、查看磁盘分区信息"><a href="#一、查看磁盘分区信息" class="headerlink" title="一、查看磁盘分区信息"></a>一、查看磁盘分区信息</h3><p>在 Linux 系统中，有多种命令可以查看磁盘和分区的信息。</p>
<h4 id="1-lsblk：列出块设备信息（最常用、最直观）"><a href="#1-lsblk：列出块设备信息（最常用、最直观）" class="headerlink" title="1. lsblk：列出块设备信息（最常用、最直观）"></a>1. <code>lsblk</code>：列出块设备信息（最常用、最直观）</h4><p><code>lsblk</code> 命令以树状结构列出所有块设备（包括磁盘、分区、RAID设备、LVM逻辑卷等），清晰地展示了设备之间的层次关系。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>

<p><strong>示例输出及解释：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda           8:0   <span class="number"> 0 </span>  200G <span class="number"> 0 </span>disk </span><br><span class="line">├─sda1        8:1   <span class="number"> 0 </span>    1G <span class="number"> 0 </span>part /boot</span><br><span class="line">├─sda2        8:2   <span class="number"> 0 </span>    4G <span class="number"> 0 </span>part [SWAP]</span><br><span class="line">└─sda3        8:3   <span class="number"> 0 </span>195.9G <span class="number"> 0 </span>part </span><br><span class="line">  ├─vg01-root 253:0   <span class="number"> 0 </span>   50G <span class="number"> 0 </span>lvm  /</span><br><span class="line">  └─vg01-home 253:1   <span class="number"> 0 </span>145.9G <span class="number"> 0 </span>lvm  /home</span><br><span class="line">sdb           8:16  <span class="number"> 0 </span>    1T <span class="number"> 0 </span>disk </span><br><span class="line">└─sdb1        8:17  <span class="number"> 0 </span>    1T <span class="number"> 0 </span>part /mnt/data</span><br><span class="line">sr0          11:0   <span class="number"> 1 </span> 1024M <span class="number"> 0 </span>rom</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>NAME</code></strong>: 设备名称（如 <code>sda</code> 代表第一块SCSI&#x2F;SATA硬盘，<code>sda1</code> 代表 <code>sda</code> 上的第一个分区）。</li>
<li><strong><code>MAJ:MIN</code></strong>: 主设备号和次设备号。</li>
<li><strong><code>RM</code></strong>: 只读设备（1表示可移动设备如U盘）。</li>
<li><strong><code>SIZE</code></strong>: 设备大小。</li>
<li><strong><code>RO</code></strong>: 只读（1表示只读设备）。</li>
<li><strong><code>TYPE</code></strong>: 设备类型 (disk-磁盘, part-分区, lvm-LVM逻辑卷, rom-光驱)。</li>
<li><strong><code>MOUNTPOINT</code></strong>: 挂载点（如果已挂载）。</li>
</ul>
<p><strong>常用参数：</strong></p>
<ul>
<li><code>lsblk -f</code>: 显示文件系统类型（FSTYPE）、UUID等更详细的信息。</li>
<li><code>lsblk -p</code>: 显示完整的设备路径，如 <code>/dev/sda1</code>。</li>
</ul>
<h4 id="2-fdisk-l：列出磁盘分区表信息（传统方式）"><a href="#2-fdisk-l：列出磁盘分区表信息（传统方式）" class="headerlink" title="2. fdisk -l：列出磁盘分区表信息（传统方式）"></a>2. <code>fdisk -l</code>：列出磁盘分区表信息（传统方式）</h4><p><code>fdisk</code> 是一个强大的分区管理工具，<code>l</code> 参数用于列出所有磁盘的分区表信息。它通常用于MBR（Master Boot Record）分区表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fdisk -l</span><br></pre></td></tr></table></figure>

<p><strong>示例输出及解释：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sda:<span class="number"> 200 </span>GiB,<span class="number"> 214748364800 </span>bytes,<span class="number"> 419430400 </span>sectors</span><br><span class="line">Units: sectors of<span class="number"> 1 </span>*<span class="number"> 512 </span>=<span class="number"> 512 </span>bytes</span><br><span class="line">Sector size (logical/physical):<span class="number"> 512 </span>bytes /<span class="number"> 512 </span>bytes</span><br><span class="line">I/O size (minimum/optimal):<span class="number"> 512 </span>bytes /<span class="number"> 512 </span>bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 5F0B0661-3A26-4B8C-940B-B4109CD1B9C7</span><br><span class="line"></span><br><span class="line">Device     Start       End   Sectors  Size Type</span><br><span class="line">/dev/sda1  <span class="number"> 2048 </span> <span class="number"> 2099199 </span> <span class="number"> 2097152 </span>   1G Linux filesystem</span><br><span class="line">/dev/sda22099200  <span class="number"> 2099200 </span><span class="number"> 83886079 </span> 40G Linux swap</span><br><span class="line">/dev/sda3 <span class="number"> 419430400 </span>419430400 195.9G Linux LVM</span><br></pre></td></tr></table></figure>

<ul>
<li>显示每个磁盘的总容量、扇区大小、分区表类型（GPT&#x2F;MBR）等。</li>
<li>列出每个分区的设备名、起始&#x2F;结束扇区、大小和分区类型。</li>
<li><strong>注意：</strong> <code>fdisk</code> 主要处理 MBR 分区表。对于 GPT（GUID Partition Table）分区表，<code>gdisk</code> 是更推荐的工具，但 <code>fdisk -l</code> 也能显示 GPT 信息。</li>
</ul>
<h4 id="3-df-hT：查看已挂载的文件系统和它们的使用情况"><a href="#3-df-hT：查看已挂载的文件系统和它们的使用情况" class="headerlink" title="3. df -hT：查看已挂载的文件系统和它们的使用情况"></a>3. <code>df -hT</code>：查看已挂载的文件系统和它们的使用情况</h4><p><code>df</code> 命令用于报告文件系统磁盘空间的使用情况。<code>h</code> 表示以人类可读格式显示大小，<code>T</code> 表示显示文件系统类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -hT</span><br></pre></td></tr></table></figure>

<p><strong>示例输出及解释：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Filesystem                Type        Size  Used Avail Use% Mounted on</span><br><span class="line">udev                      devtmpfs    3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs                     tmpfs       797M  1.6M  795M   1% /run</span><br><span class="line">/dev/mapper/vg01-root     ext4         50G   15G   33G  32% /</span><br><span class="line">/dev/sda1                 ext4        976M  178M  732M  20% /boot</span><br><span class="line">/dev/mapper/vg01-home     ext4        141G   22G  112G  17% /home</span><br><span class="line">tmpfs                     tmpfs       3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs                     tmpfs       5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs                     tmpfs       3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sdb1                 xfs         1.0T  100G  900G  10% /mnt/data</span><br></pre></td></tr></table></figure>

<ul>
<li>显示文件系统（通常是分区或逻辑卷）、文件系统类型、总大小、已使用大小、可用大小、使用百分比和挂载点。</li>
<li><strong>关键点：</strong> <code>df</code> 只能显示<strong>已挂载</strong>的文件系统。对于未挂载的分区，你需要用 <code>lsblk</code> 或 <code>fdisk -l</code> 来查看。</li>
</ul>
<h4 id="4-blkid：查看块设备的-UUID、文件系统类型和LABEL"><a href="#4-blkid：查看块设备的-UUID、文件系统类型和LABEL" class="headerlink" title="4. blkid：查看块设备的 UUID、文件系统类型和LABEL"></a>4. <code>blkid</code>：查看块设备的 UUID、文件系统类型和LABEL</h4><p><code>blkid</code> 用于定位&#x2F;识别块设备的属性，如文件系统类型、UUID、VOLUMELABEL等。这在配置 <code>/etc/fstab</code> 或进行故障排查时非常有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> blkid</span><br></pre></td></tr></table></figure>

<p><strong>示例输出：</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda1: <span class="attribute">UUID</span>=<span class="string">&quot;a1b2c3d4-e5f6-7890-1234-567890abcdef&quot;</span> <span class="attribute">TYPE</span>=<span class="string">&quot;ext4&quot;</span> <span class="attribute">PARTUUID</span>=<span class="string">&quot;1234...&quot;</span></span><br><span class="line">/dev/sda2: <span class="attribute">UUID</span>=<span class="string">&quot;f0e9d8c7-b6a5-4321-fedc-ba9876543210&quot;</span> <span class="attribute">TYPE</span>=<span class="string">&quot;swap&quot;</span> <span class="attribute">PARTUUID</span>=<span class="string">&quot;5678...&quot;</span></span><br><span class="line">/dev/sda3: <span class="attribute">UUID</span>=<span class="string">&quot;1A2B3C4D-5E6F-7G8H-9I0J-KLMNOPQRSTUV&quot;</span> <span class="attribute">TYPE</span>=<span class="string">&quot;LVM2_member&quot;</span> <span class="attribute">PARTUUID</span>=<span class="string">&quot;9012...&quot;</span></span><br><span class="line">/dev/mapper/vg01-root: <span class="attribute">UUID</span>=<span class="string">&quot;ABCDEF01-2345-6789-ABCD-EF0123456789&quot;</span> <span class="attribute">TYPE</span>=<span class="string">&quot;ext4&quot;</span></span><br><span class="line">/dev/mapper/vg01-home: <span class="attribute">UUID</span>=<span class="string">&quot;QRSTUVWXYZ01-2345-6789-ABCD-EF0123456789&quot;</span> <span class="attribute">TYPE</span>=<span class="string">&quot;ext4&quot;</span></span><br><span class="line">/dev/sdb1: <span class="attribute">UUID</span>=<span class="string">&quot;12345678-ABCD-EFAB-CDEF-1234567890AB&quot;</span> <span class="attribute">TYPE</span>=<span class="string">&quot;xfs&quot;</span> <span class="attribute">LABEL</span>=<span class="string">&quot;data_disk&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通常在 <code>/etc/fstab</code> 中使用 <code>UUID</code> 来挂载分区，因为 <code>UUID</code> 是分区独一无二的标识符，即使设备名改变（例如，<code>/dev/sda</code> 变成了 <code>/dev/sdb</code>），系统也能正确找到并挂载分区。</li>
</ul>
<hr>
<h3 id="二、管理磁盘分区"><a href="#二、管理磁盘分区" class="headerlink" title="二、管理磁盘分区"></a>二、管理磁盘分区</h3><p>磁盘分区管理通常涉及：创建&#x2F;删除分区、格式化分区（创建文件系统）、挂载&#x2F;卸载分区。</p>
<p><strong>警告：</strong> 磁盘分区操作是危险的，<strong>务必提前备份重要数据！</strong> 任何误操作都可能导致数据丢失或系统无法启动。</p>
<h4 id="1-创建-删除-修改分区-fdisk-gdisk-parted"><a href="#1-创建-删除-修改分区-fdisk-gdisk-parted" class="headerlink" title="1. 创建&#x2F;删除&#x2F;修改分区 (fdisk&#x2F;gdisk&#x2F;parted)"></a>1. 创建&#x2F;删除&#x2F;修改分区 (<code>fdisk</code>&#x2F;<code>gdisk</code>&#x2F;<code>parted</code>)</h4><ul>
<li><p><strong><code>fdisk</code>：</strong> 最常用于 MBR 分区表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fdisk /dev/sdb <span class="comment"># 操作 /dev/sdb 硬盘</span></span><br></pre></td></tr></table></figure>
<p>进入 <code>fdisk</code> 交互模式后：</p>
<ul>
<li><code>m</code>: 显示帮助菜单。</li>
<li><code>p</code>: 打印当前分区表。</li>
<li><code>n</code>: 新建分区。</li>
<li><code>d</code>: 删除分区。</li>
<li><code>w</code>: 写入分区表并退出。</li>
<li><code>q</code>: 不保存更改退出。</li>
</ul>
</li>
<li><p><strong><code>gdisk</code>：</strong> 专门用于 GPT 分区表，用法和 <code>fdisk</code> 类似。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gdisk /dev/sdb</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>parted</code>：</strong> 更现代、更强大的分区工具，支持 MBR 和 GPT，也支持非交互模式操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> parted /dev/sdb</span><br><span class="line"><span class="comment"># 进入交互模式</span></span><br><span class="line">(parted) <span class="built_in">print</span>          <span class="comment"># 查看分区</span></span><br><span class="line">(parted) mklabel gpt/msdos <span class="comment"># 设置分区表类型 (gpt 或 msdos/mbr)</span></span><br><span class="line">(parted) mkpart primary ext4 0% 100% <span class="comment"># 创建一个 ext4 类型的分区，从0%到100%</span></span><br><span class="line">(parted) <span class="built_in">rm</span> 1           <span class="comment"># 删除第一个分区</span></span><br><span class="line">(parted) quit           <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 创建分区后，需要运行 <code>partprobe</code> 或者重启系统，使内核识别新的分区表。</p>
</li>
</ul>
<h4 id="2-格式化分区（创建文件系统）"><a href="#2-格式化分区（创建文件系统）" class="headerlink" title="2. 格式化分区（创建文件系统）"></a>2. 格式化分区（创建文件系统）</h4><p>创建分区后，需要对其进行格式化才能存储数据。常用的文件系统有 Ext4、XFS、NTFS 等。</p>
<ul>
<li><p><strong>Ext4 (Linux 常用):</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkfs.ext4 /dev/sdb1 <span class="comment"># 格式化 /dev/sdb1 分区为 Ext4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>XFS (高性能，大型存储常用):</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkfs.xfs /dev/sdb1 <span class="comment"># 格式化 /dev/sdb1 分区为 XFS</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>NTFS (与 Windows 兼容):</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkfs.ntfs /dev/sdb1 <span class="comment"># 格式化 /dev/sdb1 分区为 NTFS (可能需要安装 ntfs-3g 工具)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-挂载-卸载分区"><a href="#3-挂载-卸载分区" class="headerlink" title="3. 挂载&#x2F;卸载分区"></a>3. 挂载&#x2F;卸载分区</h4><p>格式化后的分区必须挂载到文件系统中的某个目录才能访问。</p>
<ul>
<li><p><strong>创建挂载点：</strong> 挂载点是一个空目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /mnt/data</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>临时挂载：</strong> 仅在当前会话有效，重启后失效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount /dev/sdb1 /mnt/data</span><br></pre></td></tr></table></figure>
<p>验证是否挂载成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -hT /mnt/data</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>永久挂载（通过 <code>/etc/fstab</code>）：</strong> 推荐方式，系统启动时自动挂载。</p>
<ol>
<li><p><strong>获取分区的 UUID：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> blkid /dev/sdb1</span><br><span class="line"><span class="comment"># 假设输出为：/dev/sdb1: UUID=&quot;12345678-ABCD-EFAB-CDEF-1234567890AB&quot; TYPE=&quot;xfs&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>编辑 <code>/etc/fstab</code> 文件：</strong> 使用 <code>sudo vim /etc/fstab</code> 打开文件。<br>在文件末尾添加一行，格式为：<br><code>UUID=&lt;分区UUID&gt; &lt;挂载点&gt; &lt;文件系统类型&gt; &lt;挂载选项&gt; &lt;dump&gt; &lt;pass&gt;</code></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加到 /etc/fstab</span></span><br><span class="line"><span class="attribute">UUID</span>=<span class="number">12345678</span>-ABCD-EFAB-CDEF-<span class="number">1234567890</span>AB /mnt/data xfs defaults <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><code>UUID=...</code>: 使用 UUID 来标识分区，这样更稳健。</li>
<li><code>/mnt/data</code>: 挂载点目录。</li>
<li><code>xfs</code>: 文件系统类型。</li>
<li><code>defaults</code>: 标准挂载选项（rw, suid, dev, exec, auto, nouser, async）。</li>
<li><code>0</code>: <code>dump</code> 程序是否备份文件系统，0 表示不备份。</li>
<li><code>0</code>: <code>fsck</code> 检查顺序，0 表示不检查。对于非根文件系统，通常设为 0。</li>
</ul>
</li>
<li><p><strong>测试 <code>/etc/fstab</code> 配置：</strong><br>在不重启系统的情况下，可以使用 <code>mount -a</code> 命令来检查 <code>fstab</code> 配置是否有错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount -a</span><br></pre></td></tr></table></figure>
<p>如果命令没有任何输出，并且没有错误提示，说明配置是正确的。然后再次用 <code>df -hT</code> 确认。</p>
</li>
</ol>
</li>
<li><p><strong>卸载分区：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> umount /mnt/data</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">sudo</span> umount /dev/sdb1</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 卸载时，确保没有进程正在使用该分区上的文件或目录。否则会提示“target is busy”错误。可以使用 <code>lsof /mnt/data</code> 查找占用文件的进程，然后终止它们。</p>
</li>
</ul>
<hr>
<h3 id="三、LVM-Logical-Volume-Manager-逻辑卷管理（高级管理）"><a href="#三、LVM-Logical-Volume-Manager-逻辑卷管理（高级管理）" class="headerlink" title="三、LVM (Logical Volume Manager) 逻辑卷管理（高级管理）"></a>三、LVM (Logical Volume Manager) 逻辑卷管理（高级管理）</h3><p>对于更灵活和动态的磁盘管理，LVM 是一个强大的工具。它允许你将多个物理硬盘或分区组合成一个大的存储池，然后从中创建逻辑卷，可以根据需要调整大小。</p>
<p><strong>基本步骤：</strong></p>
<ol>
<li><strong>创建 PV (Physical Volume - 物理卷)：</strong> 将物理硬盘或分区初始化为 LVM 物理卷。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pvcreate /dev/sdb1 /dev/sdc1</span><br></pre></td></tr></table></figure></li>
<li><strong>创建 VG (Volume Group - 卷组)：</strong> 将一个或多个 PV 组合成一个 VG。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vgcreate my_vg /dev/sdb1 /dev/sdc1</span><br></pre></td></tr></table></figure></li>
<li><strong>创建 LV (Logical Volume - 逻辑卷)：</strong> 从 VG 中划分出 LV，LV 就像一个普通分区。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lvcreate -L 100G -n my_data_lv my_vg</span><br></pre></td></tr></table></figure></li>
<li><strong>格式化 LV：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkfs.ext4 /dev/mapper/my_vg-my_data_lv</span><br></pre></td></tr></table></figure></li>
<li><strong>挂载 LV：</strong> (与普通分区挂载类似)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /mnt/data_lv</span><br><span class="line"><span class="built_in">sudo</span> mount /dev/mapper/my_vg-my_data_lv /mnt/data_lv</span><br></pre></td></tr></table></figure>
并添加到 <code>fstab</code>：<br><code>UUID=&lt;LV的UUID&gt; /mnt/data_lv ext4 defaults 0 0</code></li>
</ol>
<p><strong>LVM 的优势：</strong></p>
<ul>
<li><strong>灵活性：</strong> 运行时可以动态调整逻辑卷的大小 (缩小或扩展)。</li>
<li><strong>聚合：</strong> 可以将多个小磁盘聚合成一个大存储池。</li>
<li><strong>快照：</strong> 支持创建文件系统快照。</li>
</ul>
<hr>
<p>掌握这些命令和概念，您就能有效地在 Linux 系统中查看和管理磁盘分区，满足日常运维需求。在进行任何分区更改之前，请务必做好备份并谨慎操作！</p>
<h3 id="磁盘配额（Disk-Quotas）管理"><a href="#磁盘配额（Disk-Quotas）管理" class="headerlink" title="磁盘配额（Disk Quotas）管理"></a>磁盘配额（Disk Quotas）管理</h3><hr>
<h3 id="一、什么是磁盘配额-Disk-Quotas-？"><a href="#一、什么是磁盘配额-Disk-Quotas-？" class="headerlink" title="一、什么是磁盘配额 (Disk Quotas)？"></a>一、什么是磁盘配额 (Disk Quotas)？</h3><p>磁盘配额是 Linux 内核提供的一项功能，它允许系统管理员为文件系统上的<strong>用户</strong>或<strong>组</strong>设定限制，包括：</p>
<ol>
<li><p>**块限制 (Block Quota)**：限制用户或组可以使用的磁盘空间总量（以数据块为单位）。</p>
<ul>
<li>**软限制 (Soft Limit)**：一个警告阈值。当用户或组达到此限制时，系统会发出警告，但仍允许其在一段宽限期（Grace Period）内继续写入。</li>
<li>**硬限制 (Hard Limit)**：一个绝对限制。一旦达到此限制，用户或组无法再写入任何新的数据或创建新文件，即使在宽限期内。</li>
</ul>
</li>
<li><p>**文件限制 (Inode Quota)**：限制用户或组可以创建的文件或目录的数量（以 inode 数量为单位）。</p>
<ul>
<li>同样有软限制和硬限制。inode 数量限制可以防止用户通过创建大量小文件来耗尽文件系统中的 inode 资源，即使其磁盘空间使用量不大。</li>
</ul>
</li>
</ol>
<p><strong>主要目的：</strong></p>
<ul>
<li><strong>资源公平分配：</strong> 确保每个用户或服务获得公平的存储资源。</li>
<li><strong>防止滥用：</strong> 阻止单个用户或进程无限制地使用存储，从而影响其他用户或整个系统。</li>
<li><strong>系统稳定性：</strong> 避免磁盘空间耗尽导致系统崩溃或服务中断。</li>
</ul>
<hr>
<h3 id="二、磁盘配额管理步骤"><a href="#二、磁盘配额管理步骤" class="headerlink" title="二、磁盘配额管理步骤"></a>二、磁盘配额管理步骤</h3><p>在 Linux 系统中进行磁盘配额管理通常涉及以下几个步骤：</p>
<h4 id="1-检查内核和文件系统支持"><a href="#1-检查内核和文件系统支持" class="headerlink" title="1. 检查内核和文件系统支持"></a>1. 检查内核和文件系统支持</h4><ul>
<li>大多数现代 Linux 内核都支持配额。</li>
<li>配额功能通常需要文件系统（如 ext4, XFS, Btrfs）的支持。常见的文件系统如 ext4 和 XFS 对配额有很好的支持。</li>
</ul>
<h4 id="2-修改-etc-fstab-配置，启用配额选项"><a href="#2-修改-etc-fstab-配置，启用配额选项" class="headerlink" title="2. 修改 /etc/fstab 配置，启用配额选项"></a>2. 修改 <code>/etc/fstab</code> 配置，启用配额选项</h4><p>这一步是告诉系统在挂载文件系统时启用配额功能。</p>
<ul>
<li><p><strong>编辑 <code>/etc/fstab</code> 文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/fstab</span><br></pre></td></tr></table></figure></li>
<li><p><strong>找到要启用配额的文件系统行</strong>（例如 <code>/home</code> 或 <code>/var/www</code>），在挂载选项中添加 <code>usrquota</code> (用户配额) 或 <code>grpquota</code> (组配额)，或两者都加。<br><strong>示例：</strong><br>假设原始 <code>/home</code> 的 fstab 行是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda2   /home   ext4    defaults        0 2</span><br></pre></td></tr></table></figure>
<p>修改为启用用户和组配额：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda2   /home   ext4    defaults,usrquota,grpquota      0 2</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>XFS 文件系统的选项有所不同：</strong> XFS 的配额功能是其文件系统内置的，通常只需要在挂载时指定 <code>prjquota</code> (项目配额), <code>usrquota</code> 或 <code>grpquota</code> 即可。对于 XFS，通常推荐使用 <code>pquota</code> (项目配额) 或直接默认启用而不需额外参数，因为 XFS 在挂载时就已经能处理配额。但是为了明确，添加 <code>usrquota,grpquota</code> 也是可行的。<br>例如： <code>defaults,usrquota,grpquota</code><br>或者，XFS 通常只需在文件系统创建时或事后通过 <code>xfs_quota</code> 命令启用。</li>
</ul>
</li>
<li><p><strong>重新挂载文件系统</strong>（或重启系统）：<br><strong>重要：</strong> 重新挂载是必要的，除非你重启系统。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount -o remount /home</span><br></pre></td></tr></table></figure>
<p>如果遇到报错，尝试先卸载再挂载（但要确保 <code>/home</code> 目录当前没有被进程使用）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> umount /home</span><br><span class="line"><span class="built_in">sudo</span> mount /home</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-安装并初始化配额工具"><a href="#3-安装并初始化配额工具" class="headerlink" title="3. 安装并初始化配额工具"></a>3. 安装并初始化配额工具</h4><ul>
<li><strong>安装 <code>quota</code> 工具包：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For RHEL/CentOS/Fedora:</span></span><br><span class="line"><span class="built_in">sudo</span> yum install quota</span><br><span class="line"><span class="comment"># Or for newer versions:</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install quota</span><br><span class="line"></span><br><span class="line"><span class="comment"># For Debian/Ubuntu:</span></span><br><span class="line"><span class="built_in">sudo</span> apt install quota</span><br></pre></td></tr></table></figure></li>
<li><strong>生成配额文件：</strong> 在文件系统根目录下（例如 <code>/home</code>）生成 <code>aquota.user</code> (用户配额文件) 和 <code>aquota.group</code> (组配额文件)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> quotacheck -cumg /home</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-c</code>: 创建新的配额文件（如果不存在）。</li>
<li><code>-u</code>: 扫描并记录用户配额使用情况。</li>
<li><code>-g</code>: 扫描并记录组配额使用情况。</li>
<li><code>-m</code>: 在线模式，当文件系统仍挂载时执行，但可能不如离线模式精确。</li>
<li><strong>XFS 文件系统不需要这一步</strong>，XFS 的配额信息存储在文件系统元数据中。</li>
</ul>
</li>
</ul>
<h4 id="4-启用配额"><a href="#4-启用配额" class="headerlink" title="4. 启用配额"></a>4. 启用配额</h4><ul>
<li><p><strong>启用指定文件系统的配额：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> quotaon -ug /home</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-u</code>: 启用用户配额。</li>
<li><code>-g</code>: 启用组配额。</li>
</ul>
</li>
<li><p><strong>系统启动时自动启用：</strong> 如果你修改了 <code>/etc/fstab</code>，并在其中添加了 <code>usrquota,grpquota</code> 选项，那么系统下次启动时会自动启用配额。</p>
</li>
</ul>
<h4 id="5-设置用户和组的配额限制"><a href="#5-设置用户和组的配额限制" class="headerlink" title="5. 设置用户和组的配额限制"></a>5. 设置用户和组的配额限制</h4><p>这是核心步骤，设定具体的磁盘空间和文件数量限制。</p>
<ul>
<li><p><strong>设置用户配额 (<code>edquota -u &lt;username&gt;</code>)：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> edquota -u testuser</span><br></pre></td></tr></table></figure>
<p>这会打开一个文本编辑器（通常是 <code>vi</code>），显示该用户在配置了配额的文件系统上的当前配额信息，例如：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disk quotas for user testuser (uid 1001):</span><br><span class="line">  Filesystem               blocks       soft      hard     inodes     soft     hard</span><br><span class="line">  /dev/sda2                 <span class="number"> 48 </span>       <span class="number"> 0 </span>       <span class="number"> 0 </span>        <span class="number"> 11 </span>      <span class="number"> 0 </span>       0</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>blocks</code></strong>: 用户当前已使用的磁盘块数量。</li>
<li><strong><code>soft</code></strong>: 软限制（块）。如果达到此值，用户会收到警告。</li>
<li><strong><code>hard</code></strong>: 硬限制（块）。如果达到此值，用户将无法写入。</li>
<li><strong><code>inodes</code></strong>: 用户当前已创建的文件数量 (inode)。</li>
<li><strong><code>soft</code></strong>: 软限制（inode）。</li>
<li><strong><code>hard</code></strong>: 硬限制（inode）。</li>
</ul>
<p>修改 <code>soft</code> 和 <code>hard</code> 字段来设置限制。例如，将用户 <code>testuser</code> 在 <code>/dev/sda2</code> 上的块软限制设置为 100MB (<code>102400</code> 块，假设块大小为 1KB)，硬限制设置为 120MB (<code>122880</code> 块)，文件数量软限制 10000，硬限制 12000：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disk quotas for user testuser (uid 1001):</span><br><span class="line">  Filesystem               blocks       soft      hard     inodes     soft     hard</span><br><span class="line">  /dev/sda2                 <span class="number"> 48 </span>   <span class="number"> 102400 </span>  <span class="number"> 122880 </span>        <span class="number"> 11 </span>  <span class="number"> 10000 </span>   12000</span><br></pre></td></tr></table></figure>
<p>保存并退出。</p>
</li>
<li><p><strong>设置组配额 (<code>edquota -g &lt;groupname&gt;</code>)：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> edquota -g webdevs</span><br></pre></td></tr></table></figure>
<p>用法与用户配额类似。</p>
</li>
<li><p><strong>复制用户配额到其他用户 (<code>edquota -p &lt;source_user&gt; &lt;target_user&gt;</code>)：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> edquota -p testuser newuser1 newuser2</span><br></pre></td></tr></table></figure>
<p>这将把 <code>testuser</code> 的配额设置复制给 <code>newuser1</code> 和 <code>newuser2</code>。</p>
</li>
</ul>
<h4 id="6-设置宽限期-Grace-Periods"><a href="#6-设置宽限期-Grace-Periods" class="headerlink" title="6. 设置宽限期 (Grace Periods)"></a>6. 设置宽限期 (Grace Periods)</h4><p>宽限期是用户达到软限制后，在硬限制生效之前可以继续写入的时间。</p>
<ul>
<li><p><strong>编辑宽限期：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> edquota -t</span><br></pre></td></tr></table></figure>
<p>这会打开编辑器，显示块和 inode 的宽限期设置：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Grace period before enforcing soft limits for use<span class="symbol">rs:</span></span><br><span class="line"><span class="built_in">Time</span> units may <span class="symbol">be:</span> <span class="built_in">days</span>, hours, minutes, seconds</span><br><span class="line">  Filesystem             Block grace period       Inode grace period</span><br><span class="line">  /dev/sda2                     <span class="number">7</span><span class="built_in">days</span>                    <span class="number">7</span><span class="built_in">days</span></span><br></pre></td></tr></table></figure>
<p>修改这些值，例如将宽限期设置为 5 天：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Grace period before enforcing soft limits for use<span class="symbol">rs:</span></span><br><span class="line"><span class="built_in">Time</span> units may <span class="symbol">be:</span> <span class="built_in">days</span>, hours, minutes, seconds</span><br><span class="line">  Filesystem             Block grace period       Inode grace period</span><br><span class="line">  /dev/sda2                     <span class="number">5</span><span class="built_in">days</span>                    <span class="number">5</span><span class="built_in">days</span></span><br></pre></td></tr></table></figure>
<p>保存并退出。</p>
</li>
</ul>
<h4 id="7-查看配额使用情况"><a href="#7-查看配额使用情况" class="headerlink" title="7. 查看配额使用情况"></a>7. 查看配额使用情况</h4><ul>
<li><p><strong>查看所有用户或组的配额报告：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> repquota -ugs /home</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-u</code>: 显示用户配额。</li>
<li><code>-g</code>: 显示组配额。</li>
<li><code>-s</code>: 显示概要信息 (summary)，包括宽限期。</li>
</ul>
<p>输出示例：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** <span class="keyword">Report</span> <span class="keyword">for</span> user quotas <span class="keyword">on</span> /home (/dev/sda2)</span><br><span class="line"><span class="keyword">Block</span> grace <span class="built_in">time</span>: <span class="number">7</span>days, Inode grace <span class="built_in">time</span>: <span class="number">7</span>days</span><br><span class="line">                                  <span class="keyword">Block</span> limits                    <span class="keyword">File</span> limits</span><br><span class="line">User            used    soft    hard  grace    used  soft  hard  grace</span><br><span class="line"><span class="comment">----------   ------------------------------------   ---------------------------</span></span><br><span class="line">root      <span class="comment">--    44       0       0      /     11     0     0      /</span></span><br><span class="line">testuser  <span class="comment">--    48  102400  122880      /     11 10000 12000      /</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>--</code>：表示未达到软限制。</li>
<li><code>+</code>：表示已达到软限制，正在使用宽限期。</li>
<li><code>-</code>：表示已达到硬限制。</li>
<li><code>grace</code>: 显示剩余的宽限期时间，或者 <code>/</code> 表示无宽限期。</li>
</ul>
</li>
<li><p><strong>查看特定用户或组的配额使用情况：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quota -u testuser</span><br><span class="line">quota -g webdevs</span><br></pre></td></tr></table></figure>
<p>普通用户也可以使用 <code>quota</code> 命令查看自己的配额信息 (无需 <code>sudo</code>)。</p>
</li>
</ul>
<hr>
<h3 id="四、XFS-文件系统的配额管理"><a href="#四、XFS-文件系统的配额管理" class="headerlink" title="四、XFS 文件系统的配额管理"></a>四、XFS 文件系统的配额管理</h3><p>XFS 文件系统有自己特殊的配额管理工具 <code>xfs_quota</code>，其管理方式集成在文件系统内部，不需要 <code>quotacheck</code> 和 <code>aquota.*</code> 文件。</p>
<ul>
<li><p><strong>启用 XFS 文件系统配额：</strong></p>
<ul>
<li>通常在 <code>/etc/fstab</code> 中添加 <code>usrquota,grpquota</code> 即可。</li>
<li>也可以使用 <code>xfs_quota -x -c &#39;quota -u on&#39;</code> 在线启用。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> xfs_quota -x -c <span class="string">&#x27;quota -u on&#x27;</span> /home</span><br><span class="line"><span class="built_in">sudo</span> xfs_quota -x -c <span class="string">&#x27;quota -g on&#x27;</span> /home</span><br></pre></td></tr></table></figure>
<code>-x</code> 启用专家模式，<code>-c</code> 执行命令。</li>
</ul>
</li>
<li><p><strong>设置 XFS 配额：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> xfs_quota -x -c <span class="string">&#x27;limit bsoft=100m bhard=120m isoft=10000 ihard=12000 testuser&#x27;</span> /home</span><br><span class="line"><span class="comment"># bsoft/bhard: 块软/硬限制</span></span><br><span class="line"><span class="comment"># isoft/ihard: inode 软/硬限制</span></span><br></pre></td></tr></table></figure>
<p>对于组也是类似：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> xfs_quota -x -c <span class="string">&#x27;limit -g bsoft=1G bhard=1.2G webdevs&#x27;</span> /home</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看 XFS 配额报告：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> xfs_quota -x -c <span class="string">&#x27;report -hugi&#x27;</span> /home</span><br><span class="line"><span class="comment"># -h: 人类可读</span></span><br><span class="line"><span class="comment"># -u: 用户</span></span><br><span class="line"><span class="comment"># -g: 组</span></span><br><span class="line"><span class="comment"># -i: inode</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置 XFS 宽限期：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> xfs_quota -x -c <span class="string">&#x27;timer -b 7d&#x27;</span> /home <span class="comment"># 块宽限期 7 天</span></span><br><span class="line"><span class="built_in">sudo</span> xfs_quota -x -c <span class="string">&#x27;timer -i 7d&#x27;</span> /home <span class="comment"># inode 宽限期 7 天</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="五、注意事项与运维实践"><a href="#五、注意事项与运维实践" class="headerlink" title="五、注意事项与运维实践"></a>五、注意事项与运维实践</h3><ul>
<li><strong>文件系统选择：</strong> 新的部署推荐使用 XFS 文件系统，因为它在大型文件系统和并发访问方面表现更好，且配额管理更集成。对于 ext4，<code>quota</code> 工具依然成熟可靠。</li>
<li><strong>根目录 (<code>/</code>) 配额：</strong> 不建议在根目录下设置配额，因为这可能导致系统服务写入失败，引发严重问题。通常在用户数据目录（如 <code>/home</code>）或特定应用数据目录上设置配额。</li>
<li><strong>监控：</strong> 定期检查磁盘使用情况和配额状态。当有用户接近其配额限制时，应考虑向其发送通知或采取其他措施。脚本可以定时运行 <code>repquota</code> 或 <code>xfs_quota</code> 并解析输出以进行告警。</li>
<li><strong>测试：</strong> 在生产环境部署前，务必在测试环境中充分测试配额设置，确保其按预期工作，不会意外地阻止合法操作。</li>
<li><strong>用户教育：</strong> 告知用户配额的存在，以及当他们达到软限制时应如何处理（清理文件，或申请更高的配额）。</li>
<li><strong>日志：</strong> 用户的配额违规行为通常会记录在系统日志中 (<code>/var/log/messages</code> 或 <code>journalctl</code>)，可以利用这些日志进行审计。</li>
</ul>
<p>磁盘配额是 Linux 服务器管理中保护存储资源的重要手段。通过细致的规划和配置，可以有效提升系统的健壮性和资源的公平性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/" class="post-title-link" itemprop="url">类型断言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:14:44" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>结论：Go语言在使用类型断言时，通常不会发生值的拷贝，而是基于接口类型底层的数据表示进行类型检查和值的提取。但需要注意的是，这取决于被断言的变量的实际类型和其在接口中的存储方式。</strong></p>
<p>让我们分情况详细讨论：</p>
<h3 id="Go接口的底层结构"><a href="#Go接口的底层结构" class="headerlink" title="Go接口的底层结构"></a>Go接口的底层结构</h3><p>首先，理解Go语言接口的底层结构是理解断言行为的关键。Go语言的接口有两种形式：</p>
<ol>
<li>**空接口 (<code>interface&#123;&#125;</code>)**：可以存储任何类型的值。</li>
<li>**非空接口 (<code>interface S</code>)**：存储实现了接口 <code>S</code> 的任意类型的值。</li>
</ol>
<p>无论哪种，接口变量在内存中通常由两部分组成：</p>
<ul>
<li><strong>类型（Type）信息</strong>：一个指向实际值类型的指针。</li>
<li><strong>值（Value）信息</strong>：一个指向实际值的指针，或者如果值很小（如基本类型、小结构体、指针），它可能直接存储值本身。</li>
</ul>
<h3 id="类型断言的机制"><a href="#类型断言的机制" class="headerlink" title="类型断言的机制"></a>类型断言的机制</h3><p>类型断言的语法是 <code>value, ok := i.(Type)</code> 或 <code>value := i.(Type)</code> (不检查 <code>ok</code>)。</p>
<p>当进行类型断言时，Go运行时会执行以下操作：</p>
<ol>
<li><strong>检查类型信息</strong>：比较接口变量中存储的类型信息是否与断言的 <code>Type</code> 匹配。</li>
<li><strong>提取值</strong>：如果类型匹配，则从接口变量中提取出实际的值。</li>
</ol>
<h3 id="断言时是否发生拷贝的两种主要情况："><a href="#断言时是否发生拷贝的两种主要情况：" class="headerlink" title="断言时是否发生拷贝的两种主要情况："></a>断言时是否发生拷贝的两种主要情况：</h3><h4 id="情况一：非指针类型值赋给接口（最常见）"><a href="#情况一：非指针类型值赋给接口（最常见）" class="headerlink" title="情况一：非指针类型值赋给接口（最常见）"></a>情况一：非指针类型值赋给接口（最常见）</h4><p>当一个非指针类型的值（如 <code>int</code>, <code>string</code>, <code>struct</code> 等）赋给接口时，<strong>Go语言会在接口内部存储一个该值的拷贝</strong>。然而，这个拷贝发生在<strong>赋值给接口时</strong>，而不是在进行<strong>类型断言时</strong>。</p>
<p>举例解释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := MyStruct&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;Original&quot;</span>&#125; <span class="comment">// 原始结构体 s</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1. 将 MyStruct s 赋值给接口 i</span></span><br><span class="line">	<span class="comment">// 此时，MyStruct 的值会被拷贝一份并存储在接口 i 的&quot;值&quot;部分</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = s </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 尝试修改原始结构体 s 的字段</span></span><br><span class="line">	s.Name = <span class="string">&quot;Modified Original&quot;</span> </span><br><span class="line">	fmt.Printf(<span class="string">&quot;Original s: %+v, Address: %p\n&quot;</span>, s, &amp;s) <span class="comment">// Output: Modified Original, Address: 0xc000010200 (示例地址)</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2. 进行类型断言</span></span><br><span class="line">	<span class="comment">// 此时，i.(MyStruct) 会直接从接口 i 的&quot;值&quot;部分取出那个拷贝，</span></span><br><span class="line">	<span class="comment">// 而不是对原始的 s 进行拷贝</span></span><br><span class="line">	<span class="comment">// 这个操作通常是非拷贝的，它只是提供一个视图或返回内部存储的副本</span></span><br><span class="line">	sAsserted, ok := i.(MyStruct) </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Asserted s: %+v, Address: %p\n&quot;</span>, sAsserted, &amp;sAsserted) <span class="comment">// Output: Original, Address: 0xc000010210 (示例地址，与s不同)</span></span><br><span class="line">		<span class="comment">// 注意 sAsserted 的 Name 仍然是 &quot;Original&quot;</span></span><br><span class="line">		<span class="comment">// 它的地址也与原始 s 的地址不同</span></span><br><span class="line">		<span class="comment">// 这是因为接口 i 中存储的是 s 赋值时的那个拷贝</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>当 <code>s</code> 赋值给 <code>i</code> (<code>var i interface&#123;&#125; = s</code>) 时， <code>s</code> 的一个<strong>副本</strong>被存储在了 <code>i</code> 内部。</li>
<li>当我们修改原始 <code>s</code> 的 <code>Name</code> 字段时，并不会影响到接口 <code>i</code> 中存储的那个副本。</li>
<li>进行 <code>sAsserted, ok := i.(MyStruct)</code> 断言时，<code>sAsserted</code> 获取的就是接口 <code>i</code> 内部存储的那个副本。<strong>这个获取过程本身，通常不是一次新的拷贝，而是直接返回接口内部值的副本。</strong> 如果值是小的，例如 <code>int</code>，它可能直接嵌入在接口数据结构中；如果是大的结构体，它会是指向堆上拷贝的这个结构体的指针。但无论如何，最终你得到的 <code>sAsserted</code> 和原始 <code>s</code> 是两个独立的内存空间。</li>
</ul>
<p><strong>关键点：拷贝发生在值赋给接口时，而不是断言时。断言只是从接口内部取出已经存在的（可能是拷贝的）值。</strong></p>
<h4 id="情况二：指针类型值赋给接口"><a href="#情况二：指针类型值赋给接口" class="headerlink" title="情况二：指针类型值赋给接口"></a>情况二：指针类型值赋给接口</h4><p>当一个指针类型的值（如 <code>*int</code>, <code>*string</code>, <code>*MyStruct</code> 等）赋给接口时，接口内部存储的是这个<strong>指针本身的拷贝</strong>。由于指针本身就是一个地址，拷贝一个地址的开销非常小，并且两个指针都指向<strong>同一个底层数据</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := MyStruct&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;Original&quot;</span>&#125; <span class="comment">// 原始结构体 s</span></span><br><span class="line">	p := &amp;s                                <span class="comment">// p 是指向 s 的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 将指针 p 赋值给接口 i</span></span><br><span class="line">	<span class="comment">// 此时，p (内存地址) 的值会被拷贝一份并存储在接口 i 的&quot;值&quot;部分</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = p </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尝试通过原始指针 p 修改结构体 MyStruct 的字段</span></span><br><span class="line">	p.Name = <span class="string">&quot;Modified via Pointer&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Original s (via p): %+v, p Address: %p\n&quot;</span>, *p, p) <span class="comment">// Output: Modified via Pointer</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2. 进行类型断言</span></span><br><span class="line">	<span class="comment">// 此时，i.(*MyStruct) 会直接从接口 i 的&quot;值&quot;部分取出那个指针的拷贝</span></span><br><span class="line">	<span class="comment">// 这个操作是非拷贝的，只是取出一个指针</span></span><br><span class="line">	pAsserted, ok := i.(*MyStruct) </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Asserted p: %p, Asserted s: %+v\n&quot;</span>, pAsserted, *pAsserted) <span class="comment">// Output: Modified via Pointer (与原始 s 相同)</span></span><br><span class="line">		<span class="comment">// 注意 pAsserted 和 p 的地址是相同的（指向同一个 MyStruct 实例）</span></span><br><span class="line">		<span class="comment">// 修改 pAsserted.Name 也会影响到原始的 s</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>当 <code>p</code> 赋值给 <code>i</code> (<code>var i interface&#123;&#125; = p</code>) 时，指针 <code>p</code> 的值（即 <code>s</code> 的内存地址）的一个副本被存储在 <code>i</code> 内部。</li>
<li>当我们修改 <code>*p</code> 时，接口 <code>i</code> 内部存储的指针仍然指向同一个 <code>MyStruct</code> 实例，所以修改会影响到接口引用的数据。</li>
<li>进行 <code>pAsserted, ok := i.(*MyStruct)</code> 断言时，<code>pAsserted</code> 获取的就是接口 <code>i</code> 内部存储的那个地址。<code>pAsserted</code> 和 <code>p</code> 指向的是同一个底层数据。<strong>在这里，也没有额外的拷贝发生。</strong></li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>赋值到接口阶段</strong>：<ul>
<li>如果是一个<strong>非指针类型的值</strong>赋值给接口，Go会创建这个值的一个<strong>拷贝</strong>并存储在接口内部。</li>
<li>如果是一个<strong>指针类型的值</strong>赋值给接口，Go会创建这个<strong>指针的拷贝</strong>（即地址的拷贝）并存储在接口内部，两个指针指向同一个底层数据。</li>
</ul>
</li>
<li><strong>类型断言阶段</strong>：<ul>
<li>在类型断言 <code>i.(Type)</code> 时，Go语言会查看接口内部存储的类型信息和值信息。</li>
<li>如果类型匹配，它会直接返回接口内部存储的那个值（如果值很小，可能是直接嵌入的；如果值大，比如结构体，则返回其指针所指向的）。这个过程通常不涉及新的、额外的数据拷贝。</li>
<li>你得到的断言结果，要么是接口内部那个“被拷贝过的值本身”，要么是接口内部那个“被拷贝过的指针”。</li>
</ul>
</li>
</ul>
<p>因此，从严格意义上讲，<strong>类型断言本身触发的拷贝非常少见或几乎没有</strong>，它更多的是在内存中查看和提取已存储的数据。但是，<strong>在使用非指针类型将变量赋给接口时，会产生一次值拷贝</strong>，这一点是需要特别注意的，因为它可能导致你对数据修改的预期不符。理解这一点对于避免潜在的bug和优化内存使用至关重要。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">网络命名空间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:17:39" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="理解-Linux-网络命名空间"><a href="#理解-Linux-网络命名空间" class="headerlink" title="理解 Linux 网络命名空间"></a>理解 Linux 网络命名空间</h1><p>如果你使用过 Docker 和 Kubernetes，那么可能应该听说过 network namespace（网络命名空间），最近在我们的 <a target="_blank" rel="noopener" href="https://youdianzhishi.com/web/course/1021">《Kubernetes 网络训练营》</a>课程中学习到了 Linux 下面的 <code>ip</code> 命令的使用，本文我将演示如何使用命令通过一对 <code>veth</code> 接口连接不同子网中的网络命名空间的进程。</p>
<h2 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h2><p>我们知道容器运行时使用 namespace（命名空间）内核功能对系统资源进行分区，以实现某种形式的进程隔离，这样，对一个命名空间中资源的更改不会影响其他命名空间中的资源，包括进程 ID、主机名、用户 ID、文件名和网络接口等。</p>
<p>网络名称空间可以虚拟化网络堆栈，每个网络名称空间都有自己的资源，例如网络接口、IP 地址、路由表、隧道、防火墙等，例如，<code>iptables</code>添加到网络名称空间的规则只会影响进入和离开该名称空间的流量。</p>
<h2 id="ip-命令"><a href="#ip-命令" class="headerlink" title="ip 命令"></a>ip 命令</h2><p><code>ip</code> 命令是用来显示或操纵 Linux 主机的路由、网络设备、策略路由和隧道，是 Linux 下较新的功能强大的网络配置工具。</p>
<p>该命令的用法如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip [OPTIONS] OBJECT COMMAND [ARGUMENTS]</span><br><span class="line"><span class="comment"># where</span></span><br><span class="line"><span class="comment">#   OPTIONS are general global options</span></span><br><span class="line"><span class="comment">#   OBJECT := &#123; link | address | addrlabel | route |</span></span><br><span class="line"><span class="comment">#     rule | neigh | ntable | tunnel | tuntap | maddress |</span></span><br><span class="line"><span class="comment">#     mroute | mrule | monitor | xfrm | netns | l2tp |</span></span><br><span class="line"><span class="comment">#     tcp_metrics &#125;</span></span><br><span class="line"><span class="comment">#   COMMAND is the action to perform on the object, such as,</span></span><br><span class="line"><span class="comment">#     show, add, del etc.</span></span><br><span class="line"><span class="comment">#   ARGUMENTS are arguments specific to the kind of OBJECT</span></span><br><span class="line"><span class="comment">#     and COMMAND</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<ul>
<li>要添加一个新的网络接口，使用 <code>ip link add &lt;interface-name&gt; type &lt;interface-type&gt; &lt;interface-arguments&gt;...</code> 命令</li>
<li>要分配一个新的 IP 地址范围到一个接口，使用 <code>ip addr add &lt;ip-address-range&gt; dev &lt;device-name&gt;</code> 命令</li>
<li>要从路由表中删除一条路由，使用 <code>ip route del &lt;route-ip-range&gt; dev &lt;device-name&gt;</code> 命令</li>
</ul>
<p>选项 <code>-n</code> 可以用来切换目标命名空间，例如，要将 <code>10.0.1.0/24</code> IP 地址范围分配给 ns1 网络命名空间内的接口 veth0，使用<code>ip -n ns1 addr add 10.0.1.0/24 dev veth0</code> 命令即可 。</p>
<blockquote>
<p>💡 <code>-n</code> 选项是 <code>ip netns exec</code> 的缩写</p>
</blockquote>
<p><img data-src="https://picdn.youdianzhishi.com/images/20201123114944.png" alt="img"></p>
<h2 id="配置第一个网络命名空间"><a href="#配置第一个网络命名空间" class="headerlink" title="配置第一个网络命名空间"></a>配置第一个网络命名空间</h2><p>首先我们使用 <code>ip link add</code> 命令创建一对新的 veth 接口：veth0 和 veth1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一对名为 veth0 和 veth1 的 veth 接口。</span></span><br><span class="line">$ ip <span class="built_in">link</span> add veth0 <span class="built_in">type</span> veth peer name veth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认 veth0 已创建</span></span><br><span class="line">$ ip <span class="built_in">link</span> show veth0</span><br><span class="line">289: veth0@veth1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 5e:87:<span class="built_in">df</span>:87:af:c7 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认 veth1 已创建</span></span><br><span class="line">$ ip <span class="built_in">link</span> show veth1</span><br><span class="line">288: veth1@veth0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether be:0d:a4:8c:9f:2a brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<p>veth 接口通常被创建为一个对，其中一端传输的数据会立即被另一端接收，这种类型的接口在容器运行时通常用于在不同网络命名空间之间传输数据包。</p>
<p>让我们创建第一个网络命名空间 ns1，然后我们可以将 veth0 接口分配给这个网络命名空间，并将 <code>10.0.1.0/24</code> 的 IP 地址范围分配给它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 ns1 网络命名空间</span></span><br><span class="line">$ ip netns add ns1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配 veth0 接口到 ns1 网络命名空间</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> veth0 netns ns1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 10.0.1.0/24 IP 地址范围分配给 veth0 接口</span></span><br><span class="line">$ ip -n ns1 addr add 10.0.1.0/24 dev veth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 veth0 接口 up 起来</span></span><br><span class="line">$ ip -n ns1 <span class="built_in">link</span> <span class="built_in">set</span> veth0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 lo 接口 up 起来，因为发往 10.0.1.0/24 的数据（本地的）</span></span><br><span class="line"><span class="comment"># （像 ping）要通过 local（本地）路由表</span></span><br><span class="line"><span class="comment"># 比如要 ping 自己</span></span><br><span class="line">$ ip -n ns1 <span class="built_in">link</span> <span class="built_in">set</span> lo up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认接口已经 up 起来</span></span><br><span class="line">$ ip -n ns1 addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">289: veth0@if288: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state LOWERLAYERDOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 5e:87:<span class="built_in">df</span>:87:af:c7 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.0.1.0/24 scope global veth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>现在如果我们从主机和 ns1 两个网络命名空间中去 ping veth0 接口会发生什么呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># veth0 不在主机的根网络命名空间中</span></span><br><span class="line">$ ip <span class="built_in">link</span> show veth0</span><br><span class="line">Device <span class="string">&quot;veth0&quot;</span> does not exist.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从主机网络命名空间中 ping 不通</span></span><br><span class="line">$ ping -c10 10.0.1.0</span><br><span class="line">PING 10.0.1.0 (10.0.1.0) 56(84) bytes of data.</span><br><span class="line">^C</span><br><span class="line">--- 10.0.1.0 ping statistics ---</span><br><span class="line">3 packets transmitted, 0 received, 100% packet loss, time 1999ms</span><br></pre></td></tr></table></figure>

<p>我们可以看到直接在主机的根网络命名空间中是找不到 veth0 这个接口的，当然也是 ping 不同 <code>10.0.1.0</code> 这个地址的，因为他们被绑定到 ns1 这个网络命名空间中，所以我们在操作的时候需要切换到这个命名空间下面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns1 ping -c10 10.0.1.0</span><br><span class="line">PING 10.0.1.0 (10.0.1.0) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.1.0: icmp_seq=1 ttl=64 time=0.121 ms</span><br><span class="line">64 bytes from 10.0.1.0: icmp_seq=2 ttl=64 time=0.063 ms</span><br><span class="line">64 bytes from 10.0.1.0: icmp_seq=3 ttl=64 time=0.066 ms</span><br><span class="line">64 bytes from 10.0.1.0: icmp_seq=4 ttl=64 time=0.109 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.1.0 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.063/0.089/0.121/0.028 ms</span><br></pre></td></tr></table></figure>

<p>这里我们使用了一条 <code>ip netns exec</code> 的命令，这个命令允许我们在指定的网络命名空间中去执行任意的命令，可以看到现在我们在 ns1 网络命名空中间去 ping <code>10.0.1.0</code> 就可以通了。</p>
<h2 id="配置第二个网络命名空间"><a href="#配置第二个网络命名空间" class="headerlink" title="配置第二个网络命名空间"></a>配置第二个网络命名空间</h2><p>下面我们用上面的方式来创建第二个网络命名空间 <code>ns2</code>，然后将 veth1 接口分配给这个网络命名空间，并将 <code>10.0.2.0/24</code> 的 IP 地址范围分配给这个接口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为 ns2 的网络命名空间</span></span><br><span class="line">$ ip netns add ns2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配 veth1 接口到 ns2 网络命名空间</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> veth1 netns ns2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 10.0.2.0/24 IP 地址范围分配给 veth1 接口</span></span><br><span class="line">$ ip -n ns2 addr add 10.0.2.0/24 dev veth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 veth1 接口 up 起来</span></span><br><span class="line">$ ip -n ns2 <span class="built_in">link</span> <span class="built_in">set</span> veth1 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 lo 口 up 起来（这样可以 ping 通自己）</span></span><br><span class="line">$ ip -n ns2 <span class="built_in">link</span> <span class="built_in">set</span> lo up</span><br><span class="line"></span><br><span class="line">$ ip -n ns2 addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">288: veth1@if289: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether be:0d:a4:8c:9f:2a brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.0.2.0/24 scope global veth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::bc0d:a4ff:fe8c:9f2a/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>为方便后面设置路由，这里我们为 veth1 接口分配一个不同的子网 IP 范围。和 veth0 接口类似，veth1 接口也不能从主机网络命名空间到达，只能在 ns2 本身的网络命名空间内工作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ip <span class="built_in">link</span> show veth1</span><br><span class="line">Device <span class="string">&quot;veth1&quot;</span> does not exist.</span><br><span class="line">$ ping -c10 10.0.2.0</span><br><span class="line">PING 10.0.2.0 (10.0.2.0) 56(84) bytes of data.</span><br><span class="line">From 180.149.159.13 icmp_seq=2 Packet filtered</span><br><span class="line">^C</span><br><span class="line">--- 10.0.2.0 ping statistics ---</span><br><span class="line">2 packets transmitted, 0 received, +1 errors, 100% packet loss, time 999</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns2 ping -c10 10.0.2.0</span><br><span class="line">PING 10.0.2.0 (10.0.2.0) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.2.0: icmp_seq=1 ttl=64 time=0.100 ms</span><br><span class="line">64 bytes from 10.0.2.0: icmp_seq=2 ttl=64 time=0.096 ms</span><br><span class="line">64 bytes from 10.0.2.0: icmp_seq=3 ttl=64 time=0.068 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.2.0 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 1999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.068/0.088/0.100/0.014 ms</span><br></pre></td></tr></table></figure>

<h2 id="配置子网路由"><a href="#配置子网路由" class="headerlink" title="配置子网路由"></a>配置子网路由</h2><p>虽然在上面的两个网络空间内可以各自访问自己，但是他们互相之间是不能 ping 通的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns1 ping -c10 10.0.2.0</span><br><span class="line">connect: Network is unreachable</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns2 ping -c10 10.0.1.0</span><br><span class="line">connect: Network is unreachable</span><br></pre></td></tr></table></figure>

<p>veth0 和 veth1 这两个接口本身也都 up 起来了，而且在各种的网络命名空间中 ping 也能正常工作，所以互相直接不通那很可能和路由有关。下面我们使用 ip 命令来调试下，我们可以通过 <code>ip route get</code> 命令来确定一个数据包所走的路由。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip -n ns1 route get 10.0.2.0</span><br><span class="line">RTNETLINK answers: Network is unreachable</span><br><span class="line">$ ip -n ns2 route get 10.0.1.0</span><br><span class="line">RTNETLINK answers: Network is unreachable</span><br></pre></td></tr></table></figure>

<p>我们可以看到都是网络不可达，我们来检查下两个网络命名空间中的路由表信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip -n ns1 route</span><br><span class="line">10.0.1.0/24 dev veth0 proto kernel scope <span class="built_in">link</span> src 10.0.1.0</span><br><span class="line">$ ip -n ns2 route</span><br><span class="line">10.0.2.0/24 dev veth1 proto kernel scope <span class="built_in">link</span> src 10.0.2.0</span><br></pre></td></tr></table></figure>

<p>看到路由表是不是很清晰了，两个网络命名空间的路由表都只有各自 IP 范围的路由条目，并没有通往其他子网的路由，所以当然不能互通了，要解决也很简单，可以使用 <code>ip route add</code> 命令在路由表中插入新的路由条目是不是就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新 veth0 路由表，添加一条通往 10.0.2.0/24 的路由</span></span><br><span class="line">$ ip -n ns1 route add 10.0.2.0/24 dev veth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认发往 10.0.2.0/24 的数据包被路由到 veth0</span></span><br><span class="line">$ ip -n ns1 route get 10.0.2.0</span><br><span class="line">10.0.2.0 dev veth0 src 10.0.1.0</span><br><span class="line">    cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样更新 veth1 路由表，添加一条通往 10.0.1.0/24 的路由</span></span><br><span class="line">$ ip -n ns2 route add 10.0.1.0/24 dev veth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认发往 10.0.1.0/24 的数据包被路由到 veth1</span></span><br><span class="line">$ ip -n ns2 route get 10.0.1.0</span><br><span class="line">10.0.1.0 dev veth1 src 10.0.2.0</span><br><span class="line">    cache</span><br></pre></td></tr></table></figure>

<p>上面我们在各自的网络命名空间中添加了对方的路由信息，现在我们来尝试 ping 下对方的 veth 接口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns1 ping -c10 10.0.2.0</span><br><span class="line">PING 10.0.2.0 (10.0.2.0) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.2.0: icmp_seq=1 ttl=64 time=0.140 ms</span><br><span class="line">64 bytes from 10.0.2.0: icmp_seq=2 ttl=64 time=0.080 ms</span><br><span class="line">64 bytes from 10.0.2.0: icmp_seq=3 ttl=64 time=0.091 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.2.0 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 1999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.080/0.103/0.140/0.028 ms</span><br><span class="line"></span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns2 ping -c10 10.0.1.0</span><br><span class="line">PING 10.0.1.0 (10.0.1.0) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.1.0: icmp_seq=1 ttl=64 time=0.114 ms</span><br><span class="line">64 bytes from 10.0.1.0: icmp_seq=2 ttl=64 time=0.084 ms</span><br><span class="line">64 bytes from 10.0.1.0: icmp_seq=3 ttl=64 time=0.086 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.1.0 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.084/0.094/0.114/0.017 ms</span><br></pre></td></tr></table></figure>

<p>可以看到已经通啦！！🎉🎉🎉</p>
<p>此外我们还可以使用 <code>tcpdump</code> 来捕获两个网络命名空间之间传输的数据包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns1 tcpdump -i veth0 icmp -l</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on veth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">11:29:22.080392 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 1, length 64</span><br><span class="line">11:29:22.080464 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 1, length 64</span><br><span class="line">11:29:23.080409 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 2, length 64</span><br><span class="line">11:29:23.080472 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 2, length 64</span><br><span class="line">11:29:24.080357 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 3, length 64</span><br><span class="line">11:29:24.080418 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 3, length 64</span><br><span class="line">11:29:25.080346 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 4, length 64</span><br><span class="line">11:29:25.080401 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 4, length 64</span><br><span class="line">11:29:26.080417 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 5, length 64</span><br><span class="line">11:29:26.080496 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 5, length 64</span><br><span class="line">11:29:27.080454 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 6, length 64</span><br><span class="line">11:29:27.080507 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 6, length 64</span><br><span class="line">11:29:28.080398 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 7, length 64</span><br><span class="line">11:29:28.080456 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 7, length 64</span><br><span class="line">11:29:29.080390 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 8, length 64</span><br><span class="line">11:29:29.080431 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 8, length 64</span><br><span class="line">11:29:30.080524 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 9, length 64</span><br><span class="line">11:29:30.080576 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 9, length 64</span><br><span class="line">11:29:31.081895 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 10, length 64</span><br><span class="line">11:29:31.081942 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 7253, <span class="built_in">seq</span> 10, length 64</span><br><span class="line">^C</span><br><span class="line">20 packets captured</span><br><span class="line">20 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure>

<h2 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h2><p>最好我们来测试下 TCP 连接，使用 nc 命令在 ns1 命名空间的 7096 端口启动一个 TCP 服务器，然后从 ns2 网络命名空间发起一个 TCP 握手连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns1 nc -l 10.0.1.0 7096 -v</span><br><span class="line"><span class="built_in">exec</span> of <span class="string">&quot;nc&quot;</span> failed: No such file or directory</span><br></pre></td></tr></table></figure>

<p>上面命令报错是因为我们还没有安装 ns 这个工具，安装完成后就正常了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y nc</span><br><span class="line"></span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns1 nc -l 10.0.1.0 7096 -v</span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening on 10.0.1.0:7096</span><br></pre></td></tr></table></figure>

<p>然后重新开一个终端进行连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 nc 从 ns2 发起 TCP 握手</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns2 nc -4t 10.0.1.0 7096 -v</span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Connected to 10.0.1.0:7096.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个时候正常会在前面的服务中看到连接状态</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns1 nc -l 10.0.1.0 7096 -v</span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening on 10.0.1.0:7096</span><br><span class="line">Ncat: Connection from 10.0.2.0.</span><br><span class="line">Ncat: Connection from 10.0.2.0:34090.</span><br></pre></td></tr></table></figure>

<p>一旦 TCP 连接建立，我们就可以从 ns2 向 ns1 发送测试消息了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns2 nc -4t 10.0.1.0 7096 -v</span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Connected to 10.0.1.0:7096.</span><br><span class="line">this is a <span class="built_in">test</span> message  <span class="comment"># 在这里输入一段信息</span></span><br></pre></td></tr></table></figure>

<p>此时我们在 ns1 这边的服务器端也会收到发送的消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns1 nc -l 10.0.1.0 7096 -v</span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening on 10.0.1.0:7096</span><br><span class="line">Ncat: Connection from 10.0.2.0.</span><br><span class="line">Ncat: Connection from 10.0.2.0:34090.</span><br><span class="line">this is a <span class="built_in">test</span> message</span><br></pre></td></tr></table></figure>

<p>同样我们也可以使用 tcpdump 来抓取所有在两个网络命名空间之间传输的数据包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns1 tcpdump -X -i veth0 -n tcp -l</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on veth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">11:42:59.912176 IP 10.0.2.0.34090 &gt; 10.0.1.0.7096: Flags [P.], <span class="built_in">seq</span> 118819706:118819735, ack 1587208228, win 229, options [nop,nop,TS val 1970393377 ecr 1970365937], length 29</span><br><span class="line">	0x0000:  4500 0051 ad52 4000 4006 7655 0a00 0200  E..Q.R@.@.vU....</span><br><span class="line">	0x0010:  0a00 0100 852a 1bb8 0715 0b7a 5e9a e024  .....*.....z^..$</span><br><span class="line">	0x0020:  8018 00e5 1743 0000 0101 080a 7571 d121  .....C......uq.!</span><br><span class="line">	0x0030:  7571 65f1 7468 6973 2069 7320 616e 6f74  uqe.this.is.anot</span><br><span class="line">	0x0040:  6865 7220 7465 7374 206d 6573 7361 6765  her.test.message</span><br><span class="line">	0x0050:  0a                                       .</span><br><span class="line">11:42:59.912207 IP 10.0.1.0.7096 &gt; 10.0.2.0.34090: Flags [.], ack 29, win 227, options [nop,nop,TS val 1970393377 ecr 1970393377], length 0</span><br><span class="line">	0x0000:  4500 0034 4612 4000 4006 ddb2 0a00 0100  E..4F.@.@.......</span><br><span class="line">	0x0010:  0a00 0200 1bb8 852a 5e9a e024 0715 0b97  .......*^..$....</span><br><span class="line">	0x0020:  8010 00e3 1726 0000 0101 080a 7571 d121  .....&amp;......uq.!</span><br><span class="line">	0x0030:  7571 d121                                uq.!</span><br></pre></td></tr></table></figure>

<p>当然也可以将这个抓包结果保存下来然后用其他工具比如大白鲨来进行详细的分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们使用 ip 子命令可以用来创建和配置网络命名空间、接口和路由等，我们创建了一对 veth 接口，这些接口被分配到两个不同的网络命名空间中，具有不同的子网 IP 地址范围，在网络命名空间的路由表中配置了额外的路由，这可以实现两个子网之间的通信。</p>
<p>两个 veth 接口都无法从主机网络命名空间直接到达，因为它们的 IP 地址范围和路由表的变化也被隔离在自己的网络命名空间中了。</p>
<p>我们可以使用 <code>ip netns exec</code> 命令运行工具和 tcpdump 来调试网络命名空间之间的连接问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">网络模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:17:45" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Kubernetes-CNI-网络模型简介"><a href="#1-Kubernetes-CNI-网络模型简介" class="headerlink" title="1. Kubernetes CNI 网络模型简介"></a>1. Kubernetes CNI 网络模型简介</h2><p>K8s 的网络模型核心要求：</p>
<ol>
<li><strong>Pod-to-Pod 互通</strong>：每个 Pod 都有唯一 IP，Pod 之间不需要 NAT 就能通信。</li>
<li><strong>Pod-to-Service 互通</strong>：通过 Service ClusterIP 或者 kube-proxy&#x2F;ipvs 实现。</li>
<li><strong>跨节点通信</strong>：不同 Node 上的 Pod 必须能直接通信。</li>
</ol>
<p>CNI（Container Network Interface）是一套标准，K8s 通过调用不同的 CNI 插件来实现具体的网络。</p>
<hr>
<h2 id="2-Flannel"><a href="#2-Flannel" class="headerlink" title="2. Flannel"></a>2. Flannel</h2><p>🔹 <strong>定位</strong>：最早、最简单的 CNI，主要实现 <strong>Pod-to-Pod 的三层网络连通性</strong>。<br> 🔹 <strong>特点</strong>：</p>
<ul>
<li>提供 Overlay 网络（VXLAN、UDP、Host-GW 等模式）。</li>
<li><strong>只管连通性</strong>，不提供 NetworkPolicy（安全策略）。</li>
<li>架构简单、易于部署，适合小规模或对网络安全需求不高的场景。</li>
</ul>
<p>✅ 优点：</p>
<ul>
<li>部署简单，稳定成熟。</li>
<li>占用资源少。</li>
</ul>
<p>❌ 缺点：</p>
<ul>
<li>功能单一，无安全策略支持。</li>
<li>性能一般（Overlay 会带来额外开销）。</li>
</ul>
<hr>
<h2 id="3-Calico"><a href="#3-Calico" class="headerlink" title="3. Calico"></a>3. Calico</h2><p>🔹 <strong>定位</strong>：功能全面的 CNI，支持 <strong>三层路由 + 安全策略</strong>。<br> 🔹 <strong>特点</strong>：</p>
<ul>
<li>默认采用 BGP（边界网关协议）做三层路由，Pod IP 可以直接在节点间路由，不一定要 overlay。</li>
<li>支持 <strong>网络策略（NetworkPolicy）</strong>，基于 iptables 或 eBPF 实现安全隔离。</li>
<li>既可以 Overlay（IP-in-IP、VXLAN），也可以纯三层（Direct Routing）。</li>
</ul>
<p>✅ 优点：</p>
<ul>
<li>高性能（BGP 直连时几乎无封装开销）。</li>
<li>完整的网络策略支持。</li>
<li>生产环境应用广泛，社区活跃。</li>
</ul>
<p>❌ 缺点：</p>
<ul>
<li>配置比 Flannel 复杂。</li>
<li>BGP 配置和大规模集群下路由收敛可能需要调优。</li>
</ul>
<hr>
<h2 id="4-Cilium"><a href="#4-Cilium" class="headerlink" title="4. Cilium"></a>4. Cilium</h2><p>🔹 <strong>定位</strong>：新一代基于 <strong>eBPF</strong> 的 CNI 插件。<br> 🔹 <strong>特点</strong>：</p>
<ul>
<li>使用 Linux eBPF 技术实现高性能数据面，替代 iptables。</li>
<li>支持 <strong>L3&#x2F;L4&#x2F;L7 网络策略</strong>（应用层可见性，甚至能基于 HTTP 方法做策略）。</li>
<li>可以与 Envoy 集成，具备 Service Mesh 能力（Cilium Service Mesh）。</li>
<li>支持 Overlay（VXLAN、Geneve）和直连路由模式。</li>
</ul>
<p>✅ 优点：</p>
<ul>
<li>高性能（eBPF 内核态转发比 iptables 更快）。</li>
<li>安全策略更细粒度（L7）。</li>
<li>可观测性强（内置 Hubble，可观察 Pod 间流量）。</li>
<li>云原生方向更先进（可替代部分 Service Mesh 功能）。</li>
</ul>
<p>❌ 缺点：</p>
<ul>
<li>对内核要求较高（Linux 内核 4.9+，推荐 5.x 以上）。</li>
<li>部署和调试复杂度比 Flannel 高。</li>
<li>对资源开销相对比 Flannel 大。</li>
</ul>
<hr>
<h2 id="5-三者对比总结"><a href="#5-三者对比总结" class="headerlink" title="5. 三者对比总结"></a>5. 三者对比总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Flannel</th>
<th>Calico</th>
<th>Cilium</th>
</tr>
</thead>
<tbody><tr>
<td>核心功能</td>
<td>Pod 网络连通</td>
<td>网络连通 + 网络策略（L3&#x2F;L4）</td>
<td>网络连通 + L3&#x2F;L4&#x2F;L7 网络策略</td>
</tr>
<tr>
<td>数据平面</td>
<td>VXLAN&#x2F;IP-in-IP</td>
<td>BGP &#x2F; VXLAN &#x2F; IP-in-IP</td>
<td>eBPF（VXLAN&#x2F;Geneve&#x2F;直连）</td>
</tr>
<tr>
<td>性能</td>
<td>中等（Overlay）</td>
<td>高（直连 BGP 模式）</td>
<td>高（eBPF 内核转发）</td>
</tr>
<tr>
<td>网络策略</td>
<td>❌ 不支持</td>
<td>✅ 支持</td>
<td>✅ 更细粒度（支持 L7）</td>
</tr>
<tr>
<td>部署复杂度</td>
<td>⭐ 最低</td>
<td>⭐⭐ 中等</td>
<td>⭐⭐⭐ 较高</td>
</tr>
<tr>
<td>适用场景</td>
<td>小规模、简单集群</td>
<td>生产环境主流、安全隔离需求强</td>
<td>对性能&#x2F;可观测性要求高的新项目</td>
</tr>
</tbody></table>
<p>好的 👍 我来给你系统讲一下 <strong>Kubernetes CNI（Container Network Interface）工作原理</strong>，包括它的流程和在 K8s 里的作用。</p>
<hr>
<h2 id="1-CNI-的背景"><a href="#1-CNI-的背景" class="headerlink" title="1. CNI 的背景"></a>1. CNI 的背景</h2><ul>
<li><strong>Kubernetes 自身不提供具体的网络实现</strong>，它只定义了网络模型要求（Pod 互通、Pod 与 Service 互通等）。</li>
<li>真正实现 Pod 网络的是 <strong>CNI 插件</strong>（例如 Flannel、Calico、Cilium）。</li>
<li><strong>CNI 是 CNCF 定义的一套标准接口</strong>，任何网络插件只要遵循这个接口，就可以和 K8s 无缝集成。</li>
</ul>
<hr>
<h2 id="2-CNI-的工作流程"><a href="#2-CNI-的工作流程" class="headerlink" title="2. CNI 的工作流程"></a>2. CNI 的工作流程</h2><p>当 Kubernetes 在某个节点上创建 Pod 时，大致流程如下：</p>
<ol>
<li><strong>Kubelet 调用 CRI（Container Runtime Interface）</strong><ul>
<li>Pod 创建时，Kubelet 通知容器运行时（如 containerd、CRI-O、Docker-shim）。</li>
</ul>
</li>
<li><strong>容器运行时调用 CNI 插件</strong><ul>
<li>容器运行时需要为容器配置网络（分配 IP、路由、DNS 等）。</li>
<li>它会根据 <code>/etc/cni/net.d/</code> 下的 CNI 配置文件，调用对应的 CNI 插件（可执行二进制）。</li>
</ul>
</li>
<li><strong>CNI 插件执行 <code>ADD</code> 操作</strong><ul>
<li>插件会创建一个 <strong>veth pair（虚拟网卡对）</strong>：一端放在 Pod 的 network namespace，另一端接到主机的 bridge 或路由设备上。</li>
<li>插件向 IPAM（IP Address Management）模块申请一个 IP 地址，分配给 Pod。</li>
<li>配置路由，使得 Pod 可以访问集群内外网络。</li>
</ul>
</li>
<li><strong>Pod 网络建立完成</strong><ul>
<li>Pod 获得 IP 地址和路由表，可以与同节点、跨节点的 Pod 通信。</li>
<li>跨节点时，CNI 插件（如 Flannel VXLAN、Calico BGP、Cilium eBPF）负责把流量正确转发到目标节点。</li>
</ul>
</li>
<li><strong>Pod 删除时调用 <code>DEL</code> 操作</strong><ul>
<li>容器运行时调用插件 <code>DEL</code>，释放 Pod 的 IP，清理网络设备。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-CNI-插件接口规范"><a href="#3-CNI-插件接口规范" class="headerlink" title="3. CNI 插件接口规范"></a>3. CNI 插件接口规范</h2><p>CNI 插件必须实现的二进制接口包括：</p>
<ul>
<li><strong>ADD</strong>：创建网络接口，分配 IP 地址。</li>
<li><strong>DEL</strong>：删除网络接口，释放 IP。</li>
<li><strong>CHECK</strong>（可选）：检查网络是否正常。</li>
<li><strong>VERSION</strong>：返回插件支持的版本信息。</li>
</ul>
<p>输入：通过标准输入传递 JSON 配置，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mynet&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isGateway&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.244.0.0/16&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出：插件返回 Pod 的 IP 信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ips&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.244.0.5/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.244.0.1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-CNI-在-Kubernetes-中的作用"><a href="#4-CNI-在-Kubernetes-中的作用" class="headerlink" title="4. CNI 在 Kubernetes 中的作用"></a>4. CNI 在 Kubernetes 中的作用</h2><ul>
<li><strong>Pod 网络接入</strong>：为每个 Pod 分配独立 IP，并与宿主机网络互通。</li>
<li><strong>跨节点通信</strong>：决定 Pod 跨节点如何转发（VXLAN、BGP、eBPF 等）。</li>
<li><strong>网络策略</strong>：部分 CNI 插件（Calico、Cilium）实现 K8s 的 <code>NetworkPolicy</code>，用于安全隔离。</li>
</ul>
<hr>
<h2 id="5-简化图示"><a href="#5-简化图示" class="headerlink" title="5. 简化图示"></a>5. 简化图示</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        Kubelet</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">    Container Runtime</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">      调用 <span class="built_in">CNI</span> 插件</span><br><span class="line">           │</span><br><span class="line">   ┌───────┴─────────┐</span><br><span class="line">   │                 │</span><br><span class="line"><span class="built_in">CNI</span> 网络插件   IPAM 插件</span><br><span class="line">   │                 │</span><br><span class="line">   └───────┬─────────┘</span><br><span class="line">           │</span><br><span class="line">   配置 Pod veth + IP</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">        Pod 获得网络</span><br></pre></td></tr></table></figure>

<p>好的，我们来深入讲解一下 <strong>Cilium 的 Native Routing with kube-proxy 模式</strong>。</p>
<hr>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>Cilium 是一个基于 <strong>eBPF</strong> 的 CNI 插件，支持多种数据路径模式，其中常见的有：</p>
<ul>
<li><strong>Overlay 模式</strong>（VXLAN&#x2F;Geneve）：流量封装后在节点之间传递。</li>
<li><strong>Native Routing 模式</strong>（直连路由）：利用节点路由表转发，不做封装，性能更高。</li>
</ul>
<p>同时，K8s 默认的 <strong>Service 转发</strong>是由 <strong>kube-proxy</strong>（基于 iptables 或 ipvs）实现的。但 Cilium 也可以完全接管 Service 转发（替代 kube-proxy），称为 <strong>kube-proxy replacement</strong> 模式。</p>
<p>你问的 <strong>Native Routing with kube-proxy 模式</strong>，意思是：<br> 👉 <strong>Cilium 使用 Native Routing 做 Pod-to-Pod 流量转发，同时 Service 还是交给 kube-proxy 处理。</strong></p>
<hr>
<h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h2><h3 id="Pod-to-Pod-通信"><a href="#Pod-to-Pod-通信" class="headerlink" title="Pod-to-Pod 通信"></a>Pod-to-Pod 通信</h3><ol>
<li>Pod 在节点上分配一个 <strong>真实的子网 IP</strong>（没有 VXLAN 封装）。</li>
<li>Cilium 配置 Linux 路由表，让不同节点之间的 Pod 网络可以直达：<ul>
<li>可以通过 <strong>BGP</strong>（Cilium + MetalLB&#x2F;FRR）动态分发路由。</li>
<li>或者通过静态路由（cluster scope routing）。</li>
</ul>
</li>
<li>数据包走主机路由转发，直接到达目标节点的 Pod（无隧道封装 → 更高性能）。</li>
</ol>
<h3 id="Pod-to-Service-通信"><a href="#Pod-to-Service-通信" class="headerlink" title="Pod-to-Service 通信"></a>Pod-to-Service 通信</h3><ul>
<li>仍由 <strong>kube-proxy</strong> 负责 Service 的虚拟 IP (ClusterIP) 转换。</li>
<li>流量到达 Service 的虚拟 IP 后，通过 iptables&#x2F;ipvs 规则 NAT 到对应 Pod。</li>
</ul>
<h3 id="简单示意："><a href="#简单示意：" class="headerlink" title="简单示意："></a>简单示意：</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[PodA]</span> <span class="built_in">--</span>(Native Routing)--&gt; <span class="selector-attr">[PodB]</span>         ✅ Cilium 直连路由</span><br><span class="line"><span class="selector-attr">[PodA]</span> <span class="built_in">--</span>(ClusterIP)--&gt; <span class="selector-attr">[kube-proxy]</span> --&gt; <span class="selector-attr">[PodB]</span>   ✅ kube-proxy NAT</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-模式特点"><a href="#3-模式特点" class="headerlink" title="3. 模式特点"></a>3. 模式特点</h2><p>✅ <strong>优点</strong>：</p>
<ul>
<li>性能好：Pod-to-Pod 无封装，减少额外开销。</li>
<li>部署简单：不用立刻替换 kube-proxy，降低接入风险。</li>
<li>兼容性强：Service 相关逻辑保持不变。</li>
</ul>
<p>❌ <strong>缺点</strong>：</p>
<ul>
<li>Service 仍然依赖 kube-proxy（iptables&#x2F;ipvs），性能和可观测性不如 Cilium eBPF Service。</li>
<li>Native Routing 需要正确配置路由（例如 BGP 或静态路由），网络环境复杂时配置量大。</li>
</ul>
<hr>
<h2 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h2><ul>
<li>集群规模中等，追求 <strong>Pod-to-Pod 高性能通信</strong>，但不想立即替换 kube-proxy。</li>
<li>已经有现成的 kube-proxy 配置，迁移成本较高。</li>
<li>对 Service 的流量性能要求不是瓶颈。</li>
</ul>
<hr>
<h2 id="5-与其他模式对比"><a href="#5-与其他模式对比" class="headerlink" title="5. 与其他模式对比"></a>5. 与其他模式对比</h2><table>
<thead>
<tr>
<th>模式</th>
<th>Pod-to-Pod</th>
<th>Pod-to-Service</th>
<th>性能</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Overlay + kube-proxy</strong></td>
<td>VXLAN&#x2F;Geneve 封装</td>
<td>kube-proxy</td>
<td>中</td>
<td>低</td>
</tr>
<tr>
<td><strong>Native Routing + kube-proxy</strong></td>
<td>直连路由</td>
<td>kube-proxy</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td><strong>Overlay + eBPF (no kube-proxy)</strong></td>
<td>VXLAN&#x2F;Geneve 封装</td>
<td>Cilium eBPF</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td><strong>Native Routing + eBPF (no kube-proxy)</strong></td>
<td>直连路由</td>
<td>Cilium eBPF</td>
<td>最高</td>
<td>高</td>
</tr>
</tbody></table>
<hr>
<p>👉 总结一句话：<br> <strong>Cilium Native Routing with kube-proxy 模式</strong>就是：</p>
<ul>
<li><strong>Pod-to-Pod</strong> 走直连路由（性能更好）。</li>
<li><strong>Service</strong> 还是走 kube-proxy（兼容性最好）。</li>
<li>适合作为从传统方案逐步迁移到 Cilium 全 eBPF 的过渡阶段。</li>
</ul>
<h2 id="Native-Routing-eBPF-hostRouting-模式工作原理"><a href="#Native-Routing-eBPF-hostRouting-模式工作原理" class="headerlink" title="Native Routing + eBPF hostRouting 模式工作原理"></a>Native Routing + eBPF hostRouting 模式工作原理</h2><p>在这个模式下：</p>
<ul>
<li><strong>Pod-to-Pod 跨节点通信</strong>：<ol>
<li>Pod 发出数据包（目的 IP &#x3D; PodB IP）。</li>
<li>Cilium 的 eBPF 程序在 veth ingress 处捕获数据包。</li>
<li>eBPF 查找路由表，判断目标 Pod 在另一个节点。</li>
<li>直接把数据包送到物理网卡，带上目标 Node 的 MAC 地址。</li>
<li>目标 Node 收到包后，Cilium eBPF 把它直接送入目标 Pod 的 veth，不再走主机协议栈。</li>
</ol>
</li>
<li><strong>Pod-to-Service</strong>：<ul>
<li>如果还保留 kube-proxy，则由 iptables&#x2F;ipvs 处理。</li>
<li>如果开启 Cilium kube-proxy replacement，则由 Cilium eBPF Service 加速。</li>
</ul>
</li>
</ul>
<h2 id="Cilium-VXLAN-模式的工作原理"><a href="#Cilium-VXLAN-模式的工作原理" class="headerlink" title="Cilium VXLAN 模式的工作原理"></a>Cilium VXLAN 模式的工作原理</h2><p>当你在 Cilium 里选择 VXLAN 模式时：</p>
<h3 id="Pod-to-Pod-流量"><a href="#Pod-to-Pod-流量" class="headerlink" title="Pod-to-Pod 流量"></a>Pod-to-Pod 流量</h3><ol>
<li><p>PodA（在 Node1）要访问 PodB（在 Node2）。</p>
</li>
<li><p>PodA 发出的数据包目的 IP &#x3D; PodB IP。</p>
</li>
<li><p>Cilium eBPF 程序拦截数据包 → 封装为 <strong>VXLAN 包</strong>：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span> IP: Node1 IP → Node2 IP</span><br><span class="line"><span class="keyword">Outer</span> UDP: dst=<span class="number">4789</span></span><br><span class="line">VXLAN <span class="keyword">Header</span></span><br><span class="line"><span class="keyword">Inner</span> Ethernet + <span class="keyword">Inner</span> IP: PodA → PodB</span><br></pre></td></tr></table></figure>
</li>
<li><p>包经过物理网络到达 Node2。</p>
</li>
<li><p>Node2 的 Cilium VXLAN 解封装，还原出 Pod-to-Pod 原始包。</p>
</li>
<li><p>交付给 PodB。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E8%81%9A%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/%E8%81%9A%E5%90%88/" class="post-title-link" itemprop="url">聚合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:14:40" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/Query-PromQL/" itemprop="url" rel="index"><span itemprop="name">Query PromQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>我们知道 Prometheus 的时间序列数据是多维数据模型，我们经常就有根据各个维度进行汇总的需求。</p>
<h2 id="基于标签聚合"><a href="#基于标签聚合" class="headerlink" title="基于标签聚合"></a>基于标签聚合</h2><p>例如我们想知道我们的 demo 服务每秒处理的请求数，那么可以将单个的速率相加就可以。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]))</span><br></pre></td></tr></table></figure>



<p>可以得到如下所示的结果：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/588hd5.png" alt="计算每秒处理请求数"></p>
<p>但是我们可以看到绘制出来的图形没有保留任何标签维度，一般来说可能我们希望保留一些维度，例如，我们可能更希望计算每个 <code>instance</code> 和 <code>path</code> 的变化率，但并不关心单个 <code>method</code> 或者 <code>status</code> 的结果，这个时候我们可以在 <code>sum()</code> 聚合器中添加一个 <code>without()</code> 的修饰符：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum without(method, status) (rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]))</span><br></pre></td></tr></table></figure>



<p>上面的查询语句相当于用 <code>by()</code> 修饰符来保留需要的标签的取反操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum by(instance, path, job) (rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]))</span><br></pre></td></tr></table></figure>



<p>现在得到的 sum 结果是就是按照 <code>instance</code>、<code>path</code>、<code>job</code> 来进行分组去聚合的了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/8a1mh5.png" alt="分组聚合"></p>
<p>这里的<strong>分组</strong>概念和 SQL 语句中的分组去聚合就非常类似了。</p>
<p>除了 <code>sum()</code> 之外，Prometheus 还支持下面的这些聚合器：</p>
<ul>
<li><code>sum()</code>：对聚合分组中的所有值进行求和</li>
<li><code>min()</code>：获取一个聚合分组中最小值</li>
<li><code>max()</code>：获取一个聚合分组中最大值</li>
<li><code>avg()</code>：计算聚合分组中所有值的平均值</li>
<li><code>stddev()</code>：计算聚合分组中所有数值的标准差</li>
<li><code>stdvar()</code>：计算聚合分组中所有数值的标准方差</li>
<li><code>count()</code>：计算聚合分组中所有序列的总数</li>
<li><code>count_values()</code>：计算具有相同样本值的元素数量</li>
<li><code>bottomk(k, ...)</code>：计算按样本值计算的最小的 k 个元素</li>
<li><code>topk(k，...)</code>：计算最大的 k 个元素的样本值</li>
<li><code>quantile(φ，...)</code>：计算维度上的 φ-分位数(0≤φ≤1)</li>
<li><code>group(...)</code>：只是按标签分组，并将样本值设为 1。</li>
</ul>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习 1"></a>练习 1</h2><p>1.按 <code>job</code> 分组聚合，计算我们正在监控的所有进程的总内存使用量（<code>process_resident_memory_bytes</code> 指标）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum by(job) (process_resident_memory_bytes)</span><br></pre></td></tr></table></figure>



<p>2.计算 <code>demo_cpu_usage_seconds_total</code> 指标有多少不同的 CPU 模式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count (group by(mode) (demo_cpu_usage_seconds_total))</span><br></pre></td></tr></table></figure>



<p>3.计算每个 job 任务和指标名称的时间序列数量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count by (job, __name__) (&#123;__name__ != &quot;&quot;&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="基于时间聚合"><a href="#基于时间聚合" class="headerlink" title="基于时间聚合"></a>基于时间聚合</h2><p>前面我们已经学习了如何使用 <code>sum()</code>、<code>avg()</code> 和相关的聚合运算符从标签维度进行聚合，这些运算符在一个时间内对多个序列进行聚合，但是有时候我们可能想在每个序列中按时间进行聚合，例如，使尖锐的曲线更平滑，或深入了解一个序列在一段时间内的最大值。</p>
<p>为了基于时间来计算这些聚合，PromQL 提供了一些与标签聚合运算符类似的函数，但是在这些函数名前面附加了 <code>_over_time()</code>：</p>
<ul>
<li><code>avg_over_time(range-vector)</code>：区间向量内每个指标的平均值。</li>
<li><code>min_over_time(range-vector)</code>：区间向量内每个指标的最小值。</li>
<li><code>max_over_time(range-vector)</code>：区间向量内每个指标的最大值。</li>
<li><code>sum_over_time(range-vector)</code>：区间向量内每个指标的求和。</li>
<li><code>count_over_time(range-vector)</code>：区间向量内每个指标的样本数据个数。</li>
<li><code>quantile_over_time(scalar, range-vector)</code>：区间向量内每个指标的样本数据值分位数。</li>
<li><code>stddev_over_time(range-vector)</code>：区间向量内每个指标的总体标准差。</li>
<li><code>stdvar_over_time(range-vector)</code>：区间向量内每个指标的总体标准方差。</li>
</ul>
<p>例如，我们查询 demo 实例中使用的 goroutine 的原始数量，可以使用查询语句 <code>go_goroutines&#123;job=&quot;demo&quot;&#125;</code>，这会产生一些尖锐的峰值图：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20210922143659.png" alt="goroutines"></p>
<p>我们可以通过对图中的每一个点来计算 10 分钟内的 goroutines 数量进行平均来使图形更加平滑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avg_over_time(go_goroutines&#123;job=&quot;demo&quot;&#125;[10m])</span><br></pre></td></tr></table></figure>



<p>这个查询结果生成的图表看起来就平滑很多了：</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20210922144109.png" alt="平滑"></p>
<p>比如要查询 1 小时内内存的使用率则可以用下面的查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 * (1 - ((avg_over_time(node_memory_MemFree_bytes[1h]) + avg_over_time(node_memory_Cached_bytes[1h]) + avg_over_time(node_memory_Buffers_bytes[1h])) / avg_over_time(node_memory_MemTotal_bytes[1h])))</span><br></pre></td></tr></table></figure>



<p><img data-src="https://picdn.youdianzhishi.com/images/20210922144924.png" alt="avg_over_time"></p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>上面所有的 <code>_over_time()</code> 函数都需要一个范围向量作为输入，通常情况下只能由一个区间向量选择器来产生，比如 <code>my_metric[5m]</code>。但是如果现在我们想使用例如 <code>max_over_time()</code> 函数来找出过去一天中 demo 服务的最大请求率应该怎么办呢？</p>
<p>请求率 <code>rate</code> 并不是一个我们可以直接选择时间的原始值，而是一个计算后得到的值，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m])</span><br></pre></td></tr></table></figure>



<p>如果我们直接将表达式传入 <code>max_over_time()</code> 并附加一天的持续时间查询的话就会产生错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ERROR!</span><br><span class="line">max_over_time(</span><br><span class="line">  rate(</span><br><span class="line">    demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]</span><br><span class="line">  )[1d]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>实际上 Prometheus 是支持子查询的，它允许我们首先以指定的步长在一段时间内执行内部查询，然后根据子查询的结果计算外部查询。子查询的表示方式类似于区间向量的持续时间，但需要冒号后添加了一个额外的步长参数：<code>[&lt;duration&gt;:&lt;resolution&gt;]</code>。</p>
<p>这样我们可以重写上面的查询语句，告诉 Prometheus 在一天的范围内评估内部表达式，步长分辨率为 15s：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max_over_time(</span><br><span class="line">  rate(</span><br><span class="line">    demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]</span><br><span class="line">  )[1d:15s] # 在1天内明确地评估内部查询，步长为15秒</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>也可以省略冒号后的步长，在这种情况下，Prometheus 会使用配置的全局 <code>evaluation_interval</code> 参数进行评估内部表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max_over_time(</span><br><span class="line">  rate(</span><br><span class="line">    demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]</span><br><span class="line">  )[1d:]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>这样就可以得到过去一天中 demo 服务最大的 5 分钟请求率，不过冒号仍然是需要的，以明确表示运行子查询。子查询还允许添加一个偏移修饰符 offset 来对内部查询进行时间偏移，类似于瞬时和区间向量选择器。</p>
<p>但是也需要注意长时间计算子查询代价也是非常昂贵的，我们可以使用<strong>记录规则</strong>（后续会讲解）预先记录中间的表达式，而不是每次运行外部查询时都实时计算它。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
