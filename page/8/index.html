<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hui&#39;s Blog">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="六一">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Kubernetes%20%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Kubernetes%20%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Kubernetes 简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:46:16" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kubernetes-简介"><a href="#Kubernetes-简介" class="headerlink" title="Kubernetes 简介"></a>Kubernetes 简介</h1><p><a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes（简称 K8S）</a> 的出现是容器化技术发展的必然结果，<strong>容器化</strong>是应用程序级别的虚拟化，运行单个内核上有多个独立的用户空间实例，这些实例就是容器；<strong>容器</strong>提供了将应用程序的代码、运行时、系统工具、系统库和配置打包到一个实例中的标准方法，而且容器是共享一个内核的；由于容器技术的兴起，导致大量的容器应用出现，所以就出现了一些用来支持应用程序容器化部署和组织的<strong>容器编排</strong>技术，一些流行的开源容器编排工具有 Docker Swarm、Kubernetes 等，但是在发展过程中 Kubernetes 现在已经成为了容器编排领域事实上的一个标准了。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/ssbhbd.png" alt="kubernetes"></p>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a> 是 Google 团队发起的一个开源项目，它的目标是管理跨多个主机的容器，用于自动部署、扩展和管理容器化的应用程序，主要实现语言为 Go 语言，他的理论基础来源与 Google 内部的 Borg 项目，所以 Kubernetes 项目的理论基础就比其他开源项目要“先进”很多，因为 Borg 系统一直依赖就被称为 Google 公司内部最强大的“私密武器”。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Kubernetes 项目依托着 Borg 项目的理论优势，确定了一个如下图所示的全局架构图：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/m3xsrl.png" alt="kubernetes arch"></p>
<p>从上面我们可以看出 Kubernetes 由 Master 和 Node 两种节点组成，这两种角色分别对应着控制节点和工作节点（可以理解为老板和员工）。</p>
<p>其中 Master 节点由三个独立的组件组成，它们分别是负责整个集群通信的 API 服务的 <code>kube-apiserver</code>、负责容器调度的 <code>kube-scheduler</code> 以及负责维护集群状态的 <code>kube-controller-manager</code> 组件。整个集群的数据都是通过 kube-apiserver 保存到 etcd 数据库中的，而其他所有组件的通信也都是通过 kube-apiserver 和 etcd 数据库进行通信的，都不会直接和 etcd 进行通信。</p>
<p>工作节点上最核心的组件就是 <code>kubelet</code>，当然还有底层的容器运行时，比如 Docker，其中 kubelet 就是主要来实现和底层的容器运行时进行通信的，这个通信的过程也被 Kubernetes 抽象成了一个 <code>CRI</code>（Container Runtime Interface）的远程调用接口，这个接口里面定义了容器运行时的所有标准操作，比如创建容器、删除容器等等。所以对于 Kubernetes 来说他根本不关心你部署的到底是什么容器运行时，只要你这个容器运行时可以实现 CRI 接口就可以被 Kubernetes 来管理。</p>
<p>kubelet 的另外一个重要功能就是调用网络插件（<code>CNI</code>）和存储插件（<code>CSI</code>）为容器配置网络和存储功能，同样的 kubelet 也是把这两个重要功能通过接口暴露给外部了，所以如果我们想要实现自己的网络插件，只需要使用 CNI 就可以很方便的对接到 Kubernetes 集群当中去。</p>
<p>可能下面的架构图看上去更清晰一些：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/5dokw9.png" alt="kubernetes high level component archtecture"></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>上面我介绍了 Kubernetes 集群的整体架构，下面我们再来更加详细的了解下这些组件的功能。</p>
<h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><p>API Server 提供了资源对象的唯一操作入口，其它所有组件都必须通过它提供的 API 来操作资源数据。<strong>只有 API Server 会与 etcd 进行通信，其它模块都必须通过 API Server 访问集群状态</strong>。API Server 作为 Kubernetes 系统的入口，封装了核心对象的增删改查操作。API Server 以 RESTFul 接口方式提供给外部客户端和内部组件调用，API Server 再对相关的资源数据（<code>全量查询 + 变化监听</code>）进行操作，以达到实时完成相关的业务功能。以 API Server 为 Kubernetes 入口的设计主要有以下好处：</p>
<ul>
<li>保证了集群状态访问的安全</li>
<li>API Server 隔离了集群状态访问和后端存储实现，这样 API Server 状态访问的方式不会因为后端存储技术 Etcd 的改变而改变，让后端存储方式选择更加灵活，方便了整个架构的扩展</li>
</ul>
<h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><p><img data-src="https://mudutestmenu.mudu.tv/upload/2qdyxz.png" alt="kube-controller-manager"></p>
<p>Controller Manager 用于实现 Kubernetes 集群故障检测和恢复的自动化工作。主要负责执行各种控制器：</p>
<ul>
<li>Replication Controller：主要是定期关联 Replication Controller (RC) 和 Pod，以保证集群中一个 RC (一种资源对象) 所关联的 Pod 副本数始终保持为与预设值一致。</li>
<li>Node Controller：Kubelet 在启动时会通过 API Server 注册自身的节点信息，并定时向 API Server 汇报状态信息。API Server 在接收到信息后将信息更新到 Etcd 中。Node Controller 通过 API Server 实时获取 Node 的相关信息，实现管理和监控集群中的各个 Node 节点的相关控制功能。</li>
<li>ResourceQuota Controller：资源配额管理控制器用于确保指定的资源对象在任何时候都不会超量占用系统上物理资源。</li>
<li>Namespace Controller：用户通过 API Server 可以创建新的 Namespace 并保存在 Etcd 中，Namespace Controller 定时通过 API Server 读取这些 Namespace 信息来操作 Namespace。比如：Namespace 被 API 标记为优雅删除，则将该 Namespace 状态设置为 Terminating 并保存到 Etcd 中。同时 Namespace Controller 删除该 Namespace 下的 ServiceAccount、Deployment、Pod 等资源对象。</li>
<li>Service Account Controller：服务账号控制器主要在命名空间内管理 ServiceAccount，以保证名为 default 的 ServiceAccount 在每个命名空间中存在。</li>
<li>Token Controller：令牌控制器作为 Controller Manager 的一部分，主要用作：监听 serviceAccount 的创建和删除动作以及监听 secret 的添加、删除动作。</li>
<li>Service Controller：服务控制器主要用作监听 Service 的变化。比如：创建的是一个 LoadBalancer 类型的 Service，Service Controller 则要确保外部的云平台上对该 Service 对应的 LoadBalancer 实例被创建、删除以及相应的路由转发表被更新。</li>
<li>Endpoint Controller：Endpoints 表示了一个 Service 对应的所有 Pod 副本的访问地址，而 Endpoints Controller 是负责生成和维护所有 Endpoints 对象的控制器。Endpoint Controller 负责监听 Service 和对应的 Pod 副本的变化。定期关联 Service 和 Pod (关联信息由 Endpoint 对象维护)，以保证 Service 到 Pod 的映射总是最新的。</li>
</ul>
<h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><p>Scheduler 是负责整个集群的资源调度的，主要的职责如下所示：</p>
<ul>
<li>主要用于收集和分析当前 Kubernetes 集群中所有 Node 节点的资源 (包括内存、CPU 等) 负载情况，然后依据资源占用情况分发新建的 Pod 到 Kubernetes 集群中可用的节点</li>
<li>实时监测 Kubernetes 集群中未分发和已分发的所有运行的 Pod</li>
<li>实时监测 Node 节点信息，由于会频繁查找 Node 节点，所以 Scheduler 同时会缓存一份最新的信息在本地</li>
<li>在分发 Pod 到指定的 Node 节点后，会把 Pod 相关的 Binding 信息写回 API Server，以方便其它组件使用</li>
</ul>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>kubelet 是负责容器真正运行的核心组件，主要的职责如下所示：</p>
<ul>
<li>负责 Node 节点上 Pod 的创建、修改、监控、删除等全生命周期的管理</li>
<li>定时上报本地 Node 的状态信息给 API Server</li>
<li>kubelet 是 Master 和 Node 之间的桥梁，接收 API Server 分配给它的任务并执行</li>
<li>kubelet 通过 API Server 间接与 Etcd 集群交互来读取集群配置信息</li>
<li>kubelet 在 Node 上做的主要工作具体如下：<ol>
<li>设置容器的环境变量、给容器绑定 Volume、给容器绑定 Port、根据指定的 Pod 运行一个单一容器、给指定的 Pod 创建 Network 容器</li>
<li>同步 Pod 的状态</li>
<li>在容器中运行命令、杀死容器、删除 Pod 的所有容器</li>
</ol>
</li>
</ul>
<h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p>kube-proxy 是为了解决外部网络能够访问集群中容器提供的应用服务而设计的，Proxy 运行在每个 Node 上。</p>
<p>每创建一个 Service，kube-proxy 就会从 API Server 获取 Services 和 Endpoints 的配置信息，然后根据其配置信息在 Node 上启动一个 Proxy 的进程并监听相应的服务端口。</p>
<p>当接收到外部请求时，kube-proxy 会根据 Load Balancer 将请求分发到后端正确的容器处理。</p>
<p>kube-proxy 不但解决了同一宿主机相同服务端口冲突的问题，还提供了 Service 转发服务端口对外提供服务的能力。</p>
<p>kube-proxy 后端使用<code>随机、轮循</code>等负载均衡算法进行调度。</p>
<h3 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h3><p>Kubectl 是 Kubernetes 的集群管理命令行客户端工具集。通过 Kubectl 命令对 API Server 进行操作，API Server 响应并返回对应的命令结果，从而达到对 Kubernetes 集群的管理</p>
<h2 id="核心资源对象"><a href="#核心资源对象" class="headerlink" title="核心资源对象"></a>核心资源对象</h2><p>上面我们都是在架构层面了解 Kubernetes，但是似乎没有发现关于容器的说明，Kubernetes 作为容器编排引擎，那么他是怎么去对容器进行编排的呢？在 Kubernetes 集群中抽象了很多集群内部的资源对象，我们可以通过这些资源对象去操作容器的编排工作。</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 是一组紧密关联的<code>容器集合</code>，它们共享 PID、IPC、Network 和 UTS namespace，是 Kubernetes 调度的<code>基本单位</code>。Pod 的设计理念是支持多个容器在一个 Pod 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。我们知道容器本质上就是进程，那么 Pod 实际上就是进程组了，只是这一组进程是作为一个整体来进行调度的。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/uywdm0.png" alt="kubernetes pod"></p>
<p>在 Kubernetes 中，所有资源对象都使用资源清单（yaml 或 json）来定义，比如我们可以定义一个简单的 nginx 服务，它包含一个镜像为 nginx 的容器：(nginx-pod.yaml)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>定义了这样一个资源清单文件后，我们就可以利用上面我们提到的 Kubectl 工具将这个 Pod 创建到 Kubernetes 集群中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-pod.yaml</span><br></pre></td></tr></table></figure>

<p>Pod 在 Kubernetes 集群中被创建的基本流程如下所示：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/8vndc6.png" alt="k8s pod process"></p>
<ul>
<li>用户通过 REST API 创建一个 Pod</li>
<li>apiserver 将其写入 etcd</li>
<li>scheduluer 检测到未绑定 Node 的 Pod，开始调度并更新 Pod 的 Node 绑定</li>
<li>kubelet 检测到有新的 Pod 调度过来，通过 container runtime 运行该 Pod</li>
<li>kubelet 通过 container runtime 取到 Pod 状态，并更新到 apiserver 中</li>
</ul>
<h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>Label 标签在 Kubernetes 资源对象中使用很多，也是非常重要的一个属性，Label 是识别 Kubernetes 对象的标签，以 <code>key/value</code> 的方式附加到对象上（key 最长不能超过 63 字节，value 可以为空，也可以是不超过 253 字节的字符串）上面我们定义的 Nginx 的 Pod 就添加了一个 <code>app=nginx</code> 的 Label 标签。Label 不提供唯一性，并且实际上经常是很多对象（如 Pods）都使用相同的 Label 来标志具体的应用。Label 定义好后其他对象可以使用 <code>Label Selector</code> 来选择一组相同 Label 的对象（比如 Service 用 Label 来选择一组 Pod）。Label Selector 支持以下几种方式：</p>
<ul>
<li>等式，如 <code>app=nginx</code> 和 <code>env!=production</code></li>
<li>集合，如 <code>env in (production, qa)</code></li>
<li>多个 Label（它们之间是<code>AND</code>关系），如<code>app=nginx,env=test</code></li>
</ul>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace（命名空间）是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的 Pods、Services、Deployments 等都是属于某一个 Namespace 的（默认是 default），比如上面我们的 Nginx Pod 没有指定 namespace，则默认就在 default 命名空间下面，而 Node, PersistentVolumes 等资源则不属于任何 Namespace，是全局的。</p>
<blockquote>
<p>注意它并不是 Linux Namespace，二者没有任何关系，它只是 Kubernetes 划分不同工作空间的一个逻辑单位。</p>
</blockquote>
<h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>我们说了 Pod 是 Kubernetes 集群中的最基本的调度单元，但是如果想要创建同一个容器的多份拷贝，需要一个一个分别创建出来么，那么能否将 Pods 划到一个逻辑组里面呢？Deployment 就是来管理 Pod 的资源对象。</p>
<p>Deployment 确保任意时间都有指定数量的 Pod“副本”在运行。如果为某个 Pod 创建了 Deployment 并且指定 3 个副本，它会创建 3 个 Pod，并且持续监控它们。如果某个 Pod 不响应，那么 Deployment 会替换它，始终保持总数为 3。</p>
<p>如果之前不响应的 Pod 恢复了，现在就有 4 个 Pod 了，那么 Deployment 会将其中一个终止保持总数为 3。如果在运行中将副本总数改为 5，Deployment 会立刻启动 2 个新 Pod，保证总数为 5。持回滚和滚动升级。</p>
<p>当创建 Deployment 时，需要指定两个东西：</p>
<ul>
<li>Pod 模板：用来创建 Pod 副本的模板</li>
<li>Label 标签：Deployment 需要监控的 Pod 的标签。</li>
</ul>
<p>现在已经创建了 Pod 的一些副本，那么这些副本上如何进行负载呢？如何把这些 Pod 暴露出去呢？这个时候我们就需要用到 Service 这种资源对象了。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 是应用服务的抽象，通过 Labels 为应用提供<code>负载均衡和服务发现</code>。匹配 Labels 的 Pod IP 和端口列表组成 Endpoints，由 kube-proxy 负责将服务 IP 负载均衡到这些 Endpoints 上。</p>
<p>每个 Service 都会自动分配一个 cluster IP（仅在集群内部可访问的虚拟地址）和 DNS 名，其他容器可以通过该地址或 DNS 来访问服务，而不需要了解后端容器的运行。</p>
<p><img data-src="https://picdn.youdianzhishi.com/images/20200510123201.png" alt="k8s service"></p>
<blockquote>
<p>了解了上面的几个基本概念后，我们就完全可以把我们的容器服务迁移到 Kubernetes 集群上了。当然我们还得先搭建好我们的 Kubernetes 集群环境。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.youdianzhishi.com/k8s/runtime/cgns/">
</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Kubernetes%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Kubernetes%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">Kubernetes 集群部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:46:07" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kubernetes-集群部署"><a href="#Kubernetes-集群部署" class="headerlink" title="Kubernetes 集群部署"></a>Kubernetes 集群部署</h1><p>现在我们使用 kubeadm 从头搭建一个使用 containerd 作为容器运行时的 Kubernetes 集群，这里我们安装最新的 <code>v1.22.2</code> 版本。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>3 个节点，都是 Centos 7.6 系统，内核版本：3.10.0-1062.4.1.el7.x86_64，在每个节点上添加 hosts 信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /etc/hosts</span><br><span class="line">192.168.31.31 master1</span><br><span class="line">192.168.31.108 node1</span><br><span class="line">192.168.31.46 node2</span><br></pre></td></tr></table></figure>

<p>hostname</p>
<p>节点的 hostname 必须使用标准的 DNS 命名，另外千万不用什么默认的<code>localhost</code> 的 hostname，会导致各种错误出现的。在 Kubernetes 项目里，机器的名字以及一切存储在 Etcd 中的 API 对象，都必须使用标准的 DNS 命名（RFC 1123）。可以使用命令 <code>hostnamectl set-hostname node1</code> 来修改 hostname。</p>
<p>禁用防火墙：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ systemctl stop firewalld</span><br><span class="line">➜  ~ systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<p>禁用 SELINUX：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ setenforce 0</span><br><span class="line">➜  ~ cat /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<p>由于开启内核 ipv4 转发需要加载 br_netfilter 模块，所以加载下该模块：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ modprobe br_netfilter</span><br></pre></td></tr></table></figure>

<p>最好将上面的命令设置成开机启动，因为重启后模块失效，下面是开机自动加载模块的方式。首先新建 <code>/etc/rc.sysinit</code> 文件，内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for file in /etc/sysconfig/modules/*.modules ; do</span><br><span class="line">[ -x $file ] &amp;&amp; $file</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>然后在 <code>/etc/sysconfig/modules/</code> 目录下新建如下文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /etc/sysconfig/modules/br_netfilter.modules</span><br><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure>

<p>增加权限：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ chmod 755 br_netfilter.modules</span><br></pre></td></tr></table></figure>

<p>然后重启后，模块就可以自动加载了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ lsmod |grep br_netfilter</span><br><span class="line">br_netfilter           22209  0</span><br><span class="line">bridge                136173  1 br_netfilter</span><br></pre></td></tr></table></figure>

<p>创建 <code>/etc/sysctl.d/k8s.conf</code>文件，添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面的内核参数可以解决ipvs模式下长连接空闲超时的问题</span></span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 30</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 10</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br></pre></td></tr></table></figure>

<p>信息</p>
<p><code>bridge-nf</code> 使得 netfilter 可以对 Linux 网桥上的 IPv4&#x2F;ARP&#x2F;IPv6 包过滤。比如，设置<code>net.bridge.bridge-nf-call-iptables＝1</code>后，二层的网桥在转发包时也会被 iptables 的 FORWARD 规则所过滤。常用的选项包括：</p>
<ul>
<li>net.bridge.bridge-nf-call-arptables：是否在 arptables 的 FORWARD 中过滤网桥的 ARP 包</li>
<li>net.bridge.bridge-nf-call-ip6tables：是否在 ip6tables 链中过滤 IPv6 包</li>
<li>net.bridge.bridge-nf-call-iptables：是否在 iptables 链中过滤 IPv4 包</li>
<li>net.bridge.bridge-nf-filter-vlan-tagged：是否在 iptables&#x2F;arptables 中过滤打了 vlan 标签的包。 :::</li>
</ul>
<p>执行如下命令使修改生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure>

<p>安装 ipvs：</p>
<p>&#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line">➜  ~ chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>

<p>上面脚本创建了的 <code>/etc/sysconfig/modules/ipvs.modules</code>文件，保证在节点重启后能自动加载所需模块。使用 <code>lsmod | grep -e ip_vs -e nf_conntrack_ipv4</code>命令查看是否已经正确加载所需的内核模块。</p>
<p>接下来还需要确保各个节点上已经安装了 ipset 软件包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ yum install ipset</span><br></pre></td></tr></table></figure>

<p>为了便于查看 ipvs 的代理规则，最好安装一下管理工具 ipvsadm：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ yum install ipvsadm</span><br></pre></td></tr></table></figure>

<p>同步服务器时间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ yum install chrony -y</span><br><span class="line">➜  ~ systemctl enable chronyd</span><br><span class="line">➜  ~ systemctl start chronyd</span><br><span class="line">➜  ~ chronyc sources</span><br><span class="line">210 Number of sources = 4</span><br><span class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample</span><br><span class="line">===============================================================================</span><br><span class="line">^+ sv1.ggsrv.de                  2   6    17    32   -823us[-1128us] +/-   98ms</span><br><span class="line">^- montreal.ca.logiplex.net      2   6    17    32    -17ms[  -17ms] +/-  179ms</span><br><span class="line">^- ntp6.flashdance.cx            2   6    17    32    -32ms[  -32ms] +/-  161ms</span><br><span class="line">^* 119.28.183.184                2   6    33    32   +661us[ +357us] +/-   38ms</span><br><span class="line">➜  ~ date</span><br><span class="line">Tue Aug 31 14:36:14 CST 2021</span><br></pre></td></tr></table></figure>

<p>关闭 swap 分区：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ swapoff -a</span><br></pre></td></tr></table></figure>

<p>修改 <code>/etc/fstab</code>文件，注释掉 SWAP 的自动挂载，使用 <code>free -m</code>确认 swap 已经关闭。swappiness 参数调整，修改 <code>/etc/sysctl.d/k8s.conf</code>添加下面一行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness=0</span><br></pre></td></tr></table></figure>

<p>执行 <code>sysctl -p /etc/sysctl.d/k8s.conf</code> 使修改生效。</p>
<h2 id="安装-Containerd"><a href="#安装-Containerd" class="headerlink" title="安装 Containerd"></a>安装 Containerd</h2><p>我们已经了解过容器运行时 containerd 的一些基本使用，接下来在各个节点上安装 Containerd。</p>
<blockquote>
<p>如果这安装集群的过程出现了容器运行时的问题，启动不起来，可以尝试使用 <code>yum install containerd.io</code> 来安装 Containerd。</p>
</blockquote>
<p>首先需要这节点商安装 <code>seccomp</code> 依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ rpm -qa |grep libseccomp</span><br><span class="line">libseccomp-2.3.1-4.el7.x86_64</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有安装 libseccomp 包则执行下面的命令安装依赖</span></span><br><span class="line">➜  ~ yum install wget -y</span><br><span class="line">➜  ~ wget http://mirror.centos.org/centos/7/os/x86_64/Packages/libseccomp-2.3.1-4.el7.x86_64.rpm</span><br><span class="line">➜  ~ yum install libseccomp-2.3.1-4.el7.x86_64.rpm -y</span><br></pre></td></tr></table></figure>

<p>由于 containerd 需要调用 runc，所以我们也需要先安装 runc，不过 containerd 提供了一个包含相关依赖的压缩包 <code>cri-containerd-cni-$&#123;VERSION&#125;.$&#123;OS&#125;-$&#123;ARCH&#125;.tar.gz</code>，可以直接使用这个包来进行安装。首先从 <a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/releases">release 页面</a>下载最新版本的压缩包，当前为 1.5.5 版本（最新的 1.5.7 版本在 CentOS7 下面执行 runc 会报错：<a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/issues/6091%EF%BC%89%EF%BC%9A">https://github.com/containerd/containerd/issues/6091）：</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ wget https://github.com/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有限制，也可以替换成下面的 URL 加速下载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget https://download.fastgit.org/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure>

<p>可以通过 tar 的 <code>-t</code> 选项直接看到压缩包中包含哪些文件，直接将压缩包解压到系统的各个目录中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ tar -C / -xzf cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后要将 <code>/usr/local/bin</code> 和 <code>/usr/local/sbin</code> 追加到 <code>~/.bashrc</code> 文件的 <code>PATH</code> 环境变量中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/bin:/usr/local/sbin</span><br></pre></td></tr></table></figure>

<p>然后执行下面的命令使其立即生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>containerd 的默认配置文件为 <code>/etc/containerd/config.toml</code>，我们可以通过如下所示的命令生成一个默认的配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mkdir -p /etc/containerd</span><br><span class="line">➜  ~ containerd config default &gt; /etc/containerd/config.toml</span><br></pre></td></tr></table></figure>

<p>对于使用 systemd 作为 init system 的 Linux 的发行版，使用 <code>systemd</code> 作为容器的 <code>cgroup driver</code> 可以确保节点在资源紧张的情况更加稳定，所以推荐将 containerd 的 cgroup driver 配置为 systemd。</p>
<p>修改前面生成的配置文件 <code>/etc/containerd/config.toml</code>，在 <code>plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options</code> 配置块下面将 <code>SystemdCgroup</code> 设置为 <code>true</code>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span></span><br><span class="line">    <span class="attr">SystemdCgroup</span> = <span class="literal">true</span></span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>然后再为镜像仓库配置一个加速器，需要在 cri 配置块下面的 <code>registry</code> 配置块下面进行配置 <code>registry.mirrors</code>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># sandbox_image = &quot;k8s.gcr.io/pause:3.5&quot;</span></span><br><span class="line">  <span class="attr">sandbox_image</span> = <span class="string">&quot;registry.aliyuncs.com/k8sxio/pause:3.5&quot;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;]</span></span><br><span class="line">        <span class="attr">endpoint</span> = [<span class="string">&quot;https://bqr1dr1n.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;k8s.gcr.io&quot;]</span></span><br><span class="line">        <span class="attr">endpoint</span> = [<span class="string">&quot;https://registry.aliyuncs.com/k8sxio&quot;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们的节点不能正常获取 <code>k8s.gcr.io</code> 的镜像，那么我们需要在上面重新配置 <code>sandbox_image</code> 镜像，否则后面 kubelet 覆盖该镜像不会生效：<code>Warning: For remote container runtime, --pod-infra-container-image is ignored in kubelet, which should be set in that remote runtime instead</code>。</p>
</blockquote>
<p>由于上面我们下载的 containerd 压缩包中包含一个 <code>etc/systemd/system/containerd.service</code> 的文件，这样我们就可以通过 systemd 来配置 containerd 作为守护进程运行了，现在我们就可以启动 containerd 了，直接执行下面的命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ systemctl daemon-reload</span><br><span class="line">➜  ~ systemctl enable containerd --now</span><br></pre></td></tr></table></figure>

<p>启动完成后就可以使用 containerd 的本地 CLI 工具 <code>ctr</code> 和 <code>crictl</code> 了，比如查看版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr version</span><br><span class="line">Client:</span><br><span class="line">  Version:  v1.5.5</span><br><span class="line">  Revision: 72cec4be58a9eb6b2910f5d10f1c01ca47d231c0</span><br><span class="line">  Go version: go1.16.6</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line">  Version:  v1.5.5</span><br><span class="line">  Revision: 72cec4be58a9eb6b2910f5d10f1c01ca47d231c0</span><br><span class="line">  UUID: cd2894ad-fd71-4ef7-a09f-5795c7eb4c3b</span><br><span class="line">➜  ~ crictl version</span><br><span class="line">Version:  0.1.0</span><br><span class="line">RuntimeName:  containerd</span><br><span class="line">RuntimeVersion:  v1.5.5</span><br><span class="line">RuntimeApiVersion:  v1alpha2</span><br></pre></td></tr></table></figure>

<h2 id="使用-kubeadm-部署-Kubernetes"><a href="#使用-kubeadm-部署-Kubernetes" class="headerlink" title="使用 kubeadm 部署 Kubernetes"></a>使用 kubeadm 部署 Kubernetes</h2><p>上面的相关环境配置也完成了，现在我们就可以来安装 Kubeadm 了，我们这里是通过指定 yum 源的方式来进行安装的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg</span><br><span class="line">        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>当然了，上面的 yum 源是需要科学上网的，如果不能科学上网的话，我们可以使用阿里云的源进行安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>然后安装 kubeadm、kubelet、kubectl：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--disableexcludes 禁掉除了kubernetes之外的别的仓库</span></span><br><span class="line">➜  ~ yum makecache fast</span><br><span class="line">➜  ~ yum install -y kubelet-1.22.2 kubeadm-1.22.2 kubectl-1.22.2 --disableexcludes=kubernetes</span><br><span class="line">➜  ~ kubeadm version</span><br><span class="line">kubeadm version: &amp;version.Info&#123;Major:&quot;1&quot;, Minor:&quot;22&quot;, GitVersion:&quot;v1.22.2&quot;, GitCommit:&quot;8b5a19147530eaac9476b0ab82980b4088bbc1b2&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2021-09-15T21:37:34Z&quot;, GoVersion:&quot;go1.16.8&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们这里安装的是 <code>v1.22.2</code> 版本，然后将 master 节点的 kubelet 设置成开机启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ systemctl enable --now kubelet</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这里为止上面所有的操作都需要在所有节点执行配置。</p>
</blockquote>
<h3 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h3><p>当我们执行 <code>kubelet --help</code> 命令的时候可以看到原来大部分命令行参数都被 <code>DEPRECATED</code>了，这是因为官方推荐我们使用 <code>--config</code> 来指定配置文件，在配置文件中指定原来这些参数的配置，可以通过官方文档 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/">Set Kubelet parameters via a config file</a> 了解更多相关信息，这样 Kubernetes 就可以支持动态 Kubelet 配置（Dynamic Kubelet Configuration）了，参考 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/reconfigure-kubelet/">Reconfigure a Node’s Kubelet in a Live Cluster</a>。</p>
<p>然后我们可以通过下面的命令在 master 节点上输出集群初始化默认使用的配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubeadm config print init-defaults --component-configs KubeletConfiguration &gt; kubeadm.yaml</span><br></pre></td></tr></table></figure>

<p>然后根据我们自己的需求修改配置，比如修改 <code>imageRepository</code> 指定集群初始化时拉取 Kubernetes 所需镜像的地址，kube-proxy 的模式为 ipvs，另外需要注意的是我们这里是准备安装 flannel 网络插件的，需要将 <code>networking.podSubnet</code> 设置为 <code>10.244.0.0/16</code>：</p>
<p>kubeadm.yaml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">bootstrapTokens:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">system:bootstrappers:kubeadm:default-node-token</span></span><br><span class="line">    <span class="attr">token:</span> <span class="string">abcdef.0123456789abcdef</span></span><br><span class="line">    <span class="attr">ttl:</span> <span class="string">24h0m0s</span></span><br><span class="line">    <span class="attr">usages:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">signing</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">authentication</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitConfiguration</span></span><br><span class="line"><span class="attr">localAPIEndpoint:</span></span><br><span class="line">  <span class="attr">advertiseAddress:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.31</span> <span class="comment"># 指定master节点内网IP</span></span><br><span class="line">  <span class="attr">bindPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line">  <span class="attr">criSocket:</span> <span class="string">/run/containerd/containerd.sock</span> <span class="comment"># 使用 containerd的Unix socket 地址</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">taints:</span> <span class="comment"># 给master添加污点，master节点不能调度应用</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">&#x27;NoSchedule&#x27;</span></span><br><span class="line">      <span class="attr">key:</span> <span class="string">&#x27;node-role.kubernetes.io/master&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeproxy.config.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeProxyConfiguration</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">ipvs</span> <span class="comment"># kube-proxy 模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">  <span class="attr">timeoutForControlPlane:</span> <span class="string">4m0s</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line"><span class="attr">clusterName:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">controllerManager:</span> &#123;&#125;</span><br><span class="line"><span class="attr">dns:</span> &#123;&#125;</span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.aliyuncs.com/k8sxio</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="number">1.22</span><span class="number">.2</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">dnsDomain:</span> <span class="string">cluster.local</span></span><br><span class="line">  <span class="attr">serviceSubnet:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span></span><br><span class="line">  <span class="attr">podSubnet:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span> <span class="comment"># 指定 pod 子网</span></span><br><span class="line"><span class="attr">scheduler:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubelet.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">authentication:</span></span><br><span class="line">  <span class="attr">anonymous:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">webhook:</span></span><br><span class="line">    <span class="attr">cacheTTL:</span> <span class="string">0s</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">x509:</span></span><br><span class="line">    <span class="attr">clientCAFile:</span> <span class="string">/etc/kubernetes/pki/ca.crt</span></span><br><span class="line"><span class="attr">authorization:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">Webhook</span></span><br><span class="line">  <span class="attr">webhook:</span></span><br><span class="line">    <span class="attr">cacheAuthorizedTTL:</span> <span class="string">0s</span></span><br><span class="line">    <span class="attr">cacheUnauthorizedTTL:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">clusterDNS:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line"><span class="attr">clusterDomain:</span> <span class="string">cluster.local</span></span><br><span class="line"><span class="attr">cpuManagerReconcilePeriod:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">evictionPressureTransitionPeriod:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">fileCheckFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">healthzBindAddress:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">healthzPort:</span> <span class="number">10248</span></span><br><span class="line"><span class="attr">httpCheckFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">imageMinimumGCAge:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeletConfiguration</span></span><br><span class="line"><span class="attr">cgroupDriver:</span> <span class="string">systemd</span> <span class="comment"># 配置 cgroup driver</span></span><br><span class="line"><span class="attr">logging:</span> &#123;&#125;</span><br><span class="line"><span class="attr">memorySwap:</span> &#123;&#125;</span><br><span class="line"><span class="attr">nodeStatusReportFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">nodeStatusUpdateFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">rotateCertificates:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">runtimeRequestTimeout:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">shutdownGracePeriod:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">shutdownGracePeriodCriticalPods:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">staticPodPath:</span> <span class="string">/etc/kubernetes/manifests</span></span><br><span class="line"><span class="attr">streamingConnectionIdleTimeout:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">syncFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">volumeStatsAggPeriod:</span> <span class="string">0s</span></span><br></pre></td></tr></table></figure>



<p>对于上面的资源清单的文档比较杂，要想完整了解上面的资源对象对应的属性，可以查看对应的 godoc 文档，地址：<a target="_blank" rel="noopener" href="https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta3%E3%80%82">https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta3。</a> :::</p>
<p>在开始初始化集群之前可以使用 <code>kubeadm config images pull --config kubeadm.yaml</code> 预先在各个服务器节点上拉取所 k8s 需要的容器镜像。</p>
<p>配置文件准备好过后，可以使用如下命令先将相关镜像 pull 下面：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubeadm config images pull --config kubeadm.yaml</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/k8sxio/kube-apiserver:v1.22.2</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/k8sxio/kube-controller-manager:v1.22.2</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/k8sxio/kube-scheduler:v1.22.2</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/k8sxio/kube-proxy:v1.22.2</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/k8sxio/pause:3.5</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/k8sxio/etcd:3.5.0-0</span><br><span class="line">failed to pull image &quot;registry.aliyuncs.com/k8sxio/coredns:v1.8.4&quot;: output: time=&quot;2021-10-25T17:34:48+08:00&quot; level=fatal msg=&quot;pulling image: rpc error: code = NotFound desc = failed to pull and unpack image \&quot;registry.aliyuncs.com/k8sxio/coredns:v1.8.4\&quot;: failed to resolve reference \&quot;registry.aliyuncs.com/k8sxio/coredns:v1.8.4\&quot;: registry.aliyuncs.com/k8sxio/coredns:v1.8.4: not found&quot;</span><br><span class="line">, error: exit status 1</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure>



<p>上面在拉取 <code>coredns</code> 镜像的时候出错了，没有找到这个镜像，我们可以手动 pull 该镜像，然后重新 tag 下镜像地址即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ctr -n k8s.io i pull docker.io/coredns/coredns:1.8.4</span><br><span class="line">docker.io/coredns/coredns:1.8.4:                                                  resolved       |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">index-sha256:6e5a02c21641597998b4be7cb5eb1e7b02c0d8d23cce4dd09f4682d463798890:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">manifest-sha256:10683d82b024a58cc248c468c2632f9d1b260500f7cd9bb8e73f751048d7d6d4: done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:bc38a22c706b427217bcbd1a7ac7c8873e75efdd0e59d6b9f069b4b243db4b4b:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">config-sha256:8d147537fb7d1ac8895da4d55a5e53621949981e2e6460976dae812f83d84a44:   done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:c6568d217a0023041ef9f729e8836b19f863bcdb612bb3a329ebc165539f5a80:    exists         |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">elapsed: 12.4s                                                                    total:  12.0 M (991.3 KiB/s)</span><br><span class="line">unpacking linux/amd64 sha256:6e5a02c21641597998b4be7cb5eb1e7b02c0d8d23cce4dd09f4682d463798890...</span><br><span class="line">done: 410.185888ms</span><br><span class="line">➜  ~ ctr -n k8s.io i tag docker.io/coredns/coredns:1.8.4 registry.aliyuncs.com/k8sxio/coredns:v1.8.4</span><br></pre></td></tr></table></figure>



<p>然后就可以使用上面的配置文件在 master 节点上进行初始化：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubeadm init --config kubeadm.yaml</span><br><span class="line">[init] Using Kubernetes version: v1.22.2</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;</span><br><span class="line">[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[certs] Generating &quot;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local master1] and IPs [10.96.0.1 192.168.31.31]</span><br><span class="line">[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/server&quot; certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [localhost master1] and IPs [192.168.31.31 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/peer&quot; certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [localhost master1] and IPs [192.168.31.31 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;sa&quot; key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 12.004224 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config-1.22&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node master1 as control-plane by adding the labels: [node-role.kubernetes.io/master(deprecated) node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers]</span><br><span class="line">[mark-control-plane] Marking the node master1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: abcdef.0123456789abcdef</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.31.31:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:ca0c87226c69309d7779096c15b6a41e14b077baf4650bfdb6f9d3178d4da645</span><br></pre></td></tr></table></figure>



<p>根据安装提示拷贝 kubeconfig 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mkdir -p $HOME/.kube</span><br><span class="line">➜  ~ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">➜  ~ sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>



<p>然后可以使用 kubectl 命令查看 master 节点已经初始化成功了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES                  AGE   VERSION</span><br><span class="line">master1   Ready    control-plane,master   41s   v1.22.2</span><br></pre></td></tr></table></figure>



<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>记住初始化集群上面的配置和操作要提前做好，将 master 节点上面的 <code>$HOME/.kube/config</code> 文件拷贝到 node 节点对应的文件中，安装 kubeadm、kubelet、kubectl（可选），然后执行上面初始化完成后提示的 join 命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubeadm join 192.168.31.31:6443 --token abcdef.0123456789abcdef \</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">--discovery-token-ca-cert-hash sha256:ca0c87226c69309d7779096c15b6a41e14b077baf4650bfdb6f9d3178d4da645</span></span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure>



<p>重新获取 join 命令</p>
<p>如果忘记了上面的 join 命令可以使用命令<code>kubeadm token create --print-join-command</code> 重新获取。</p>
<p>执行成功后运行 get nodes 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES                  AGE     VERSION</span><br><span class="line">master1   Ready    control-plane,master   2m35s   v1.22.2</span><br><span class="line">node1     Ready    &lt;none&gt;                 45s     v1.22.2</span><br></pre></td></tr></table></figure>



<p>这个时候其实集群还不能正常使用，因为还没有安装网络插件，接下来安装网络插件，可以在文档 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/</a> 中选择我们自己的网络插件，这里我们安装 flannel:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有节点是多网卡，则需要在资源清单文件中指定内网网卡</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索到名为 kube-flannel-ds 的 DaemonSet，在kube-flannel容器下面</span></span><br><span class="line">➜  ~ vi kube-flannel.yml</span><br><span class="line">......</span><br><span class="line">containers:</span><br><span class="line">- name: kube-flannel</span><br><span class="line">  image: quay.io/coreos/flannel:v0.15.0</span><br><span class="line">  command:</span><br><span class="line">  - /opt/bin/flanneld</span><br><span class="line">  args:</span><br><span class="line">  - --ip-masq</span><br><span class="line">  - --kube-subnet-mgr</span><br><span class="line">  - --iface=eth0  # 如果是多网卡的话，指定内网网卡的名称</span><br><span class="line">......</span><br><span class="line">➜  ~ kubectl apply -f kube-flannel.yml  # 安装 flannel 网络插件</span><br></pre></td></tr></table></figure>



<p>隔一会儿查看 Pod 运行状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get pods -n kube-system</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-7568f67dbd-5mg59         1/1     Running   0          8m32s</span><br><span class="line">coredns-7568f67dbd-b685t         1/1     Running   0          8m31s</span><br><span class="line">etcd-master                      1/1     Running   0          66m</span><br><span class="line">kube-apiserver-master            1/1     Running   0          66m</span><br><span class="line">kube-controller-manager-master   1/1     Running   0          66m</span><br><span class="line">kube-flannel-ds-dsbt6            1/1     Running   0          11m</span><br><span class="line">kube-flannel-ds-zwlm6            1/1     Running   0          11m</span><br><span class="line">kube-proxy-jq84n                 1/1     Running   0          66m</span><br><span class="line">kube-proxy-x4hbv                 1/1     Running   0          19m</span><br><span class="line">kube-scheduler-master            1/1     Running   0          66m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们部署完网络插件后执行 ifconfig 命令，正常会看到新增的<code>cni0</code>与 <code>flannel1</code>这两个虚拟设备，但是如果没有看到 <code>cni0</code>这个设备也不用太担心，我们可以观察 <code>/var/lib/cni</code>目录是否存在，如果不存在并不是说部署有问题，而是该节点上暂时还没有应用运行，我们只需要在该节点上运行一个 Pod 就可以看到该目录会被创建，并且 <code>cni0</code>设备也会被创建出来。</p>
<p>用同样的方法添加另外一个节点即可。</p>
<h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><p><code>v1.22.2</code> 版本的集群需要安装最新的 2.0+ 版本的 Dashboard：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推荐使用下面这种方式</span></span><br><span class="line">➜  ~ wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml</span><br><span class="line">➜  ~ vi recommended.yaml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改Service为NodePort类型</span></span><br><span class="line">......</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  type: NodePort  # 加上type=NodePort变成NodePort类型的服务</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>在 YAML 文件中可以看到新版本 Dashboard 集成了一个 metrics-scraper 的组件，可以通过 Kubernetes 的 Metrics API 收集一些基础资源的监控信息，并在 web 页面上展示，所以要想在页面上展示监控信息就需要提供 Metrics API，比如安装 Metrics Server。</p>
<p>直接创建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f recommended.yaml</span><br></pre></td></tr></table></figure>

<p>新版本的 Dashboard 会被默认安装在 kubernetes-dashboard 这个命名空间下面：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get pods -n kubernetes-dashboard -o wide</span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE   IP          NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">dashboard-metrics-scraper-856586f554-pllvt   1/1     Running   0          24m   10.88.0.7   master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubernetes-dashboard-76597d7df5-82998        1/1     Running   0          21m   10.88.0.2   node2    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>我们仔细看可以发现上面的 Pod 分配的 IP 段是 <code>10.88.xx.xx</code>，包括前面自动安装的 CoreDNS 也是如此，我们前面不是配置的 podSubnet 为 <code>10.244.0.0/16</code> 吗？我们先去查看下 CNI 的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ls -la /etc/cni/net.d/</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x  2 1001 docker  67 Aug 31 16:45 .</span><br><span class="line">drwxr-xr-x. 3 1001 docker  19 Jul 30 01:13 ..</span><br><span class="line">-rw-r--r--  1 1001 docker 604 Jul 30 01:13 10-containerd-net.conflist</span><br><span class="line">-rw-r--r--  1 root root   292 Aug 31 16:45 10-flannel.conflist</span><br></pre></td></tr></table></figure>



<p>可以看到里面包含两个配置，一个是 <code>10-containerd-net.conflist</code>，另外一个是我们上面创建的 Flannel 网络插件生成的配置，我们的需求肯定是想使用 Flannel 的这个配置，我们可以查看下 containerd 这个自带的 cni 插件配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /etc/cni/net.d/10-containerd-net.conflist</span><br><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;0.4.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;containerd-net&quot;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">      &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="line">      &quot;isGateway&quot;: true,</span><br><span class="line">      &quot;ipMasq&quot;: true,</span><br><span class="line">      &quot;promiscMode&quot;: true,</span><br><span class="line">      &quot;ipam&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">        &quot;ranges&quot;: [</span><br><span class="line">          [&#123;</span><br><span class="line">            &quot;subnet&quot;: &quot;10.88.0.0/16&quot;</span><br><span class="line">          &#125;],</span><br><span class="line">          [&#123;</span><br><span class="line">            &quot;subnet&quot;: &quot;2001:4860:4860::/64&quot;</span><br><span class="line">          &#125;]</span><br><span class="line">        ],</span><br><span class="line">        &quot;routes&quot;: [</span><br><span class="line">          &#123; &quot;dst&quot;: &quot;0.0.0.0/0&quot; &#125;,</span><br><span class="line">          &#123; &quot;dst&quot;: &quot;::/0&quot; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="line">      &quot;capabilities&quot;: &#123;&quot;portMappings&quot;: true&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面的 IP 段恰好就是 <code>10.88.0.0/16</code>，但是这个 cni 插件类型是 <code>bridge</code> 网络，网桥的名称为 <code>cni0</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ip a</span><br><span class="line">...</span><br><span class="line">6: cni0: &lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 9a:e7:eb:40:e8:66 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.88.0.1/16 brd 10.88.255.255 scope global cni0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 2001:4860:4860::1/64 scope global</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::98e7:ebff:fe40:e866/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但是使用 bridge 网络的容器无法跨多个宿主机进行通信，跨主机通信需要借助其他的 cni 插件，比如上面我们安装的 Flannel，或者 Calico 等等，由于我们这里有两个 cni 配置，所以我们需要将 <code>10-containerd-net.conflist</code> 这个配置删除，因为如果这个目录中有多个 cni 配置文件，kubelet 将会使用按文件名的字典顺序排列的第一个作为配置文件，所以前面默认选择使用的是 <code>containerd-net</code> 这个插件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mv /etc/cni/net.d/10-containerd-net.conflist /etc/cni/net.d/10-containerd-net.conflist.bak</span><br><span class="line">➜  ~ ifconfig cni0 down &amp;&amp; ip link delete cni0</span><br><span class="line">➜  ~ systemctl daemon-reload</span><br><span class="line">➜  ~ systemctl restart containerd kubelet</span><br></pre></td></tr></table></figure>

<p>然后记得重建 coredns 和 dashboard 的 Pod，重建后 Pod 的 IP 地址就正常了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get pods -n kubernetes-dashboard -o wide</span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE   IP           NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">dashboard-metrics-scraper-856586f554-tp8m5   1/1     Running   0          42s   10.244.1.6   node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubernetes-dashboard-76597d7df5-9rmbx        1/1     Running   0          66s   10.244.1.5   node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">➜  ~ kubectl get pods -n kube-system -o wide -l k8s-app=kube-dns</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE     IP           NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-7568f67dbd-n7bfx   1/1     Running   0          5m40s   10.244.1.2   node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-7568f67dbd-plrv8   1/1     Running   0          3m47s   10.244.1.4   node2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>查看 Dashboard 的 NodePort 端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get svc -n kubernetes-dashboard</span><br><span class="line">NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">dashboard-metrics-scraper   ClusterIP   10.99.37.172    &lt;none&gt;        8000/TCP        25m</span><br><span class="line">kubernetes-dashboard        NodePort    10.103.102.27   &lt;none&gt;        443:31050/TCP   25m</span><br></pre></td></tr></table></figure>



<p>然后可以通过上面的 31050 端口去访问 Dashboard，要记住使用 https，Chrome 不生效可以使用 <code>Firefox</code> 测试，如果没有 Firefox 下面打不开页面，可以点击下页面中的 <code>信任证书</code>即可：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/cazr4e.png" alt="信任证书"></p>
<p>信任后就可以访问到 Dashboard 的登录页面了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/8lfobs.png" alt="k8s dashboard login"></p>
<p>然后创建一个具有全局所有权限的用户来登录 Dashboard：(admin.yaml)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure>



<p>直接创建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f admin.yaml</span><br><span class="line">➜  ~ kubectl get secret -n kubernetes-dashboard|grep admin-token</span><br><span class="line">admin-token-lwmmx                  kubernetes.io/service-account-token   3         1d</span><br><span class="line">➜  ~ kubectl get secret admin-token-lwmmx -o jsonpath=&#123;.data.token&#125; -n kubernetes-dashboard |base64 -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会生成一串很长的<span class="built_in">base64</span>后的字符串</span></span><br></pre></td></tr></table></figure>



<p>然后用上面的 base64 解码后的字符串作为 token 登录 Dashboard 即可，新版本还新增了一个暗黑模式：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/fmyv1s.png" alt="k8s dashboard"></p>
<p>最终我们就完成了使用 kubeadm 搭建 v1.22.1 版本的 kubernetes 集群、coredns、ipvs、flannel、containerd。</p>
<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>如果你的集群安装过程中遇到了其他问题，我们可以使用下面的命令来进行重置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubeadm reset</span><br><span class="line">➜  ~ ifconfig cni0 down &amp;&amp; ip link delete cni0</span><br><span class="line">➜  ~ ifconfig flannel.1 down &amp;&amp; ip link delete flannel.1</span><br><span class="line">➜  ~ rm -rf /var/lib/cni/</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Kubernetes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Kubernetes/" class="post-title-link" itemprop="url">Kubernetes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:46:31" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="解释什么是-Kubernetes，并描述其主要组件及其作用"><a href="#解释什么是-Kubernetes，并描述其主要组件及其作用" class="headerlink" title="解释什么是 Kubernetes，并描述其主要组件及其作用"></a>解释什么是 Kubernetes，并描述其主要组件及其作用</h3><h3 id="🤔-分析过程："><a href="#🤔-分析过程：" class="headerlink" title="🤔 分析过程："></a>🤔 分析过程：</h3><p>此问题是考察对Kubernetes整体概念和核心架构的理解。回答此问题的关键在于：</p>
<ol>
<li>首先给出一个精准、高度概括的定义，说明Kubernetes是做什么的。</li>
<li>然后，逻辑清晰地拆解其架构，通常分为<strong>控制平面（Control Plane）</strong>和<strong>工作节点（Node）</strong>两大部分。</li>
<li>最后，逐一解释每个核心组件的功能，并说明它们之间是如何协同工作的。</li>
</ol>
<h3 id="💡-答案生成："><a href="#💡-答案生成：" class="headerlink" title="💡 答案生成："></a>💡 答案生成：</h3><h4 id="1-概念或定义"><a href="#1-概念或定义" class="headerlink" title="1. 概念或定义"></a>1. 概念或定义</h4><p><strong>Kubernetes</strong>（常简称为K8s）是一个开源的、用于<strong>自动化部署、扩展和管理容器化应用程序</strong>的平台。</p>
<p>Kubernetes的核心思想是<strong>“声明式配置”</strong>（Declarative Configuration）和<strong>“自动化”</strong>。开发者只需声明应用程序的“期望状态”（例如，我需要运行我的应用3个副本），Kubernetes就会持续工作，确保集群的“实际状态”与这个“期望状态”保持一致，并能自动处理节点故障、流量分发、服务扩缩容等复杂任务。</p>
<h4 id="2-主要组件及其作用"><a href="#2-主要组件及其作用" class="headerlink" title="2. 主要组件及其作用"></a>2. 主要组件及其作用</h4><p>Kubernetes的架构遵循经典的Master-Slave（现在更常称为Control Plane-Node）模型。</p>
<hr>
<h3 id="A-控制平面组件-Control-Plane-Components"><a href="#A-控制平面组件-Control-Plane-Components" class="headerlink" title="A. 控制平面组件 (Control Plane Components)"></a>A. 控制平面组件 (Control Plane Components)</h3><p>控制平面是集群的大脑，负责做出全局决策（如调度）以及检测和响应集群事件。这些组件可以运行在任何机器上，但为了简单起见，通常会全部启动在同一台（或多台，为了高可用）服务器上。</p>
<p><strong>(1) API Server (<code>kube-apiserver</code>)</strong></p>
<ul>
<li><strong>作用：</strong> <strong>集群的统一入口和网关</strong>。</li>
<li><strong>描述：</strong> 它是控制平面的前端，所有与集群的交互（无论是来自用户<code>kubectl</code>命令、UI界面还是其他组件）都必须通过API Server。它负责处理REST请求，验证请求的合法性，并更新<code>etcd</code>中对应对象的状态。它是整个集群的中枢神经系统。</li>
</ul>
<p><strong>(2) etcd</strong></p>
<ul>
<li><strong>作用：</strong> <strong>集群的分布式键值存储系统</strong>。</li>
<li><strong>描述：</strong> <code>etcd</code>是Kubernetes的“单一事实来源”（Single Source of Truth），用于持久化存储整个集群的所有状态数据，包括Pod、Service、Secret、ConfigMap等所有API对象的配置和状态信息。集群的高可用性严重依赖于<code>etcd</code>的可靠性。</li>
</ul>
<p><strong>(3) Scheduler (<code>kube-scheduler</code>)</strong></p>
<ul>
<li><strong>作用：</strong> <strong>负责Pod的调度</strong>。</li>
<li><strong>描述：</strong> Scheduler持续监视API Server，寻找新创建的、但尚未被分配到节点的Pod。它根据一系列预设的策略（如资源需求、硬件约束、亲和性与反亲和性规则、污点与容忍度等），为这些Pod选择一个最合适的Node来运行。调度器只负责“决策”，不负责“执行”。</li>
</ul>
<p><strong>(4) Controller Manager (<code>kube-controller-manager</code>)</strong></p>
<ul>
<li><strong>作用：</strong> <strong>运行核心的控制器，维护集群状态</strong>。</li>
<li><strong>描述：</strong> 这是】件。每个控制器都是一个独立的进程，负责一个特定的资源。例如：<ul>
<li><strong>Deployment Controller:</strong> 确保Deployment对象所期望的Pod副本数与实际运行的副本数一致。</li>
<li><strong>Node Controller:</strong> 监视节点的状态，负责在节点宕机时进行通知和响应。</li>
<li><strong>Replication Controller:</strong> 维护ReplicaSet中Pod的数量。<br>这些控制器通过API Server监视集群状态，并自动进行修复、扩缩容等操作，以驱动实际状态向期望状态收敛。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="B-节点组件-Node-Components"><a href="#B-节点组件-Node-Components" class="headerlink" title="B. 节点组件 (Node Components)"></a>B. 节点组件 (Node Components)</h3><p>工作节点是集群中的工作负载（即容器化应用）实际运行的地方。每个节点都必须运行以下组件。</p>
<p><strong>(1) Kubelet</strong></p>
<ul>
<li><strong>作用：</strong> <strong>节点上的代理（Agent）</strong>。</li>
<li><strong>描述：</strong> Kubelet是运行在每个节点上的主要代理程序。它从API Server接收该节点上Pod的期望状态（PodSpec），并确保这些Pod中的容器按照期望运行。它直接与容器运行时（Container Runtime）交互，负责Pod的生命周期管理，如启动、停止、监控容器健康状况，并向API Server汇报节点的真实状态。</li>
</ul>
<p><strong>(2) Kube-proxy</strong></p>
<ul>
<li><strong>作用：</strong> <strong>负责节点上的网络代理和负载均衡</strong>。</li>
<li><strong>描述：</strong> Kube-proxy在集群的每个节点上维护网络规则，这些规则允许从集群内部或外部与Pod进行网络通信。它通过修改节点上的<code>iptables</code>或<code>IPVS</code>规则，实现了Kubernetes <code>Service</code>的概念，将发往Service虚拟IP的流量转发到后端正确的Pod上。</li>
</ul>
<p><strong>(3) 容器运行时 (Container Runtime)</strong></p>
<ul>
<li><strong>作用：</strong> <strong>负责运行容器</strong>。</li>
<li><strong>描述：</strong> 这是真正运行容器的软件。Kubernetes是通用的，支持多种符合CRI（Container Runtime Interface）标准的容器运行时，最常见的包括 <strong><code>containerd</code><strong>、</strong>CRI-O</strong>，以及早期的<strong>Docker</strong>。Kubelet通过CRI接口命令容器运行时来拉取镜像、启动和停止容器。</li>
</ul>
<h4 id="3-应用场景-作用"><a href="#3-应用场景-作用" class="headerlink" title="3. 应用场景&#x2F;作用"></a>3. 应用场景&#x2F;作用</h4><p>Kubernetes 作为一个平台，其主要作用是：</p>
<ul>
<li><strong>服务发现和负载均衡:</strong> 自动为Pod分配IP和DNS名称，并能在它们之间进行负载均衡。</li>
<li><strong>自动化的滚动更新和回滚:</strong> 可以逐步更新应用，如果出现问题，也能自动回滚到上一个版本。</li>
<li><strong>自动装箱:</strong> 根据资源需求自动将容器放置在最佳节点上，提高资源利用率。</li>
<li><strong>自我修复:</strong> 能够重新启动失败的容器、替换Pod、杀死不健康的容器，并在节点死亡时重新调度Pod。</li>
<li><strong>密钥和配置管理:</strong> 允许存储和管理敏感信息（如密码、令牌）和应用配置，而无需重新构建镜像。</li>
</ul>
<h4 id="4-扩展知识-最佳实践"><a href="#4-扩展知识-最佳实践" class="headerlink" title="4. 扩展知识&#x2F;最佳实践"></a>4. 扩展知识&#x2F;最佳实践</h4><ul>
<li><strong>高可用性（HA）:</strong> 在生产环境中，控制平面组件（特别是<code>kube-apiserver</code>和<code>etcd</code>）必须以多副本方式部署，以避免单点故障。</li>
<li><strong>声明式API:</strong> 理解Kubernetes的声明式本质是关键。用户关注的是“What”（我想要什么），而不是“How”（具体怎么做），这极大地简化了运维工作。</li>
<li><strong>可扩展性:</strong> Kubernetes的强大之处在于其可扩展性。通过自定义资源定义（CRD）和Operator模式，社区可以像扩展原生API一样，为Kubernetes添加新的功能（如数据库管理、消息队列集群等）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/LInux%20%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/LInux%20%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">LInux 安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:46:39" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Manage/" itemprop="url" rel="index"><span itemprop="name">Manage</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="常见的网络攻击类型"><a href="#常见的网络攻击类型" class="headerlink" title="常见的网络攻击类型"></a>常见的网络攻击类型</h3><h3 id="1-CC-攻击-Challenge-Collapsar"><a href="#1-CC-攻击-Challenge-Collapsar" class="headerlink" title="1. CC 攻击 (Challenge Collapsar)"></a>1. CC 攻击 (Challenge Collapsar)</h3><p><strong>CC 攻击</strong> 是 <strong>应用层攻击</strong> 的一种，主要针对 Web 服务器的 <strong>应用层</strong>，通过模拟大量真实用户访问行为，耗尽服务器的处理资源。它的目标是让网站无法正常响应合法用户的请求。</p>
<p><strong>攻击原理：</strong><br>CC 攻击通常会伪造大量的 IP 地址，向目标网站的同一个页面或多个页面发送大量<strong>合法的 HTTP 请求</strong>。这些请求通常是动态页面（如登录页面、搜索页面、提交表单页面等），因为动态页面的处理需要服务器执行复杂的计算、查询数据库、调用后端程序，这会消耗大量的 CPU、内存和数据库资源。</p>
<ul>
<li><strong>模拟真实用户行为：</strong> 攻击者会模拟用户的 GET 或 POST 请求，可能包括浏览器头、Referer 等信息，使得这些请求看起来像是正常的访问。</li>
<li><strong>高并发请求：</strong> 在短时间内发送海量的请求，使服务器的连接数、并发处理能力达到上限。</li>
<li><strong>耗尽服务器资源：</strong> 导致服务器处理请求队列堆积，CPU 负载过高，内存耗尽，数据库连接池饱和，最终表现为网站响应缓慢或直接崩溃，无法服务正常用户。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>隐蔽性相对较高：</strong> 请求包本身是合法的 HTTP 请求，难以通过简单的防火墙规则过滤。</li>
<li><strong>成本较低：</strong> 攻击者可以使用僵尸网络（Botnet）发动攻击，或者自己编写脚本模拟请求。</li>
<li><strong>针对应用层：</strong> 专注于消耗服务器的应用层处理能力，而非网络带宽。</li>
</ul>
<p><strong>防范思路（运维角度）：</strong></p>
<ul>
<li><strong>Web 应用防火墙 (WAF)：</strong> WAF 可以识别和过滤恶意请求，例如基于行为模式、IP 信誉库、请求频率等。</li>
<li><strong>CDN (内容分发网络)：</strong> CDN 可以分散请求，并提供DDoS&#x2F;CC防护能力。</li>
<li><strong>负载均衡：</strong> 将流量分散到多台服务器，提高整体处理能力。</li>
<li><strong>请求频率限制：</strong> 限制单个 IP 在单位时间内的请求次数。</li>
<li><strong>验证码&#x2F;人机验证：</strong> 在高频访问或关键操作处引入验证码（如 Google reCAPTCHA），区分人与机器。</li>
<li><strong>优化服务器配置：</strong> 优化 Web 服务器（Nginx&#x2F;Apache）配置，如连接数、超时时间等。</li>
<li><strong>代码优化：</strong> 提高网站程序的处理效率，减少数据库查询和复杂运算。</li>
<li><strong>IP 黑白名单：</strong> 识别并封禁恶意 IP，或允许已知信誉良好的 IP。</li>
</ul>
<h3 id="2-DDoS-攻击-Distributed-Denial-of-Service-Attack"><a href="#2-DDoS-攻击-Distributed-Denial-of-Service-Attack" class="headerlink" title="2. DDoS 攻击 (Distributed Denial of Service Attack)"></a>2. DDoS 攻击 (Distributed Denial of Service Attack)</h3><p><strong>DDoS 攻击</strong> 是 <strong>分布式拒绝服务攻击</strong> 的缩写。它是一种利用大量的“傀儡机”或“僵尸网络”从多个不同地理位置同时发起攻击，以超负荷的流量或请求淹没目标服务器或网络，使其无法提供正常服务的攻击方式。</p>
<p><strong>攻击原理：</strong><br>DDoS 攻击的本质是“量”的攻击。攻击者通常会控制大量的受感染计算机（僵尸网络），形成一个庞大的攻击集群。然后，这些僵尸计算机同时向目标发起攻击，可以是：</p>
<ul>
<li><strong>带宽消耗型攻击：</strong> 发送大量无意义的流量（如 UDP Flood, ICMP Flood），直接耗尽目标网络的带宽，导致所有正常流量都无法通过。</li>
<li><strong>协议消耗型攻击：</strong> 利用网络协议的缺陷，发送畸形包或大量半连接请求（如 SYN Flood），耗尽服务器的连接表或协议栈资源。</li>
<li><strong>应用层攻击：</strong> 除了之前提到的 CC 攻击（本身就是应用层 DDoS 的一种），还有其他更复杂的应用层攻击，通过模拟合法用户行为，耗尽应用服务器资源。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>分布式：</strong> 攻击源分散在世界各地，难以追溯和简单封禁。</li>
<li><strong>攻击流量巨大：</strong> 可以是单个攻击者无法比拟的巨大流量，可能达到数 Tbps。</li>
<li><strong>范围广：</strong> 可以攻击网络的各个层面（L3, L4, L7）。</li>
<li><strong>目的直接：</strong> 使目标服务彻底不可用，造成业务中断和经济损失。</li>
</ul>
<p><strong>防范思路（运维角度）：</strong><br>DDoS 防御是一个复杂的多层次工程：</p>
<ul>
<li><strong>流量清洗服务：</strong> 部署专业的 DDoS 清洗服务（如高防 IP、云服务商提供的 DDoS 防护服务）。这些服务在流量到达您的源站之前，通过高速识别和过滤技术，清洗掉恶意流量。</li>
<li><strong>防火墙和路由器 ACLs：</strong> 配置路由器和防火墙的访问控制列表，限制不必要的端口，过滤已知恶意 IP。</li>
<li><strong>入侵检测&#x2F;防御系统 (IDS&#x2F;IPS)：</strong> 实时监控网络流量，识别异常模式并采取防御措施。</li>
<li><strong>CDN：</strong> 作为第一道防线，分发流量，隐藏源站 IP，吸收部分攻击。</li>
<li><strong>负载均衡和集群：</strong> 增加后端服务器的数量和处理能力，提高对流量洪峰的承受力。</li>
<li><strong>带宽扩容：</strong> 在经济条件允许的情况下，尽可能增加运营商接入带宽。</li>
<li><strong>应急响应计划：</strong> 提前制定 DDoS 攻击的应急响应流程，包括流量分析、切换清洗服务、联系运营商等。</li>
<li><strong>安全意识和系统加固：</strong> 防止自己的服务器成为僵尸网络的一部分。</li>
</ul>
<h3 id="3-网站数据库注入-SQL-Injection"><a href="#3-网站数据库注入-SQL-Injection" class="headerlink" title="3. 网站数据库注入 (SQL Injection)"></a>3. 网站数据库注入 (SQL Injection)</h3><p><strong>数据库注入</strong> 是一种 <strong>代码注入技术</strong>，攻击者通过在 Web 应用的输入接口中插入恶意的 SQL（Structured Query Language）代码，来绕过应用程序的安全验证，执行非授权的数据库操作。最常见的是 <strong>SQL 注入</strong>。</p>
<p><strong>攻击原理：</strong><br>当网站应用程序在构建数据库查询时，如果直接将用户输入的数据拼接到 SQL 语句中，而没有进行充分的验证和过滤，攻击者就可以通过巧妙构造输入内容，改变原有 SQL 语句的逻辑。</p>
<p><strong>例如，一个登录验证的 SQL 语句可能是这样的：</strong><br><code>SELECT * FROM users WHERE username = &#39;用户输入&#39; AND password = &#39;用户输入的密码&#39;</code></p>
<p><strong>攻击者在用户名输入框中输入：</strong><br><code>admin&#39; OR &#39;1&#39;=&#39;1</code></p>
<p><strong>原本的 SQL 语句就会变成：</strong><br><code>SELECT * FROM users WHERE username = &#39;admin&#39; OR &#39;1&#39;=&#39;1&#39; AND password = &#39;用户输入的密码&#39;</code></p>
<p>由于 <code>&#39;1&#39;=&#39;1&#39;</code> 永远为真，这个查询语句就会绕过密码验证，直接返回 <code>admin</code> 用户的数据，从而实现无需密码登录。</p>
<p><strong>更严重的攻击手段：</strong></p>
<ul>
<li><strong>获取敏感数据：</strong> 攻击者可以利用注入语句查询其他表格的数据（如用户信息、订单信息等）。</li>
<li><strong>修改或删除数据：</strong> 使用 <code>UPDATE</code> 或 <code>DELETE</code> 语句修改甚至删除数据库中的关键数据。</li>
<li><strong>执行系统命令：</strong> 在某些配置不当的数据库服务器上，甚至可以通过注入语句执行操作系统的命令，获取服务器控制权。</li>
<li><strong>绕过认证：</strong> 如上述登录绕过。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>针对应用程序漏洞：</strong> 攻击的是应用程序层面的编程错误。</li>
<li><strong>危害巨大：</strong> 可能导致数据泄露、数据篡改、数据丢失，甚至服务器被完全控制。</li>
<li><strong>攻击面广：</strong> 任何与数据库交互的用户输入点都可能存在注入风险。</li>
</ul>
<p><strong>防范思路（运维与开发协作）：</strong><br>虽然 SQL 注入主要是开发人员的责任，但作为运维工程师，我们也有助于推动和部署相关安全措施：</p>
<ol>
<li><strong>参数化查询 (Prepared Statements)：</strong> <strong>这是最有效且推荐的方法</strong>。使用预编译语句或参数化查询，将用户输入作为参数传递，而不是直接拼接在 SQL 语句中。这样数据库会区分代码和数据，不会将用户输入解析为 SQL 命令。<ul>
<li><strong>开发必须采用这种方式。</strong></li>
</ul>
</li>
<li><strong>输入验证和过滤：</strong><ul>
<li><strong>白名单验证：</strong> 只允许合法的字符集、数据类型和格式通过。</li>
<li><strong>黑名单过滤：</strong> 过滤或转义常见的 SQL 关键字和特殊字符（如单引号 <code>&#39;</code>、双引号 <code>&quot;</code>、分号 <code>;</code>、注释符 <code>--</code>、<code>/* */</code> 等）。但<strong>不建议单独依赖黑名单过滤</strong>，因为它很容易被绕过。</li>
</ul>
</li>
<li><strong>最小权限原则：</strong><ul>
<li>数据库用户（应用程序连接数据库的用户）只授予其执行必要操作的最小权限。例如，一个读取数据的模块，就只给 <code>SELECT</code> 权限，不给 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 权限。</li>
</ul>
</li>
<li><strong>Web 应用防火墙 (WAF)：</strong> WAF 可以识别和阻止常见的 SQL 注入攻击模式，它能在应用层面对请求进行深度检测。</li>
<li><strong>错误信息处理：</strong> 不要向用户暴露详细的数据库错误信息，这可能泄露数据库结构和敏感信息，帮助攻击者构造注入语句。</li>
<li><strong>定期安全审计和代码审查：</strong> 定期进行代码审查和渗透测试，发现并修复潜在的注入漏洞。</li>
<li><strong>数据库安全配置：</strong> 禁用不安全的数据库特性，如 <code>xp_cmdshell</code> (SQL Server) 或 <code>LOAD_FILE</code> (MySQL)，这些可能被利用来执行系统命令。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Linux%20iostat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Linux%20iostat/" class="post-title-link" itemprop="url">Linux iostat</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:47:52" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/%E6%80%A7%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">性能</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>iostat</code> 是 <strong>Linux sysstat 工具集</strong>中的一个命令，主要用于 <strong>CPU 使用情况</strong> 和 <strong>磁盘 I&#x2F;O 统计</strong>。<br> 它通常用来排查 <strong>磁盘性能瓶颈</strong> 或 <strong>CPU 负载问题</strong>。</p>
<hr>
<h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat [选项] [间隔] [次数]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>间隔</strong>：两次采样之间的秒数</li>
<li><strong>次数</strong>：采样次数</li>
<li>如果不加参数，只显示一次从系统启动以来的平均统计</li>
</ul>
<hr>
<h2 id="二、常用选项"><a href="#二、常用选项" class="headerlink" title="二、常用选项"></a>二、常用选项</h2><ul>
<li>**<code>-c</code>**：只显示 CPU 统计信息</li>
<li>**<code>-d</code>**：只显示磁盘设备统计信息</li>
<li>**<code>-x</code>**：显示扩展统计信息（更详细的磁盘指标）</li>
<li>**<code>-p [设备]</code>**：显示指定设备的分区统计</li>
<li>**<code>-k</code> &#x2F; <code>-m</code>**：以 KB&#x2F;s 或 MB&#x2F;s 显示数据传输速率</li>
<li>**<code>-N</code>**：显示 LVM 的统计信息</li>
<li>**<code>-t</code>**：显示时间戳</li>
</ul>
<hr>
<h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><ol>
<li><strong>查看所有 CPU 和磁盘的 I&#x2F;O 统计</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>每隔 2 秒更新一次 CPU 和磁盘统计，显示 5 次</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat 2 5</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>只看 CPU 使用率</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -c 1 3</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>只看磁盘 I&#x2F;O</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d 1 3</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>查看更详细的磁盘 I&#x2F;O 信息</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x 1 5</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>指定某个磁盘（如 sda）</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -p sda 2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、输出字段解释"><a href="#四、输出字段解释" class="headerlink" title="四、输出字段解释"></a>四、输出字段解释</h2><h3 id="CPU-部分"><a href="#CPU-部分" class="headerlink" title="CPU 部分"></a>CPU 部分</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">avg</span>-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">          <span class="attribute">5</span>.<span class="number">23</span>    <span class="number">0</span>.<span class="number">01</span>    <span class="number">1</span>.<span class="number">22</span>    <span class="number">0</span>.<span class="number">11</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">93</span>.<span class="number">43</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>%user</strong>：用户态 CPU 使用率</li>
<li><strong>%nice</strong>：调整过优先级的用户进程 CPU 使用率</li>
<li><strong>%system</strong>：内核态 CPU 使用率</li>
<li><strong>%iowait</strong>：等待 I&#x2F;O 的 CPU 时间百分比（高说明磁盘可能是瓶颈）</li>
<li><strong>%steal</strong>：虚拟机被其他 VM 占用的 CPU 时间</li>
<li><strong>%idle</strong>：CPU 空闲时间</li>
</ul>
<h3 id="磁盘部分"><a href="#磁盘部分" class="headerlink" title="磁盘部分"></a>磁盘部分</h3><p>（普通模式 <code>-d</code>）</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line"><span class="attribute">sda</span>              <span class="number">12</span>.<span class="number">35</span>       <span class="number">1024</span>.<span class="number">5</span>       <span class="number">2048</span>.<span class="number">2</span>   <span class="number">12345678</span>   <span class="number">98765432</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>tps</strong>：每秒 I&#x2F;O 请求次数</li>
<li><strong>kB_read&#x2F;s</strong>：每秒读数据量</li>
<li><strong>kB_wrtn&#x2F;s</strong>：每秒写数据量</li>
<li><strong>kB_read &#x2F; kB_wrtn</strong>：累计读写数据量</li>
</ul>
<p>（扩展模式 <code>-x</code>）</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>:         rrqm/s   wrqm/s     r/s     w/s   rkB/s   wkB/s  avgrq-sz avgqu-sz await r_await w_await svctm  %util</span><br><span class="line"><span class="attribute">sda</span>               <span class="number">0</span>.<span class="number">00</span>     <span class="number">1</span>.<span class="number">23</span>   <span class="number">10</span>.<span class="number">45</span>   <span class="number">20</span>.<span class="number">12</span>  <span class="number">512</span>.<span class="number">34</span> <span class="number">1024</span>.<span class="number">56</span>    <span class="number">80</span>.<span class="number">45</span>     <span class="number">1</span>.<span class="number">02</span>  <span class="number">15</span>.<span class="number">23</span>  <span class="number">12</span>.<span class="number">34</span>  <span class="number">17</span>.<span class="number">89</span>   <span class="number">2</span>.<span class="number">50</span>  <span class="number">76</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>r&#x2F;s, w&#x2F;s</strong>：每秒读&#x2F;写请求次数</li>
<li><strong>rkB&#x2F;s, wkB&#x2F;s</strong>：每秒读写 KB 数</li>
<li><strong>avgrq-sz</strong>：平均每次 I&#x2F;O 的数据大小（扇区数）</li>
<li><strong>avgqu-sz</strong>：平均请求队列长度</li>
<li><strong>await</strong>：I&#x2F;O 请求平均等待时间（毫秒，含排队+服务时间）</li>
<li><strong>r_await &#x2F; w_await</strong>：读 &#x2F; 写请求的平均等待时间</li>
<li><strong>svctm</strong>：I&#x2F;O 请求的平均服务时间（毫秒）</li>
<li><strong>%util</strong>：设备利用率（接近 100% 说明磁盘可能成为瓶颈）</li>
</ul>
<hr>
<h2 id="五、常见应用场景"><a href="#五、常见应用场景" class="headerlink" title="五、常见应用场景"></a>五、常见应用场景</h2><ul>
<li><strong>排查 CPU 问题</strong>：查看 <code>%iowait</code> 是否过高</li>
<li><strong>分析磁盘性能</strong>：通过 <code>await</code>、<code>%util</code> 判断磁盘是否成为瓶颈</li>
<li><strong>对比不同磁盘性能</strong>：多个设备的 I&#x2F;O 负载均衡情况</li>
<li><strong>长期监控</strong>：结合 <code>iostat 1 &gt;&gt; io.log</code> 做日志分析</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Linux%20pidstat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Linux%20pidstat/" class="post-title-link" itemprop="url">Linux pidstat</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:47:56" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/%E6%80%A7%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">性能</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>837</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>pidstat</code> 是 <strong>Linux 下 sysstat 工具集</strong>中的一个命令，用来监控指定进程（PID）的各种运行指标，常用于排查性能问题。它比 <code>top</code> 更细粒度，可以按进程或线程输出统计信息。</p>
<hr>
<h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat [选项] [时间间隔] [次数]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间间隔</strong>：两次采样之间的秒数</li>
<li><strong>次数</strong>：采样的次数</li>
<li>如果不加时间间隔和次数，只输出一次快照</li>
</ul>
<hr>
<h2 id="二、常用选项"><a href="#二、常用选项" class="headerlink" title="二、常用选项"></a>二、常用选项</h2><ul>
<li>**<code>-u</code>**：显示 CPU 使用情况（默认）</li>
<li>**<code>-r</code>**：显示内存使用情况（RSS、VSZ、内存比例等）</li>
<li>**<code>-d</code>**：显示 I&#x2F;O 使用情况（读写速率）</li>
<li>**<code>-w</code>**：显示上下文切换情况（自愿&#x2F;非自愿）</li>
<li>**<code>-t</code>**：显示线程级别统计（默认是进程级别）</li>
<li>**<code>-p &lt;pid&gt;</code>**：指定进程 PID（否则显示所有进程）</li>
<li>**<code>-h</code>**：以更易读的方式显示时间（hh:mm:ss 格式）</li>
</ul>
<hr>
<h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><ol>
<li><strong>监控所有进程的 CPU 使用情况，每隔 2 秒，采集 5 次</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 2 5</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>监控某个进程（PID&#x3D;1234）的 CPU 和内存情况</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u -r -p 1234 1</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>监控所有进程的 I&#x2F;O 使用情况</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -d 2</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>查看线程级别的 CPU 使用情况</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -t -u -p 1234 1</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>统计上下文切换</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -w 1</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、输出字段解释（示例：pidstat-u）"><a href="#四、输出字段解释（示例：pidstat-u）" class="headerlink" title="四、输出字段解释（示例：pidstat -u）"></a>四、输出字段解释（示例：<code>pidstat -u</code>）</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">08</span>:<span class="number">41</span>:<span class="number">03</span> PM   UID   PID  %usr %system  %guest  %CPU   CPU  Command</span><br><span class="line"><span class="attribute">08</span>:<span class="number">41</span>:<span class="number">04</span> PM     <span class="number">0</span>  <span class="number">1234</span>  <span class="number">5</span>.<span class="number">00</span>    <span class="number">1</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">6</span>.<span class="number">00</span>     <span class="number">1</span>  nginx</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>UID</strong>：进程所属用户 ID</li>
<li><strong>PID</strong>：进程号</li>
<li><strong>%usr</strong>：用户态 CPU 使用率</li>
<li><strong>%system</strong>：内核态 CPU 使用率</li>
<li><strong>%guest</strong>：运行虚拟 CPU 的时间</li>
<li><strong>%CPU</strong>：进程总 CPU 使用率</li>
<li><strong>CPU</strong>：进程运行在哪个 CPU 上</li>
<li><strong>Command</strong>：命令名称</li>
</ul>
<hr>
<h2 id="五、常见应用场景"><a href="#五、常见应用场景" class="headerlink" title="五、常见应用场景"></a>五、常见应用场景</h2><ul>
<li>精确定位某个进程的 <strong>CPU 消耗</strong>（比 <code>top</code> 更直观）</li>
<li>分析进程的 <strong>内存占用趋势</strong></li>
<li>查看进程的 <strong>磁盘 I&#x2F;O 行为</strong></li>
<li>调查进程的 <strong>上下文切换频率</strong>（排查线程切换过多问题）</li>
<li>按 <strong>线程</strong> 维度分析性能瓶颈</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Linux%20Selinux%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Linux%20Selinux%20/" class="post-title-link" itemprop="url">Linux Selinux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:48:01" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Command/" itemprop="url" rel="index"><span itemprop="name">Command</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="SELinux-Security-Enhanced-Linux"><a href="#SELinux-Security-Enhanced-Linux" class="headerlink" title="SELinux (Security-Enhanced Linux)"></a>SELinux (Security-Enhanced Linux)</h3><p>SELinux 是 Linux 系统中一个非常强大的安全模块，它提供了强制访问控制（Mandatory Access Control, MAC）机制，极大地增强了系统的安全性。理解 SELinux 的工作原理和作用，对于构建健壮安全的 Linux 环境至关重要。</p>
<hr>
<h3 id="一、什么是-SELinux？"><a href="#一、什么是-SELinux？" class="headerlink" title="一、什么是 SELinux？"></a>一、什么是 SELinux？</h3><p>SELinux 是美国国家安全局（NSA）和 Red Hat 公司合作开发的一个 Linux 内核安全模块。它在 Linux 标准的自主访问控制（Discretionary Access Control, DAC）权限模型之上，添加了一层更细粒度、更严格的访问控制机制。</p>
<p><strong>DAC vs. MAC (SELinux):</strong></p>
<ul>
<li><strong>自主访问控制 (DAC)：</strong> 这是传统的 Linux 权限模型。文件的所有者可以决定谁可以访问他们的文件（读、写、执行）。例如，一个用户不能删除另一个用户的文件，除非对方赋予了删除权限。DAC 的弱点在于，如果一个应用程序被攻破，攻击者就可以以该应用程序的权限为所欲为，因为 DAC 只关心用户和进程的身份，不关心它们的行为。</li>
<li><strong>强制访问控制 (MAC &#x2F; SELinux)：</strong> SELinux 不仅仅依赖于用户和文件所有者的身份。它为文件、目录、端口、进程等系统资源都分配了安全上下文（Security Context），然后根据预定义的策略规则，强制所有进程的访问行为都必须符合这些规则。即使是 <code>root</code> 用户或被入侵的应用程序，其行为也必须受到 SELinux 策略的约束。这意味着，如果一个 Web 服务器被攻破，即使攻击者获得了 Web 服务器进程的权限，SELinux 也可能阻止该进程去访问它不应该访问的文件（比如 <code>/etc/passwd</code>）或执行它不应该执行的操作（比如监听非 HTTP 端口），从而限制了攻击者的破坏范围。</li>
</ul>
<p>简而言之，SELinux 像一个守卫森严的门卫系统，它不仅仅看你有没有钥匙（DAC），它还要看你是什么身份（安全上下文），以及你在试图进入哪个房间（目标资源的安全上下文），并根据事先规定好的详细规则（策略）来决定是否允许你进入或操作。</p>
<hr>
<h3 id="二、SELinux-的作用"><a href="#二、SELinux-的作用" class="headerlink" title="二、SELinux 的作用"></a>二、SELinux 的作用</h3><p>SELinux 在 Linux 系统中的核心作用是<strong>增强系统的安全性，限制潜在的损害</strong>。具体体现在以下几个方面：</p>
<ol>
<li><p><strong>强制访问控制 (MAC)：</strong> 这是最核心的作用。SELinux 定义了详细的规则集（策略），规定了哪些进程可以访问哪些资源（文件、目录、套接字、端口等）。即使进程拥有 DAC 权限，如果没有对应的 SELinux 规则允许，访问也会被拒绝。</p>
<ul>
<li><strong>示例：</strong> 通常，HTTP 服务器（如 Apache 或 Nginx）只需要访问特定的 Web 根目录（如 <code>/var/www/html</code>）。即使攻击者利用 Web 服务器漏洞获得了执行代码的权限，SELinux 策略也能阻止 Web 服务器进程去读取 <code>/etc/shadow</code> 或修改 <code>/boot</code> 目录下的文件，因为策略明确禁止了这种行为。</li>
</ul>
</li>
<li><p><strong>最小权限原则：</strong> SELinux 强制实施最小权限原则。进程只能拥有其正常运行所需的最小权限，而不是像 DAC 那样，一个进程拥有用户的所有权限。这大大缩小了攻击面。</p>
</li>
<li><p><strong>防止权限提升：</strong> 即使攻击者成功利用某个应用程序的漏洞，并且获得了该应用程序的进程权限，SELinux 也会阻止该进程进行未经授权的权限提升尝试，因为它的安全上下文定义了其能执行的操作范围。</p>
</li>
<li><p><strong>限制服务：</strong> 每个服务（如 Apache, Nginx, MySQL, SSHD）都有其自己的 SELinux 域（domain），并被分配特定的安全上下文。这些域中的进程只能访问与其角色和功能相关的资源。</p>
<ul>
<li><strong>示例：</strong> SSHD 进程通常只能监听 SSH 端口 (22)，读写用户主目录下的 SSH 相关文件。SELinux 会阻止它尝试监听 Web 端口或访问数据库文件。</li>
</ul>
</li>
<li><p><strong>增强系统完整性：</strong> SELinux 可以防止未经授权的修改系统关键文件和二进制文件，即使是具有高权限的进程也需要符合策略。</p>
</li>
<li><p><strong>防止未知漏洞攻击（零日攻击）：</strong> 由于 SELinux 是基于行为而非身份进行控制，它可以在某种程度上抵御针对已知或未知漏洞的攻击。即使攻击者发明了一种新的攻击方式，只要这种攻击行为违反了事先定义的安全规则，SELinux 就会阻止它。这为系统提供了额外的防御层。</p>
</li>
<li><p><strong>细粒度控制：</strong> SELinux 能够针对非常具体的文件类型和进程类型进行控制。例如，它不仅可以限制 Web 服务器进程不能访问 <code>/etc/passwd</code>，还可以具体到 Web 服务器不能写入 <code>/var/www/html</code> 目录之外的任何文件，除非该文件明确被标记为可写。</p>
</li>
</ol>
<hr>
<h3 id="三、SELinux-的安全上下文"><a href="#三、SELinux-的安全上下文" class="headerlink" title="三、SELinux 的安全上下文"></a>三、SELinux 的安全上下文</h3><p>在 SELinux 中，所有文件、目录、进程、端口等都带有**安全上下文 (Security Context)**。安全上下文通常由三个或四个字段组成，用冒号 <code>:</code> 分隔：</p>
<p><code>user:role:type[:level]</code></p>
<ul>
<li><strong><code>user</code> (用户身份)：</strong> SELinux 用户，通常与 Linux 用户账户不直接对应。如 <code>systeme_u</code> (系统用户), <code>staff_u</code> (管理人员), <code>user_u</code> (普通用户)。</li>
<li><strong><code>role</code> (角色)：</strong> SELinux 角色，定义了用户可以执行的操作集合。如 <code>sysadm_r</code> (系统管理员角色), <code>system_r</code> (系统角色)。</li>
<li><strong><code>type</code> (类型&#x2F;域)：</strong> 这是 SELinux 最重要的部分。它定义了文件或进程的类别。<ul>
<li><strong>文件类型：</strong> 如 <code>httpd_sys_content_t</code> (Web 服务器内容类型), <code>var_log_t</code> (日志文件类型), <code>etc_t</code> (配置文件类型)。</li>
<li><strong>进程域：</strong> 如 <code>httpd_t</code> (Apache 服务器进程域), <code>sshd_t</code> (SSH 服务进程域)。</li>
<li>策略规则正是基于这些类型来定义允许或拒绝的访问。例如，策略会说 <code>httpd_t</code> 进程可以读取 <code>httpd_sys_content_t</code> 类型的文件。</li>
</ul>
</li>
<li><strong><code>level</code> (级别)：</strong> 这是一个可选的多级别安全（MLS）或多类别安全（MCS）组件，用于更高级别的安全策略。如 <code>s0:c0.c1023</code>。</li>
</ul>
<p><strong>查看安全上下文：</strong></p>
<ul>
<li><code>ls -Z &lt;file/directory&gt;</code>：查看文件或目录的安全上下文。</li>
<li><code>ps -Z &lt;PID&gt;</code> 或 <code>ps auxZ</code>：查看进程的安全上下文。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -Z /var/www/html/index.html</span><br><span class="line"><span class="comment"># 输出可能为：-rw-r--r--. username username system_u:object_r:httpd_sys_content_t:s0 /var/www/html/index.html</span></span><br><span class="line"></span><br><span class="line">ps -Z | grep httpd</span><br><span class="line"><span class="comment"># 输出可能为：system_u:system_r:httpd_t:s0     httpd</span></span><br></pre></td></tr></table></figure>
<p>上面的输出表明 <code>index.html</code> 的类型是 <code>httpd_sys_content_t</code>，而 <code>httpd</code> 进程的类型是 <code>httpd_t</code>。SELinux 策略会定义 <code>httpd_t</code> 进程可以访问 <code>httpd_sys_content_t</code> 类型的文件。</p>
<hr>
<h3 id="四、SELinux-的工作模式"><a href="#四、SELinux-的工作模式" class="headerlink" title="四、SELinux 的工作模式"></a>四、SELinux 的工作模式</h3><p>SELinux 可以运行在三种模式下：</p>
<ol>
<li><strong><code>enforcing</code> (强制模式)：</strong> SELinux 策略生效，所有不符合策略规则的操作都会被拒绝。这是生产环境中的推荐模式。</li>
<li><strong><code>permissive</code> (宽容模式)：</strong> SELinux 策略生效，但不会拒绝任何操作。不符合策略规则的操作会被记录到日志中（审计模式），但不会阻止其执行。此模式常用于调试 SELinux 策略或在部署服务前收集潜在的 SELinux 拒绝日志。</li>
<li><strong><code>disabled</code> (禁用模式)：</strong> SELinux 完全禁用，不提供任何安全保护。不推荐在生产环境中使用此模式，因为它剥夺了 SELinux 提供的额外安全层。</li>
</ol>
<p><strong>查看当前模式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sestatus</span><br></pre></td></tr></table></figure>

<p><strong>临时切换模式：</strong></p>
<ul>
<li>切换到宽容模式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> setenforce 0</span><br></pre></td></tr></table></figure></li>
<li>切换到强制模式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> setenforce 1</span><br></pre></td></tr></table></figure>
<strong>注意：</strong> <code>setenforce</code> 命令只在当前运行时生效，系统重启后会恢复到配置文件的模式。</li>
</ul>
<p><strong>永久切换模式：</strong></p>
<p>修改 SELinux 配置文件 <code>/etc/selinux/config</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/selinux/config</span><br></pre></td></tr></table></figure>

<p>将 <code>SELINUX=</code> 后面的值修改为 <code>enforcing</code>, <code>permissive</code>, 或 <code>disabled</code>。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="comment"># SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="comment">#       enforcing - Enforce SELinux policies (default)</span></span><br><span class="line"><span class="comment">#       permissive - Permissive mode (don&#x27;t enforce, just warn)</span></span><br><span class="line"><span class="comment">#       disabled - SELinux disabled</span></span><br><span class="line"><span class="attr">SELINUX</span>=enforcing</span><br><span class="line"><span class="comment"># SELINUXTYPE= can take one of these three values:</span></span><br><span class="line"><span class="comment">#       targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="comment">#                  the rest are left unprotected</span></span><br><span class="line"><span class="comment">#       minimum - Security for selected processes,</span></span><br><span class="line"><span class="comment">#                 plus the ability to customize your own policies</span></span><br><span class="line"><span class="comment">#       mls - Multi Level Security protection.</span></span><br><span class="line"><span class="attr">SELINUXTYPE</span>=targeted</span><br></pre></td></tr></table></figure>
<p>修改后，需要<strong>重启系统</strong>才能使永久配置生效。</p>
<hr>
<h3 id="五、SELinux-的管理与故障排除"><a href="#五、SELinux-的管理与故障排除" class="headerlink" title="五、SELinux 的管理与故障排除"></a>五、SELinux 的管理与故障排除</h3><p>SELinux 的强大也意味着它可能在配置不当时导致服务无法正常运行，因为它会拒绝看似合理的行为。</p>
<ol>
<li><p><strong>审核日志：</strong> 当 SELinux 拒绝一个操作时，它会将事件记录到审计日志中。这是排除 SELinux 相关问题最关键的途径。</p>
<ul>
<li><strong>CentOS&#x2F;RHEL:</strong> 日志通常在 <code>/var/log/audit/audit.log</code></li>
<li><strong>Ubuntu&#x2F;Debian:</strong> 日志通常在 <code>/var/log/kern.log</code> 或 <code>/var/log/syslog</code>，或者需要安装 <code>auditd</code> 服务。</li>
<li>使用 <code>ausearch</code> 工具筛选 SELinux 拒绝事件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ausearch -m AVC -ts today</span><br><span class="line"><span class="comment"># 或者使用 sealert 工具进行分析:</span></span><br><span class="line"><span class="built_in">sudo</span> yum install setroubleshoot-server <span class="comment"># RHEL/CentOS</span></span><br><span class="line"><span class="built_in">sudo</span> apt install setroubleshoot-server <span class="comment"># Ubuntu/Debian</span></span><br><span class="line"><span class="built_in">sudo</span> sealert -a /var/log/audit/audit.log</span><br></pre></td></tr></table></figure>
<code>sealert</code> 会提供更友好的拒绝事件描述，并经常给出解决建议（例如，<code>semanage fcontext</code> 或 <code>setsebool</code> 命令）。</li>
</ul>
</li>
<li><p><strong>管理安全上下文：</strong></p>
<ul>
<li><strong><code>chcon</code>：</strong> 临时改变文件或目录的安全上下文。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chcon</span> -t httpd_sys_content_t /path/to/web/files</span><br></pre></td></tr></table></figure>
<strong>注意：</strong> <code>chcon</code> 是临时的，文件系统重新标签或文件被更新后会恢复，不建议用于持久化配置。</li>
<li><strong><code>restorecon</code>：</strong> 恢复文件或目录到其默认的安全上下文（根据策略文件中的定义）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> restorecon -Rv /var/www/html/</span><br></pre></td></tr></table></figure></li>
<li><strong><code>semanage fcontext</code>：</strong> 永久性地修改文件或目录的默认安全上下文映射。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 /data/webcontent 目录及其下的所有文件都标记为 httpd_sys_content_t 类型</span></span><br><span class="line"><span class="built_in">sudo</span> semanage fcontext -a -t httpd_sys_content_t <span class="string">&quot;/data/webcontent(/.*)?&quot;</span></span><br><span class="line"><span class="built_in">sudo</span> restorecon -Rv /data/webcontent/</span><br></pre></td></tr></table></figure>
<strong>注意：</strong> <code>semanage</code> 命令在 RHEL&#x2F;CentOS 上可用，Ubuntu 默认没有 <code>semanage</code>，需要安装 <code>policycoreutils-python-utils</code> 包。</li>
</ul>
</li>
<li><p><strong>布尔值 (Booleans)：</strong> SELinux 提供了许多布尔值来打开或关闭特定的策略规则，而无需重新编译整个策略。</p>
<ul>
<li><strong>查看所有布尔值及其状态：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsebool -a</span><br></pre></td></tr></table></figure></li>
<li><strong>临时设置布尔值：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> setsebool httpd_can_network_connect on <span class="comment"># 允许httpd连接网络</span></span><br></pre></td></tr></table></figure></li>
<li><strong>永久设置布尔值：</strong> 使用 <code>-P</code> 参数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> setsebool -P httpd_can_network_connect on</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SELinux 是 Linux 系统安全的重要基石。它通过强制访问控制，为系统提供了强大的第二道防线，即使是高权限用户或被入侵的应用程序，其行为也受到严格约束。虽然学习曲线较陡峭，且在排查问题时可能增加复杂性，但其在提升系统安全性，特别是防止零日漏洞攻击和限制攻击范围方面的作用是无可替代的。在生产环境中，**强烈建议启用并正确配置 SELinux (enforcing 模式)**。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Linux%20strace%20%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Linux%20strace%20%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux strace</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:48:14" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Command/" itemprop="url" rel="index"><span itemprop="name">Command</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="二、strace-的基本使用方法"><a href="#二、strace-的基本使用方法" class="headerlink" title="二、strace 的基本使用方法"></a>二、<code>strace</code> 的基本使用方法</h3><p><code>strace</code> 有两种主要的使用方式：</p>
<h4 id="1-启动一个新程序并跟踪"><a href="#1-启动一个新程序并跟踪" class="headerlink" title="1. 启动一个新程序并跟踪"></a>1. 启动一个新程序并跟踪</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace &lt;<span class="built_in">command</span>&gt; [arguments...]</span><br></pre></td></tr></table></figure>
<p>这将启动 <code>&lt;command&gt;</code>，并将其所有的系统调用输出到标准错误 (<code>stderr</code>)。</p>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace <span class="built_in">ls</span> -l /tmp/nonexistent_file</span><br></pre></td></tr></table></figure>
<p>可能的输出会显示 <code>openat(&quot;/tmp/nonexistent_file&quot;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)</code>，清楚地表明文件不存在。</p>
<h4 id="2-附加到已运行进程"><a href="#2-附加到已运行进程" class="headerlink" title="2. 附加到已运行进程"></a>2. 附加到已运行进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>
<p>这会附加到指定 PID 的进程，并开始跟踪其后续的系统调用。当进程退出或 <code>strace</code> 被中断（Ctrl+C）时，<code>strace</code> 会分离。</p>
<p><strong>示例：</strong><br>假设你的 Web 服务器 Nginx 遇到了问题，其主进程 PID 是 12345。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> strace -p 12345</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 附加到运行时进程需要 <code>root</code> 权限或相应的 <code>CAP_SYS_PTRACE</code> 能力。</p>
<hr>
<h3 id="三、strace-的常用选项和高级用法"><a href="#三、strace-的常用选项和高级用法" class="headerlink" title="三、strace 的常用选项和高级用法"></a>三、<code>strace</code> 的常用选项和高级用法</h3><p><code>strace</code> 提供了丰富的选项来过滤、格式化和摘要输出，以便更高效地定位问题。</p>
<h4 id="1-输出到文件-o"><a href="#1-输出到文件-o" class="headerlink" title="1. 输出到文件 (-o)"></a>1. 输出到文件 (<code>-o</code>)</h4><p>默认输出到 <code>stderr</code>，但在生产环境中或输出量很大时，将其重定向到文件非常重要。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strace -o output.log &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">strace -o output.log -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-统计系统调用次数和耗时-c-C"><a href="#2-统计系统调用次数和耗时-c-C" class="headerlink" title="2. 统计系统调用次数和耗时 (-c, -C)"></a>2. 统计系统调用次数和耗时 (<code>-c</code>, <code>-C</code>)</h4><ul>
<li><code>-c</code>：统计每个系统调用的调用次数、错误次数和总耗时。在程序退出时打印报告。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">strace -c <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># ... ls 的正常输出 ...</span></span><br><span class="line"><span class="comment"># ... 在 ls 退出后，strace 会打印统计报告 ...</span></span><br><span class="line"><span class="comment"># % time     seconds  usecs/call     calls    errors syscall</span></span><br><span class="line"><span class="comment"># ------ ----------- ----------- --------- --------- ----------------</span></span><br><span class="line"><span class="comment">#  38.45    0.000049           1        30           read</span></span><br><span class="line"><span class="comment">#  16.41    0.000021           1        27           close</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li>
<li><code>-C</code> (默认包含 <code>-c</code>)：与 <code>-c</code> 类似，但更详细，包括打开文件、socket 等统计。</li>
</ul>
<h4 id="3-过滤系统调用-e"><a href="#3-过滤系统调用-e" class="headerlink" title="3. 过滤系统调用 (-e)"></a>3. 过滤系统调用 (<code>-e</code>)</h4><p>这是最常用的功能之一，可以显著减少无关输出。</p>
<ul>
<li><strong>按系统调用名称过滤：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strace -e open,<span class="built_in">read</span>,write <span class="built_in">ls</span>          <span class="comment"># 只追踪 open, read, write 系统调用</span></span><br><span class="line">strace -e trace=file <span class="built_in">ls</span>               <span class="comment"># 只追踪与文件操作相关的系统调用 (快捷方式)</span></span><br><span class="line">strace -e trace=!network_io curl      <span class="comment"># 追踪除网络 I/O 外的所有系统调用 (反向过滤)</span></span><br></pre></td></tr></table></figure></li>
<li><strong>按错误码过滤：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strace -e fault=open <span class="built_in">ls</span>               <span class="comment"># 只在 open 调用失败时才打印堆栈信息</span></span><br><span class="line">strace -e <span class="string">&#x27;fault=all:errno=EPERM&#x27;</span> <span class="built_in">ls</span>  <span class="comment"># 只在所有系统调用返回 EPERM (权限拒绝) 时打印</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-显示时间戳-t-tt-ttt-T"><a href="#4-显示时间戳-t-tt-ttt-T" class="headerlink" title="4. 显示时间戳 (-t, -tt, -ttt, -T)"></a>4. 显示时间戳 (<code>-t</code>, <code>-tt</code>, <code>-ttt</code>, <code>-T</code>)</h4><ul>
<li><code>-t</code>：在每行输出前添加时间戳。</li>
<li><code>-tt</code>：添加微秒级时间戳。</li>
<li><code>-ttt</code>：添加微秒级时间戳，并打印自 epoch 以来的秒数。</li>
<li><code>-T</code>：显示每个系统调用耗时。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strace -T <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># openat(AT_FDCWD, &quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000009&gt;</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># openat 的耗时是 9 微秒</span></span><br></pre></td></tr></table></figure>
对于性能问题排查非常有用，可以快速找出耗时长的系统调用。</li>
</ul>
<h4 id="5-显示额外信息-v-y-yy"><a href="#5-显示额外信息-v-y-yy" class="headerlink" title="5. 显示额外信息 (-v, -y, -yy)"></a>5. 显示额外信息 (<code>-v</code>, <code>-y</code>, <code>-yy</code>)</h4><ul>
<li><code>-v</code>：显示更多详细信息，例如环境字符串、结构体内容。</li>
<li><code>-y</code>：显示文件描述符（FD）对应的路径和类型。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strace -y <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># openat(AT_FDCWD, &quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3&lt;/etc/ld.so.cache&gt;</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li>
<li><code>-yy</code>：不仅显示 FD 路径，还显示 socket 详情（地址、端口等）。</li>
</ul>
<h4 id="6-跟踪子进程-f"><a href="#6-跟踪子进程-f" class="headerlink" title="6. 跟踪子进程 (-f)"></a>6. 跟踪子进程 (<code>-f</code>)</h4><p>当被跟踪的程序 fork 出子进程时，<code>strace</code> 默认只跟踪父进程。使用 <code>-f</code> 可以同时跟踪所有子进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -f &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这在调试 Web 服务器 (如 Apache, Nginx 启动 worker 进程) 或其他多进程应用时非常关键。</p>
<h4 id="7-限制字符串长度-s"><a href="#7-限制字符串长度-s" class="headerlink" title="7. 限制字符串长度 (-s)"></a>7. 限制字符串长度 (<code>-s</code>)</h4><p>默认情况下，<code>strace</code> 会截断长字符串。使用 <code>-s &lt;size&gt;</code> 可以设置显示的最大字符串长度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -s 256 <span class="built_in">cat</span> large_file.txt</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、strace-实际故障排查案例"><a href="#四、strace-实际故障排查案例" class="headerlink" title="四、strace 实际故障排查案例"></a>四、<code>strace</code> 实际故障排查案例</h3><p>假设一个 Web 应用无法上传文件，Web 服务器返回 500 错误。</p>
<ol>
<li><p><strong>初步定位：</strong> 检查 Web 服务器（Nginx&#x2F;Apache）和应用服务器（PHP-FPM&#x2F;Tomcat&#x2F;Node.js）的错误日志。可能看到类似“permission denied”或“could not open file”的错误，但日志信息不详。</p>
</li>
<li><p><strong>使用 <code>strace</code> 跟踪 Web 应用进程：</strong> 找到对应的应用程序进程 PID（例如 PHP-FPM 的 worker 进程 PID）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到一个处理上传请求的 PHP-FPM worker 进程 PID，或者直接重启服务并用 strace 包装启动命令</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop php-fpm</span><br><span class="line"><span class="built_in">sudo</span> strace -f -o /tmp/php-fpm_strace.log php-fpm -F  <span class="comment"># -F 确保在前台运行</span></span><br><span class="line"><span class="comment"># 等待用户进行一次文件上传操作</span></span><br><span class="line"><span class="comment"># Ctrl+C 停止 strace</span></span><br></pre></td></tr></table></figure>
<p>或者直接附加已经运行的进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep php-fpm  <span class="comment"># 找到一个 worker 进程 PID，例如 12345</span></span><br><span class="line"><span class="built_in">sudo</span> strace -f -o /tmp/php-fpm_strace.log -p 12345</span><br><span class="line"><span class="comment"># 用户进行上传操作</span></span><br><span class="line"><span class="comment"># Ctrl+C 停止</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分析 <code>strace</code> 输出日志 (<code>/tmp/php-fpm_strace.log</code>)：</strong></p>
<p>打开 <code>php-fpm_strace.log</code> 文件，搜索跟文件操作、权限相关的系统调用，或者直接搜索 <code>EACCES</code> (Permission denied) 或 <code>ENOENT</code> (No such file or directory) 错误。</p>
<p><strong>可能发现的线索：</strong></p>
<ul>
<li><p><strong>权限问题：</strong></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openat(<span class="name">AT_FDCWD</span>, <span class="string">&quot;/var/www/html/uploads/my_file.jpg&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>) = <span class="number">-1</span> EACCES (<span class="name">Permission</span> denied)</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong> 程序尝试在 <code>/var/www/html/uploads/</code> 目录下创建文件 <code>my_file.jpg</code>，但被拒绝访问。<br><strong>解决方案：</strong> 检查 <code>/var/www/html/uploads/</code> 目录的权限和所有者，确保 PHP-FPM 运行的用户（通常是 <code>www-data</code> 或 <code>nginx</code>）对其有写权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -ld /var/www/html/uploads/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> www-data:www-data /var/www/html/uploads/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 755 /var/www/html/uploads/  <span class="comment"># 或者 775，如果需要组写权限</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>目录不存在：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">stat</span><span class="params">(<span class="string">&quot;/var/www/html/uploads/2023/10&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;)</span></span> = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">openat</span><span class="params">(AT_FDCWD, <span class="string">&quot;/var/www/html/uploads/2023/10/my_file.jpg&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>)</span></span> = -<span class="number">1</span> ENOENT (No such file or directory)</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong> <code>stat</code> 命令成功检查了存在的父目录 <code>/var/www/html/uploads/2023/10</code>，但随后 <code>openat</code> 尝试创建文件时发现路径不存在。这通常意味着程序以为父目录存在，但实际上路径的一部分 (例如 <code>/2023/10</code> 这一层) 在尝试写入文件时才发现不存在，或者程序没有递归创建目录的能力。<br><strong>解决方案：</strong> 确保上传目录的完整路径存在，或者程序在上传前会创建相应的子目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /var/www/html/uploads/2023/10</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R www-data:www-data /var/www/html/uploads/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置文件找不到：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">openat</span><span class="params">(AT_FDCWD, <span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>, O_RDONLY|O_CLOEXEC)</span></span> = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="title">openat</span><span class="params">(AT_FDCWD, <span class="string">&quot;/path/to/my_app/config.json&quot;</span>, O_RDONLY|O_CLOEXEC)</span></span> = -<span class="number">1</span> ENOENT (No such file or directory)</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong> 程序在尝试读取 <code>/path/to/my_app/config.json</code> 时失败，因为它不存在。<br><strong>解决方案：</strong> 检查配置文件路径是否正确，文件是否存在，以及应用程序是否有权限读取它。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="五、使用-strace-的注意事项"><a href="#五、使用-strace-的注意事项" class="headerlink" title="五、使用 strace 的注意事项"></a>五、使用 <code>strace</code> 的注意事项</h3><ul>
<li><strong>性能开销：</strong> <code>strace</code> 通过拦截系统调用来工作，这会引入显著的性能开销，尤其是在跟踪 I&#x2F;O 密集型或高并发程序时。**切勿在生产环境长期运行 <code>strace</code>**，尤其是在核心业务进程上，除非是短期的、有目的的故障排查。</li>
<li><strong>权限：</strong> 大多数情况下，运行 <code>strace</code> 需要 <code>root</code> 权限。</li>
<li><strong>输出量：</strong> 即使是简单的命令，<code>strace</code> 的输出也可能非常庞大。务必使用 <code>-o</code> 将输出重定向到文件，并善用 <code>-e</code> 过滤。</li>
<li><strong>并非所有问题都能解决：</strong> <code>strace</code> 只能看到程序与内核的交互。它看不到程序内部的逻辑错误、内存泄漏（除非导致 <code>mmap</code> 或 <code>brk</code> 大量调用）、线程死锁（除非涉及到 <code>futex</code> 等同步系统调用），以及非系统调用层面的运行时错误（例如解析 JSON 失败）。对于这些问题，需要结合代码调试器 (如 GDB)、内存分析工具、日志分析或更高级的 APM 工具。</li>
</ul>
<p><code>strace</code> 是 Linux 运维工程师排查底层疑难杂症的利器。熟练掌握它的使用方法，能够大大提高解决系统和应用层问题的效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Linux%20tcpdump%20%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Linux%20tcpdump%20%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux tcpdump 命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:48:22" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Command/" itemprop="url" rel="index"><span itemprop="name">Command</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作为一名运维工程师，<code>tcpdump</code> 是我进行网络故障排查和性能分析时不可或缺的“瑞士军刀”。它是一个基于命令行的数据包捕获工具，能够截获并显示通过网络接口的数据包。无论是在诊断网络连接问题、分析协议行为、检测异常流量，还是验证防火墙规则时，<code>tcpdump</code> 都扮演着至关重要的角色。</p>
<hr>
<h3 id="一、tcpdump-简介"><a href="#一、tcpdump-简介" class="headerlink" title="一、tcpdump 简介"></a>一、<code>tcpdump</code> 简介</h3><ul>
<li><strong>功能：</strong> 捕获网络接口上符合指定条件的数据包，并将其内容打印到标准输出或保存到文件中。</li>
<li><strong>原理：</strong> <code>tcpdump</code> 使用 <code>libpcap</code> 库来与网络接口进行交互，接收、过滤和解析流经接口的数据包。它工作在数据链路层，能够看到IP层及以上的所有协议数据。</li>
<li><strong>应用场景：</strong><ul>
<li><strong>诊断连通性问题：</strong> 验证客户端&#x2F;服务器之间是否有数据包传输。</li>
<li><strong>分析协议行为：</strong> 深入了解 HTTP、DNS、SSH 等协议的具体交互过程。</li>
<li><strong>排查防火墙问题：</strong> 确认流量是否被防火墙阻拦。</li>
<li><strong>检测异常流量：</strong> 发现端口扫描、拒绝服务攻击（DoS）的迹象。</li>
<li><strong>性能瓶颈分析：</strong> 识别延迟、丢包等网络性能问题。</li>
<li><strong>验证流量转发：</strong> 检查路由和 NAT 是否按预期工作。</li>
<li><strong>安全审计：</strong> 监控关键系统的网络活动。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、tcpdump-的基本使用方法"><a href="#二、tcpdump-的基本使用方法" class="headerlink" title="二、tcpdump 的基本使用方法"></a>二、<code>tcpdump</code> 的基本使用方法</h3><p>最简单的 <code>tcpdump</code> 命令会捕获所有流经默认网络接口的数据包并打印出来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 运行 <code>tcpdump</code> 通常需要 <code>root</code> 权限。若输出太快，可使用 <code>Ctrl+C</code> 停止。</p>
<p><strong>默认输出格式解释：</strong><br><code>tcpdump</code> 的输出由多列组成，通常包含：<br><code>时间戳 协议 源IP.源端口 &gt; 目的IP.目的端口 标志位 序号 确认号 窗口大小 选项 [数据长度]</code></p>
<p>示例：<br><code>15:00:00.123456 IP 192.168.1.10.54321 &gt; 192.168.1.1.80: Flags [S], seq 123, win 29200, length 0</code></p>
<ul>
<li><code>15:00:00.123456</code>: 数据包捕获的时间戳。</li>
<li><code>IP</code>: 协议类型 (此处是 IP)。</li>
<li><code>192.168.1.10.54321</code>: 源 IP 地址和端口。</li>
<li><code>192.168.1.1.80</code>: 目的 IP 地址和端口。</li>
<li><code>Flags [S]</code>: TCP 标志位，<code>S</code> 表示 SYN (同步)，用于建立连接。</li>
<li><code>seq 123</code>: TCP 序列号。</li>
<li><code>win 29200</code>: TCP 窗口大小。</li>
<li><code>length 0</code>: 应用层数据长度。</li>
</ul>
<hr>
<h3 id="三、tcpdump-的常用选项"><a href="#三、tcpdump-的常用选项" class="headerlink" title="三、tcpdump 的常用选项"></a>三、<code>tcpdump</code> 的常用选项</h3><h4 id="1-指定网络接口-i"><a href="#1-指定网络接口-i" class="headerlink" title="1. 指定网络接口 (-i)"></a>1. 指定网络接口 (<code>-i</code>)</h4><p>默认情况下，<code>tcpdump</code> 会选择第一个活动的网络接口。在多网卡系统中，务必指定接口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0             <span class="comment"># 捕获 eth0 接口上的流量</span></span><br><span class="line">tcpdump -i any              <span class="comment"># 捕获所有接口上的流量</span></span><br><span class="line">tcpdump -i lo               <span class="comment"># 捕获回环接口上的流量 (用于调试本地进程间网络通信)</span></span><br></pre></td></tr></table></figure>
<p>可以使用 <code>ip a</code> 或 <code>ifconfig</code> 命令查看系统上的网络接口名称。</p>
<h4 id="2-显示详细信息-v-vv-vvv"><a href="#2-显示详细信息-v-vv-vvv" class="headerlink" title="2. 显示详细信息 (-v, -vv, -vvv)"></a>2. 显示详细信息 (<code>-v</code>, <code>-vv</code>, <code>-vvv</code>)</h4><p>这些选项会增加输出的详细程度，对于协议分析非常有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -v                  <span class="comment"># 更详细的输出，如 TTL、ID 等</span></span><br><span class="line">tcpdump -vv                 <span class="comment"># 再详细一些，如 HTTP-INFO</span></span><br><span class="line">tcpdump -vvv                <span class="comment"># 最详细输出</span></span><br></pre></td></tr></table></figure>

<h4 id="3-不解析主机名和端口号-n-nn"><a href="#3-不解析主机名和端口号-n-nn" class="headerlink" title="3. 不解析主机名和端口号 (-n, -nn)"></a>3. 不解析主机名和端口号 (<code>-n</code>, <code>-nn</code>)</h4><ul>
<li><code>-n</code>: 不进行主机名解析，直接显示 IP 地址。这会加快捕获速度，并避免DNS解析延时。</li>
<li><code>-nn</code>: 不进行主机名和端口号解析，直接显示 IP 地址和端口号。在排查问题时非常推荐，可以避免误解服务名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -i eth0</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-显示数据包内容-A-X-XX"><a href="#4-显示数据包内容-A-X-XX" class="headerlink" title="4. 显示数据包内容 (-A, -X, -XX)"></a>4. 显示数据包内容 (<code>-A</code>, <code>-X</code>, <code>-XX</code>)</h4><ul>
<li><code>-A</code>: 以 ASCII 码形式打印每个数据包的载荷 (Payload)。适用于查看 HTTP 请求&#x2F;响应、纯文本协议内容。</li>
<li><code>-X</code>: 以十六进制和 ASCII 码形式打印每个数据包的载荷。适用于查看二进制协议或更详细的数据结构。</li>
<li><code>-XX</code>: 与 <code>-X</code> 类似，但还包含链路层头信息 (如以太网头)。</li>
</ul>
<h4 id="5-限制捕获数量-c"><a href="#5-限制捕获数量-c" class="headerlink" title="5. 限制捕获数量 (-c)"></a>5. 限制捕获数量 (<code>-c</code>)</h4><p>指定捕获多少个数据包后停止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -c 10 -i eth0       <span class="comment"># 捕获 10 个数据包后停止</span></span><br></pre></td></tr></table></figure>

<h4 id="6-将捕获写入文件-w"><a href="#6-将捕获写入文件-w" class="headerlink" title="6. 将捕获写入文件 (-w)"></a>6. 将捕获写入文件 (<code>-w</code>)</h4><p>将捕获的数据包保存到文件中，以便后续使用 <code>tcpdump -r</code> 或 Wireshark 等工具进行离线分析。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w traffic.pcap -i eth0</span><br></pre></td></tr></table></figure>
<ul>
<li><code>.pcap</code> 是标准的数据包捕获文件格式。</li>
</ul>
<h4 id="7-从文件读取捕获-r"><a href="#7-从文件读取捕获-r" class="headerlink" title="7. 从文件读取捕获 (-r)"></a>7. 从文件读取捕获 (<code>-r</code>)</h4><p>读取之前使用 <code>-w</code> 保存的 <code>.pcap</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -r traffic.pcap</span><br><span class="line">tcpdump -r traffic.pcap -nn -A  <span class="comment"># 读取并以 ASCII 码显示内容</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、tcpdump-强大的过滤表达式"><a href="#四、tcpdump-强大的过滤表达式" class="headerlink" title="四、tcpdump 强大的过滤表达式"></a>四、<code>tcpdump</code> 强大的过滤表达式</h3><p>过滤表达式是 <code>tcpdump</code> 的核心，允许你只捕获感兴趣的流量，大大减少输出量，提高分析效率。过滤表达式可以组合使用逻辑运算符 (<code>and</code>, <code>or</code>, <code>not</code>)。</p>
<h4 id="1-协议类型过滤"><a href="#1-协议类型过滤" class="headerlink" title="1. 协议类型过滤"></a>1. 协议类型过滤</h4><ul>
<li><code>tcp</code>: 只捕获 TCP 包。</li>
<li><code>udp</code>: 只捕获 UDP 包。</li>
<li><code>icmp</code>: 只捕获 ICMP 包 (如 <code>ping</code>)。</li>
<li><code>arp</code>: 只捕获 ARP 包。</li>
<li><code>ip</code>: 只捕获 IP 包。</li>
<li><code>net</code>: 只捕获网络层的特定协议（如 <code>ip</code>, <code>ip6</code>, <code>arp</code>）。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 tcp           <span class="comment"># 捕获 TCP 流量</span></span><br><span class="line">tcpdump -i eth0 icmp          <span class="comment"># 捕获 ping 包</span></span><br></pre></td></tr></table></figure>

<h4>2. 主机过滤 (<code>host</code>)</h4>

<ul>
<li><code>host &lt;ip_address&gt;</code>: 捕获与指定 IP 地址相关的所有流量（作为源或目的）。</li>
<li><code>src host &lt;ip_address&gt;</code>: 只捕获源 IP 为指定地址的流量。</li>
<li><code>dst host &lt;ip_address&gt;</code>: 只捕获目的 IP 为指定地址的流量。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 host 192.168.1.100    <span class="comment"># 与 192.168.1.100 相关的流量</span></span><br><span class="line">tcpdump -i eth0 src host 192.168.1.100 <span class="comment"># 源自 192.168.1.100 的流量</span></span><br></pre></td></tr></table></figure>

<h4 id="3-端口过滤-port"><a href="#3-端口过滤-port" class="headerlink" title="3. 端口过滤 (port)"></a>3. 端口过滤 (<code>port</code>)</h4><ul>
<li><code>port &lt;port_number&gt;</code>: 捕获与指定端口号相关的所有流量（作为源或目的）。</li>
<li><code>src port &lt;port_number&gt;</code>: 只捕获源端口为指定端口的流量。</li>
<li><code>dst port &lt;port_number&gt;</code>: 只捕获目的端口为指定端口的流量。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 port 80             <span class="comment"># 捕获所有 http 流量 (80 端口)</span></span><br><span class="line">tcpdump -i eth0 dst port 22         <span class="comment"># 捕获所有发往 22 端口的 SSH 流量</span></span><br></pre></td></tr></table></figure>

<h4 id="4-网络过滤-net"><a href="#4-网络过滤-net" class="headerlink" title="4. 网络过滤 (net)"></a>4. 网络过滤 (<code>net</code>)</h4><ul>
<li><code>net &lt;network_address&gt;</code>: 捕获与指定网段相关的所有流量。</li>
<li><code>src net &lt;network_address&gt;</code>: 只捕获源 IP 在指定网段的流量。</li>
<li><code>dst net &lt;network_address&gt;</code>: 只捕获目的 IP 在指定网段的流量。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 net 192.168.1.0/24  <span class="comment"># 捕获与 192.168.1.0/24 网段相关的流量</span></span><br></pre></td></tr></table></figure>

<h4 id="5-组合过滤表达式"><a href="#5-组合过滤表达式" class="headerlink" title="5. 组合过滤表达式"></a>5. 组合过滤表达式</h4><p>使用 <code>and</code> (或 <code>&amp;&amp;</code>), <code>or</code> (或 <code>||</code>), <code>not</code> (或 <code>!</code>) 组合多个过滤条件。<br><strong>注意：</strong> 组合时，为避免歧义，复杂表达式建议使用括号 <code>()</code>，但括号在 shell 中有特殊含义，需要用引号 <code>&#39;&#39;</code> 或 <code>\</code> 转义。</p>
<p><strong>示例：</strong></p>
<ul>
<li><strong>捕获来自 192.168.1.100 的发往 80 端口的 TCP 流量：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -i eth0 <span class="string">&#x27;src host 192.168.1.100 and tcp dst port 80&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>捕获除了 SSH (22) 和 HTTP (80) 以外的 TCP 流量：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -i eth0 <span class="string">&#x27;tcp and not (port 22 or port 80)&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>捕获 HTTP 请求 (假设是 GET 方法):</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 捕获目的端口是80的tcp流量，并且数据包中有&quot;GET&quot;字符串（区分大小写）</span></span><br><span class="line">tcpdump -nn -A -i eth0 <span class="string">&#x27;tcp dst port 80 and (tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420)&#x27;</span></span><br><span class="line"><span class="comment"># ^ 这是一个高级过滤方式，表示 TCP payload 的前 4 个字节等于 &quot;GET &quot; 的 ASCII 码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单点的，直接捕获到文件再用 grep 过滤可能更快：</span></span><br><span class="line"><span class="comment"># tcpdump -w http.pcap -nn -i eth0 tcp dst port 80</span></span><br><span class="line"><span class="comment"># strings http.pcap | grep &quot;GET /&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="五、tcpdump-实际故障排查案例"><a href="#五、tcpdump-实际故障排查案例" class="headerlink" title="五、tcpdump 实际故障排查案例"></a>五、<code>tcpdump</code> 实际故障排查案例</h3><p><strong>故障场景：</strong> Web服务器无法连接到数据库服务器，应用程序报错“无法连接数据库”。<code>ping</code> 数据库服务器正常。</p>
<ol>
<li><p><strong>确认问题出在哪里：</strong></p>
<ul>
<li><code>ping</code> 正常表示 IP 层连通性正常，网络路由可能没问题。</li>
<li>应用程序报错是连接层面。</li>
<li>检查数据库服务（MySQL）本身是否运行：<code>systemctl status mysql</code>，确认运行正常。</li>
</ul>
</li>
<li><p><strong>在 Web 服务器上捕获流量：</strong><br>我们怀疑是 Web 服务器到数据库服务器的连接问题，所以在 Web 服务器上使用 <code>tcpdump</code> 捕获到数据库服务器的 MySQL 端口 (3306) 流量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Web 服务器上执行</span></span><br><span class="line">tcpdump -nn -i eth0 <span class="string">&#x27;host &lt;DB_SERVER_IP&gt; and tcp port 3306&#x27;</span> -c 100 -s 0 -w /tmp/db_conn_issue.pcap</span><br><span class="line"><span class="comment"># -i eth0: 指定网卡</span></span><br><span class="line"><span class="comment"># host &lt;DB_SERVER_IP&gt;: 过滤掉其他IP的流量，只看数据库服务器的流量</span></span><br><span class="line"><span class="comment"># tcp port 3306: 只看3306端口的TCP流量</span></span><br><span class="line"><span class="comment"># -c 100: 捕获100个包后停止，防止文件过大</span></span><br><span class="line"><span class="comment"># -s 0: 不截断数据包，完全捕获数据包内容（默认为65535，即不截断）</span></span><br><span class="line"><span class="comment"># -w /tmp/db_conn_issue.pcap: 保存到文件，方便后面用Wireshark分析</span></span><br></pre></td></tr></table></figure>
<p>同时，触发一次应用程序连接数据库的操作（如刷新网页）。</p>
</li>
<li><p><strong>分析捕获结果：</strong></p>
<p>a. <strong>直接在命令行查看简要信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -r /tmp/db_conn_issue.pcap</span><br></pre></td></tr></table></figure>
<p><strong>可能发现的现象及解释：</strong></p>
<ul>
<li><p><strong>只有 SYN 包，没有 SYN-ACK 包：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;WEB_IP&gt;<span class="string">.54321</span> &gt; &lt;DB_IP&gt;<span class="string">.3306</span>: Flags [S], seq <span class="string">...</span> length 0</span><br><span class="line">&lt;WEB_IP&gt;<span class="string">.54322</span> &gt; &lt;DB_IP&gt;<span class="string">.3306</span>: Flags [S], seq <span class="string">...</span> length 0</span><br><span class="line"><span class="string">...</span> <span class="params">(反复出现 SYN 包)</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong> Web服务器发送了连接请求 (SYN)，但数据库服务器没有响应 (SYN-ACK)。<br><strong>原因：</strong></p>
<ol>
<li><strong>数据库服务器防火墙阻拦：</strong> 数据库服务器的 3306 端口可能没有对 Web 服务器开放。</li>
<li><strong>网络ACL&#x2F;安全组问题：</strong> 云环境中，安全组可能阻止了入站流量。</li>
<li><strong>数据库服务未监听或端口错误：</strong> MySQL 服务可能没有在 3306 端口监听，或者监听的地址不对 (例如只监听了 <code>127.0.0.1</code>)。</li>
</ol>
<p><strong>进一步排查：</strong></p>
<ul>
<li>在<strong>数据库服务器</strong>上执行 <code>tcpdump -nn -i eth0 &#39;host &lt;WEB_IP&gt; and tcp port 3306&#39;</code>，看能否收到 Web 服务器发来的 SYN 包。如果能收到，说明网络路径没问题，问题出在数据库服务器本身。</li>
<li>在<strong>数据库服务器</strong>上检查防火墙 (<code>firewalld</code>, <code>ufw</code>, <code>iptables</code>) 规则。</li>
<li>检查 MySQL 配置 (<code>my.cnf</code>)，确认 <code>bind-address</code> 和 <code>port</code> 设置是否正确。</li>
</ul>
</li>
<li><p><strong>看到 SYN, SYN-ACK，但没有 ACK 或 RST：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;WEB_IP&gt;<span class="string">.54321</span> &gt; &lt;DB_IP&gt;<span class="string">.3306</span>: Flags [S], seq <span class="string">...</span> length 0</span><br><span class="line">&lt;DB_IP&gt;<span class="string">.3306</span> &gt; &lt;WEB_IP&gt;<span class="string">.54321</span>: Flags [S.], seq <span class="string">...</span>, ack <span class="string">...</span>, length 0</span><br><span class="line"><span class="string">...</span> <span class="params">(没有第三个包)</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong> 数据库服务器成功响应用 <code>SYN-ACK</code>，但 Web 服务器没有发送最终的 <code>ACK</code> 包完成三次握手。<br><strong>原因：</strong></p>
<ol>
<li><strong>Web服务器防火墙阻拦：</strong> Web 服务器出站或入站的某些规则可能阻止了响应流量。</li>
<li><strong>网络ACL&#x2F;安全组问题：</strong> Web服务器的出站安全组可能阻止了 ACK 包。</li>
<li><strong>Web服务器端口耗尽：</strong> 连接数过多，可用临时端口耗尽。</li>
</ol>
</li>
<li><p><strong>看到 RST (复位) 包：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;WEB_IP&gt;<span class="string">.54321</span> &gt; &lt;DB_IP&gt;<span class="string">.3306</span>: Flags [S], seq <span class="string">...</span> length 0</span><br><span class="line">&lt;DB_IP&gt;<span class="string">.3306</span> &gt; &lt;WEB_IP&gt;<span class="string">.54321</span>: Flags [R.], seq <span class="string">...</span>, ack <span class="string">...</span>, win 0, length 0</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong> 数据库服务器收到了 SYN 包，但立即发送了一个 RST 包，表示连接被拒绝。<br><strong>原因：</strong></p>
<ol>
<li><strong>连接数超出限制：</strong> 数据库服务器当前连接数已达到上限。</li>
<li><strong>账号密码错误：</strong> 通常在三次握手后，应用层认证失败才会导致断开，但有时配置错误也可能在连接建立初期就 RST。</li>
<li><strong>服务异常：</strong> 数据库服务可能内部错误导致无法接受新连接。</li>
</ol>
</li>
</ul>
<p>b. <strong>使用 Wireshark 进行图形化分析：</strong><br>对于复杂的场景，将 <code>.pcap</code> 文件下载到本地，用 Wireshark 打开能提供更直观、强大的分析能力，包括：</p>
<ul>
<li>TCP Stream Reassembly (重组TCP流，看到应用层数据)</li>
<li>Expert Information (专家信息，快速识别异常)</li>
<li>Follow TCP Stream (跟踪单个TCP会话)</li>
<li>统计图表</li>
</ul>
<p>通过 Wireshark 的“专家信息”或“跟踪 TCP 流”，可以清晰地看到三次握手是否完成，以及是否有应用层协议数据（如 MySQL 协议的认证消息）被发送或接收。</p>
</li>
</ol>
<h3 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h3><ul>
<li><strong>权限：</strong> <code>tcpdump</code> 通常需要 <code>root</code> 权限。</li>
<li><strong>性能影响：</strong> 在高流量的生产环境中捕获所有数据包可能会引起显著的 CPU 和内存开销。务必使用精确的过滤条件，并限制捕获时间或数量。</li>
<li><strong>环形缓冲区：</strong> 对于长时间的捕获，可以结合 <code>split</code> 或 <code>rotat</code> 选项创建多个文件，形成环形缓冲区，避免单个文件过大：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w traffic-%Y%m%d%H%M%S.pcap -G 3600 -C 100 -i eth0 host &lt;IP&gt;</span><br><span class="line"><span class="comment"># -G 3600: 每 3600 秒 (1小时) 创建一个新文件</span></span><br><span class="line"><span class="comment"># -C 100: 每个文件最大 100MB</span></span><br></pre></td></tr></table></figure></li>
<li><strong>隐私和安全：</strong> 捕获的数据包可能包含敏感信息（如密码、API 密钥）。在非信任环境中操作时要小心，并且分析完后及时删除捕获文件。</li>
<li><strong>不足之处：</strong> <code>tcpdump</code> 捕获的是已经到达网卡的数据包。如果问题发生在更早的层面（如硬件故障、网线未插紧），<code>tcpdump</code> 可能什么都捕获不到。</li>
</ul>
<p>掌握 <code>tcpdump</code> 的使用，不仅能快速定位网络层故障，还能帮助我们更深入地理解网络协议，是任何运维工程师的必备技能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Linux%20%E4%B8%AD%20df%20%E4%B8%8E%20du%20%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Linux%20%E4%B8%AD%20df%20%E4%B8%8E%20du%20%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Linux 中 df 与 du 区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:47:43" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Command/" itemprop="url" rel="index"><span itemprop="name">Command</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>df</code> 和 <code>du</code> 是日常工作中用于查看磁盘使用情况的两个最基本也是最重要的命令。它们都与磁盘空间有关，但它们的工作原理、关注点以及提供的信息维度截然不同。理解这两者的区别至关重要，因为它能帮助我们准确地判断磁盘空间问题，而不是被表象所迷惑。</p>
<hr>
<h3 id="一、df-disk-free"><a href="#一、df-disk-free" class="headerlink" title="一、df (disk free)"></a>一、<code>df</code> (disk free)</h3><p><code>df</code> 命令用于报告<strong>文件系统</strong>的磁盘空间使用情况。它读取的是文件系统的<strong>超级块（superblock）</strong>信息，反映的是文件系统层面上的整体空间统计。</p>
<h4 id="1-核心特点："><a href="#1-核心特点：" class="headerlink" title="1. 核心特点："></a>1. <strong>核心特点：</strong></h4><ul>
<li><strong>报告文件系统总览：</strong> 关注的是整个文件系统（分区、挂载点）的使用情况。</li>
<li><strong>读取文件系统元数据：</strong> 它直接查询文件系统的元数据（如 inode 表、块位图等），来得知已用、可用空间和总容量。</li>
<li><strong>速度快：</strong> 由于只读取元数据，不遍历文件，所以执行速度通常很快。</li>
<li><strong>计算已挂载文件系统：</strong> 只能报告已挂载的文件系统，包括本地磁盘、网络文件系统（NFS, Samba&#x2F;CIFS）、虚拟文件系统等。</li>
<li><strong>显示已分配但未释放的空间：</strong> 如果文件被删除但仍被进程占用（即文件句柄未释放），<code>df</code> 会将这部分空间计入“已用”空间，因为它对文件系统来说这部分空间是“被占用的”。</li>
</ul>
<h4 id="2-常用选项："><a href="#2-常用选项：" class="headerlink" title="2. 常用选项："></a>2. <strong>常用选项：</strong></h4><ul>
<li><code>-h</code>：以人类可读的格式（例如，使用 K、M、G 等单位）显示。<strong>最常用！</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure>
输出示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1        50G   10G   38G  21% /</span><br><span class="line">/dev/sdb1       100G   50G   50G  50% /data</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br></pre></td></tr></table></figure></li>
<li><code>-T</code>：显示文件系统类型。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -hT</span><br></pre></td></tr></table></figure>
输出示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Filesystem     Type   Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1      ext4    50G   10G   38G  21% /</span><br><span class="line">/dev/sdb1      xfs    100G   50G   50G  50% /data</span><br><span class="line">tmpfs          tmpfs  3.9G     0  3.9G   0% /dev/shm</span><br></pre></td></tr></table></figure></li>
<li><code>-i</code>：显示 inode 使用情况（inode 是文件&#x2F;目录的元数据结构，文件数量的限制）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -hi</span><br></pre></td></tr></table></figure>
输出示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      Inodes IUsed IFree IUse% Mounted on</span><br><span class="line">/dev/sda1         3.2M  160K  3.0M    5% /</span><br><span class="line">/dev/sdb1         6.4M  320K  6.1M    5% /data</span><br></pre></td></tr></table></figure>
即使磁盘空间足够，如果 inode 耗尽，也无法创建新文件。</li>
</ul>
<h4 id="3-典型问题："><a href="#3-典型问题：" class="headerlink" title="3. 典型问题："></a>3. <strong>典型问题：</strong></h4><ul>
<li><strong>文件句柄未释放导致的“假”满：</strong> 当通过 <code>rm</code> 命令删除了一个大文件，但有进程仍然持有该文件的文件句柄时，<code>df</code> 会显示该文件系统空间没有被释放（<code>Use%</code> 依然很高），而 <code>du</code> 不会计算已被删除的文件。这是 <code>df</code> 最大的“坑”之一，也是 <code>lsof</code> 大显身手的时候。</li>
</ul>
<hr>
<h3 id="二、du-disk-usage"><a href="#二、du-disk-usage" class="headerlink" title="二、du (disk usage)"></a>二、<code>du</code> (disk usage)</h3><p><code>du</code> 命令用于报告<strong>指定文件或目录</strong>的磁盘空间使用情况。它通过遍历指定路径下的所有文件和子目录来计算它们实际占用的磁盘块大小。</p>
<h4 id="1-核心特点：-1"><a href="#1-核心特点：-1" class="headerlink" title="1. 核心特点："></a>1. <strong>核心特点：</strong></h4><ul>
<li><strong>报告文件&#x2F;目录粒度：</strong> 关注的是文件或目录树占用的实际空间。</li>
<li><strong>遍历文件系统：</strong> 它会递归地遍历指定路径下的文件和目录，累加文件占用的块大小。</li>
<li><strong>速度相对慢：</strong> 对于包含大量文件或大文件的目录，遍历需要时间，速度比 <code>df</code> 慢。</li>
<li><strong>计算文件的块使用量：</strong> 统计的是<strong>文件实际占用的磁盘块数量</strong>。这可能比文件本身的大小（<code>ls -l</code> 看到的字节数）大，因为磁盘分配是按块进行的，即使文件很小也会占用一个或多个完整的块。</li>
<li><strong>不计算已删除但未释放的文件：</strong> <code>du</code> 不会计算那些已经被“删除”但其文件句柄仍被进程持有的文件，因为它只扫描文件系统目录树中“存在”的文件。</li>
</ul>
<h4 id="2-常用选项：-1"><a href="#2-常用选项：-1" class="headerlink" title="2. 常用选项："></a>2. <strong>常用选项：</strong></h4><ul>
<li><code>-h</code>：以人类可读的格式显示。<strong>最常用！</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h /path/to/directory</span><br><span class="line"><span class="built_in">du</span> -h /var/log</span><br></pre></td></tr></table></figure></li>
<li><code>-s</code>：只显示总计（summarize），不显示子目录的详细信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh /path/to/directory <span class="comment"># 显示指定目录的总大小</span></span><br></pre></td></tr></table></figure></li>
<li><code>-a</code>：显示所有文件（不仅仅是目录）的大小。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -ha /path/to/directory</span><br></pre></td></tr></table></figure></li>
<li><code>--max-depth=&lt;N&gt;</code>：限制递归的深度。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h --max-depth=1 /var <span class="comment"># 显示 /var 下一级目录的大小</span></span><br></pre></td></tr></table></figure></li>
<li><code>-c</code>：除了每个参数的总和，还显示所有指定参数的总和。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -hc /home/user1 /home/user2</span><br></pre></td></tr></table></figure></li>
<li><code>--exclude=&lt;PATTERN&gt;</code>：排除符合特定模式的文件或目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h --exclude=<span class="string">&quot;*.log&quot;</span> /var/log</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-典型问题：-1"><a href="#3-典型问题：-1" class="headerlink" title="3. 典型问题："></a>3. <strong>典型问题：</strong></h4><ul>
<li><strong>文件系统差异：</strong> <code>du</code> 统计的是文件占用的块数，而文件系统可能存在一些特殊的元数据开销，导致 <code>du</code> 报告的总和与 <code>df</code> 的“已用”空间略有差异，但这个差异通常不大。</li>
<li><strong>权限问题：</strong> 如果你没有某个目录的读取权限，<code>du</code> 将无法计算其内容的大小，并可能报错。</li>
</ul>
<hr>
<h3 id="三、df-与-du-的核心区别总结"><a href="#三、df-与-du-的核心区别总结" class="headerlink" title="三、df 与 du 的核心区别总结"></a>三、<code>df</code> 与 <code>du</code> 的核心区别总结</h3><table>
<thead>
<tr>
<th align="left">特征</th>
<th align="left"><code>df</code> (disk free)</th>
<th align="left"><code>du</code> (disk usage)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>侧重</strong></td>
<td align="left">整个<strong>文件系统&#x2F;分区</strong>的整体空间使用情况</td>
<td align="left"><strong>文件和目录</strong>的实际磁盘占用大小</td>
</tr>
<tr>
<td align="left"><strong>工作原理</strong></td>
<td align="left">读取文件系统的超级块（元数据）</td>
<td align="left">遍历指定目录下的所有文件和子目录，累加块大小</td>
</tr>
<tr>
<td align="left"><strong>计算速度</strong></td>
<td align="left">快</td>
<td align="left">相对慢（取决于文件数量和目录深度）</td>
</tr>
<tr>
<td align="left"><strong>是否包含已删除但未释放文件</strong></td>
<td align="left"><strong>包含</strong></td>
<td align="left"><strong>不包含</strong>（因为它只遍历文件系统中“可见”的文件）</td>
</tr>
<tr>
<td align="left"><strong>应用场景</strong></td>
<td align="left">快速查看分区空间概览；检查 inode 使用；判断整个文件系统是否已满。</td>
<td align="left">查找大文件&#x2F;目录；分析特定路径下的空间使用详情。</td>
</tr>
<tr>
<td align="left"><strong>常见痛点</strong></td>
<td align="left">无法解释 <code>df</code> 满但 <code>du</code> 不满的情况（文件句柄未释放）</td>
<td align="left">无法访问无权限的文件；对于大量文件的目录可能耗时。</td>
</tr>
</tbody></table>
<hr>
<h3 id="四、实际运维中的应用场景"><a href="#四、实际运维中的应用场景" class="headerlink" title="四、实际运维中的应用场景"></a>四、实际运维中的应用场景</h3><p>作为运维工程师，我通常会这样使用它们：</p>
<ol>
<li><p><strong>日常监控：</strong></p>
<ul>
<li>使用 <code>df -h</code> 快速查看所有挂载点（尤其是根分区 <code>/</code> 和数据分区）的整体空间使用率 (<code>Use%</code>)。如果某个分区达到警戒值（如 80% 或 90%），我会进一步排查。</li>
<li>使用 <code>df -hi</code> 来检查 inode 使用率，防止因文件数量过多导致的问题。</li>
</ul>
</li>
<li><p><strong>空间不足排查：</strong></p>
<ul>
<li>当 <code>df -h</code> 显示某个文件系统已满时，我的第一反应是使用 <code>du -sh /*</code> 或 <code>du -sh /path/to/directory/*</code>（结合 <code>--max-depth</code>）来找出是哪个子目录占用了大量空间。</li>
<li>如果 <code>df</code> 显示空间不足，但 <code>du</code> 的总和却远小于 <code>df</code> 的“已用”空间，那么十有八九是<strong>有被删除但仍被进程占用的文件</strong>。这时，我会立即使用 <code>lsof +L1</code> 来查找这些文件及其对应的进程，并采取措施（如重启相关服务或 <code>kill</code> 进程）来释放空间。</li>
</ul>
</li>
<li><p><strong>容量规划：</strong></p>
<ul>
<li>在进行容量规划时，<code>du</code> 可以帮助我了解特定应用程序数据或日志目录的增长趋势。</li>
</ul>
</li>
</ol>
<p>理解 <code>df</code> 和 <code>du</code> 的根本差异，并结合 <code>lsof</code> 等工具，是精确诊断和解决 Linux 磁盘空间相关问题的关键。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
