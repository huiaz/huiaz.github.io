<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hui&#39;s Blog">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="六一">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%A9%BAstruct%7B%7D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%A9%BAstruct%7B%7D/" class="post-title-link" itemprop="url">Go 语言中空struct{}</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:33:48" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>您好，这是一个非常深刻的问题，对 <code>struct&#123;&#125;</code> 的理解直接反映了对 Go 语言内存模型和设计哲学的掌握程度。</p>
<p><strong>核心答案：<code>struct&#123;&#125;</code> 是一个不包含任何字段的结构体类型，它的关键特性是其实例（value）不占用任何内存空间（大小为零）。</strong></p>
<p>正因为这个特性，它在 Go 中被广泛用作一个“信号”或“占位符”，我们只关心它的<strong>存在</strong>，而完全不关心它的<strong>值</strong>。</p>
<p>我们可以通过 <code>unsafe.Sizeof</code> 来验证它的大小：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;空 struct&#123;&#125; 的大小是: %d 字节\n&quot;</span>, unsafe.Sizeof(emptyStruct)) <span class="comment">// 输出: 空 struct&#123;&#125; 的大小是: 0 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这 0 字节的特性，使其在以下两个核心场景中，成为最高效、最地道的选择。</p>
<hr>
<h3 id="用途一：实现集合（Set）-map-T-struct"><a href="#用途一：实现集合（Set）-map-T-struct" class="headerlink" title="用途一：实现集合（Set）- map[T]struct{}"></a>用途一：实现集合（Set）- <code>map[T]struct&#123;&#125;</code></h3><p><strong>问题场景：</strong> 在后端开发中，我们经常需要一个”集合”数据结构来快速判断某个元素是否存在，例如：记录已经处理过的用户 ID、存储在线用户的用户名等。Go 语言标准库没有内置的 <code>Set</code> 类型。</p>
<p><strong>解决方案：</strong> 我们可以使用 <code>map</code> 的键（key）来模拟集合。但 <code>map</code> 需要一个值（value），我们给这个值赋什么类型呢？</p>
<ul>
<li><p><strong>不好的方式: <code>map[string]bool</code></strong></p>
<ul>
<li>这很直观，<code>mySet[&quot;user1&quot;] = true</code>。</li>
<li><strong>缺点：</strong> 每个 <code>bool</code> 值都会占用 1 个字节的内存。如果你的集合中有 100 万个元素，你将浪费大约 1MB 的内存，仅仅是为了存储 <code>true</code> 这个无意义的值。</li>
</ul>
</li>
<li><p><strong>最佳实践: <code>map[string]struct&#123;&#125;</code></strong></p>
<ul>
<li>使用空结构体作为 <code>map</code> 的值。</li>
<li><strong>优点：</strong> <code>struct&#123;&#125;</code> 本身不占用内存。这使得 <code>map</code> 成为一个纯粹的、内存效率最高的集合实现。所有的内存都用于存储键和 <code>map</code> 自身的开销。</li>
</ul>
</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个用于存储用户名的集合</span></span><br><span class="line">	userSet := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- 向集合中添加元素 ---</span></span><br><span class="line">	<span class="comment">// 我们将一个空结构体的实例作为值。这个实例不占用内存。</span></span><br><span class="line">	userSet[<span class="string">&quot;alice&quot;</span>] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	userSet[<span class="string">&quot;bob&quot;</span>] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- 检查元素是否存在 ---</span></span><br><span class="line">	<span class="comment">// 这是 map 的 &quot;comma ok&quot; 用法，也是检查集合元素存在性的标准方法</span></span><br><span class="line">	username := <span class="string">&quot;alice&quot;</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := userSet[username]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;&#x27;%s&#x27; 存在于集合中\n&quot;</span>, username) <span class="comment">// 输出: &#x27;alice&#x27; 存在于集合中</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;&#x27;%s&#x27; 不存在于集合中\n&quot;</span>, username)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	username = <span class="string">&quot;charlie&quot;</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := userSet[username]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;&#x27;%s&#x27; 存在于集合中\n&quot;</span>, username)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;&#x27;%s&#x27; 不存在于集合中\n&quot;</span>, username) <span class="comment">// 输出: &#x27;charlie&#x27; 不存在于集合中</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// --- 从集合中删除元素 ---</span></span><br><span class="line">    <span class="built_in">delete</span>(userSet, <span class="string">&quot;bob&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="用途二：并发编程中的信号通知-chan-struct"><a href="#用途二：并发编程中的信号通知-chan-struct" class="headerlink" title="用途二：并发编程中的信号通知 - chan struct{}"></a>用途二：并发编程中的信号通知 - <code>chan struct&#123;&#125;</code></h3><p><strong>问题场景：</strong> 在使用 Goroutine 和 Channel 进行并发编程时，我们经常只需要一个<strong>信号</strong>，而不需要传递任何实际数据。例如：</p>
<ul>
<li>一个或多个 worker goroutine 通知 <code>main</code> goroutine “我们已经完成了任务”。</li>
<li>一个父 goroutine 通知所有子 goroutine “可以停止工作了”。</li>
</ul>
<p><strong>解决方案：</strong> 使用一个传递空结构体的 channel：<code>chan struct&#123;&#125;</code>。</p>
<ul>
<li><p><strong>不好的方式: <code>chan bool</code> 或 <code>chan int</code></strong></p>
<ul>
<li><code>done &lt;- true</code> 或 <code>done &lt;- 1</code>。</li>
<li><strong>缺点一（内存）：</strong> 传递的值 <code>true</code> 或 <code>1</code> 至少占用 1 个字节，虽然微小，但并非零。</li>
<li><strong>缺点二（意图）：</strong> 更重要的是，这会使代码的<strong>意图变得模糊</strong>。读代码的人可能会想：”为什么是 <code>true</code>？<code>false</code> 代表什么？为什么是 <code>1</code>？<code>0</code> 或 <code>-1</code> 有特殊含义吗？”。</li>
</ul>
</li>
<li><p><strong>最佳实践: <code>chan struct&#123;&#125;</code></strong></p>
<ul>
<li>使用 <code>done &lt;- struct&#123;&#125;&#123;&#125;</code> 发送信号。</li>
<li><strong>优点（清晰的意图）：</strong> <code>chan struct&#123;&#125;</code> 毫不含糊地告诉所有阅读代码的人：<strong>这个 channel 只用于传递信号，不承载任何数据</strong>。这是一种强烈的、符合语言习惯的编程约定，极大地提高了代码的可读性和可维护性。</li>
</ul>
</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Worker: 开始执行耗时任务...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟工作</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Worker: 任务完成！&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送一个信号，通知任务已完成。</span></span><br><span class="line">	<span class="comment">// 我们发送的是一个不占内存的空 struct 实例。</span></span><br><span class="line">	done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个用于信号通知的 channel</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> worker(done)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// main goroutine 在这里阻塞，等待从 done channel 接收信号</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Main: 等待 worker 完成...&quot;</span>)</span><br><span class="line">	&lt;-done</span><br><span class="line">	fmt.Println(<span class="string">&quot;Main: 已收到 worker 的完成信号，程序退出。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">使用场景</th>
<th align="left">用法</th>
<th align="left">核心优势</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现集合（Set）</strong></td>
<td align="left"><code>map[KeyType]struct&#123;&#125;</code></td>
<td align="left"><strong>内存效率最高</strong>：值（value）不占用任何内存空间。</td>
</tr>
<tr>
<td align="left"><strong>并发信号（Signaling）</strong></td>
<td align="left"><code>chan struct&#123;&#125;</code></td>
<td align="left"><strong>意图清晰</strong>：明确表示 Channel 仅用于通知，不传递任何实际数据。</td>
</tr>
<tr>
<td align="left"><strong>标记无用字段</strong></td>
<td align="left"><code>MyStruct &#123; Field struct&#123;&#125; &#125;</code></td>
<td align="left">偶尔用于标记一个字段的存在，但不需要它有值或占用空间，例如只是为了满足某个接口的字段对齐。</td>
</tr>
</tbody></table>
<p>作为后端开发人员，理解并熟练运用 <code>struct&#123;&#125;</code> 是编写高效、地道（Idiomatic）Go 代码的标志之一。它体现了 Go 语言崇尚简洁、高效和意图明确的设计哲学。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87%EF%BC%88slice%EF%BC%89%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87%EF%BC%88slice%EF%BC%89%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/" class="post-title-link" itemprop="url">Go 语言中，如何判断两个字符串切片（slice）是否相等</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:33:27" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h3 id="核心要点：为什么不能用-？"><a href="#核心要点：为什么不能用-？" class="headerlink" title="核心要点：为什么不能用 ==？"></a>核心要点：为什么不能用 <code>==</code>？</h3><p>首先，必须明确：<strong>在 Go 中，你不能直接使用 <code>==</code> 操作符来判断两个切片是否相等</strong>（除非是和 <code>nil</code> 比较）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">s2 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line"><span class="comment">// if s1 == s2 &#123; ... &#125; // 这行代码无法通过编译!</span></span><br><span class="line"><span class="comment">// 编译错误: invalid operation: s1 == s2 (slice can only be compared to nil)</span></span><br></pre></td></tr></table></figure>

<p>原因是切片本身是一个<strong>描述符（descriptor）</strong>，它由三部分组成：</p>
<ol>
<li><strong>指针（Pointer）</strong>：指向底层数组的一个元素的内存地址。</li>
<li><strong>长度（Length）</strong>：切片中包含的元素个数。</li>
<li><strong>容量（Capacity）</strong>：从切片开始位置到底层数组结尾的元素个数。</li>
</ol>
<p>直接比较 <code>s1 == s2</code> 是在比较这两个描述符，而不是它们所指向的实际数据内容。Go 语言的设计者决定不允许这种比较，以避免混淆和错误。</p>
<h3 id="“相等”的定义"><a href="#“相等”的定义" class="headerlink" title="“相等”的定义"></a>“相等”的定义</h3><p>在进行判断之前，我们需要清晰地定义 “两个字符串切片相等” 的含义。在绝大多数情况下，我们指的是：</p>
<ol>
<li>两个切片的<strong>长度相同</strong>。</li>
<li>在相同索引位置上的<strong>元素完全相同</strong>（顺序也必须一致）。</li>
<li><code>nil</code> 切片和空切片（<code>[]string&#123;&#125;</code>）被认为是相等的。</li>
</ol>
<h3 id="方法一：手动循环比较（性能最优，推荐）"><a href="#方法一：手动循环比较（性能最优，推荐）" class="headerlink" title="方法一：手动循环比较（性能最优，推荐）"></a>方法一：手动循环比较（性能最优，推荐）</h3><p>这是最直接、最高效、也是最符合 Go 语言风格的做法。通过编写一个辅助函数，我们可以实现清晰、可控的比较逻辑。</p>
<p><strong>实现逻辑：</strong></p>
<ol>
<li>首先检查两个切片的长度是否相等。如果不等，它们必然不相等，这是最快的失败路径。</li>
<li>如果长度相等，再遍历其中一个切片，逐一比较对应位置的元素。</li>
<li>只要发现任何一个位置的元素不同，就立刻返回 <code>false</code>。</li>
<li>如果循环正常结束，说明所有元素都相同，返回 <code>true</code>。</li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// areStringSlicesEqual 判断两个字符串切片是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">areStringSlicesEqual</span><span class="params">(s1, s2 []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 检查长度是否相等</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s1) != <span class="built_in">len</span>(s2) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 逐一比较元素</span></span><br><span class="line">	<span class="comment">// 如果两个切片都是 nil，长度都为0，循环不会执行，直接返回 true，符合预期。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s1 &#123;</span><br><span class="line">		<span class="keyword">if</span> s1[i] != s2[i] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 所有元素都相同</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s1 []<span class="type">string</span> <span class="comment">// nil slice</span></span><br><span class="line">	s2 := []<span class="type">string</span>&#123;&#125; <span class="comment">// empty slice</span></span><br><span class="line">	s3 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">	s4 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">	s5 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">	s6 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;s1 vs s2: %v\n&quot;</span>, areStringSlicesEqual(s1, s2)) <span class="comment">// true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;s3 vs s4: %v\n&quot;</span>, areStringSlicesEqual(s3, s4)) <span class="comment">// true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;s3 vs s5: %v\n&quot;</span>, areStringSlicesEqual(s3, s5)) <span class="comment">// false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;s3 vs s6: %v\n&quot;</span>, areStringSlicesEqual(s3, s6)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><strong>性能最高：</strong> 没有额外的函数调用开销或内存分配，是最快的比较方式。</li>
<li><strong>逻辑清晰：</strong> 代码直接反映了比较逻辑，易于理解和维护。</li>
<li><strong>无依赖：</strong> 仅使用语言内置功能。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要自己编写一个辅助函数。</li>
</ul>
<hr>
<h3 id="方法二：使用-reflect-DeepEqual（便捷，但性能较差）"><a href="#方法二：使用-reflect-DeepEqual（便捷，但性能较差）" class="headerlink" title="方法二：使用 reflect.DeepEqual（便捷，但性能较差）"></a>方法二：使用 <code>reflect.DeepEqual</code>（便捷，但性能较差）</h3><p>Go 的标准库 <code>reflect</code> 提供了一个 <code>DeepEqual</code> 函数，它可以递归地比较两个任意类型的值是否“深度相等”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s1 []<span class="type">string</span> <span class="comment">// nil slice</span></span><br><span class="line">	s2 := []<span class="type">string</span>&#123;&#125; <span class="comment">// empty slice</span></span><br><span class="line">	s3 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">	s4 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">	s5 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reflect.DeepEqual 认为 nil 切片和空切片不相等，需要注意！</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;s1 vs s2: %v\n&quot;</span>, reflect.DeepEqual(s1, s2)) <span class="comment">// false</span></span><br><span class="line">	</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s3 vs s4: %v\n&quot;</span>, reflect.DeepEqual(s3, s4)) <span class="comment">// true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;s3 vs s5: %v\n&quot;</span>, reflect.DeepEqual(s3, s5)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><strong>方便快捷：</strong> 无需编写辅助函数，一行代码即可搞定。</li>
<li><strong>通用性强：</strong> 不仅限于字符串切片，可以比较任意复杂的类型（如 map, struct, 嵌套切片等）。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>性能开销大：</strong> 反射（Reflection）在运行时需要分析值的类型和结构，比直接的循环比较慢得多。</li>
<li><strong>行为差异：</strong> <code>reflect.DeepEqual</code> 对 <code>nil</code> 和空切片的处理规则可能与你的业务逻辑不符。它认为 <code>nil</code> 切片和空切片是<strong>不相等</strong>的，这一点需要特别留意。</li>
</ul>
<hr>
<h3 id="特殊情况：如果顺序无关怎么办？"><a href="#特殊情况：如果顺序无关怎么办？" class="headerlink" title="特殊情况：如果顺序无关怎么办？"></a>特殊情况：如果顺序无关怎么办？</h3><p>如果你的需求是判断两个切片是否包含<strong>相同的元素集合</strong>，而<strong>不关心它们的顺序</strong>，那么问题就从“切片相等”变成了“集合相等”。</p>
<p>这时，你需要使用 <code>map</code> 来辅助判断。</p>
<p><strong>实现逻辑：</strong></p>
<ol>
<li>检查长度是否相等，这是必要条件。</li>
<li>创建一个 <code>map[string]int</code> 来统计第一个切片中每个字符串出现的次数。</li>
<li>遍历第二个切片，对于每个元素，去 <code>map</code> 中查找并将其计数减一。</li>
<li>如果发现 <code>map</code> 中没有该元素，或者该元素的计数已经为0，则两个集合不相等。</li>
</ol>
<p><strong>代码示例:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">areStringSetsEqual</span><span class="params">(s1, s2 []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s1) != <span class="built_in">len</span>(s2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="built_in">len</span>(s1))</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> s1 &#123;</span><br><span class="line">        counts[item]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        <span class="keyword">if</span> counts[item] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 元素不存在或数量不匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">        counts[item]--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">s1 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">s2 := []<span class="type">string</span>&#123;<span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line"><span class="comment">// areStringSetsEqual(s1, s2) -&gt; true</span></span><br></pre></td></tr></table></figure>

<h3 id="最终总结与建议"><a href="#最终总结与建议" class="headerlink" title="最终总结与建议"></a>最终总结与建议</h3><table>
<thead>
<tr>
<th>方法</th>
<th>性能</th>
<th>易用性</th>
<th>行为说明</th>
<th>推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>手动循环比较</strong></td>
<td><strong>最优</strong></td>
<td>中等</td>
<td>逻辑清晰，完全可控。<code>nil</code> 和空切片相等。</td>
<td><strong>绝大多数情况下的首选</strong>，尤其是在性能敏感的后端服务、库函数中。</td>
</tr>
<tr>
<td><strong><code>reflect.DeepEqual</code></strong></td>
<td>较差</td>
<td><strong>最高</strong></td>
<td>通用性强，但有反射开销。<code>nil</code> 和空切片不相等。</td>
<td>用于编写<strong>测试用例</strong>、非性能热点的工具脚本，或处理复杂未知结构时。</td>
</tr>
</tbody></table>
<p><strong>作为后端开发专家，我强烈建议您使用第一种方法：手动循环比较。</strong></p>
<p>它不仅性能更好，而且能让您对代码的行为有百分之百的掌控，这对于构建稳定、高效的系统至关重要。将这个辅助函数放在一个公共的 <code>utils</code> 包中，便可在整个项目中复用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E6%88%96%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E5%90%97%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E6%88%96%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E5%90%97%EF%BC%9F/" class="post-title-link" itemprop="url">Go 语言支持默认参数或可选参数吗？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:33:14" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Go 语言支持默认参数或可选参数吗？</p>
<p>直接的答案是：<strong>不，Go 语言从语言层面不支持函数默认参数或可选参数。</strong></p>
<p>这与 Python 的 <code>def func(arg1, optional_arg=&quot;default&quot;)</code> 或 C++ 的 <code>void func(int arg1, int optional_arg = 0)</code> 不同。Go 的设计者们出于对代码<strong>明确性（explicitness）</strong>和<strong>可读性（readability）</strong>的极致追求，刻意省略了这个特性。</p>
<p>作为后端开发专家，我将为您阐述其背后的设计考量，并提供 Go 语言中实现类似功能的几种惯用（idiomatic）模式。</p>
<hr>
<h3 id="一、为什么-Go-选择不支持？——-设计哲学"><a href="#一、为什么-Go-选择不支持？——-设计哲学" class="headerlink" title="一、为什么 Go 选择不支持？—— 设计哲学"></a>一、为什么 Go 选择不支持？—— 设计哲学</h3><p>Go 语言的设计哲学强调“少即是多”（Less is more）和“明晰胜于隐含”（Clarity is better than implicitness）。不支持默认&#x2F;可选参数主要基于以下考量：</p>
<ol>
<li><p><strong>提升代码可读性和明确性：</strong><br>当函数调用者写下 <code>createUser(&quot;admin&quot;)</code> 时，如果 <code>createUser</code> 函数签名是 <code>func createUser(name string, role string, active bool)</code>，调用者可能不清楚 <code>role</code> 和 <code>active</code> 的默认值是什么。他必须跳转到函数定义去查看。Go 语言希望每一次函数调用都是自解释的、清晰的。<code>createUser(&quot;admin&quot;, &quot;admin_role&quot;, true)</code> 这样显式的调用虽然更长，但意图一目了然，不会产生任何歧义。</p>
</li>
<li><p><strong>简化语言规范：</strong><br>引入默认参数会使函数签名变得复杂。例如，如何处理 <code>func(a int, b int = 10, c int)</code> 这样的情况？这会增加语言解析的复杂度和学习成本。Go 致力于保持语言本身的简单。</p>
</li>
<li><p><strong>避免函数重载的需要：</strong><br>在其他语言中，默认参数常常和函数重载（function overloading）一起使用。Go 从根本上就不支持函数重载，它认为使用不同名字的函数（如 <code>CreateUser</code> 和 <code>CreateUserWithRole</code>）来表达不同的行为是更清晰的模式。</p>
</li>
</ol>
<hr>
<p>###二、Go 的惯用解决方案 (Idiomatic Go Solutions)</p>
<p>既然语言本身不支持，Go 社区发展出了几种非常优雅且高效的模式来解决这个问题。</p>
<h4 id="模式一：使用配置结构体-Options-Struct-推荐的首选方案"><a href="#模式一：使用配置结构体-Options-Struct-推荐的首选方案" class="headerlink" title="模式一：使用配置结构体 (Options Struct) - 推荐的首选方案"></a>模式一：使用配置结构体 (Options Struct) - <strong>推荐的首选方案</strong></h4><p>这是最常见、最清晰、也是最具扩展性的方法。它的核心思想是：将所有可选参数聚合到一个配置结构体中，并将该结构体的指针作为函数参数。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>定义一个 <code>Config</code> 或 <code>Options</code> 结构体来封装所有参数。</li>
<li>函数接收这个结构体的指针。</li>
<li>函数内部检查传入的配置，如果为 <code>nil</code> 或某些字段为零值，则使用预设的默认值。</li>
</ol>
<p><strong>代码示例：</strong></p>
<p>假设我们要创建一个 HTTP 服务器，它有必须的 <code>Address</code>，但 <code>Port</code> 和 <code>Timeout</code> 是可选的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义配置结构体</span></span><br><span class="line"><span class="keyword">type</span> ServerConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	Port    <span class="type">int</span></span><br><span class="line">	Timeout time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. NewServer 函数接收一个必须参数和一个可选的配置指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(address <span class="type">string</span>, config *ServerConfig)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置默认值</span></span><br><span class="line">	defaultPort := <span class="number">8080</span></span><br><span class="line">	defaultTimeout := <span class="number">30</span> * time.Second</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果传入了配置，则覆盖默认值</span></span><br><span class="line">	<span class="keyword">if</span> config != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> config.Port != <span class="number">0</span> &#123;        <span class="comment">// 检查零值来决定是否覆盖</span></span><br><span class="line">			defaultPort = config.Port</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> config.Timeout != <span class="number">0</span> &#123;</span><br><span class="line">			defaultTimeout = config.Timeout</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Starting server at %s:%d with timeout %v\n&quot;</span>,</span><br><span class="line">		address, defaultPort, defaultTimeout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 场景1: 不提供任何可选参数，使用全部默认值</span></span><br><span class="line">	<span class="comment">// 传入 nil 表示使用所有默认配置</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;--- 场景1: 使用默认配置 ---&quot;</span>)</span><br><span class="line">	NewServer(<span class="string">&quot;localhost&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 场景2: 只提供部分可选参数</span></span><br><span class="line">	<span class="comment">// 创建一个配置实例，只设置我们关心的字段</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 场景2: 自定义端口 ---&quot;</span>)</span><br><span class="line">	NewServer(<span class="string">&quot;localhost&quot;</span>, &amp;ServerConfig&#123;</span><br><span class="line">		Port: <span class="number">9000</span>,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 场景3: 提供所有可选参数</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 场景3: 自定义所有配置 ---&quot;</span>)</span><br><span class="line">	NewServer(<span class="string">&quot;localhost&quot;</span>, &amp;ServerConfig&#123;</span><br><span class="line">		Port:    <span class="number">8888</span>,</span><br><span class="line">		Timeout: <span class="number">60</span> * time.Second,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><strong>高度可读：</strong> <code>&amp;ServerConfig&#123;Port: 9000&#125;</code> 清晰地标明了要修改哪个参数。</li>
<li><strong>易于扩展：</strong> 未来如果需要增加新的可选参数（如<code>MaxConnections</code>），只需在 <code>ServerConfig</code> 结构体中增加一个字段即可，函数签名完全不需要改变，保持了向后兼容。</li>
<li><strong>零值即默认：</strong> 巧妙地利用了 Go 的零值机制。</li>
</ul>
<h4 id="模式二：函数式选项模式-Functional-Options-Pattern-高级模式"><a href="#模式二：函数式选项模式-Functional-Options-Pattern-高级模式" class="headerlink" title="模式二：函数式选项模式 (Functional Options Pattern) - 高级模式"></a>模式二：函数式选项模式 (Functional Options Pattern) - <strong>高级模式</strong></h4><p>这是一种更高级、更灵活的模式，常见于知名的 Go 库中（如 gRPC, Docker SDK）。它将每个“选项”都实现为一个函数。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>定义一个 <code>Option</code> 函数类型，它接收一个指向配置对象的指针。</li>
<li>为每个可选参数编写一个返回 <code>Option</code> 的函数（例如 <code>WithPort</code>, <code>WithTimeout</code>）。</li>
<li>主构造函数接收一个可变数量的 <code>Option</code> 函数作为参数，并依次应用它们。</li>
</ol>
<p><strong>代码示例（续上例）：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">	Port    <span class="type">int</span></span><br><span class="line">	Timeout time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义 Option 函数类型</span></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*Server)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 为每个选项编写一个返回 Option 的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPort</span><span class="params">(port <span class="type">int</span>)</span></span> Option &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">		s.Port = port</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(timeout time.Duration)</span></span> Option &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">		s.Timeout = timeout</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. NewServer 接收可变数量的 Option</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(address <span class="type">string</span>, options ...Option)</span></span> *Server &#123;</span><br><span class="line">	<span class="comment">// 初始化带默认值的 Server</span></span><br><span class="line">	srv := &amp;Server&#123;</span><br><span class="line">		Address: address,</span><br><span class="line">		Port:    <span class="number">8080</span>,</span><br><span class="line">		Timeout: <span class="number">30</span> * time.Second,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环应用所有传入的 options 函数，覆盖默认值</span></span><br><span class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> options &#123;</span><br><span class="line">		opt(srv)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> srv</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 场景1: 使用默认值</span></span><br><span class="line">	s1 := NewServer(<span class="string">&quot;localhost&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Server 1: %+v\n&quot;</span>, s1)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 场景2: 自定义端口和超时</span></span><br><span class="line">	s2 := NewServer(<span class="string">&quot;localhost&quot;</span>, WithPort(<span class="number">9000</span>), WithTimeout(<span class="number">60</span>*time.Second))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Server 2: %+v\n&quot;</span>, s2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 场景3: 只自定义超时，顺序无关</span></span><br><span class="line">	s3 := NewServer(<span class="string">&quot;localhost&quot;</span>, WithTimeout(<span class="number">10</span>*time.Second))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Server 3: %+v\n&quot;</span>, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><strong>极高的灵活性和可读性：</strong> 调用链 <code>NewServer(&quot;localhost&quot;, WithPort(9000))</code> 非常清晰。</li>
<li><strong>良好的封装：</strong> <code>Server</code> 结构体的字段可以是私有的，只能通过 <code>Option</code> 函数修改，控制力更强。</li>
</ul>
<hr>
<h3 id="三、总结与对比"><a href="#三、总结与对比" class="headerlink" title="三、总结与对比"></a>三、总结与对比</h3><table>
<thead>
<tr>
<th>模式</th>
<th>适用场景</th>
<th>复杂度</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>配置结构体</strong> (首选)</td>
<td><strong>绝大多数应用和内部项目。</strong> 简单、直接、高效。</td>
<td><strong>低</strong></td>
<td>易于理解和实现，极佳的可扩展性。</td>
<td>需要暴露配置结构体。</td>
</tr>
<tr>
<td><strong>函数式选项</strong> (高级)</td>
<td><strong>公共库、SDK、需要复杂配置的 API。</strong></td>
<td><strong>中</strong></td>
<td>灵活性和封装性极佳，调用方式非常优雅。</td>
<td>实现稍复杂，样板代码多。</td>
</tr>
</tbody></table>
<p><strong>结论：</strong><br>Go 语言不支持默认参数是其设计哲学的一种体现，旨在强制开发者编写清晰、明确、易于维护的代码。在实践中，<strong>配置结构体（Options Struct）模式</strong>是解决此类问题的黄金标准，而<strong>函数式选项模式</strong>则为库和框架的作者提供了更强大的武器。这两种模式都比简单的默认参数更为健壮和可扩展，体现了 Go 语言在设计上对代码长期健康度的深刻考量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9C%89%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9C%89%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F/" class="post-title-link" itemprop="url">Go 语言的有类型常量和无类型常量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:33:05" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、无类型常量-Untyped-Constants"><a href="#一、无类型常量-Untyped-Constants" class="headerlink" title="一、无类型常量 (Untyped Constants)"></a>一、无类型常量 (Untyped Constants)</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>无类型常量是一个没有固定 Go 语言类型的值。它只拥有一个<strong>默认类型（Default Type）</strong>，但直到它被用于需要特定类型表达式的上下文中，它才真正“获得”一个类型。</p>
<ul>
<li><strong>默认类型规则：</strong><ul>
<li>普通的整数字面量：<code>int</code></li>
<li>浮点数字面量：<code>float64</code></li>
<li>符文字面量（用单引号）：<code>rune</code> (即 <code>int32</code>)</li>
<li>字符串字面量：<code>string</code></li>
<li>复数字面量：<code>complex128</code></li>
</ul>
</li>
</ul>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul>
<li><strong>类型灵活性：</strong> 这是无类型常量最核心的特点。它们可以被用于任何兼容的类型上下文，只要其值在目标类型范围内。编译器会根据上下文自动推断或转换其类型。</li>
<li><strong>字面值精确：</strong> 无类型常量可以表示比任何 Go 类型都更高的精度。例如，一个无类型浮点常量可以拥有无限的精度，直到它被赋予一个 Go 的 <code>float32</code> 或 <code>float64</code> 类型。</li>
<li><strong>不参与类型检查：</strong> 在进行算术运算时，只要运算的常量都是无类型的，它们之间不会触发严格的类型检查，这使得混合不同“种类”的数字（如整数和浮点数）进行计算变得非常方便。</li>
</ul>
<h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明无类型常量</span></span><br><span class="line">	<span class="keyword">const</span> UntypedInt = <span class="number">100</span>            <span class="comment">// 默认类型 int</span></span><br><span class="line">	<span class="keyword">const</span> UntypedFloat = <span class="number">3.1415926535</span> <span class="comment">// 默认类型 float64</span></span><br><span class="line">	<span class="keyword">const</span> UntypedString = <span class="string">&quot;Hello, Go!&quot;</span> <span class="comment">// 默认类型 string</span></span><br><span class="line">	<span class="keyword">const</span> UntypedBool = <span class="literal">true</span>          <span class="comment">// 默认类型 bool</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;UntypedInt 类型：%T, 值：%v\n&quot;</span>, UntypedInt, UntypedInt) <span class="comment">// int, 100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;UntypedFloat 类型：%T, 值：%v\n&quot;</span>, UntypedFloat, UntypedFloat) <span class="comment">// float64, 3.1415926535</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 无类型常量可以赋值给不同类型的变量，只要值能装下</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span> = UntypedInt</span><br><span class="line">	<span class="keyword">var</span> i32 <span class="type">int32</span> = UntypedInt <span class="comment">// 100 能够适配 int32</span></span><br><span class="line">	<span class="keyword">var</span> f64 <span class="type">float64</span> = UntypedInt <span class="comment">// 100 能够适配 float64</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;var i int: %v, var i32 int32: %v, var f64 float64: %v\n&quot;</span>, i, i32, f64)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> f32 <span class="type">float32</span> = UntypedFloat <span class="comment">// 3.1415926535 会被截断以适配 float32</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;var f32 float32: %v\n&quot;</span>, f32) <span class="comment">// 3.1415927</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 无类型常量之间的运算可以跨“种类”</span></span><br><span class="line">	<span class="keyword">const</span> result = UntypedInt * UntypedFloat <span class="comment">// Result 仍然是无类型常量 (默认 float64)</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;UntypedInt * UntypedFloat 类型：%T, 值：%v\n&quot;</span>, result, result) <span class="comment">// float64, 314.15926535</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 无类型常量可以作为函数参数，函数签名决定了常量类型</span></span><br><span class="line">	fmt.Println(addInt(UntypedInt))      <span class="comment">// addInt 接受 int 类型</span></span><br><span class="line">	fmt.Println(addFloat(UntypedFloat))  <span class="comment">// addFloat 接受 float64 类型</span></span><br><span class="line">	fmt.Println(addFloat(UntypedInt))    <span class="comment">// 100 会被自动转换为 float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addInt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addFloat</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、有类型常量-Typed-Constants"><a href="#二、有类型常量-Typed-Constants" class="headerlink" title="二、有类型常量 (Typed Constants)"></a>二、有类型常量 (Typed Constants)</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>有类型常量是在声明时就明确指定了其 Go 语言类型的常量。</p>
<h4 id="2-特点-1"><a href="#2-特点-1" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul>
<li><strong>严格类型检查：</strong> 一旦常量被赋予了特定的类型，它就会像该类型的一个变量一样，严格遵守 Go 语言的类型系统规则。</li>
<li><strong>不兼容类型赋值需要显式转换：</strong> 除非目标类型是其本身或其底层类型，否则不能直接将有类型常量赋值给不同类型的变量，需要进行显式类型转换。</li>
<li><strong>适用于 <code>iota</code> 枚举：</strong> 在 <code>iota</code> 用于创建一系列枚举值时，通常会给这些常量指定一个底层类型，以确保类型安全。</li>
</ul>
<h4 id="3-示例-1"><a href="#3-示例-1" class="headerlink" title="3. 示例"></a>3. 示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明有类型常量</span></span><br><span class="line">	<span class="keyword">const</span> TypedInt <span class="type">int</span> = <span class="number">200</span></span><br><span class="line">	<span class="keyword">const</span> TypedFloat <span class="type">float32</span> = <span class="number">6.28</span> <span class="comment">// 注意，这里是 float32</span></span><br><span class="line">	<span class="keyword">const</span> TypedString <span class="type">string</span> = <span class="string">&quot;Go Lang&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;TypedInt 类型：%T, 值：%v\n&quot;</span>, TypedInt, TypedInt) <span class="comment">// int, 200</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;TypedFloat 类型：%T, 值：%v\n&quot;</span>, TypedFloat, TypedFloat) <span class="comment">// float32, 6.28</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有类型常量赋值给相同或兼容类型的变量</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span> = TypedInt</span><br><span class="line">	fmt.Printf(<span class="string">&quot;var i int: %v\n&quot;</span>, i)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尝试将有类型常量赋值给不兼容类型，需要显式转换</span></span><br><span class="line">	<span class="comment">// var i32 int32 = TypedInt // 编译错误！cannot use TypedInt (type int) as type int32 in assignment</span></span><br><span class="line">	<span class="keyword">var</span> i32 <span class="type">int32</span> = <span class="type">int32</span>(TypedInt) <span class="comment">// 正确做法：显式转换</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;var i32 int32: %v\n&quot;</span>, i32)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有类型常量与无类型常量或不同类型的有类型常量运算</span></span><br><span class="line">	<span class="comment">// const badResult = TypedInt * TypedFloat // 编译错误！mismatched types int and float32</span></span><br><span class="line">	<span class="keyword">const</span> goodResult <span class="type">float64</span> = <span class="type">float64</span>(TypedInt) * <span class="type">float64</span>(TypedFloat) <span class="comment">// 需要先转换类型才能运算</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;TypedInt * TypedFloat (转换后) 类型：%T, 值：%v\n&quot;</span>, goodResult, goodResult) <span class="comment">// float64, 1256</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有类型常量在 iota 中的应用</span></span><br><span class="line">	<span class="keyword">type</span> Direction <span class="type">int</span></span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		North Direction = <span class="literal">iota</span> <span class="comment">// North 是 Direction 类型，值为 0</span></span><br><span class="line">		East                   <span class="comment">// East 是 Direction 类型，值为 1</span></span><br><span class="line">		South                  <span class="comment">// South 是 Direction 类型，值为 2</span></span><br><span class="line">		West                   <span class="comment">// West 是 Direction 类型，值为 3</span></span><br><span class="line">	)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;North 类型：%T, 值：%v\n&quot;</span>, North, North) <span class="comment">// main.Direction, 0</span></span><br><span class="line">	<span class="comment">// var d int = North // 编译错误！cannot use North (type Direction) as type int in assignment</span></span><br><span class="line">	<span class="keyword">var</span> d <span class="type">int</span> = <span class="type">int</span>(North) <span class="comment">// 需要显式转换</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;var d int: %v\n&quot;</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">无类型常量 (Untyped Constants)</th>
<th align="left">有类型常量 (Typed Constants)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>声明方式</strong></td>
<td align="left"><code>const Name = value</code> (无显式类型)</td>
<td align="left"><code>const Name Type = value</code> (有显式类型)</td>
</tr>
<tr>
<td align="left"><strong>类型状态</strong></td>
<td align="left">默认具有隐含的“种类” (如 <code>integer</code>, <code>float</code>)，但在编译时没有固定 Go 类型。在上下文需要时才获得类型。</td>
<td align="left">从声明起就固定为指定的 Go 类型。</td>
</tr>
<tr>
<td align="left"><strong>类型灵活性</strong></td>
<td align="left"><strong>高</strong>：可以赋值给任何兼容类型，编译器自动处理类型匹配。</td>
<td align="left"><strong>低</strong>：严格遵守类型规则，赋值给不同类型需要显式转换。</td>
</tr>
<tr>
<td align="left"><strong>精度</strong></td>
<td align="left">可以保持更高（甚至是理论上无限）的精度，直到被赋值给具体类型。</td>
<td align="left">精度由其声明的 Go 类型决定。</td>
</tr>
<tr>
<td align="left"><strong>运算规则</strong></td>
<td align="left">可以与其他无类型常量，或任何兼容类型的变量&#x2F;常量混合运算，编译器自动处理类型提升&#x2F;转换。</td>
<td align="left">严格遵守类型规则，与不同类型运算时需要显式转换。</td>
</tr>
<tr>
<td align="left"><strong>常见用途</strong></td>
<td align="left">大多数数字、字符串常量，提供最大灵活性。</td>
<td align="left">需要严格类型约束的场景，如 <code>iota</code> 定义的枚举类型。</td>
</tr>
<tr>
<td align="left"><strong>实际体验</strong></td>
<td align="left">更“宽松”，减少显式类型转换。</td>
<td align="left">更“严格”，提供更强的类型安全保障。</td>
</tr>
</tbody></table>
<hr>
<h3 id="何时使用哪种？"><a href="#何时使用哪种？" class="headerlink" title="何时使用哪种？"></a>何时使用哪种？</h3><ul>
<li><strong>优先使用无类型常量：</strong> 在大多数情况下，当你声明一个数字或字符串常量时，你通常希望它能尽可能灵活地用于不同的数字类型上下文（<code>int</code>, <code>int32</code>, <code>float64</code> 等）。无类型常量正是为此而设计，它们能减少不必要的类型转换，使代码更简洁。</li>
<li><strong>使用有类型常量：</strong><ol>
<li>当你需要将一系列常量定义为特定的枚举类型时，例如 <code>const ( A MyType = iota )</code>。</li>
<li>当你<strong>明确希望</strong>常量具有特定的类型，从而强制执行严格的类型检查，防止意外的类型转换或赋值错误。这通常在设计 API 或库时对外部接口的类型有严格要求时使用。</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E5%90%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E5%90%97/" class="post-title-link" itemprop="url">Go 语言类型的值可以修改吗</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：22:33:10" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Go 语言类型的值可以修改吗？</p>
<p>您好！这是一个非常精确且深入的问题，它涉及到 Go 语言中类型行为的核心——<strong>可变性（Mutability）</strong>和<strong>值语义&#x2F;引用语义（Value Semantics &#x2F; Reference Semantics）</strong>。</p>
<p>答案是：<strong>取决于具体的类型。</strong></p>
<p>Go 语言中的类型可以大致分为两类：<strong>不可修改值（Immutable）</strong>的类型和<strong>可以修改值（Mutable）</strong>的类型。同时，理解<strong>值传递</strong>和<strong>引用传递（通过指针）</strong>对理解可变性至关重要。</p>
<hr>
<h3 id="一、-值不可修改的类型-Immutable-Types"><a href="#一、-值不可修改的类型-Immutable-Types" class="headerlink" title="一、 值不可修改的类型 (Immutable Types)"></a>一、 值不可修改的类型 (Immutable Types)</h3><p>这些类型的变量一旦被创建并赋值，它们自身的值就不能被“原地”修改。如果你尝试修改它们，实际上是创建了一个新的值，然后将这个新值赋给了变量（这被称为“重赋值”），而不是修改了原始值所在的内存。</p>
<ol>
<li><p><strong>基本数据类型：</strong></p>
<ul>
<li><code>int</code>, <code>float32</code>, <code>float64</code>, <code>bool</code>, <code>complex64</code>, <code>complex128</code>, <code>byte</code>, <code>rune</code> 等所有数值型和布尔型。</li>
<li>修改这些类型的变量意味着为其赋一个新值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Initial x: %d, Address: %p\n&quot;</span>, x, &amp;x) <span class="comment">// 假设地址是 0xAAA</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">20</span> <span class="comment">// 实际上是创建了一个新的 int 值 20，然后将 x 指向它（或者在栈上直接覆盖）</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Modified x: %d, Address: %p\n&quot;</span>, x, &amp;x) <span class="comment">// 地址仍然是 0xAAA，但内容变了</span></span><br><span class="line">                                                <span class="comment">// 对于栈上的基本类型，是直接覆盖；对于堆上的，可能是新的内存分配</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串 (<code>string</code>)：</strong></p>
<ul>
<li>Go 语言中的字符串是不可变的字节序列。任何对字符串的操作，如拼接 (<code>+</code>)、切片 (<code>[i:j]</code>) 或通过 <code>strings</code> 包的函数处理，都会产生一个新的字符串，而原始字符串保持不变。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Initial s: %q, Address: %p\n&quot;</span>, s, &amp;s) <span class="comment">// 假设地址是 0xBBB</span></span><br><span class="line"></span><br><span class="line">s = s + <span class="string">&quot; world&quot;</span> <span class="comment">// 这创建了一个新的字符串 &quot;hello world&quot;，并将其赋给 s</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Modified s: %q, Address: %p\n&quot;</span>, s, &amp;s) <span class="comment">// s 的地址可能相同，但潜在的底层数据指针可能指向新内存</span></span><br><span class="line">                                                 <span class="comment">// 关键是，&quot;hello&quot; 那个字符串数据本身没有被修改。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="二、-值可以修改的类型-Mutable-Types"><a href="#二、-值可以修改的类型-Mutable-Types" class="headerlink" title="二、 值可以修改的类型 (Mutable Types)"></a>二、 值可以修改的类型 (Mutable Types)</h3><p>这些类型的变量在创建并赋值后，可以在不改变变量本身内存地址的情况下，修改其内部的内容或结构。</p>
<ol>
<li><p><strong>切片 (<code>slice</code>)：</strong></p>
<ul>
<li>切片是引用类型，它包含一个指向底层数组的指针、长度和容量。</li>
<li>你可以通过索引修改切片中的元素，或使用 <code>append</code>、<code>copy</code> 等操作来改变其长度和内容（可能在必要时重新分配底层数组）。这些操作会直接影响切片引用的底层数据。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Initial slice: %v, underlying address of 0th element: %p\n&quot;</span>, s, &amp;s[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// 直接修改了底层数组的第一个元素</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Modified slice: %v, underlying address of 0th element: %p\n&quot;</span>, s, &amp;s[<span class="number">0</span>]) <span class="comment">// 地址不变，值变了</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>) <span class="comment">// append 可能会导致底层数组重新分配，但切片概念上是可变的</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Appended slice: %v\n&quot;</span>, s)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>映射 (<code>map</code>)：</strong></p>
<ul>
<li>映射也是引用类型。你可以添加、删除或修改映射中的键值对。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Initial map: %v\n&quot;</span>, m)</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="number">10</span> <span class="comment">// 修改现有键的值</span></span><br><span class="line">m[<span class="string">&quot;c&quot;</span>] = <span class="number">30</span> <span class="comment">// 添加新的键值对</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Modified map: %v\n&quot;</span>, m)</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;b&quot;</span>) <span class="comment">// 删除键值对</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;After delete map: %v\n&quot;</span>, m)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通道 (<code>channel</code>)：</strong></p>
<ul>
<li>通道用于并发通信。你可以向通道发送数据或从通道接收数据，这改变了通道的内部状态（例如，缓冲区中的数据）。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 向通道发送数据，改变通道内部状态</span></span><br><span class="line">val := &lt;-ch <span class="comment">// 从通道接收数据，再次改变通道内部状态</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Channel value: %d\n&quot;</span>, val)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数组 (<code>array</code>)：</strong></p>
<ul>
<li>数组的<strong>元素</strong>是可修改的。你可以通过索引直接修改数组中的元素。</li>
<li><strong>然而，需要特别注意：</strong> 数组是<strong>值类型</strong>。这意味着当你将一个数组赋给另一个变量，或者将数组作为参数传递给函数时，会创建一个<strong>完整的副本</strong>。对副本的修改不会影响原始数组。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Initial Array: %v, Address: %p\n&quot;</span>, arr, &amp;arr)</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// 修改数组的元素</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Modified Array: %v, Address: %p\n&quot;</span>, arr, &amp;arr) <span class="comment">// 地址不变，元素值变了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组作为函数参数是值拷贝</span></span><br><span class="line">modifyArray(arr)</span><br><span class="line">fmt.Printf(<span class="string">&quot;After modifyArray (original): %v\n&quot;</span>, arr) <span class="comment">// 仍然是 [10 2 3], 没变</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(a [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Inside modifyArray (copy): %v\n&quot;</span>, a) <span class="comment">// [99 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结构体 (<code>struct</code>)：</strong></p>
<ul>
<li>结构体的<strong>字段</strong>是可修改的。你可以直接修改结构体实例的字段。</li>
<li><strong>同样需要注意：</strong> 结构体也是<strong>值类型</strong>。当你将一个结构体赋给另一个变量，或者将结构体作为参数传递给函数时，会创建一个<strong>完整的副本</strong>。对副本的修改不会影响原始结构体。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Initial Person: %+v, Address: %p\n&quot;</span>, p, &amp;p)</span><br><span class="line"></span><br><span class="line">p.Age = <span class="number">31</span> <span class="comment">// 修改结构体字段</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Modified Person: %+v, Address: %p\n&quot;</span>, p, &amp;p) <span class="comment">// 地址不变，字段值变了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体作为函数参数是值拷贝</span></span><br><span class="line">changeName(p)</span><br><span class="line">fmt.Printf(<span class="string">&quot;After changeName (original): %+v\n&quot;</span>, p) <span class="comment">// 仍然是 &#123;Name:Alice Age:31&#125;, Nome 没变</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeName</span><span class="params">(person Person)</span></span> &#123;</span><br><span class="line">    person.Name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Inside changeName (copy): %+v\n&quot;</span>, person) <span class="comment">// &#123;Name:Bob Age:31&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指针 (<code>*T</code>)：</strong></p>
<ul>
<li>指针本身是可修改的：你可以让它指向不同的地址。</li>
<li><strong>指针指向的值</strong>通常也是可修改的（如果它指向的是一个可修改类型的值）。通过解引用 (<code>*ptr</code>) 可以修改它所指向的值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">ptr := &amp;val <span class="comment">// ptr 指向 val</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Initial *ptr: %d\n&quot;</span>, *ptr)</span><br><span class="line"></span><br><span class="line">*ptr = <span class="number">20</span> <span class="comment">// 通过指针修改 val 的值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Modified *ptr: %d, val: %d\n&quot;</span>, *ptr, val) <span class="comment">// 都变成了 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherVal <span class="type">int</span> = <span class="number">30</span></span><br><span class="line">ptr = &amp;anotherVal <span class="comment">// 让 ptr 指向另一个变量，指针本身的值改变了</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ptr now points to: %d\n&quot;</span>, *ptr) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="三、-总结与实践建议"><a href="#三、-总结与实践建议" class="headerlink" title="三、 总结与实践建议"></a>三、 总结与实践建议</h3><ul>
<li><strong>值类型 (Value Types)<strong>：<code>int</code>, <code>float</code>, <code>bool</code>, <code>string</code>, <code>array</code>, <code>struct</code>。当你赋值或传递这类变量时，会创建一个</strong>副本</strong>。对副本的修改不会影响原始变量。<ul>
<li>如果你希望函数能够修改原始的 <code>array</code> 或 <code>struct</code>，你必须传递它们的<strong>指针</strong>。</li>
</ul>
</li>
<li><strong>引用类型 (Reference Types &#x2F; Pointer-like Types)<strong>：<code>slice</code>, <code>map</code>, <code>channel</code>, <code>func</code>, <code>interface</code>。当你赋值或传递这类变量时，传递的是一个对底层数据结构的</strong>引用</strong>。对引用的操作（如修改切片元素，增删映射条目）会影响所有持有该引用的变量。<ul>
<li><code>string</code> 虽属于基本类型，但其不变性是重要特性。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Grafana/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/Grafana/" class="post-title-link" itemprop="url">Grafana</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:39:01" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/" itemprop="url" rel="index"><span itemprop="name">k8s-monitor</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/" itemprop="url" rel="index"><span itemprop="name">Prometheus</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s-monitor/Prometheus/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h1><p>前面我们使用 Prometheus 采集了 Kubernetes 集群中的一些监控数据指标，我们也尝试使用 promQL 语句查询出了一些数据，并且在 Prometheus 的 Dashboard 中进行了展示，但是明显可以感觉到 Prometheus 的图表功能相对较弱，所以一般情况下我们还是会使用 Grafana 来进行展示，前面我们已经详细学习过 Grafana 的使用了，这里我们在 Kubernetes 集群中使用，所以同样可以将 Grafana 安装到集群中来，当然在集群外也是可以的。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>第一步去查看 grafana 的 docker 镜像的介绍，我们可以在 dockerhub 上去搜索，也可以在官网去查看相关资料，镜像地址如下：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/grafana/grafana/%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BB%8B%E7%BB%8D%E4%B8%AD%E8%BF%90%E8%A1%8C">https://hub.docker.com/r/grafana/grafana/，我们可以看到介绍中运行</a> grafana 容器的命令非常简单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=grafana -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure>

<p>但是还有一个需要注意的是 Changelog 中 v5.1.0 版本的更新介绍：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Major restructuring of the container</span><br><span class="line">Usage of chown removed</span><br><span class="line">File permissions incompatibility with previous versions</span><br><span class="line">user id changed from 104 to 472</span><br><span class="line">group id changed from 107 to 472</span><br><span class="line">Runs as the grafana user by default (instead of root)</span><br><span class="line">All default volumes removed</span><br></pre></td></tr></table></figure>

<p>特别需要注意第 3 条，<code>userid</code> 和 <code>groupid</code> 都有所变化，所以我们在运行的容器的时候需要注意这个变化。现在我们将这个容器转化成 Kubernetes 中的 Pod：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grafana.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">grafana-data</span></span><br><span class="line">      <span class="attr">initContainers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fix-permissions</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">chown</span>, <span class="string">-R</span>, <span class="string">&#x27;472:472&#x27;</span>, <span class="string">&#x27;/var/lib/grafana&#x27;</span>]</span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/grafana</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">grafana/grafana:8.3.3</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3000</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_SECURITY_ADMIN_USER</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">admin</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_SECURITY_ADMIN_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">admin321</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/api/health</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/api/health</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">150m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">150m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/grafana</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana-local</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-storage</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/k8s/grafana</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">node2</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana-data</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-mon</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-storage</span></span><br></pre></td></tr></table></figure>

<p>我们使用了最新的镜像 <code>grafana/grafana:8.3.3</code>，然后添加了健康检查、资源声明，另外两个比较重要的环境变量<code>GF_SECURITY_ADMIN_USER</code> 和 <code>GF_SECURITY_ADMIN_PASSWORD</code>，用来配置 grafana 的管理员用户和密码的，由于 grafana 将 dashboard、插件这些数据保存在 <code>/var/lib/grafana</code> 这个目录下面的，所以我们这里如果需要做数据持久化的话，就需要针对这个目录进行 volume 挂载声明，由于上面我们刚刚提到的 Changelog 中 grafana 的 userid 和 groupid 有所变化，所以我们这里增加一个 <code>initContainers</code> 来修改数据卷的权限，最后，我们需要对外暴露 grafana 这个服务，所以我们需要一个对应的 Service 对象，当然用 NodePort 或者再建立一个 ingress 对象都是可行的。</p>
<p>现在我们直接创建上面的这些资源对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl apply -f https://p8s.io/docs/k8s/manifests/prometheus/grafana.yaml</span><br></pre></td></tr></table></figure>

<p>创建完成后，我们可以查看 grafana 对应的 Pod 是否正常：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl get pods -n kube-mon -l app=grafana</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">grafana-7fbc6c7684-792mx   1/1     Running   0          4m37s</span><br><span class="line">☸ ➜ kubectl logs -f grafana-7fbc6c7684-792mx -n kube-mon</span><br><span class="line">......</span><br><span class="line">t=2022-01-10T08:07:04+0000 lvl=info msg=&quot;warming cache for startup&quot; logger=ngalert</span><br><span class="line">t=2022-01-10T08:07:04+0000 lvl=info msg=&quot;HTTP Server Listen&quot; logger=http.server address=[::]:3000 protocol=http subUrl= socket=</span><br></pre></td></tr></table></figure>

<p>看到上面的日志信息就证明我们的 grafana 的 Pod 已经正常启动起来了。这个时候我们可以查看 Service 对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☸ ➜ kubectl get svc -n kube-mon</span><br><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">grafana      NodePort    10.109.3.79      &lt;none&gt;        3000:31384/TCP      6m6s</span><br></pre></td></tr></table></figure>

<p>现在我们就可以在浏览器中使用 <code>http://&lt;任意节点IP:31384&gt;</code> 来访问 grafana 这个服务了：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/h6rvvx.png" alt="grafana login"></p>
<p>由于上面我们配置了管理员的，所以第一次打开的时候会跳转到登录界面，然后就可以用上面我们配置的两个环境变量的值来进行登录了，登录完成后就可以进入到下面 Grafana 的首页，然后接下来的使用方式就可以参考前面<strong>数据可视化</strong>章节中的内容了，首先点击<code>Add data source</code>进入添加数据源界面。</p>
<p>我们这个地方配置的数据源是 <code>Prometheus</code>，我们这里 Prometheus 和 Grafana 都处于 kube-mon 这同一个 namespace 下面，所以我们这里的数据源地址：<code>http://prometheus:9090</code>（因为在同一个 namespace 下面所以直接用 Service 名也可以），然后其他的配置信息就根据实际情况了，比如 Auth 认证，我们这里没有，所以跳过即可，点击最下方的 <code>Save &amp; Test</code> 提示成功证明我们的数据源配置正确：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/hi05ls.png" alt="grafana prometheus datasource"></p>
<p>然后接下来就可以根据我们的需求去创建可视化的 Dashboard 面板了。</p>
<h2 id="导入-Dashboard"><a href="#导入-Dashboard" class="headerlink" title="导入 Dashboard"></a>导入 Dashboard</h2><p>为了能够快速对系统进行监控，我们可以直接复用别人的 Grafana Dashboard，在 Grafana 的官方网站上就有很多非常优秀的第三方 Dashboard，我们完全可以直接导入进来即可。比如我们想要对所有的集群节点进行监控，也就是 node-exporter 采集的数据进行展示，这里我们就可以导入 <a target="_blank" rel="noopener" href="https://grafana.com/grafana/dashboards/8919">https://grafana.com/grafana/dashboards/8919</a> 这个 Dashboard。</p>
<p>在侧边栏点击 “+”，选择 <code>Import</code>，在 Grafana Dashboard 的文本框中输入 8919 即可导入：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/v86ebg.png" alt="import"></p>
<p>进入导入 Dashboard 的页面，可以编辑名称，选择 Prometheus 的数据源：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/5f9jl5.png" alt="edit dashboard"></p>
<p>保存后即可进入导入的 Dashboard 页面。由于该 Dashboard 更新比较及时，所以基本上导入进来就可以直接使用了，我们也可以对页面进行一些调整，如果有的图表没有出现对应的图形，则可以编辑根据查询语句去 DEBUG。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/wdjj02.png" alt="node-exporter dashboard"></p>
<p>然后如果想自定义图表直接根据我们的需求参考<strong>可视化</strong>章节内容去制作即可，还有其他需求也可以去 Grafana 官网导入合适的 Dashboard。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/HPA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/HPA/" class="post-title-link" itemprop="url">HPA</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:39:09" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/%E6%8E%A7%E5%88%B6%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">控制器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HPA-控制器"><a href="#HPA-控制器" class="headerlink" title="HPA 控制器"></a>HPA 控制器</h1><p>在前面的学习中我们使用了一个 <code>kubectl scale</code> 命令可以来实现 Pod 的扩缩容功能，但是这个是完全手动操作的，要应对线上的各种复杂情况，我们需要能够做到自动化去感知业务，来自动进行扩缩容。为此，Kubernetes 也为我们提供了这样的一个资源对象：<code>Horizontal Pod Autoscaling（Pod 水平自动伸缩）</code>，简称 <code>HPA</code>，HPA 通过监控分析一些控制器控制的所有 Pod 的负载变化情况来确定是否需要调整 Pod 的副本数量，这是 HPA 最基本的原理：</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/3v1m3o.png" alt="HPA"></p>
<p>我们可以简单的通过 <code>kubectl autoscale</code> 命令来创建一个 HPA 资源对象，<code>HPA Controller</code> 默认<code>30s</code>轮询一次（可通过 <code>kube-controller-manager</code> 的<code>--horizontal-pod-autoscaler-sync-period</code> 参数进行设置），查询指定的资源中的 Pod 资源使用率，并且与创建时设定的值和指标做对比，从而实现自动伸缩的功能。</p>
<h2 id="Metrics-Server"><a href="#Metrics-Server" class="headerlink" title="Metrics Server"></a>Metrics Server</h2><p>在 HPA 的第一个版本中，我们需要 <code>Heapster</code> 提供 CPU 和内存指标，在 HPA v2 过后就需要安装 Metrcis Server 了，<code>Metrics Server</code> 可以通过标准的 Kubernetes API 把监控数据暴露出来，有了 <code>Metrics Server</code> 之后，我们就完全可以通过标准的 Kubernetes API 来访问我们想要获取的监控数据了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://10.96.0.1/apis/metrics.k8s.io/v1beta1/namespaces/&lt;namespace-name&gt;/pods/&lt;pod-name&gt;</span><br></pre></td></tr></table></figure>



<p>比如当我们访问上面的 API 的时候，我们就可以获取到该 Pod 的资源数据，这些数据其实是来自于 kubelet 的 <code>Summary API</code> 采集而来的。不过需要说明的是我们这里可以通过标准的 API 来获取资源监控数据，并不是因为 <code>Metrics Server</code> 就是 APIServer 的一部分，而是通过 Kubernetes 提供的 <code>Aggregator</code> 汇聚插件来实现的，是独立于 APIServer 之外运行的。</p>
<p><img data-src="https://mudutestmenu.mudu.tv/upload/oyooqu.jpg" alt="HAP Metrics Server"></p>
<h3 id="聚合-API"><a href="#聚合-API" class="headerlink" title="聚合 API"></a>聚合 API</h3><p><code>Aggregator</code> 允许开发人员编写一个自己的服务，把这个服务注册到 Kubernetes 的 APIServer 里面去，这样我们就可以像原生的 APIServer 提供的 API 使用自己的 API 了，我们把自己的服务运行在 Kubernetes 集群里面，然后 Kubernetes 的 <code>Aggregator</code> 通过 Service 名称就可以转发到我们自己写的 Service 里面去了。这样这个聚合层就带来了很多好处：</p>
<ul>
<li>增加了 API 的扩展性，开发人员可以编写自己的 API 服务来暴露他们想要的 API。</li>
<li>丰富了 API，核心 kubernetes 团队阻止了很多新的 API 提案，通过允许开发人员将他们的 API 作为单独的服务公开，这样就无须社区繁杂的审查了。</li>
<li>开发分阶段实验性 API，新的 API 可以在单独的聚合服务中开发，当它稳定之后，在合并会 APIServer 就很容易了。</li>
<li>确保新 API 遵循 Kubernetes 约定，如果没有这里提出的机制，社区成员可能会被迫推出自己的东西，这样很可能造成社区成员和社区约定不一致。</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>所以现在我们要使用 HPA，就需要在集群中安装 <code>Metrics Server</code> 服务，要安装 <code>Metrics Server</code> 就需要开启 <code>Aggregator</code>，因为 <code>Metrics Server</code> 就是通过该代理进行扩展的，不过我们集群是通过 Kubeadm 搭建的，默认已经开启了，如果是二进制方式安装的集群，需要单独配置 kube-apsierver 添加如下所示的参数：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">--requestheader-client-ca-file=&lt;path</span> <span class="string">to</span> <span class="string">aggregator</span> <span class="string">CA</span> <span class="string">cert&gt;</span></span><br><span class="line"><span class="string">--requestheader-allowed-names=aggregator</span></span><br><span class="line"><span class="string">--requestheader-extra-headers-prefix=X-Remote-Extra-</span></span><br><span class="line"><span class="string">--requestheader-group-headers=X-Remote-Group</span></span><br><span class="line"><span class="string">--requestheader-username-headers=X-Remote-User</span></span><br><span class="line"><span class="string">--proxy-client-cert-file=&lt;path</span> <span class="string">to</span> <span class="string">aggregator</span> <span class="string">proxy</span> <span class="string">cert&gt;</span></span><br><span class="line"><span class="string">--proxy-client-key-file=&lt;path</span> <span class="string">to</span> <span class="string">aggregator</span> <span class="string">proxy</span> <span class="string">key&gt;</span></span><br></pre></td></tr></table></figure>



<p>如果 <code>kube-proxy</code> 没有和 APIServer 运行在同一台主机上，那么需要确保启用了如下 kube-apsierver 的参数：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">--enable-aggregator-routing=true</span></span><br></pre></td></tr></table></figure>



<p>对于这些证书的生成方式，我们可以查看官方文档：<a target="_blank" rel="noopener" href="https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/docs/concepts/auth.md%E3%80%82">https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/docs/concepts/auth.md。</a></p>
<p><code>Aggregator</code> 聚合层启动完成后，就可以来安装 <code>Metrics Server</code> 了，我们可以获取该仓库的官方安装资源清单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官方仓库地址：https://github.com/kubernetes-sigs/metrics-server</span></span><br><span class="line">➜  ~ wget https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.5.1/components.yaml</span><br></pre></td></tr></table></figure>



<p>在部署之前，修改 <code>components.yaml</code> 的镜像地址为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hostNetwork:</span> <span class="literal">true</span> <span class="comment"># 使用hostNetwork模式</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">cnych/metrics-server:v0.5.1</span></span><br></pre></td></tr></table></figure>



<p>等部署完成后，可以查看 Pod 日志是否正常：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f components.yaml</span><br><span class="line">➜  ~ kubectl get pods -n kube-system -l k8s-app=metrics-server</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">metrics-server-6f667d74b6-6c9ps   0/1     Running   0          7m52s</span><br><span class="line">➜  ~ manifests kubectl logs -f metrics-server-6f667d74b6-6c9ps -n kube-system</span><br><span class="line">I1115 10:06:02.381541       1 serving.go:341] Generated self-signed cert (/tmp/apiserver.crt, /tmp/apiserver.key)</span><br><span class="line">E1115 10:06:02.735837       1 scraper.go:139] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://192.168.31.31:10250/stats/summary?only_cpu_and_memory=true\&quot;: x509: cannot validate certificate for 192.168.31.31 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;master1&quot;</span><br><span class="line">E1115 10:06:02.744967       1 scraper.go:139] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://192.168.31.108:10250/stats/summary?only_cpu_and_memory=true\&quot;: x509: cannot validate certificate for 192.168.31.108 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;node1&quot;</span><br><span class="line">I1115 10:06:02.751391       1 requestheader_controller.go:169] Starting RequestHeaderAuthRequestController</span><br><span class="line">I1115 10:06:02.751410       1 shared_informer.go:240] Waiting for caches to sync for RequestHeaderAuthRequestController</span><br><span class="line">I1115 10:06:02.751413       1 configmap_cafile_content.go:202] Starting client-ca::kube-system::extension-apiserver-authentication::requestheader-client-ca-file</span><br><span class="line">I1115 10:06:02.751397       1 configmap_cafile_content.go:202] Starting client-ca::kube-system::extension-apiserver-authentication::client-ca-file</span><br><span class="line">I1115 10:06:02.751423       1 shared_informer.go:240] Waiting for caches to sync for client-ca::kube-system::extension-apiserver-authentication::requestheader-client-ca-file</span><br><span class="line">I1115 10:06:02.751424       1 shared_informer.go:240] Waiting for caches to sync for client-ca::kube-system::extension-apiserver-authentication::client-ca-file</span><br><span class="line">I1115 10:06:02.751473       1 dynamic_serving_content.go:130] Starting serving-cert::/tmp/apiserver.crt::/tmp/apiserver.key</span><br><span class="line">I1115 10:06:02.751822       1 secure_serving.go:202] Serving securely on [::]:443</span><br><span class="line">I1115 10:06:02.751896       1 tlsconfig.go:240] Starting DynamicServingCertificateController</span><br><span class="line">E1115 10:06:02.756987       1 scraper.go:139] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://192.168.31.46:10250/stats/summary?only_cpu_and_memory=true\&quot;: x509: cannot validate certificate for 192.168.31.46 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;node2&quot;</span><br><span class="line">I1115 10:06:02.851642       1 shared_informer.go:247] Caches are synced for client-ca::kube-system::extension-apiserver-authentication::requestheader-client-ca-file</span><br><span class="line">I1115 10:06:02.851739       1 shared_informer.go:247] Caches are synced for RequestHeaderAuthRequestController</span><br><span class="line">I1115 10:06:02.851748       1 shared_informer.go:247] Caches are synced for client-ca::kube-system::extension-apiserver-authentication::client-ca-file</span><br><span class="line">E1115 10:06:17.742350       1 scraper.go:139] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://192.168.31.108:10250/stats/summary?only_cpu_and_memory=true\&quot;: x509: cannot validate certificate for 192.168.31.108 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;node1&quot;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>因为部署集群的时候，CA 证书并没有把各个节点的 IP 签上去，所以这里 <code>Metrics Server</code> 通过 IP 去请求时，提示签的证书没有对应的 IP（错误：<code>x509: cannot validate certificate for 192.168.31.108 because it doesn&#39;t contain any IP SANs</code>），我们可以添加一个<code>--kubelet-insecure-tls</code>参数跳过证书校验：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--cert-dir=/tmp</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--secure-port=443</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--kubelet-insecure-tls</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--kubelet-preferred-address-types=InternalIP</span></span><br></pre></td></tr></table></figure>



<p>然后再重新安装即可成功！可以通过如下命令来验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f components.yaml</span><br><span class="line">➜  ~ kubectl get pods -n kube-system -l k8s-app=metrics-server</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">metrics-server-85499dc4f5-mgpcb   1/1     Running   0          32s</span><br><span class="line">➜  ~ kubectl logs -f metrics-server-85499dc4f5-mgpcb -n kube-system</span><br><span class="line">I1115 10:14:19.401808       1 serving.go:341] Generated self-signed cert (/tmp/apiserver.crt, /tmp/apiserver.key)</span><br><span class="line">I1115 10:14:19.840290       1 secure_serving.go:202] Serving securely on [::]:443</span><br><span class="line">I1115 10:14:19.840395       1 requestheader_controller.go:169] Starting RequestHeaderAuthRequestController</span><br><span class="line">I1115 10:14:19.840403       1 shared_informer.go:240] Waiting for caches to sync for RequestHeaderAuthRequestController</span><br><span class="line">I1115 10:14:19.840411       1 dynamic_serving_content.go:130] Starting serving-cert::/tmp/apiserver.crt::/tmp/apiserver.key</span><br><span class="line">I1115 10:14:19.840438       1 tlsconfig.go:240] Starting DynamicServingCertificateController</span><br><span class="line">......</span><br><span class="line">➜  ~ kubectl get apiservice | grep metrics</span><br><span class="line">v1beta1.metrics.k8s.io                 kube-system/metrics-server   True        10m</span><br><span class="line">➜  ~ kubectl get --raw &quot;/apis/metrics.k8s.io/v1beta1/nodes&quot;</span><br><span class="line">&#123;&quot;kind&quot;:&quot;NodeMetricsList&quot;,&quot;apiVersion&quot;:&quot;metrics.k8s.io/v1beta1&quot;,&quot;metadata&quot;:&#123;&#125;,&quot;items&quot;:[&#123;&quot;metadata&quot;:&#123;&quot;name&quot;:&quot;master1&quot;,&quot;creationTimestamp&quot;:&quot;2021-11-15T10:15:38Z&quot;,&quot;labels&quot;:&#123;&quot;beta.kubernetes.io/arch&quot;:&quot;amd64&quot;,&quot;beta.kubernetes.io/os&quot;:&quot;linux&quot;,&quot;kubernetes.io/arch&quot;:&quot;amd64&quot;,&quot;kubernetes.io/hostname&quot;:&quot;master1&quot;,&quot;kubernetes.io/os&quot;:&quot;linux&quot;,&quot;node-role.kubernetes.io/control-plane&quot;:&quot;&quot;,&quot;node-role.kubernetes.io/master&quot;:&quot;&quot;,&quot;node.kubernetes.io/exclude-from-external-load-balancers&quot;:&quot;&quot;&#125;&#125;,&quot;timestamp&quot;:&quot;2021-11-15T10:15:33Z&quot;,&quot;window&quot;:&quot;20s&quot;,&quot;usage&quot;:&#123;&quot;cpu&quot;:&quot;132348072n&quot;,&quot;memory&quot;:&quot;813200Ki&quot;&#125;&#125;,&#123;&quot;metadata&quot;:&#123;&quot;name&quot;:&quot;node1&quot;,&quot;creationTimestamp&quot;:&quot;2021-11-15T10:15:38Z&quot;,&quot;labels&quot;:&#123;&quot;beta.kubernetes.io/arch&quot;:&quot;amd64&quot;,&quot;beta.kubernetes.io/os&quot;:&quot;linux&quot;,&quot;kubernetes.io/arch&quot;:&quot;amd64&quot;,&quot;kubernetes.io/hostname&quot;:&quot;node1&quot;,&quot;kubernetes.io/os&quot;:&quot;linux&quot;&#125;&#125;,&quot;timestamp&quot;:&quot;2021-11-15T10:15:32Z&quot;,&quot;window&quot;:&quot;20s&quot;,&quot;usage&quot;:&#123;&quot;cpu&quot;:&quot;60153492n&quot;,&quot;memory&quot;:&quot;520628Ki&quot;&#125;&#125;,&#123;&quot;metadata&quot;:&#123;&quot;name&quot;:&quot;node2&quot;,&quot;creationTimestamp&quot;:&quot;2021-11-15T10:15:38Z&quot;,&quot;labels&quot;:&#123;&quot;beta.kubernetes.io/arch&quot;:&quot;amd64&quot;,&quot;beta.kubernetes.io/os&quot;:&quot;linux&quot;,&quot;kubernetes.io/arch&quot;:&quot;amd64&quot;,&quot;kubernetes.io/hostname&quot;:&quot;node2&quot;,&quot;kubernetes.io/os&quot;:&quot;linux&quot;&#125;&#125;,&quot;timestamp&quot;:&quot;2021-11-15T10:15:29Z&quot;,&quot;window&quot;:&quot;20s&quot;,&quot;usage&quot;:&#123;&quot;cpu&quot;:&quot;81697469n&quot;,&quot;memory&quot;:&quot;557208Ki&quot;&#125;&#125;]&#125;</span><br><span class="line">➜  ~ kubectl top nodes</span><br><span class="line">NAME      CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%</span><br><span class="line">master1   115m         5%     794Mi           21%</span><br><span class="line">node1     58m          1%     505Mi           6%</span><br><span class="line">node2     55m          1%     545Mi           7%</span><br></pre></td></tr></table></figure>



<p>现在我们可以通过 <code>kubectl top</code> 命令来获取到资源数据了，证明 <code>Metrics Server</code> 已经安装成功了。</p>
<h2 id="HPA-对象"><a href="#HPA-对象" class="headerlink" title="HPA 对象"></a>HPA 对象</h2><p>现在我们用 Deployment 来创建一个 Nginx Pod，然后利用 <code>HPA</code> 来进行自动扩缩容。资源清单如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hpa-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hpa-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<p>然后直接创建 Deployment，注意一定先把之前创建的具有 <code>app=nginx</code> 的 Pod 先清除掉：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f hpa-demo.yaml</span><br><span class="line">deployment.apps/hpa-demo created</span><br><span class="line">➜  ~ kubectl get pods -l app=nginx</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">hpa-demo-7848d4b86f-khndb   1/1     Running   0          56s</span><br></pre></td></tr></table></figure>



<p>现在我们来创建一个 <code>HPA</code> 资源对象，可以使用<code>kubectl autoscale</code>命令来创建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl autoscale deployment hpa-demo --cpu-percent=10 --min=1 --max=10</span><br><span class="line">horizontalpodautoscaler.autoscaling/hpa-demo autoscaled</span><br><span class="line">➜  ~ kubectl get hpa</span><br><span class="line">NAME       REFERENCE             TARGETS         MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">hpa-demo   Deployment/hpa-demo   &lt;unknown&gt;/10%   1         10        0          6s</span><br></pre></td></tr></table></figure>



<p>此命令创建了一个关联资源 hpa-demo 的 HPA，最小的 Pod 副本数为 1，最大为 10。HPA 会根据设定的 cpu 使用率（10%）动态的增加或者减少 Pod 数量。</p>
<p>当然我们依然还是可以通过创建 YAML 文件的形式来创建 HPA 资源对象。如果我们不知道怎么编写的话，可以查看上面命令行创建的 HPA 的 YAML 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get hpa hpa-demo -o yaml</span><br><span class="line">apiVersion: autoscaling/v1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    autoscaling.alpha.kubernetes.io/conditions: &#x27;[&#123;&quot;type&quot;:&quot;AbleToScale&quot;,&quot;status&quot;:&quot;True&quot;,&quot;lastTransitionTime&quot;:&quot;2021-11-15T10:19:06Z&quot;,&quot;reason&quot;:&quot;SucceededGetScale&quot;,&quot;message&quot;:&quot;the</span><br><span class="line">      HPA controller was able to get the target&#x27;&#x27;s current scale&quot;&#125;,&#123;&quot;type&quot;:&quot;ScalingActive&quot;,&quot;status&quot;:&quot;False&quot;,&quot;lastTransitionTime&quot;:&quot;2021-11-15T10:19:06Z&quot;,&quot;reason&quot;:&quot;FailedGetResourceMetric&quot;,&quot;message&quot;:&quot;the</span><br><span class="line">      HPA was unable to compute the replica count: failed to get cpu utilization:</span><br><span class="line">      missing request for cpu&quot;&#125;]&#x27;</span><br><span class="line">  creationTimestamp: &quot;2021-11-15T10:18:51Z&quot;</span><br><span class="line">  managedFields:</span><br><span class="line">  - apiVersion: autoscaling/v1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:spec:</span><br><span class="line">        f:maxReplicas: &#123;&#125;</span><br><span class="line">        f:minReplicas: &#123;&#125;</span><br><span class="line">        f:scaleTargetRef: &#123;&#125;</span><br><span class="line">        f:targetCPUUtilizationPercentage: &#123;&#125;</span><br><span class="line">    manager: kubectl</span><br><span class="line">    operation: Update</span><br><span class="line">    time: &quot;2021-11-15T10:18:51Z&quot;</span><br><span class="line">  - apiVersion: autoscaling/v1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:metadata:</span><br><span class="line">        f:annotations:</span><br><span class="line">          .: &#123;&#125;</span><br><span class="line">          f:autoscaling.alpha.kubernetes.io/conditions: &#123;&#125;</span><br><span class="line">      f:status:</span><br><span class="line">        f:currentReplicas: &#123;&#125;</span><br><span class="line">    manager: kube-controller-manager</span><br><span class="line">    operation: Update</span><br><span class="line">    subresource: status</span><br><span class="line">    time: &quot;2021-11-15T10:19:06Z&quot;</span><br><span class="line">  name: hpa-demo</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;631809&quot;</span><br><span class="line">  uid: 34b91709-d003-4039-9cf0-05bb3fa4da73</span><br><span class="line">spec:</span><br><span class="line">  maxReplicas: 10</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: hpa-demo</span><br><span class="line">  targetCPUUtilizationPercentage: 10</span><br><span class="line">status:</span><br><span class="line">  currentReplicas: 1</span><br><span class="line">  desiredReplicas: 0</span><br></pre></td></tr></table></figure>



<p>然后我们可以根据上面的 YAML 文件就可以自己来创建一个基于 YAML 的 HPA 描述文件了。但是我们发现上面信息里面出现了一些 Fail 信息，我们来查看下这个 HPA 对象的信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl describe hpa hpa-demo</span><br><span class="line">Name:                                                  hpa-demo</span><br><span class="line">Namespace:                                             default</span><br><span class="line">Labels:                                                &lt;none&gt;</span><br><span class="line">Annotations:                                           &lt;none&gt;</span><br><span class="line">CreationTimestamp:                                     Mon, 15 Nov 2021 18:18:51 +0800</span><br><span class="line">Reference:                                             Deployment/hpa-demo</span><br><span class="line">Metrics:                                               ( current / target )</span><br><span class="line">  resource cpu on pods  (as a percentage of request):  &lt;unknown&gt; / 10%</span><br><span class="line">Min replicas:                                          1</span><br><span class="line">Max replicas:                                          10</span><br><span class="line">Deployment pods:                                       1 current / 0 desired</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason                   Message</span><br><span class="line">  ----           ------  ------                   -------</span><br><span class="line">  AbleToScale    True    SucceededGetScale        the HPA controller was able to get the target&#x27;s current scale</span><br><span class="line">  ScalingActive  False   FailedGetResourceMetric  the HPA was unable to compute the replica count: failed to get cpu utilization: missing request for cpu</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason                        Age               From                       Message</span><br><span class="line">  ----     ------                        ----              ----                       -------</span><br><span class="line">  Warning  FailedGetResourceMetric       1s (x3 over 31s)  horizontal-pod-autoscaler  failed to get cpu utilization: missing request for cpu</span><br><span class="line">  Warning  FailedComputeMetricsReplicas  1s (x3 over 31s)  horizontal-pod-autoscaler  invalid metrics (1 invalid out of 1), first error is: failed to get cpu utilization: missing request for cpu</span><br></pre></td></tr></table></figure>



<p>我们可以看到上面的事件信息里面出现了 <code>failed to get cpu utilization: missing request for cpu</code> 这样的错误信息。这是因为我们上面创建的 Pod 对象<strong>没有添加 request 资源</strong>声明，这样导致 HPA 读取不到 CPU 指标信息，所以如果要想让 HPA 生效，对应的 Pod 资源必须添加 requests 资源声明，更新我们的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hpa-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">50Mi</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">50m</span></span><br></pre></td></tr></table></figure>



<p>然后重新更新 Deployment，重新创建 HPA 对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f hpa-demo.yaml</span><br><span class="line">deployment.apps/hpa-demo configured</span><br><span class="line">➜  ~ kubectl get pods -o wide -l app=nginx</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">hpa-demo-6b4467b546-h489x   1/1     Running   0          18s   10.244.1.11   node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">➜  ~ kubectl delete hpa hpa-demo</span><br><span class="line">horizontalpodautoscaler.autoscaling &quot;hpa-demo&quot; deleted</span><br><span class="line">➜  ~ kubectl autoscale deployment hpa-demo --cpu-percent=10 --min=1 --max=10</span><br><span class="line">horizontalpodautoscaler.autoscaling/hpa-demo autoscaled</span><br><span class="line">➜  ~ kubectl describe hpa hpa-demo</span><br><span class="line">Name:                                                  hpa-demo</span><br><span class="line">Namespace:                                             default</span><br><span class="line">Labels:                                                &lt;none&gt;</span><br><span class="line">Annotations:                                           &lt;none&gt;</span><br><span class="line">CreationTimestamp:                                     Mon, 15 Nov 2021 18:21:12 +0800</span><br><span class="line">Reference:                                             Deployment/hpa-demo</span><br><span class="line">Metrics:                                               ( current / target )</span><br><span class="line">  resource cpu on pods  (as a percentage of request):  0% (0) / 10%</span><br><span class="line">Min replicas:                                          1</span><br><span class="line">Max replicas:                                          10</span><br><span class="line">Deployment pods:                                       1 current / 1 desired</span><br><span class="line">Conditions:</span><br><span class="line">  Type            Status  Reason               Message</span><br><span class="line">  ----            ------  ------               -------</span><br><span class="line">  AbleToScale     True    ScaleDownStabilized  recent recommendations were higher than current one, applying the highest recent recommendation</span><br><span class="line">  ScalingActive   True    ValidMetricFound     the HPA was able to successfully calculate a replica count from cpu resource utilization (percentage of request)</span><br><span class="line">  ScalingLimited  False   DesiredWithinRange   the desired count is within the acceptable range</span><br><span class="line">Events:           &lt;none&gt;</span><br><span class="line">➜  ~ kubectl get hpa</span><br><span class="line">NAME       REFERENCE             TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">hpa-demo   Deployment/hpa-demo   0%/10%    1         10        1          35s</span><br></pre></td></tr></table></figure>



<p>现在可以看到 HPA 资源对象已经正常了，现在我们来增大负载进行测试，我们来创建一个 busybox 的 Pod，并且循环访问上面创建的 Pod：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl run -it --image busybox test-hpa --restart=Never --rm /bin/sh</span><br><span class="line">If you don&#x27;t see a command prompt, try pressing enter.</span><br><span class="line">/ # while true; do wget -q -O- http://10.244.1.11; done</span><br></pre></td></tr></table></figure>



<p>然后观察 Pod 列表，可以看到，HPA 已经开始工作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get hpa</span><br><span class="line">NAME       REFERENCE             TARGETS    MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">hpa-demo   Deployment/hpa-demo   310%/10%   1         10        1          105s</span><br><span class="line">➜  ~ kubectl get pods -l app=nginx --watch</span><br><span class="line">NAME                        READY   STATUS              RESTARTS   AGE</span><br><span class="line">hpa-demo-6b4467b546-h489x   1/1     Running             0          2m25s</span><br><span class="line">hpa-demo-6b4467b546-pg4fz   0/1     ContainerCreating   0          9s</span><br><span class="line">hpa-demo-6b4467b546-qrwv5   0/1     ContainerCreating   0          9s</span><br><span class="line">hpa-demo-6b4467b546-s4vdz   0/1     ContainerCreating   0          9s</span><br></pre></td></tr></table></figure>



<p>我们可以看到已经自动拉起了很多新的 Pod，最后会定格在了我们上面设置的 10 个 Pod，同时查看资源 hpa-demo 的副本数量，副本数量已经从原来的 1 变成了 10 个：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get deployment hpa-demo</span><br><span class="line">NAME       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">hpa-demo   10/10    10           10           2m56s</span><br></pre></td></tr></table></figure>



<p>查看 HPA 资源的对象了解工作过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl describe hpa hpa-demo</span><br><span class="line">Name:                                                  hpa-demo</span><br><span class="line">Namespace:                                             default</span><br><span class="line">Labels:                                                &lt;none&gt;</span><br><span class="line">Annotations:                                           &lt;none&gt;</span><br><span class="line">CreationTimestamp:                                     Mon, 15 Nov 2021 18:21:12 +0800</span><br><span class="line">Reference:                                             Deployment/hpa-demo</span><br><span class="line">Metrics:                                               ( current / target )</span><br><span class="line">  resource cpu on pods  (as a percentage of request):  110% (55m) / 10%</span><br><span class="line">Min replicas:                                          1</span><br><span class="line">Max replicas:                                          10</span><br><span class="line">Deployment pods:                                       10 current / 10 desired</span><br><span class="line">Conditions:</span><br><span class="line">  Type            Status  Reason               Message</span><br><span class="line">  ----            ------  ------               -------</span><br><span class="line">  AbleToScale     True    ScaleDownStabilized  recent recommendations were higher than current one, applying the highest recent recommendation</span><br><span class="line">  ScalingActive   True    ValidMetricFound     the HPA was able to successfully calculate a replica count from cpu resource utilization (percentage of request)</span><br><span class="line">  ScalingLimited  True    TooManyReplicas      the desired replica count is more than the maximum replica count</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                       Message</span><br><span class="line">  ----    ------             ----  ----                       -------</span><br><span class="line">  Normal  SuccessfulRescale  67s   horizontal-pod-autoscaler  New size: 4; reason: cpu resource utilization (percentage of request) above target</span><br><span class="line">  Normal  SuccessfulRescale  52s   horizontal-pod-autoscaler  New size: 8; reason: cpu resource utilization (percentage of request) above target</span><br><span class="line">  Normal  SuccessfulRescale  37s   horizontal-pod-autoscaler  New size: 10; reason: cpu resource utilization (percentage of request) above target</span><br></pre></td></tr></table></figure>



<p>同样的这个时候我们来关掉 busybox 来减少负载，然后等待一段时间观察下 HPA 和 Deployment 对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ k8strain3 kubectl get hpa</span><br><span class="line">NAME       REFERENCE             TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">hpa-demo   Deployment/hpa-demo   0%/10%    1         10        10         3m46s</span><br><span class="line">➜  ~ kubectl get deployment hpa-demo</span><br><span class="line">NAME       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">hpa-demo   1/1     1            1           24m</span><br></pre></td></tr></table></figure>



<p>!!! info “缩放间隙”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从 Kubernetes `v1.12` 版本开始我们可以通过设置 `kube-controller-manager` 组件的`--horizontal-pod-autoscaler-downscale-stabilization` 参数来设置一个持续时间，用于指定在当前操作完成后，`HPA` 必须等待多长时间才能执行另一次缩放操作。默认为5分钟，也就是默认需要等待5分钟后才会开始自动缩放。</span><br></pre></td></tr></table></figure>



<p>可以看到副本数量已经由 10 变为 1，当前我们只是演示了 CPU 使用率这一个指标，在后面的课程中我们还会学习到根据自定义的监控指标来自动对 Pod 进行扩缩容。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>要使用基于内存或者自定义指标进行扩缩容（现在的版本都必须依赖 metrics-server 这个项目）。现在我们再用 Deployment 来创建一个 Nginx Pod，然后利用 HPA 来进行自动扩缩容。资源清单如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hpa-mem-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hpa-mem-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">increase-mem-script</span></span><br><span class="line">          <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">increase-mem-config</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">increase-mem-script</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/etc/script</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">50Mi</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">50m</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<p>这里和前面普通的应用有一些区别，我们将一个名为 <code>increase-mem-config</code> 的 ConfigMap 资源对象挂载到了容器中，该配置文件是用于后面增加容器内存占用的脚本，配置文件如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># increase-mem-cm.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">increase-mem-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">increase-mem.sh:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    #!/bin/bash</span></span><br><span class="line"><span class="string">    mkdir /tmp/memory</span></span><br><span class="line"><span class="string">    mount -t tmpfs -o size=40M tmpfs /tmp/memory</span></span><br><span class="line"><span class="string">    dd if=/dev/zero of=/tmp/memory/block</span></span><br><span class="line"><span class="string">    sleep 60</span></span><br><span class="line"><span class="string">    rm /tmp/memory/block</span></span><br><span class="line"><span class="string">    umount /tmp/memory</span></span><br><span class="line"><span class="string">    rmdir /tmp/memory</span></span><br></pre></td></tr></table></figure>



<p>由于这里增加内存的脚本需要使用到 <code>mount</code> 命令，这需要声明为特权模式，所以我们添加了 <code>securityContext.privileged=true</code> 这个配置。现在我们直接创建上面的资源对象即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f increase-mem-cm.yaml</span><br><span class="line">➜  ~ kubectl apply -f hpa-mem-demo.yaml</span><br><span class="line">➜  ~ kubectl get pods -l app=nginx</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">hpa-mem-demo-74675cc6c9-sqz2l   1/1     Running   0          17s</span><br></pre></td></tr></table></figure>



<p>然后需要创建一个基于内存的 HPA 资源对象：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hpa-mem.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hpa-mem-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hpa-mem-demo</span></span><br><span class="line">  <span class="attr">metrics:</span> <span class="comment"># 指定内存的一个配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">      <span class="attr">resource:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">memory</span></span><br><span class="line">        <span class="attr">targetAverageUtilization:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>



<p>要注意这里使用的 <code>apiVersion</code> 是 <code>autoscaling/v2beta1</code>，然后 <code>metrics</code> 属性里面指定的是内存的配置，直接创建上面的资源对象即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f hpa-mem.yaml</span><br><span class="line">horizontalpodautoscaler.autoscaling/hpa-mem-demo created</span><br><span class="line">➜  ~ kubectl get hpa</span><br><span class="line">NAME           REFERENCE                 TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">hpa-mem-demo   Deployment/hpa-mem-demo   6%/30%    1         5         1          32s</span><br></pre></td></tr></table></figure>



<p>到这里证明 HPA 资源对象已经部署成功了，接下来我们对应用进行压测，将内存压上去，直接执行上面我们挂载到容器中的 <code>increase-mem.sh</code> 脚本即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl exec -it hpa-mem-demo-74675cc6c9-sqz2l -- /bin/bash</span><br><span class="line">root@hpa-mem-demo-74675cc6c9-sqz2l:/# ls /etc/script/</span><br><span class="line">increase-mem.sh</span><br><span class="line">root@hpa-mem-demo-74675cc6c9-sqz2l:/# source /etc/script/increase-mem.sh</span><br><span class="line">dd: writing to &#x27;/tmp/memory/block&#x27;: No space left on device</span><br><span class="line">81921+0 records in</span><br><span class="line">81920+0 records out</span><br><span class="line">41943040 bytes (42 MB, 40 MiB) copied, 0.0908717 s, 462 MB/s</span><br></pre></td></tr></table></figure>



<p>然后打开另外一个终端观察 HPA 资源对象的变化情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get hpa -w</span><br><span class="line">NAME           REFERENCE                 TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">hpa-mem-demo   Deployment/hpa-mem-demo   87%/30%   1         5         3          90s</span><br><span class="line">➜  ~ kubectl describe hpa hpa-mem-demo</span><br><span class="line">Name:                                                     hpa-mem-demo</span><br><span class="line">Namespace:                                                default</span><br><span class="line">Labels:                                                   &lt;none&gt;</span><br><span class="line">Annotations:                                              kubectl.kubernetes.io/last-applied-configuration:</span><br><span class="line">                                                            &#123;&quot;apiVersion&quot;:&quot;autoscaling/v2beta1&quot;,&quot;kind&quot;:&quot;HorizontalPodAutoscaler&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;name&quot;:&quot;hpa-mem-demo&quot;,&quot;namespace&quot;:&quot;defau...</span><br><span class="line">CreationTimestamp:                                        Mon, 15 Nov 2021 18:40:37 +0800</span><br><span class="line">Reference:                                                Deployment/hpa-mem-demo</span><br><span class="line">Metrics:                                                  ( current / target )</span><br><span class="line">  resource memory on pods  (as a percentage of request):  87% (45752320) / 30%</span><br><span class="line">Min replicas:                                             1</span><br><span class="line">Max replicas:                                             5</span><br><span class="line">Deployment pods:                                          3 current / 3 desired</span><br><span class="line">Conditions:</span><br><span class="line">  Type            Status  Reason              Message</span><br><span class="line">  ----            ------  ------              -------</span><br><span class="line">  AbleToScale     True    ReadyForNewScale    recommended size matches current size</span><br><span class="line">  ScalingActive   True    ValidMetricFound    the HPA was able to successfully calculate a replica count from memory resource utilization (percentage of request)</span><br><span class="line">  ScalingLimited  False   DesiredWithinRange  the desired count is within the acceptable range</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason                        Age   From                       Message</span><br><span class="line">  ----     ------                        ----  ----                       -------</span><br><span class="line">  Warning  FailedGetResourceMetric       87s   horizontal-pod-autoscaler  failed to get memory utilization: unable to get metrics for resource memory: no metrics returned from resource metrics API</span><br><span class="line">  Warning  FailedComputeMetricsReplicas  87s   horizontal-pod-autoscaler  invalid metrics (1 invalid out of 1), first error is: failed to get memory utilization: unable to get metrics for resource memory: no metrics returned from resource metrics API</span><br><span class="line">  Normal   SuccessfulRescale             27s   horizontal-pod-autoscaler  New size: 3; reason: memory resource utilization (percentage of request) above target</span><br><span class="line">  Normal   SuccessfulRescale             46s    horizontal-pod-autoscaler  New size: 4; reason: memory resource utilization (percentage of request) above target</span><br><span class="line">➜  ~ kubectl top pod hpa-mem-demo-74675cc6c9-gbj9t</span><br><span class="line">NAME                            CPU(cores)   MEMORY(bytes)</span><br><span class="line">hpa-mem-demo-66944b79bf-tqrn9   0m           41Mi</span><br></pre></td></tr></table></figure>

<p>可以看到内存使用已经超过了我们设定的 30% 这个阈值了，HPA 资源对象也已经触发了自动扩容，变成了 4 个副本了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl get pods -l app=nginx</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">hpa-mem-demo-74675cc6c9-cpdw4   1/1     Running   0          69s</span><br><span class="line">hpa-mem-demo-74675cc6c9-s8bz4   1/1     Running   0          114s</span><br><span class="line">hpa-mem-demo-74675cc6c9-sqz2l   1/1     Running   0          3m9s</span><br><span class="line">hpa-mem-demo-74675cc6c9-z8cx8   1/1     Running   0          114s</span><br></pre></td></tr></table></figure>

<p>当内存释放掉后，controller-manager 默认 5 分钟过后会进行缩放，到这里就完成了基于内存的 HPA 操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/HTTP%201.0%20%E5%92%8C%202.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/HTTP%201.0%20%E5%92%8C%202.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">HTTP 1.0 和 2.0 有什么区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:39:34" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HTTP-1-0-和-2-0-有什么区别？"><a href="#HTTP-1-0-和-2-0-有什么区别？" class="headerlink" title="HTTP 1.0 和 2.0 有什么区别？"></a>HTTP 1.0 和 2.0 有什么区别？</h3><p>HTTP 1.0 和 2.0 在性能、效率和功能方面存在显著差异。以下是它们的关键区别：</p>
<p><strong>HTTP 1.0 (最初的成功)</strong></p>
<ul>
<li><strong>核心概念：每次请求&#x2F;响应一个连接。</strong> 这是它最主要的特点。<ul>
<li><strong>短连接 (Short-lived connections):</strong> 每个请求和响应都需要建立一个新的TCP连接，在完成传输后立即关闭。这导致了大量的连接建立和关闭开销（三次握手和四次挥手）。</li>
</ul>
</li>
<li><strong>串行请求 (Serial requests):</strong> 浏览器一次只能发送一个请求，必须等待当前请求的响应，才能发送下一个请求。这导致了“队头阻塞 (Head-of-Line Blocking)”问题，即一个慢的响应会阻碍后续所有请求。</li>
<li><strong>无头部压缩 (No header compression):</strong> 每个请求和响应的头部信息都是原始的，可能包含大量重复信息。</li>
<li><strong>无服务器推送 (No server push):</strong> 服务器无法主动向客户端发送资源，只能响应客户端的请求。</li>
<li><strong>无二进制分帧 (No binary framing):</strong> 数据以文本形式传输，效率较低。</li>
<li><strong>Cookie (部分支持):</strong> Cookie的概念在HTTP 1.0后期出现并得到支持，用于会话管理。</li>
</ul>
<p><strong>HTTP 2.0 (性能的飞跃)</strong></p>
<p>HTTP 2.0 是在 SPDY 协议的基础上开发的，旨在解决 HTTP 1.0 和 1.1 的性能瓶颈。</p>
<ul>
<li><strong>多路复用 (Multiplexing):</strong><ul>
<li><strong>核心概念：一个TCP连接承载多个并发的请求和响应。</strong> 这是HTTP 2.0 最重要的特性。</li>
<li>通过流（Stream）的概念实现。每个请求&#x2F;响应都分配一个独立的流，多个流可以在同一个TCP连接上同时进行，互不影响。</li>
<li><strong>解决了“队头阻塞”问题。</strong> 即使某个流的数据传输较慢，也不会阻塞其他流的传输。</li>
</ul>
</li>
<li><strong>头部压缩 (Header Compression - HPACK):</strong><ul>
<li>HTTP 2.0 使用 HPACK 算法对请求和响应的头部信息进行压缩。</li>
<li>通过维护一个共享的静态和动态表，以及霍夫曼编码技术，大大减少了头部信息的大小，降低了网络流量。</li>
</ul>
</li>
<li><strong>服务器推送 (Server Push):</strong><ul>
<li>服务器可以在客户端请求HTML页面时，预测客户端可能需要的其他资源（如CSS、JavaScript、图片），并主动将这些资源推送给客户端，而无需客户端额外发起请求。</li>
<li>这可以减少往返时间（RTT），提高页面加载速度。</li>
</ul>
</li>
<li><strong>二进制分帧 (Binary Framing):</strong><ul>
<li>HTTP 2.0 将所有传输的数据（包括头部和实体）都分割成更小的、二进制的帧。</li>
<li>这些帧可以在不同的流之间交错传输，提高了传输效率和解析速度。</li>
<li>HTTP 1.x 采用文本协议，解析成本较高。</li>
</ul>
</li>
<li><strong>请求优先级 (Request Prioritization):</strong><ul>
<li>客户端可以为不同的请求设置优先级，以便服务器优先处理重要的资源（如CSS和JS文件），从而更快地渲染页面。</li>
</ul>
</li>
<li><strong>流控制 (Flow Control):</strong><ul>
<li>允许接收方控制发送方发送数据的速率，防止发送方发送过多的数据导致接收方缓冲区溢出。</li>
</ul>
</li>
</ul>
<p><strong>总结表格：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">HTTP 1.0</th>
<th align="left">HTTP 2.0</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>连接管理</strong></td>
<td align="left">短连接 (每个请求一个新连接)</td>
<td align="left">多路复用 (一个连接承载多个流)</td>
</tr>
<tr>
<td align="left"><strong>请求方式</strong></td>
<td align="left">串行请求 (等待当前请求完成才能发送下一个)</td>
<td align="left">并行请求 (多个请求可在同一连接上同时进行)</td>
</tr>
<tr>
<td align="left"><strong>队头阻塞</strong></td>
<td align="left">存在</td>
<td align="left">通过多路复用解决</td>
</tr>
<tr>
<td align="left"><strong>头部传输</strong></td>
<td align="left">无压缩，重复信息多</td>
<td align="left">HPACK 头部压缩，高效传输</td>
</tr>
<tr>
<td align="left"><strong>服务器能力</strong></td>
<td align="left">只能响应请求</td>
<td align="left">支持服务器推送 (主动发送资源)</td>
</tr>
<tr>
<td align="left"><strong>数据格式</strong></td>
<td align="left">文本协议</td>
<td align="left">二进制分帧协议</td>
</tr>
<tr>
<td align="left"><strong>优先级</strong></td>
<td align="left">无</td>
<td align="left">支持请求优先级</td>
</tr>
<tr>
<td align="left"><strong>流控制</strong></td>
<td align="left">无</td>
<td align="left">支持流控制</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">相对较低</td>
<td align="left">显著提高，尤其是在高延迟和高并发环境下</td>
</tr>
<tr>
<td align="left"><strong>TLS&#x2F;SSL集成</strong></td>
<td align="left">不强制 (但常与HTTPS结合)</td>
<td align="left">大多数实现强制要求通过 TLS&#x2F;SSL (虽然规范不强制)</td>
</tr>
</tbody></table>
<p><strong>为什么 HTTP 2.0 如此重要？</strong></p>
<p>随着Web应用程序变得越来越复杂，包含的资源（CSS、JS、图片等）也越来越多，HTTP 1.0 的性能瓶颈变得越来越明显。HTTP 2.0 通过其创新的特性，显著提高了Web的加载速度和响应能力，为现代Web提供了更好的用户体验。虽然HTTP 1.1 在一定程度上缓解了HTTP 1.0 的一些问题（如持久连接），但 HTTP 2.0 带了更根本的性能提升。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/HTTP%202.0%20%E5%92%8C%203.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/HTTP%202.0%20%E5%92%8C%203.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">HTTP 2.0 和 3.0 有什么区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:39:38" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HTTP-2-0-和-3-0-有什么区别？"><a href="#HTTP-2-0-和-3-0-有什么区别？" class="headerlink" title="HTTP 2.0 和 3.0 有什么区别？"></a>HTTP 2.0 和 3.0 有什么区别？</h3><p>HTTP 2.0 和 HTTP 3.0 在核心传输协议、解决的问题以及它们所针对的应用场景上存在革命性的差异。HTTP 3.0 不仅仅是 HTTP 2.0 的简单升级，它是一个范式转变，因为它彻底抛弃了 TCP，转而使用 UDP 作为其底层传输协议。</p>
<p><strong>HTTP 2.0 (基于 TCP 的增强)</strong></p>
<ul>
<li><strong>底层协议：</strong> 基于 TCP（传输控制协议）。</li>
<li><strong>主要目标：</strong> 解决 HTTP 1.x 的队头阻塞（Head-of-Line Blocking）问题以及效率低下。</li>
<li><strong>主要特性（回顾）：</strong><ul>
<li><strong>多路复用 (Multiplexing)：</strong> 在单个 TCP 连接上同时发送和接收多个独立的请求和响应流。这解决了应用层的队头阻塞。</li>
<li><strong>头部压缩 (HPACK)：</strong> 减少请求和响应头部的大小。</li>
<li><strong>服务器推送 (Server Push)：</strong> 服务器主动将客户端可能需要的资源推送到客户端。</li>
<li><strong>二进制分帧：</strong> 数据以二进制格式传输，提高解析效率。</li>
</ul>
</li>
</ul>
<p><strong>HTTP 3.0 (基于 UDP&#x2F;QUIC 的革命)</strong></p>
<ul>
<li><p><strong>底层协议：</strong> 基于 UDP（用户数据报协议）之上的 <strong>QUIC (Quick UDP Internet Connections)</strong> 协议。</p>
</li>
<li><p><strong>主要目标：</strong> 解决 TCP 层面的队头阻塞和连接建立延迟（握手延迟），以及提供更流畅的移动设备体验。</p>
</li>
<li><p><strong>核心原因：</strong> 尽管 HTTP&#x2F;2 通过多路复用解决了<strong>应用层</strong>的队头阻塞，但它仍然受限于 TCP 的<strong>传输层</strong>队头阻塞。</p>
<ul>
<li>当一个 TCP 连接上的一个数据包丢失时，整个 TCP 流都会被阻塞，直到该丢失的数据包被重传并确认。这意味着即使一个 HTTP&#x2F;2 流上的数据包丢失，也会阻塞该 TCP 连接上的所有其他 HTTP&#x2F;2 流，因为它们都依赖于 TCP 层面的有序交付。</li>
<li>TCP 的连接建立（3次握手）和 TLS 握手（HTTP&#x2F;2 通常强制 HTTPS）需要多个往返时间（RTT），增加了延迟。</li>
</ul>
</li>
<li><p><strong>HTTP 3.0 的主要特性源自 QUIC：</strong></p>
<ul>
<li><strong>解决了传输层队头阻塞 (Head-of-Line Blocking)：</strong><ul>
<li>QUIC 在其内部实现了多路复用，但与 HTTP&#x2F;2 的应用层多路复用不同，QUIC 的流是独立的。</li>
<li>即使某个流的数据包丢失，也只会影响该流的传输，而不会阻塞同一 QUIC 连接上的其他流，因为 QUIC 的数据包丢失恢复和重传是基于流进行的。</li>
</ul>
</li>
<li><strong>更快的连接建立 (0-RTT 和 1-RTT 握手)：</strong><ul>
<li><strong>首次连接：</strong> QUIC 将 TCP 握手和 TLS 握手结合在一起，通常只需要 1 个 RTT 即可建立安全连接。</li>
<li><strong>恢复连接：</strong> 对于客户端之前连接过的服务器，QUIC 可以使用预共享的密钥和加密上下文，实现零往返时间（0-RTT）恢复连接，大大减少了重新连接的延迟。</li>
</ul>
</li>
<li><strong>改进的拥塞控制：</strong> QUIC 允许更灵活和可插拔的拥塞控制算法，可以根据不同的网络条件进行优化，而 TCP 的拥塞控制算法是操作系统的一部分，更新和修改更困难。</li>
<li><strong>连接迁移 (Connection Migration)：</strong><ul>
<li>当用户的 IP 地址或端口发生变化时（例如，从 Wi-Fi 切换到蜂窝数据，或在不同网络之间漫游），TCP 连接会被中断，需要重新建立。</li>
<li>QUIC 连接通过连接 ID 标识，而不是基于 IP 地址和端口。这意味着即使用户的 IP 地址或端口改变，QUIC 连接也能保持活跃，而无需重新建立，大大改善了移动设备用户的体验。</li>
</ul>
</li>
<li><strong>更强大的加密：</strong> QUIC 将加密（TLS 1.3）集成到协议的底层，提供了更强的安全性和私密性。QUIC 的所有握手包和数据包都默认加密，而 TCP 上的 HTTPS 只是在 TCP 连接建立后再进行 TLS 协商。</li>
<li><strong>去除队头阻塞的 UDP 基础：</strong> UDP 是一个无连接、不可靠的协议，但 QUIC 在其上构建了可靠性、有序交付（在每个流内部）、拥塞控制和安全性，有效地避免了 UDP 的缺点，并利用了其灵活性。</li>
</ul>
</li>
</ul>
<p><strong>总结表格：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">HTTP 2.0</th>
<th align="left">HTTP 3.0 (基于 QUIC)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层传输协议</strong></td>
<td align="left">TCP</td>
<td align="left">UDP (上层是 QUIC 协议)</td>
</tr>
<tr>
<td align="left"><strong>队头阻塞</strong></td>
<td align="left"><strong>应用层</strong>队头阻塞解决 (通过多路复用)；<strong>传输层</strong>队头阻塞仍在 (TCP 机制导致)</td>
<td align="left"><strong>传输层</strong>队头阻塞解决 (QUIC 流独立，不互相影响)</td>
</tr>
<tr>
<td align="left"><strong>连接建立延迟</strong></td>
<td align="left">较高 (TCP 3次握手 + TLS 握手)</td>
<td align="left">显著降低 (QUIC 1-RTT 握手，0-RTT 恢复)</td>
</tr>
<tr>
<td align="left"><strong>连接迁移</strong></td>
<td align="left">不支持 (IP&#x2F;端口变化导致连接中断)</td>
<td align="left">支持 (通过连接 ID，无缝切换网络 IP&#x2F;端口)</td>
</tr>
<tr>
<td align="left"><strong>拥塞控制</strong></td>
<td align="left">基于 TCP (操作系统实现，更新慢)</td>
<td align="left">QUIC 实现，更灵活，可插拔，易于优化</td>
</tr>
<tr>
<td align="left"><strong>加密</strong></td>
<td align="left">TLS 1.2&#x2F;1.3 (构建在 TCP 之上)</td>
<td align="left">TLS 1.3 (集成在 QUIC 协议内部，默认加密所有数据)</td>
</tr>
<tr>
<td align="left"><strong>性能提升</strong></td>
<td align="left">相对于 1.x 显著提升</td>
<td align="left">相对于 2.0 在高延迟、高丢包率以及移动网络环境下性能更优</td>
</tr>
<tr>
<td align="left"><strong>部署复杂性</strong></td>
<td align="left">较易，通常是通过 web 服务器模块升级</td>
<td align="left">较复杂，需要操作系统和网络设备支持 QUIC，且通常需要新的服务器软件</td>
</tr>
</tbody></table>
<p><strong>何时使用哪一个？</strong></p>
<ul>
<li><strong>HTTP 2.0：</strong> 目前仍然是主流的 HTTP 版本，广泛部署在各种 Web 服务器和浏览器中。它对 HTTP 1.x 的性能提升巨大，对于大多数常见的网络环境，其表现已经足够优秀。</li>
<li><strong>HTTP 3.0：</strong> 代表了 Web 协议的未来。它特别适用于以下场景：<ul>
<li><strong>移动设备用户：</strong> 网络切换频繁，IP 地址变化导致连接中断的问题更为突出。</li>
<li><strong>高延迟和丢包率的网络：</strong> 例如发展中国家的网络、公共 Wi-Fi 或蜂窝网络，HTTP 3.0 的队头阻塞解决方案和快速连接建立能够提供更流畅的体验。</li>
<li><strong>实时应用：</strong> 需要低延迟和高吞吐量的应用（如在线游戏、音视频流媒体）。</li>
</ul>
</li>
</ul>
<p>虽然 HTTP 3.0 仍在逐步普及中，但主流浏览器（Chrome、Firefox、Edge）和一些大型科技公司（如 Google、Facebook）已经在其服务中广泛支持和部署 HTTP 3.0。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/HTTP%20%E5%92%8C%20HTTPS%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/11/HTTP%20%E5%92%8C%20HTTPS%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">HTTP 和 HTTPS 有什么区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:39:20" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HTTP-和-HTTPS-有什么区别？"><a href="#HTTP-和-HTTPS-有什么区别？" class="headerlink" title="HTTP 和 HTTPS 有什么区别？"></a>HTTP 和 HTTPS 有什么区别？</h3><p>HTTP (Hypertext Transfer Protocol) 和 HTTPS (Hypertext Transfer Protocol Secure) 的主要区别在于<strong>安全性</strong>。HTTPS 是 HTTP 的安全版本，通过在 HTTP 层和 TCP 层之间添加一个加密层（SSL&#x2F;TLS）来实现数据的加密和认证。</p>
<p>让我们详细分解它们的区别：</p>
<hr>
<h3 id="1-安全性-Security"><a href="#1-安全性-Security" class="headerlink" title="1. 安全性 (Security)"></a>1. 安全性 (Security)</h3><ul>
<li><p><strong>HTTP:</strong></p>
<ul>
<li><strong>不安全：</strong> HTTP 传输的数据是明文的。这意味着任何中间人（如网络运营商、ISP、恶意攻击者）都可以拦截、读取、甚至修改传输中的数据。</li>
<li><strong>没有完整性：</strong> 无法验证数据在传输过程中是否被篡改。</li>
<li><strong>没有认证：</strong> 无法验证你连接的服务器是否是你声称要连接的服务器。</li>
</ul>
</li>
<li><p><strong>HTTPS:</strong></p>
<ul>
<li><strong>加密：</strong> HTTPS 对所有传输的数据进行加密。即使数据被拦截，攻击者也无法轻易理解其内容。这保护了用户隐私（如用户输入的密码、信用卡号、个人信息等）。</li>
<li><strong>数据完整性：</strong> 传输的数据在到达目的地时会进行完整性校验。如果数据在传输过程中被篡改，客户端或服务器会检测到并拒绝该数据。</li>
<li><strong>服务器认证：</strong> HTTPS 使用数字证书（通常由受信任的证书颁发机构 CA 颁发）来验证服务器的身份。这可以防止中间人攻击，确保用户连接到的是真正的网站，而不是一个假冒的站点。</li>
<li><strong>客户端认证（可选）：</strong> 尽管不常用，但 HTTPS 也可以支持客户端认证，以验证连接的客户端身份。</li>
</ul>
</li>
</ul>
<h3 id="2-端口-Port"><a href="#2-端口-Port" class="headerlink" title="2. 端口 (Port)"></a>2. 端口 (Port)</h3><ul>
<li><strong>HTTP:</strong> 默认使用 <strong>80</strong> 端口。</li>
<li><strong>HTTPS:</strong> 默认使用 <strong>443</strong> 端口。</li>
</ul>
<h3 id="3-连接建立过程"><a href="#3-连接建立过程" class="headerlink" title="3. 连接建立过程"></a>3. 连接建立过程</h3><ul>
<li><p><strong>HTTP:</strong></p>
<ol>
<li>客户端发起 TCP 连接到服务器的 80 端口。</li>
<li>客户端发送 HTTP 请求。</li>
<li>服务器返回 HTTP 响应。</li>
<li>TCP 连接关闭（或保持“Keep-Alive”）。</li>
</ol>
</li>
<li><p><strong>HTTPS:</strong></p>
<ol>
<li>客户端发起 TCP 连接到服务器的 443 端口。</li>
<li><strong>SSL&#x2F;TLS 握手：</strong> 这是 HTTPS 独有的步骤。<ul>
<li>客户端和服务器协商加密算法和密钥。</li>
<li>服务器发送其数字证书给客户端。</li>
<li>客户端验证服务器证书的有效性（检查 CA、有效期、域名匹配等）。</li>
<li>如果证书有效，客户端和服务器生成用于加密通信的会话密钥。</li>
</ul>
</li>
<li><strong>加密的 HTTP 通信：</strong> 一旦 SSL&#x2F;TLS 握手成功，所有后续的 HTTP 请求和响应都会使用协商好的密钥进行加密和解密。</li>
<li>TCP 连接关闭。</li>
</ol>
</li>
</ul>
<h3 id="4-性能-Performance"><a href="#4-性能-Performance" class="headerlink" title="4. 性能 (Performance)"></a>4. 性能 (Performance)</h3><ul>
<li><p><strong>HTTP:</strong></p>
<ul>
<li>性能开销较低，因为不需要加密和解密。</li>
</ul>
</li>
<li><p><strong>HTTPS:</strong></p>
<ul>
<li>性能开销略高，因为：<ul>
<li><strong>SSL&#x2F;TLS 握手：</strong> 增加了首次连接的延迟（通常是 1-2 个额外往返时间 RTT）。</li>
<li><strong>加密&#x2F;解密：</strong> 数据的加密和解密需要额外的 CPU 资源。</li>
</ul>
</li>
<li><strong>但请注意：</strong> 随着硬件性能的提升、TLS 协议的优化（如 TLS 1.3 的 1-RTT&#x2F;0-RTT 握手、会话恢复）以及服务器端的优化（如使用专用硬件加速器），HTTPS 的性能开销已经大大降低，对于大多数现代网站，用户几乎感受不到差异。</li>
</ul>
</li>
</ul>
<h3 id="5-SEO-Search-Engine-Optimization"><a href="#5-SEO-Search-Engine-Optimization" class="headerlink" title="5. SEO (Search Engine Optimization)"></a>5. SEO (Search Engine Optimization)</h3><ul>
<li><p><strong>HTTP:</strong></p>
<ul>
<li>搜索引擎（尤其是 Google）会<strong>优先收录 HTTPS 网站</strong>，并可能给予其更高的排名。Google 明确表示 HTTPS 是一个排名信号。</li>
</ul>
</li>
<li><p><strong>HTTPS:</strong></p>
<ul>
<li><strong>有利于 SEO。</strong></li>
</ul>
</li>
</ul>
<h3 id="6-可信度-用户体验-Trust-User-Experience"><a href="#6-可信度-用户体验-Trust-User-Experience" class="headerlink" title="6. 可信度&#x2F;用户体验 (Trust&#x2F;User Experience)"></a>6. 可信度&#x2F;用户体验 (Trust&#x2F;User Experience)</h3><ul>
<li><p><strong>HTTP:</strong></p>
<ul>
<li>在浏览器地址栏中显示为 <code>http://</code>，通常会伴随一个“不安全”或“未加密”的警告图标。</li>
<li>用户（尤其是对网络安全有意识的用户）可能会因为感到不安全而避免在这些网站上输入敏感信息。</li>
</ul>
</li>
<li><p><strong>HTTPS:</strong></p>
<ul>
<li>在浏览器地址栏中显示为 <code>https://</code>，通常会显示一个<strong>挂锁图标</strong>，表明连接是安全的。</li>
<li>增强了用户对网站的信任度。</li>
</ul>
</li>
</ul>
<h3 id="总结表格："><a href="#总结表格：" class="headerlink" title="总结表格："></a>总结表格：</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">HTTP</th>
<th align="left">HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">不安全 (明文传输)</td>
<td align="left">安全 (SSL&#x2F;TLS 加密、完整性、认证)</td>
</tr>
<tr>
<td align="left"><strong>端口</strong></td>
<td align="left">80</td>
<td align="left">443</td>
</tr>
<tr>
<td align="left"><strong>握手</strong></td>
<td align="left">只有 TCP 握手</td>
<td align="left">TCP 握手 + SSL&#x2F;TLS 握手</td>
</tr>
<tr>
<td align="left"><strong>数据</strong></td>
<td align="left">可被监听、篡改</td>
<td align="left">加密，不易被监听和篡改</td>
</tr>
<tr>
<td align="left"><strong>证书</strong></td>
<td align="left">不需要</td>
<td align="left">需要数字证书 (由 CA 颁发)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">理论上稍快，但如今差距微乎其微</td>
<td align="left">理论上稍慢 (由于加密解密开销和握手延迟)</td>
</tr>
<tr>
<td align="left"><strong>URL</strong></td>
<td align="left">以 <code>http://</code> 开头</td>
<td align="left">以 <code>https://</code> 开头</td>
</tr>
<tr>
<td align="left"><strong>SEO</strong></td>
<td align="left">不利于排名</td>
<td align="left">有利于 SEO 排名</td>
</tr>
<tr>
<td align="left"><strong>信任</strong></td>
<td align="left">浏览器提示“不安全”</td>
<td align="left">浏览器显示安全锁图标，增强用户信任</td>
</tr>
</tbody></table>
<p><strong>结论：</strong><br>由于网络安全的重要性以及用户隐私保护的需求，<strong>HTTPS 已成为现代 Web 的标准</strong>。所有提供敏感信息交互（如登录、支付）的网站都必须使用 HTTPS。即使是纯内容网站，为了提升用户体验、SEO 和应对未来的浏览器警告，也强烈建议部署 HTTPS。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
