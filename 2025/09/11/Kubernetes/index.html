<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kubernetes | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="解释什么是 Kubernetes，并描述其主要组件及其作用🤔 分析过程：此问题是考察对Kubernetes整体概念和核心架构的理解。回答此问题的关键在于：  首先给出一个精准、高度概括的定义，说明Kubernetes是做什么的。 然后，逻辑清晰地拆解其架构，通常分为控制平面（Control Plane）和工作节点（Node）两大部分。 最后，逐一解释每个核心组件的功能，并说明它们之间是如何协同工">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/Kubernetes/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="解释什么是 Kubernetes，并描述其主要组件及其作用🤔 分析过程：此问题是考察对Kubernetes整体概念和核心架构的理解。回答此问题的关键在于：  首先给出一个精准、高度概括的定义，说明Kubernetes是做什么的。 然后，逻辑清晰地拆解其架构，通常分为控制平面（Control Plane）和工作节点（Node）两大部分。 最后，逐一解释每个核心组件的功能，并说明它们之间是如何协同工">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:46:31.373Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kubernetes",
  "url": "https://huiaz.github.io/2025/09/11/Kubernetes/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:46:31.373Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/Kubernetes/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kubernetes',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Kubernetes</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Kubernetes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:46:31.373Z" title="更新于 2025-09-11 21:46:31">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="解释什么是-Kubernetes，并描述其主要组件及其作用"><a href="#解释什么是-Kubernetes，并描述其主要组件及其作用" class="headerlink" title="解释什么是 Kubernetes，并描述其主要组件及其作用"></a>解释什么是 Kubernetes，并描述其主要组件及其作用</h3><h3 id="🤔-分析过程："><a href="#🤔-分析过程：" class="headerlink" title="🤔 分析过程："></a>🤔 分析过程：</h3><p>此问题是考察对Kubernetes整体概念和核心架构的理解。回答此问题的关键在于：</p>
<ol>
<li>首先给出一个精准、高度概括的定义，说明Kubernetes是做什么的。</li>
<li>然后，逻辑清晰地拆解其架构，通常分为<strong>控制平面（Control Plane）</strong>和<strong>工作节点（Node）</strong>两大部分。</li>
<li>最后，逐一解释每个核心组件的功能，并说明它们之间是如何协同工作的。</li>
</ol>
<h3 id="💡-答案生成："><a href="#💡-答案生成：" class="headerlink" title="💡 答案生成："></a>💡 答案生成：</h3><h4 id="1-概念或定义"><a href="#1-概念或定义" class="headerlink" title="1. 概念或定义"></a>1. 概念或定义</h4><p><strong>Kubernetes</strong>（常简称为K8s）是一个开源的、用于<strong>自动化部署、扩展和管理容器化应用程序</strong>的平台。</p>
<p>Kubernetes的核心思想是<strong>“声明式配置”</strong>（Declarative Configuration）和<strong>“自动化”</strong>。开发者只需声明应用程序的“期望状态”（例如，我需要运行我的应用3个副本），Kubernetes就会持续工作，确保集群的“实际状态”与这个“期望状态”保持一致，并能自动处理节点故障、流量分发、服务扩缩容等复杂任务。</p>
<h4 id="2-主要组件及其作用"><a href="#2-主要组件及其作用" class="headerlink" title="2. 主要组件及其作用"></a>2. 主要组件及其作用</h4><p>Kubernetes的架构遵循经典的Master-Slave（现在更常称为Control Plane-Node）模型。</p>
<hr>
<h3 id="A-控制平面组件-Control-Plane-Components"><a href="#A-控制平面组件-Control-Plane-Components" class="headerlink" title="A. 控制平面组件 (Control Plane Components)"></a>A. 控制平面组件 (Control Plane Components)</h3><p>控制平面是集群的大脑，负责做出全局决策（如调度）以及检测和响应集群事件。这些组件可以运行在任何机器上，但为了简单起见，通常会全部启动在同一台（或多台，为了高可用）服务器上。</p>
<p><strong>(1) API Server (<code>kube-apiserver</code>)</strong></p>
<ul>
<li><strong>作用：</strong> <strong>集群的统一入口和网关</strong>。</li>
<li><strong>描述：</strong> 它是控制平面的前端，所有与集群的交互（无论是来自用户<code>kubectl</code>命令、UI界面还是其他组件）都必须通过API Server。它负责处理REST请求，验证请求的合法性，并更新<code>etcd</code>中对应对象的状态。它是整个集群的中枢神经系统。</li>
</ul>
<p><strong>(2) etcd</strong></p>
<ul>
<li><strong>作用：</strong> <strong>集群的分布式键值存储系统</strong>。</li>
<li><strong>描述：</strong> <code>etcd</code>是Kubernetes的“单一事实来源”（Single Source of Truth），用于持久化存储整个集群的所有状态数据，包括Pod、Service、Secret、ConfigMap等所有API对象的配置和状态信息。集群的高可用性严重依赖于<code>etcd</code>的可靠性。</li>
</ul>
<p><strong>(3) Scheduler (<code>kube-scheduler</code>)</strong></p>
<ul>
<li><strong>作用：</strong> <strong>负责Pod的调度</strong>。</li>
<li><strong>描述：</strong> Scheduler持续监视API Server，寻找新创建的、但尚未被分配到节点的Pod。它根据一系列预设的策略（如资源需求、硬件约束、亲和性与反亲和性规则、污点与容忍度等），为这些Pod选择一个最合适的Node来运行。调度器只负责“决策”，不负责“执行”。</li>
</ul>
<p><strong>(4) Controller Manager (<code>kube-controller-manager</code>)</strong></p>
<ul>
<li><strong>作用：</strong> <strong>运行核心的控制器，维护集群状态</strong>。</li>
<li><strong>描述：</strong> 这是】件。每个控制器都是一个独立的进程，负责一个特定的资源。例如：<ul>
<li><strong>Deployment Controller:</strong> 确保Deployment对象所期望的Pod副本数与实际运行的副本数一致。</li>
<li><strong>Node Controller:</strong> 监视节点的状态，负责在节点宕机时进行通知和响应。</li>
<li><strong>Replication Controller:</strong> 维护ReplicaSet中Pod的数量。<br>这些控制器通过API Server监视集群状态，并自动进行修复、扩缩容等操作，以驱动实际状态向期望状态收敛。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="B-节点组件-Node-Components"><a href="#B-节点组件-Node-Components" class="headerlink" title="B. 节点组件 (Node Components)"></a>B. 节点组件 (Node Components)</h3><p>工作节点是集群中的工作负载（即容器化应用）实际运行的地方。每个节点都必须运行以下组件。</p>
<p><strong>(1) Kubelet</strong></p>
<ul>
<li><strong>作用：</strong> <strong>节点上的代理（Agent）</strong>。</li>
<li><strong>描述：</strong> Kubelet是运行在每个节点上的主要代理程序。它从API Server接收该节点上Pod的期望状态（PodSpec），并确保这些Pod中的容器按照期望运行。它直接与容器运行时（Container Runtime）交互，负责Pod的生命周期管理，如启动、停止、监控容器健康状况，并向API Server汇报节点的真实状态。</li>
</ul>
<p><strong>(2) Kube-proxy</strong></p>
<ul>
<li><strong>作用：</strong> <strong>负责节点上的网络代理和负载均衡</strong>。</li>
<li><strong>描述：</strong> Kube-proxy在集群的每个节点上维护网络规则，这些规则允许从集群内部或外部与Pod进行网络通信。它通过修改节点上的<code>iptables</code>或<code>IPVS</code>规则，实现了Kubernetes <code>Service</code>的概念，将发往Service虚拟IP的流量转发到后端正确的Pod上。</li>
</ul>
<p><strong>(3) 容器运行时 (Container Runtime)</strong></p>
<ul>
<li><strong>作用：</strong> <strong>负责运行容器</strong>。</li>
<li><strong>描述：</strong> 这是真正运行容器的软件。Kubernetes是通用的，支持多种符合CRI（Container Runtime Interface）标准的容器运行时，最常见的包括 <strong><code>containerd</code><strong>、</strong>CRI-O</strong>，以及早期的<strong>Docker</strong>。Kubelet通过CRI接口命令容器运行时来拉取镜像、启动和停止容器。</li>
</ul>
<h4 id="3-应用场景-作用"><a href="#3-应用场景-作用" class="headerlink" title="3. 应用场景&#x2F;作用"></a>3. 应用场景&#x2F;作用</h4><p>Kubernetes 作为一个平台，其主要作用是：</p>
<ul>
<li><strong>服务发现和负载均衡:</strong> 自动为Pod分配IP和DNS名称，并能在它们之间进行负载均衡。</li>
<li><strong>自动化的滚动更新和回滚:</strong> 可以逐步更新应用，如果出现问题，也能自动回滚到上一个版本。</li>
<li><strong>自动装箱:</strong> 根据资源需求自动将容器放置在最佳节点上，提高资源利用率。</li>
<li><strong>自我修复:</strong> 能够重新启动失败的容器、替换Pod、杀死不健康的容器，并在节点死亡时重新调度Pod。</li>
<li><strong>密钥和配置管理:</strong> 允许存储和管理敏感信息（如密码、令牌）和应用配置，而无需重新构建镜像。</li>
</ul>
<h4 id="4-扩展知识-最佳实践"><a href="#4-扩展知识-最佳实践" class="headerlink" title="4. 扩展知识&#x2F;最佳实践"></a>4. 扩展知识&#x2F;最佳实践</h4><ul>
<li><strong>高可用性（HA）:</strong> 在生产环境中，控制平面组件（特别是<code>kube-apiserver</code>和<code>etcd</code>）必须以多副本方式部署，以避免单点故障。</li>
<li><strong>声明式API:</strong> 理解Kubernetes的声明式本质是关键。用户关注的是“What”（我想要什么），而不是“How”（具体怎么做），这极大地简化了运维工作。</li>
<li><strong>可扩展性:</strong> Kubernetes的强大之处在于其可扩展性。通过自定义资源定义（CRD）和Operator模式，社区可以像扩展原生API一样，为Kubernetes添加新的功能（如数据库管理、消息队列集群等）。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/Kubernetes/">https://huiaz.github.io/2025/09/11/Kubernetes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Kubernetes%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" title="Kubernetes 集群部署"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Kubernetes 集群部署</div></div><div class="info-2"><div class="info-item-1">Kubernetes 集群部署现在我们使用 kubeadm 从头搭建一个使用 containerd 作为容器运行时的 Kubernetes 集群，这里我们安装最新的 v1.22.2 版本。 环境准备3 个节点，都是 Centos 7.6 系统，内核版本：3.10.0-1062.4.1.el7.x86_64，在每个节点上添加 hosts 信息： 1234➜  ~ cat /etc/hosts192.168.31.31 master1192.168.31.108 node1192.168.31.46 node2  hostname 节点的 hostname 必须使用标准的 DNS 命名，另外千万不用什么默认的localhost 的 hostname，会导致各种错误出现的。在 Kubernetes 项目里，机器的名字以及一切存储在 Etcd 中的 API 对象，都必须使用标准的 DNS 命名（RFC 1123）。可以使用命令 hostnamectl set-hostname node1 来修改 hostname。 禁用防火墙： 12➜  ~ systemctl stop firewal...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Kubernetes%20%E7%AE%80%E4%BB%8B/" title="Kubernetes 简介"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Kubernetes 简介</div></div><div class="info-2"><div class="info-item-1">Kubernetes 简介Kubernetes（简称 K8S） 的出现是容器化技术发展的必然结果，容器化是应用程序级别的虚拟化，运行单个内核上有多个独立的用户空间实例，这些实例就是容器；容器提供了将应用程序的代码、运行时、系统工具、系统库和配置打包到一个实例中的标准方法，而且容器是共享一个内核的；由于容器技术的兴起，导致大量的容器应用出现，所以就出现了一些用来支持应用程序容器化部署和组织的容器编排技术，一些流行的开源容器编排工具有 Docker Swarm、Kubernetes 等，但是在发展过程中 Kubernetes 现在已经成为了容器编排领域事实上的一个标准了。  Kubernetes 是 Google 团队发起的一个开源项目，它的目标是管理跨多个主机的容器，用于自动部署、扩展和管理容器化的应用程序，主要实现语言为 Go 语言，他的理论基础来源与 Google 内部的 Borg 项目，所以 Kubernetes 项目的理论基础就比其他开源项目要“先进”很多，因为 Borg 系统一直依赖就被称为 Google 公司内部最强大的“私密武器”。 架构Kubernetes 项目依托...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Gateway%20API/" title="Gateway API"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Gateway API</div></div><div class="info-2"><div class="info-item-1">Gateway APIGateway API（之前叫 Service API）是由 SIG-NETWORK 社区管理的开源项目，项目地址：https://gateway-api.sigs.k8s.io/。主要原因是 Ingress 资源对象不能很好的满足网络需求，很多场景下 Ingress 控制器都需要通过定义 annotations 或者 crd 来进行功能扩展，这对于使用标准和支持是非常不利的，新推出的 Gateway API 旨在通过可扩展的面向角色的接口来增强服务网络。 Gateway API 是 Kubernetes 中的一个 API 资源集合，包括 GatewayClass、Gateway、HTTPRoute、TCPRoute、Service 等，这些资源共同为各种网络用例构建模型。  Gateway API 的改进比当前的 Ingress 资源对象有很多更好的设计：  面向角色 - Gateway 由各种 API 资源组成，这些资源根据使用和配置 Kubernetes 服务网络的角色进行建模。 通用性 - 和 Ingress 一样是一个具有众多实现的通用规范，Gat...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Dockerfile%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="Dockerfile 最佳实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Dockerfile 最佳实践</div></div><div class="info-2"><div class="info-item-1">Dockerfile 最佳实践Docker官方关于Dockerfile最佳实践原文链接地址：https://docs.docker.com/develop/develop-images/dockerfile_best-practices/ Docker可以通过从Dockerfile包含所有命令的文本文件中读取指令自动构建镜像，以便构建给定镜像。 Dockerfiles使用特定的格式并使用一组特定的指令。您可以在 Dockerfile Reference 页面上了解基础知识 。如果你是新手写作Dockerfile，你应该从那里开始。 本文档介绍了由 Docker，Inc. 和 Docker 社区推荐的用于构建高效镜像的最佳实践和方法。要查看更多实践和建议，请查看 Dockerfile for buildpack-deps。 一般准则和建议容器应该是短暂的通过 Dockerfile 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。我们可以查看下12 Factor(12要素)应用程序方法...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Thanos-%E6%9E%B6%E6%9E%84/" title="Thanos-架构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Thanos-架构</div></div><div class="info-2"><div class="info-item-1">Thanos 架构Thanos 是一个基于 Prometheus 实现的监控方案，其主要设计目的是解决原生 Prometheus 上的痛点，并且做进一步的提升，主要的特性有：全局查询，高可用，动态拓展，长期存储。 架构Thanos 主要由如下几个特定功能的组件组成：  边车组件（Sidecar）：连接到 Prometheus，并把 Prometheus 暴露给查询网关（Querier&#x2F;Query），以供实时查询，并且可以上传 Prometheus 数据到云存储，以供长期保存 查询网关（Querier）：实现 Prometheus API 以聚合来自底层组件（如边车组件 Sidecar，或是存储网关 Store Gateway）的数据 存储网关（Store Gateway）：将云存储中的数据内容暴露出来 压缩器（Compactor）：将云存储中的数据进行压缩和下采样和保留 接收器（Receiver）：从 Prometheus 的远程写入 WAL 接收数据，将其暴露出去或者上传到云存储 规则组件（Ruler）：根据 Thanos 中的数据评估记录和警报规则 查询前端：实现 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/" title="集合操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">集合操作</div></div><div class="info-2"><div class="info-item-1">集合操作有的时候我们需要过滤或将一组时间序列与另一组时间序列进行合并，Prometheus 提供了 3 个在瞬时向量之间操作的集合运算符。  and（集合交集）：比如对较高错误率触发报警，但是只有当对应的总错误率超过某个阈值的时候才会触发报警 or（集合并集）：对序列进行并集计算 unless（除非）：比如要对磁盘空间不足进行告警，除非它是只读文件系统。   与算术和过滤二元运算符类似，这些集合运算符会尝试根据相同的标签集在左侧和右侧之间查找来匹配序列，除非你提供 on() 或 ignoring() 修饰符来指定应该如何找到匹配。  注意：与算术和过滤二进制运算符相比，集合运算符没有 group_left() 或 group_right() 修饰符，因为集合运算符总是进行多对多的匹配，也就是说，它们总是允许任何一边的匹配序列与另一边的多个序列相匹配。  对于 and 运算符，如果找到一个匹配的，左边的序列就会成为输出结果的一部分，如果右边没有匹配的序列，则不会输出任何结果。 例如我们想筛选出第 90 个百分位延迟高于 50ms 的所有 HTTP 端点，但只针对每秒收到多个请求的维...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20Deployment/" title="k8s Deployment"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s Deployment</div></div><div class="info-2"><div class="info-item-1">Kubernetes 中的 Deployment 和 StatefulSet 有什么区别？🤔 分析过程：该问题旨在考察对Kubernetes中两种核心工作负载控制器（Workload Controllers）的理解和区分能力。一个优秀的回答不仅要罗列出功能上的差异，更要阐明这两种控制器在设计哲学上的根本不同，即它们分别是为了解决无状态应用（Stateless）和有状态应用（Stateful）这两大类问题的。本回答将通过一个清晰的对比表格来突出核心区别，并结合应用场景和选型指南，帮助面试者建立深刻的理解。 💡 答案生成：1. 核心概念定义 Deployment: 是Kubernetes中用于管理无状态应用的控制器。它确保指定数量的、完全相同的Pod副本（Replicas）处于运行状态。这些Pod是可互换的（Interchangeable&#x2F;Fungible），可以被随意地创建和销毁，而不会影响应用的整体状态。  StatefulSet: 是用于管理有状态应用的控制器。它为每个Pod提供唯一的、稳定的身份标识，并保证Pod的部署、伸缩和更新是有序的。这些Pod不是可互换的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20ResourceQuota/" title="k8s ResourceQuota"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s ResourceQuota</div></div><div class="info-2"><div class="info-item-1">描述在 Kubernetes 中如何配置资源配额，并解释其作用。	 🤔 分析过程：此问题旨在考察对Kubernetes资源治理和多租户管理的理解。核心是ResourceQuota对象。一个高质量的回答不仅要说明如何创建ResourceQuota，更要阐明其核心目的：为命名空间（Namespace）设置资源“预算”。这包括计算资源（CPU&#x2F;Memory）、存储资源和对象数量的限制。此外，还应提及它与LimitRange对象的关系，这能体现出对资源管理体系的深入理解。 💡 答案生成：1. 概念或定义ResourceQuota（资源配额）是Kubernetes中的一个策略对象，它为命名空间（Namespace）提供了资源消耗的总量限制。它允许集群管理员为每个命名空间分配一个“预算”，确保单个团队或应用不会消耗掉超出其分配额度的资源，从而影响到集群中的其他用户。 核心要点： 资源配额是作用于命名空间级别的，不是作用于单个Pod或节点的。 2. 作用与目的配置资源配额的主要作用是实现集群的治理和公平性，具体目标包括：  防止“邻居吵闹”问题 (Noisy Neighbor):...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AF-Kubernetes%EF%BC%8C%E5%B9%B6%E6%8F%8F%E8%BF%B0%E5%85%B6%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">解释什么是 Kubernetes，并描述其主要组件及其作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%94-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">🤔 分析过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E7%AD%94%E6%A1%88%E7%94%9F%E6%88%90%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">💡 答案生成：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5%E6%88%96%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">1. 概念或定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2. 主要组件及其作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6-Control-Plane-Components"><span class="toc-number">4.</span> <span class="toc-text">A. 控制平面组件 (Control Plane Components)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E8%8A%82%E7%82%B9%E7%BB%84%E4%BB%B6-Node-Components"><span class="toc-number">5.</span> <span class="toc-text">B. 节点组件 (Node Components)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-%E4%BD%9C%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">3. 应用场景&#x2F;作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.2.</span> <span class="toc-text">4. 扩展知识&#x2F;最佳实践</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>