<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP连接 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="好的，我们来深入理解一下 TCP 连接。 TCP (Transmission Control Protocol，传输控制协议) 连接是计算机网络中一种可靠的、面向连接的、基于字节流的通信方式。它是互联网的基础协议之一，位于 OSI 模型的传输层。 要理解 TCP 连接，首先要明白它解决了哪些问题，以及它是如何解决的。  TCP 解决了什么问题？想象一下你给朋友寄包裹。如果你想确保包裹一定能送到、顺">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP连接">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/TCP%E8%BF%9E%E6%8E%A5/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="好的，我们来深入理解一下 TCP 连接。 TCP (Transmission Control Protocol，传输控制协议) 连接是计算机网络中一种可靠的、面向连接的、基于字节流的通信方式。它是互联网的基础协议之一，位于 OSI 模型的传输层。 要理解 TCP 连接，首先要明白它解决了哪些问题，以及它是如何解决的。  TCP 解决了什么问题？想象一下你给朋友寄包裹。如果你想确保包裹一定能送到、顺">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:07:22.427Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP连接",
  "url": "https://huiaz.github.io/2025/09/11/TCP%E8%BF%9E%E6%8E%A5/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:07:22.427Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/TCP%E8%BF%9E%E6%8E%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP连接',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP连接</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP连接</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:07:22.427Z" title="更新于 2025-09-11 22:07:22">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>好的，我们来深入理解一下 TCP 连接。</p>
<p>TCP (Transmission Control Protocol，传输控制协议) 连接是计算机网络中一种<strong>可靠的、面向连接的、基于字节流</strong>的通信方式。它是互联网的基础协议之一，位于 OSI 模型的传输层。</p>
<p>要理解 TCP 连接，首先要明白它解决了哪些问题，以及它是如何解决的。</p>
<hr>
<h3 id="TCP-解决了什么问题？"><a href="#TCP-解决了什么问题？" class="headerlink" title="TCP 解决了什么问题？"></a>TCP 解决了什么问题？</h3><p>想象一下你给朋友寄包裹。如果你想确保包裹<strong>一定能送到</strong>、<strong>顺序不错乱</strong>、<strong>没有丢失</strong>、<strong>没有重复</strong>，并且能知道朋友<strong>是否收到了</strong>，这就是 TCP 试图在数据传输中实现的目标。</p>
<p>具体来说，TCP 针对底层的 IP (Internet Protocol，网际协议) 的局限性，提供了以下关键服务：</p>
<ol>
<li><p><strong>可靠性 (Reliability)：</strong> IP 是不可靠的，它只负责尽力而为地转发数据包，不保证数据包是否到达，也不保证顺序。TCP通过以下机制确保可靠性：</p>
<ul>
<li><strong>确认机制 (Acknowledgements - ACK)：</strong> 接收方收到数据后会发送确认包给发送方。</li>
<li><strong>重传机制 (Retransmission)：</strong> 如果发送方在一定时间内没有收到确认包，它会认为数据包丢失，并重新发送。</li>
<li><strong>校验和 (Checksums)：</strong> 检查数据在传输过程中是否被损坏。</li>
</ul>
</li>
<li><p><strong>顺序性 (In-order Delivery)：</strong> IP 数据包可能乱序到达。TCP 给每个数据包（更准确地说，是每个字节流的段）编号，接收方能根据编号重新排列数据，确保应用程序收到的是按发送顺序排列的完整数据流。</p>
</li>
<li><p><strong>流量控制 (Flow Control)：</strong> 防止发送方发送数据过快，导致接收方来不及处理而缓冲区溢出。TCP 使用滑动窗口 (Sliding Window) 机制，让接收方告知发送方自己还有多少可用缓冲区空间。</p>
</li>
<li><p><strong>拥塞控制 (Congestion Control)：</strong> 防止网络中出现过多的数据，导致网络性能下降甚至崩溃。TCP 会根据网络拥堵情况动态调整发送速率，避免加重拥堵。</p>
</li>
<li><p><strong>面向连接 (Connection-Oriented)：</strong> 在数据传输之前，发送方和接收方之间会建立一个逻辑上的“连接”，完成“握手”过程，协商好各项参数。数据完成后，还会进行“挥手”断开连接。</p>
</li>
</ol>
<hr>
<h3 id="TCP-连接的三个核心阶段："><a href="#TCP-连接的三个核心阶段：" class="headerlink" title="TCP 连接的三个核心阶段："></a>TCP 连接的三个核心阶段：</h3><p>一个 TCP 连接的生命周期可以分为三个主要阶段：</p>
<h4 id="1-连接建立-Connection-Establishment-三次握手-Three-Way-Handshake"><a href="#1-连接建立-Connection-Establishment-三次握手-Three-Way-Handshake" class="headerlink" title="1. 连接建立 (Connection Establishment) - 三次握手 (Three-Way Handshake)"></a>1. 连接建立 (Connection Establishment) - 三次握手 (Three-Way Handshake)</h4><p><img src="https://mudutestmenu.mudu.tv/upload/mi0tlx.png" alt="企业微信截图_a8cf363d-e487-4bfb-a444-ee9a9ecd6aa1"></p>
<p>这是建立 TCP 连接的过程，确保双方都准备好进行数据通信。</p>
<ul>
<li><strong>第一次握手：</strong> 客户端发送一个 <code>SYN</code> (Synchronize) 包到服务器，请求建立连接。包中包含客户端的初始序列号 (ISN_c)。</li>
<li><strong>第二次握手：</strong> 服务器收到 <code>SYN</code> 包后，发送一个 <code>SYN-ACK</code> (Synchronize-Acknowledgement) 包作为响应。<code>SYN-ACK</code> 中包含服务器的初始序列号 (ISN_s) 和对客户端 <code>SYN</code> 包的确认号 (ACK_c &#x3D; ISN_c + 1)。</li>
<li><strong>第三次握手：</strong> 客户端收到 <code>SYN-ACK</code> 包后，发送一个 <code>ACK</code> (Acknowledgement) 包作为响应，确认收到服务器的 <code>SYN</code>。包中包含对服务器 <code>SYN</code> 包的确认号 (ACK_s &#x3D; ISN_s + 1)。</li>
</ul>
<p>至此，双方都确认了彼此能够发送和接收数据，连接建立成功。</p>
<h4 id="2-数据传输-Data-Transfer"><a href="#2-数据传输-Data-Transfer" class="headerlink" title="2. 数据传输 (Data Transfer)"></a>2. 数据传输 (Data Transfer)</h4><p>连接建立后，客户端和服务器可以开始互相发送和接收数据。这个阶段涉及到：</p>
<ul>
<li><strong>数据分段：</strong> 应用程序数据被 TCP 分割成较小的数据段 (Segment)。</li>
<li><strong>序列号和确认号：</strong> 每个数据段都有一个序列号，接收方会发送一个确认号，表示它已经收到了哪些数据，并期望接收下一个序列号的数据。</li>
<li><strong>滑动窗口：</strong> 允许发送方在收到所有确认之前发送多个数据段，提高效率。接收方通过窗口大小来告知发送方可以发送多少数据。</li>
<li><strong>重传机制：</strong> 如果数据包丢失或确认超时，发送方会重传。</li>
<li><strong>流量控制和拥塞控制：</strong> 动态调整发送速率以适应接收方处理能力和网络状况。</li>
</ul>
<h4 id="3-连接终止-Connection-Termination-四次挥手-Four-Way-Handshake"><a href="#3-连接终止-Connection-Termination-四次挥手-Four-Way-Handshake" class="headerlink" title="3. 连接终止 (Connection Termination) - 四次挥手 (Four-Way Handshake)"></a>3. 连接终止 (Connection Termination) - 四次挥手 (Four-Way Handshake)</h4><p>当数据传输完成时，双方需要协调关闭连接。由于 TCP 是全双工的（双方都可以独立发送和接收数据），所以它需要四步来确保双方都完成数据发送。</p>
<ul>
<li><strong>第一次挥手：</strong> 客户端发送一个 <code>FIN</code> (Finish) 包，表示它已经没有数据要发送了。</li>
<li><strong>第二次挥手：</strong> 服务器收到 <code>FIN</code> 包后，发送一个 <code>ACK</code> 包，确认收到客户端的关闭请求。此时，客户端到服务器的方向已经关闭，但服务器到客户端的方向仍然可以发送数据。</li>
<li><strong>第三次挥手：</strong> 服务器也发送一个 <code>FIN</code> 包，表示它也没有数据要发送了。</li>
<li><strong>第四次挥手：</strong> 客户端收到服务器的 <code>FIN</code> 包后，发送一个 <code>ACK</code> 包确认。然后进入 <code>TIME_WAIT</code> 状态，等待一段时间以确保服务器收到最后的 ACK。服务器收到最后的 ACK 后，连接彻底关闭。</li>
</ul>
<hr>
<h3 id="为什么说它是“面向连接”？"><a href="#为什么说它是“面向连接”？" class="headerlink" title="为什么说它是“面向连接”？"></a>为什么说它是“面向连接”？</h3><p>“面向连接”意味着在实际数据传输之前，通信双方必须先建立一个逻辑上的通道（连接）。这个通道在传输过程中一直存在，并且在数据传输完成后需要关闭。</p>
<p>这与“无连接”协议（如 UDP - User Datagram Protocol）形成对比。UDP 不需要握手，直接发送数据，不保证可靠性或顺序性，但开销更小，延迟更低。</p>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>TCP 连接可以理解为：通信双方之间建立的一条<strong>可靠的、双向的、经过协商</strong>的数据传输通道。这条通道通过复杂的机制（三次握手、四次挥手、序列号、确认号、滑动窗口、重传、流量控制、拥塞控制等）来保证数据的<strong>完整性、顺序性、不重复和不丢失</strong>，使得上层应用可以放心地进行数据交换，而无需关心底层的网络细节。</p>
<p>HTTP、FTP、SMTP 等许多我们日常使用的应用层协议都是基于 TCP 连接来传输数据的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/TCP%E8%BF%9E%E6%8E%A5/">https://huiaz.github.io/2025/09/11/TCP%E8%BF%9E%E6%8E%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP快速重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCP快速重传机制</div></div><div class="info-2"><div class="info-item-1">TCP 引入快速重传（Fast Retransmit）机制，是为了弥补仅仅依靠超时重传的不足，提高网络吞吐量和链路利用率，尤其是在数据包丢失不严重但仍存在的情况下。 让我们来详细了解一下： 超时重传的不足：超时重传是 TCP 可靠性最基本的保障，但它有一个致命的弱点：等待时间过长。  重传超时时间 (RTO) 的计算： RTO 是根据网络中的往返时间 (RTT) 动态调整的，通常比 RTT 要长一些。即使网络状况良好，RTO 至少也得几十毫秒甚至几百毫秒。 等待 RTO 的代价： 吞吐量下降： 如果一个数据包丢失了，发送方必须一直等到 RTO 到期才能重传。在这漫长的等待期间，发送方可能无法发送新的数据（如果拥塞窗口和接收窗口限制），导致网络带宽得不到充分利用，吞吐量显著下降。 延迟增加： 对于实时性要求较高的应用，长时间的等待会导致明显的延迟增加。 可能触发不必要的拥塞控制： 当超时发生时，TCP 会认为发生了一次严重的丢包事件，通常会大幅度降低拥塞窗口（例如，将拥塞窗口降到 1 MSS），这会极大地限制后续的数据发送，加剧吞吐量下降，即便实际上可能只丢失了一个包。    快速...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCPIP%204%20%E5%B1%82%E6%A8%A1%E5%9E%8B/" title="TCPIP 4 层模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TCPIP 4 层模型</div></div><div class="info-2"><div class="info-item-1">TCP&#x2F;IP 四层模型（也称为 TCP&#x2F;IP 协议栈、TCP&#x2F;IP 参考模型）是计算机网络中最常用和最重要的分层模型之一。它将复杂的网络通信过程划分为若干个逻辑层，每层负责不同的功能。 这个模型与 OSI 七层模型有所不同，虽然它们都致力于解决网络通信的复杂性，但 TCP&#x2F;IP 模型更注重实际应用和协议实现。 TCP&#x2F;IP 四层模型的构成：TCP&#x2F;IP 模型通常被划分为以下四层：  应用层 (Application Layer) 传输层 (Transport Layer) 网络层 (Internet Layer) 网络接口层 (Network Access Layer) 或 数据链路层&#x2F;物理层  让我们逐一详细了解每一层的功能、协议和数据单元。  1. 应用层 (Application Layer) 功能： 提供应用程序之间的通信服务。它是用户与网络进行交互的最高层，负责处理特定应用程序的数据，并将其转换为通过网络传输的格式。 代表协议： HTTP&#x2F;HTTPS： (超文本传输协议) 用于网页浏览。 F...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/" title="路由算法与协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">路由算法与协议</div></div><div class="info-2"><div class="info-item-1">路由协议 (Routing Protocols) 和路由选择算法 (Routing Algorithms) 是网络路由领域紧密相关但又截然不同的两个概念。理解它们之间的区别对于掌握网络路由的精髓至关重要。 路由选择算法 (Routing Algorithms)核心： 路由选择算法是决定数据包在网络中从源到目的地最佳路径的逻辑或计算过程。它关注的是“如何计算出最佳路径”。 特点：  数学模型&#x2F;逻辑： 它们是一套定义了如何根据特定度量（如跳数、延迟、带宽、成本等）来计算最优路径的数学模型或逻辑步骤。 通用性： 许多路由算法是通用的计算机科学概念，不局限于特定的网络设备或协议。 独立于实现： 算法本身只是一套理论，它不关心具体如何被实现或在哪个设备上运行。 输入： 它们通常需要网络拓扑信息（节点和链路）以及链路成本&#x2F;度量作为输入。 输出： 输出是到达网络中各个目的地的最佳路径。  常见的路由选择算法：  Dijkstra (迪克斯特拉) 算法： 经典的最短路径算法，常用于链路状态路由（如 OSPF）。它计算从单个源到所有其他节点的单源最短路径。 Bellman-Fo...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%201.0%20%E5%92%8C%202.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" title="HTTP 1.0 和 2.0 有什么区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 1.0 和 2.0 有什么区别</div></div><div class="info-2"><div class="info-item-1">HTTP 1.0 和 2.0 有什么区别？HTTP 1.0 和 2.0 在性能、效率和功能方面存在显著差异。以下是它们的关键区别： HTTP 1.0 (最初的成功)  核心概念：每次请求&#x2F;响应一个连接。 这是它最主要的特点。 短连接 (Short-lived connections): 每个请求和响应都需要建立一个新的TCP连接，在完成传输后立即关闭。这导致了大量的连接建立和关闭开销（三次握手和四次挥手）。   串行请求 (Serial requests): 浏览器一次只能发送一个请求，必须等待当前请求的响应，才能发送下一个请求。这导致了“队头阻塞 (Head-of-Line Blocking)”问题，即一个慢的响应会阻碍后续所有请求。 无头部压缩 (No header compression): 每个请求和响应的头部信息都是原始的，可能包含大量重复信息。 无服务器推送 (No server push): 服务器无法主动向客户端发送资源，只能响应客户端的请求。 无二进制分帧 (No binary framing): 数据以文本形式传输，效率较低。 Cookie (部分支...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP-四次挥手"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP-四次挥手</div></div><div class="info-2"><div class="info-item-1">TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。 假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。 四次挥手过程详解：第一次挥手：FIN 报文段（客户端 A → 服务器 B）  客户端 A (主动关闭方)：  当客户端 A 的应用层想要关闭连接时（例如调用 close() 或 shutdown()），客户端 A 的 TCP 会发送一个带有 FIN (Finish) 标志的报文段给服务器 B。 这个 FIN 报文段的序列号通常是它发送的最后一个数据字节的序列号的下一个。 发送 FIN 后，客户端 A 进入 FIN_WAIT_1 状态。这意味着客户端 A 不再发送数据，但仍然可以接收数据。  状态变化： ESTABLISHED → FIN_WAIT_1   第二次挥手：ACK 报文段（服务器 B → 客户端 A）  服务器 B (被动关闭方)：  当...</div></div></div></a><a class="pagination-related" href="/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/" title="DHCP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">DHCP 协议</div></div><div class="info-2"><div class="info-item-1">DHCP 协议的工作原理及应用场景什么是 DHCP 协议？DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 是一种网络协议，用于自动化管理和分配网络中的 IP 地址以及其他相关配置信息（如子网掩码、默认网关、DNS 服务器地址等）。它的核心思想是取代手动配置每台设备的网络参数，实现即插即用，大大简化了大型网络的管理。 DHCP 协议的工作原理 (DORA 过程)DHCP 协议通常通过四步过程（称为 DORA 过程）来完成 IP 地址分配：  Discover (发现)  客户端行为： 当一台新设备（或一台没有配置 IP 地址的设备）连接到网络时，它不知道网络中是否有 DHCP 服务器，也不知道自己的 IP 地址。因此，它会广播一个 DHCP Discover 消息到局域网内的所有设备（使用目的 IP 地址 255.255.255.255，源 IP 地址 0.0.0.0）。 目的： 寻找网络中的 DHCP 服务器。   Offer (提供)  服务器行为： 网络中的 DHCP 服务器收到 DHCP Discover 消息后，会从...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ARP%E5%8D%8F%E8%AE%AE/" title="ARP协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ARP协议</div></div><div class="info-2"><div class="info-item-1">好的，我们来详细了解一下 ARP 和 RARP。  1. ARP (Address Resolution Protocol) - 地址解析协议作用： 将网络层（IP 地址） 地址解析为数据链路层（MAC 地址） 的协议。 应用场景：当一个主机想与同一局域网内的另一个主机进行通信时，它知道目标主机的 IP 地址，但数据链路层（如以太网）需要目标主机的 MAC 地址来封装帧。此时就需要 ARP 来完成 IP 到 MAC 的映射。 工作原理（简化流程）：  ARP 请求： 主机 A（已知主机 B 的 IP 地址）希望获取主机 B 的 MAC 地址，它会构建一个 ARP 请求报文，其中包含自己的 IP 地址和 MAC 地址，以及目标主机 B 的 IP 地址。 广播： 主机 A 将这个 ARP 请求报文封装在一个以太网帧中，并将目的 MAC 地址设置为广播地址（FFFF.FFFF.FFFF），然后发送到局域网中。 接收与响应： 局域网中的所有主机都会收到这个广播帧。 每个主机都会检查 ARP 请求报文中的目标 IP 地址是否是自己的 IP 地址。 只有目标主机 B 会识别出这个 IP 地址...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E4%B8%AD%E7%9A%84%20%60RST%60%EF%BC%88Reset%EF%BC%89%E6%8A%A5%E6%96%87/" title="TCP 中的 &#96;RST&#96;（Reset）报文"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 中的 &#96;RST&#96;（Reset）报文</div></div><div class="info-2"><div class="info-item-1">TCP 中的 RST（Reset）报文是一种特殊的控制报文，它表示连接的异常终止或拒绝。与正常关闭连接的 FIN 报文不同，RST 是一种“硬”关闭，它强制终止连接，不进行正常的四次挥手过程，也不保证任何未发送或未确认的数据被可靠传递。 以下是 TCP 中出现 RST 报文的几种常见情况： 1. 端口未开放（连接被拒绝）当客户端向一个服务器的某个端口发起 TCP 连接（发送 SYN 报文），但该端口并没有任何进程在监听（即端口未开放或服务器不接受该连接），或者服务器明确拒绝接收该连接时，服务器会立即返回一个 RST 报文作为对 SYN 报文的响应。  场景： 你尝试 telnet 192.168.1.100 80，但服务器上没有 web 服务运行在 80 端口。 表现： 客户端收到 RST 后，会报告“Connection refused”之类的错误。  2. 半开连接或无效连接当一方的 TCP 连接意外关闭（例如，进程崩溃、拔掉网线、操作系统重启等），而另一方没有意识到连接已经中断，仍然尝试向此已关闭的连接发送数据时，已关闭的一方（或其操作系统）会发送一个 RST 报文，告知对...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">TCP 解决了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">TCP 连接的三个核心阶段：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B-Connection-Establishment-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-Three-Way-Handshake"><span class="toc-number">2.1.</span> <span class="toc-text">1. 连接建立 (Connection Establishment) - 三次握手 (Three-Way Handshake)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-Data-Transfer"><span class="toc-number">2.2.</span> <span class="toc-text">2. 数据传输 (Data Transfer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%9E%E6%8E%A5%E7%BB%88%E6%AD%A2-Connection-Termination-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-Four-Way-Handshake"><span class="toc-number">2.3.</span> <span class="toc-text">3. 连接终止 (Connection Termination) - 四次挥手 (Four-Way Handshake)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%AE%83%E6%98%AF%E2%80%9C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E2%80%9D%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">为什么说它是“面向连接”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">总结：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>