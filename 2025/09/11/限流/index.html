<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>限流 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="如何用 Nginx 做限流？Nginx 主要通过其核心模块 ngx_http_limit_req_module 和 ngx_http_limit_conn_module 来实现限流。  **limit_req**：限制单位时间内的请求速率（处理频率）。 **limit_conn**：限制同一时间内的并发连接数。  下面我们详细讲解如何配置和实现。 限流算法的种类和实现Nginx 主要支持基于令牌桶">
<meta property="og:type" content="article">
<meta property="og:title" content="限流">
<meta property="og:url" content="http://example.com/2025/09/11/%E9%99%90%E6%B5%81/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="如何用 Nginx 做限流？Nginx 主要通过其核心模块 ngx_http_limit_req_module 和 ngx_http_limit_conn_module 来实现限流。  **limit_req**：限制单位时间内的请求速率（处理频率）。 **limit_conn**：限制同一时间内的并发连接数。  下面我们详细讲解如何配置和实现。 限流算法的种类和实现Nginx 主要支持基于令牌桶">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:18:06.122Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "限流",
  "url": "http://example.com/2025/09/11/%E9%99%90%E6%B5%81/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:18:06.122Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/11/%E9%99%90%E6%B5%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '限流',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">限流</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">限流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:18:06.122Z" title="更新于 2025-09-11 22:18:06">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Nginx/">Nginx</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="如何用-Nginx-做限流？"><a href="#如何用-Nginx-做限流？" class="headerlink" title="如何用 Nginx 做限流？"></a>如何用 Nginx 做限流？</h3><p>Nginx 主要通过其核心模块 <code>ngx_http_limit_req_module</code> 和 <code>ngx_http_limit_conn_module</code> 来实现限流。</p>
<ul>
<li>**<code>limit_req</code>**：限制单位时间内的请求速率（处理频率）。</li>
<li>**<code>limit_conn</code>**：限制同一时间内的并发连接数。</li>
</ul>
<p>下面我们详细讲解如何配置和实现。</p>
<h3 id="限流算法的种类和实现"><a href="#限流算法的种类和实现" class="headerlink" title="限流算法的种类和实现"></a>限流算法的种类和实现</h3><p>Nginx 主要支持基于令牌桶算法（Token Bucket）的请求速率限流和基于计数器算法的并发连接数限流。</p>
<h4 id="1-基于请求速率的限流-limit-req-module-令牌桶算法"><a href="#1-基于请求速率的限流-limit-req-module-令牌桶算法" class="headerlink" title="1. 基于请求速率的限流 (limit_req_module) - 令牌桶算法"></a>1. 基于请求速率的限流 (<code>limit_req_module</code>) - 令牌桶算法</h4><p><strong>算法原理 (令牌桶):</strong></p>
<p>想象有一个固定容量的“令牌桶”，系统会以恒定的速率往桶里添加令牌。每当一个请求到来，它必须从桶里取走一个令牌才能被处理。如果桶里没有令牌，请求就会被拒绝或等待。</p>
<ul>
<li><strong>优点：</strong> 允许短时间的突发流量（即桶里积累的令牌），但长期来看会限制平均速率。</li>
<li><strong>缺点：</strong> 桶的容量决定了允许的突发流量大小，如果设置不当，可能无法有效应对极端的流量高峰。</li>
</ul>
<p><strong>Nginx 实现：</strong></p>
<p>主要通过 <code>limit_req_zone</code> 和 <code>limit_req</code> 指令实现。</p>
<p><strong>a. 定义限流区域 (<code>limit_req_zone</code>)</strong></p>
<p>在 <code>http</code> 块中配置，定义一个共享内存区域来存储限流状态。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Syntax: limit_req_zone $variable zone=name:size rate=rate [sync];</span></span><br><span class="line"><span class="comment"># context: http</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=mylimit:<span class="number">10m</span> rate=10r/s;</span><br><span class="line"><span class="comment"># $binary_remote_addr: 使用二进制形式的客户端IP地址作为键，节省内存。</span></span><br><span class="line"><span class="comment"># zone=mylimit:10m: 定义一个名为 mylimit 的共享内存区域，大小为 10MB。</span></span><br><span class="line"><span class="comment">#                  10MB 大概可以存储 16 万个 IP 地址的状态信息。</span></span><br><span class="line"><span class="comment"># rate=10r/s: 限制每个 IP 地址每秒最多 10 个请求（r/s = request per second）。</span></span><br><span class="line"><span class="comment">#             也可以是 rate=60r/m (每分钟 60 个请求)。</span></span><br></pre></td></tr></table></figure>

<p><strong>解析参数：</strong></p>
<ul>
<li><code>$binary_remote_addr</code>：这是限流的“键”。表示根据客户端的 IP 地址进行限流。你也可以使用 <code>$server_name</code>（根据域名）、<code>$request_uri</code>（根据请求URI）等变量作为键，取决于你想如何划分限流对象。使用 <code>$binary_remote_addr</code> 是非常常见的做法，因为它能有效识别不同的客户端。</li>
<li><code>zone=mylimit:10m</code>：创建一个名为 <code>mylimit</code> 的共享内存区域，大小为 <code>10MB</code>。这个区域用于存储各个客户端 IP 的请求状态信息（如上次请求时间、当前令牌数量等）。</li>
<li><code>rate=10r/s</code>：指定限流的速率。这里表示每个 IP 地址每秒最多处理 10 个请求。如果设置为 <code>10r/m</code>，则表示每分钟 10 个请求。</li>
</ul>
<p><strong>b. 应用限流策略 (<code>limit_req</code>)</strong></p>
<p>在 <code>http</code>, <code>server</code>, 或 <code>location</code> 块中应用前面定义的限流区域。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Syntax: limit_req zone=name [burst=number] [nodelay | delay=number];</span></span><br><span class="line"><span class="comment"># context: http, server, location</span></span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=mylimit burst=<span class="number">5</span> nodelay; </span><br><span class="line">        <span class="comment"># 其他 proxy_pass 或 root 配置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /api/login &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=mylimit burst=<span class="number">10</span>; <span class="comment"># 允许登录接口有更大的突发，但延迟处理</span></span><br><span class="line">        <span class="comment"># proxy_pass ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析参数：</strong></p>
<ul>
<li><code>zone=mylimit</code>：引用前面定义的限流区域。</li>
<li><code>burst=number</code>：<strong>爆发量</strong>。这个参数是令牌桶算法的关键。它定义了在达到平均速率限制之后，允许客户端额外发起的请求数量。<ul>
<li>例如，<code>rate=10r/s burst=5</code> 意味着平均每秒只处理 10 个请求。但是，如果客户端突然在极短时间内发送了 15 个请求，前 10 个会立即处理，接下来的 5 个会被放入一个队列（如果 <code>nodelay</code> 没有设置），或被立即处理（如果 <code>nodelay</code> 或 <code>delay</code> 设置为 0）。如果超过 5 个突发，多余的请求就会被拒绝（返回 503 Service Unavailable）。</li>
</ul>
</li>
<li><code>nodelay</code>：如果设置了 <code>burst</code>，且请求超出了 <code>rate</code> 限制但在 <code>burst</code> 范围内，<code>nodelay</code> 会让这些请求立即处理，而不是排队等待。这有助于处理突发流量，但如果突发量过大，后端可能因瞬时高压而崩溃。<ul>
<li><strong>推荐使用场景：</strong> 对于希望立即处理突发请求，但又不想突破总速率的场景。</li>
</ul>
</li>
<li><code>delay=number</code>：替代 <code>nodelay</code>，指定服务器将排队请求响应的延迟时间（秒数）。例如 <code>delay=1</code> 意味着如果请求被限制，将会延迟 1 秒响应，而不是直接拒绝。这可以平滑请求峰值。<ul>
<li><strong>推荐使用场景：</strong> 对于希望平滑请求峰值，避免后端瞬间压力过大的场景。</li>
<li><strong>注意：</strong> <code>burst</code> 和 <code>delay</code> 配合使用时，Nginx 只会延迟 <code>burst</code> 限制内的请求。超过 <code>burst</code> 的请求仍会被拒绝。</li>
</ul>
</li>
</ul>
<p><strong>Nginx 响应：</strong> 当请求被限流拒绝时，Nginx 默认会返回 <strong>HTTP 503 (Service Unavailable)</strong> 状态码。你也可以通过 <code>limit_req_log_level</code> 和 <code>limit_req_status</code> 指令进行自定义。</p>
<h4 id="2-基于并发连接数的限流-limit-conn-module-计数器算法"><a href="#2-基于并发连接数的限流-limit-conn-module-计数器算法" class="headerlink" title="2. 基于并发连接数的限流 (limit_conn_module) - 计数器算法"></a>2. 基于并发连接数的限流 (<code>limit_conn_module</code>) - 计数器算法</h4><p><strong>算法原理 (计数器):</strong></p>
<p>非常直接的算法。维护一个计数器，每当一个新连接到来时计数器加一，连接断开时减一。如果计数器达到预设的最大值，新的连接就会被拒绝。</p>
<ul>
<li><strong>优点：</strong> 简单高效，直接控制并发量。</li>
<li><strong>缺点：</strong> 无法平滑处理流量，达到限制后直接拒绝。如果限流的粒度过粗，可能会误伤。</li>
</ul>
<p><strong>Nginx 实现：</strong></p>
<p>主要通过 <code>limit_conn_zone</code> 和 <code>limit_conn</code> 指令实现。</p>
<p><strong>a. 定义限流区域 (<code>limit_conn_zone</code>)</strong></p>
<p>在 <code>http</code> 块中配置，定义一个共享内存区域来存储连接状态。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Syntax: limit_conn_zone $variable zone=name:size;</span></span><br><span class="line"><span class="comment"># context: http</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=conn_limit:<span class="number">10m</span>;</span><br><span class="line"><span class="comment"># $binary_remote_addr: 同样使用客户端IP作为键。</span></span><br><span class="line"><span class="comment"># zone=conn_limit:10m: 定义一个名为 conn_limit 的共享内存区域，大小为 10MB。</span></span><br></pre></td></tr></table></figure>

<p><strong>解析参数：</strong></p>
<ul>
<li><code>$binary_remote_addr</code>：基于客户端 IP 地址进行连接限流。</li>
<li><code>zone=conn_limit:10m</code>：创建一个名为 <code>conn_limit</code> 的共享内存区域，存储连接数信息。</li>
</ul>
<p><strong>b. 应用限流策略 (<code>limit_conn</code>)</strong></p>
<p>在 <code>http</code>, <code>server</code>, 或 <code>location</code> 块中应用。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Syntax: limit_conn zone=name number;</span></span><br><span class="line"><span class="comment"># context: http, server, location</span></span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_conn</span> conn_limit <span class="number">10</span>; <span class="comment"># 限制每个 IP 同时只能有 10 个并发连接</span></span><br><span class="line">        <span class="comment"># proxy_pass ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /download &#123;</span><br><span class="line">        <span class="attribute">limit_conn</span> conn_limit <span class="number">2</span>; <span class="comment"># 限制下载接口每个 IP 只能有 2 个并发连接，防止滥用下载</span></span><br><span class="line">        <span class="comment"># proxy_pass ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析参数：</strong></p>
<ul>
<li><code>zone=conn_limit</code>：引用前面定义的限流区域。</li>
<li><code>10</code>：限制每个 <code>zone</code> 键值（在此例中是每个 IP 地址）同时只能建立 10 个并发连接。</li>
</ul>
<p><strong>Nginx 响应：</strong> 当连接被限流拒绝时，Nginx 默认会返回 <strong>HTTP 503 (Service Unavailable)</strong> 状态码。</p>
<h3 id="总结和最佳实践："><a href="#总结和最佳实践：" class="headerlink" title="总结和最佳实践："></a>总结和最佳实践：</h3><ol>
<li><p><strong>区分请求速率和并发连接：</strong></p>
<ul>
<li><code>limit_req</code> 针对的是“每秒&#x2F;每分钟发起多少次请求”。</li>
<li><code>limit_conn</code> 针对的是“同时有多少个连接（会话）”。</li>
<li>两者通常结合使用，以提供更全面的保护。</li>
</ul>
</li>
<li><p><strong>合理设置 <code>burst</code> 和 <code>nodelay</code>&#x2F;<code>delay</code>：</strong></p>
<ul>
<li>对于大多数 Web 应用，<code>burst</code> 是必要的，它能允许正常的突发流量，避免误杀正常用户。</li>
<li><code>nodelay</code> 会让突发请求立即处理，后端可能会承受瞬时高负载。</li>
<li><code>delay</code> 会将突发请求排队，平滑流量尖峰，但可能会增加用户感知到的响应时间。根据应用场景权衡选择。通常在对响应时间不敏感的场景选择 <code>delay</code> 更好。</li>
</ul>
</li>
<li><p><strong>细粒度限流：</strong></p>
<ul>
<li>尽可能在 <code>location</code> 块中根据具体接口或资源路径进行限流，而不是在全局 <code>server</code> 块中一刀切。例如，登录接口、文件上传接口、API 接口等可能需要不同的限流策略。</li>
<li>可以根据 <code>$server_name</code> 对不同的虚拟主机进行限流。</li>
</ul>
</li>
<li><p><strong>IP 白名单：</strong> 对于内部系统、监控系统或某些受信任的 IP 地址，可以使用 <code>geo</code> 或 <code>map</code> 模块结合 <code>limit_req</code> 指令实现白名单，让他们不受限流影响。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 http 块中定义</span></span><br><span class="line"><span class="attribute">geo</span> <span class="variable">$white_ip</span> &#123;</span><br><span class="line">    <span class="attribute">default</span> <span class="number">1</span>; <span class="comment"># 默认所有IP都需要限流</span></span><br><span class="line">    192.168.1.0/24 0; <span class="comment"># 白名单IP，不进行限流</span></span><br><span class="line">    127.0.0.1 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=mylimit:<span class="number">10m</span> rate=10r/s;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 只有当 $white_ip 为 1 时（即不在白名单内），才应用限流</span></span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$white_ip</span> = <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="attribute">limit_req</span> zone=mylimit burst=<span class="number">5</span> nodelay;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>监控和调整：</strong> 限流参数并非一劳永逸。在实际生产环境中，需要持续监控系统的性能和流量模式，根据实际情况对限流参数进行调整和优化。Nginx 的 access log 和 error log 也会记录限流相关的信息，可以用于分析。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/%E9%99%90%E6%B5%81/">http://example.com/2025/09/11/%E9%99%90%E6%B5%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/" title="集群模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">集群模式</div></div><div class="info-2"><div class="info-item-1">集群模式对于低于每秒一百万个数据点的摄取率，建议使用单节点版本而不是集群版本。单节点版本可根据 CPU 内核、RAM 和可用存储空间的数量进行扩展。单节点版本比集群版本更容易配置和操作，所以在使用集群版本之前要三思而后行。上面我们介绍了 VM 的单节点版本的基本使用，接下来我们来介绍下如何使用集群版。 集群版主要特点：  支持单节点版本的所有功能。 性能和容量水平扩展。 支持时间序列数据的多个独立命名空间（多租户）。 支持多副本。  组件服务前面我们了解了 VM 的基本架构，对于集群模式下主要包含以下几个服务：  vmstorage：存储原始数据并返回指定标签过滤器在给定时间范围内的查询数据，当 -storageDataPath 指向的目录包含的可用空间少于 -storage.minFreeDiskSpaceBytes 时，vmstorage 节点会自动切换到只读模式，vminsert 节点也会停止向此类节点发送数据并开始将数据重新路由到剩余的 vmstorage 节点。 vminsert：接受摄取的数据并根据指标名称及其所有标签的一致性哈希将其分散存储到 vmstorage 节...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E9%98%88%E5%80%BC/" title="阈值"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">阈值</div></div><div class="info-2"><div class="info-item-1">阈值PromQL 通过提供一组过滤的二元运算符（&gt;、&lt;、== 等），允许根据其样本值过滤一组序列，这种过滤最常见的场景就是在报警规则中使用的阈值。比如我们想查找在过去 15 分钟内的 status=&quot;500&quot; 错误率大于 20% 的所有 HTTP 路径，我们在 rate 表达式后面添加一个 &gt;0.2 的过滤运算符： 1rate(demo_api_request_duration_seconds_count&#123;status=&quot;500&quot;,job=&quot;demo&quot;&#125;[15m]) &gt; 0.2    这个查询只会将错误率大于 20% 的数据过滤出来。   注意：由于在图形中的每个步长都是完全独立评估表达式的，因此根据每个步骤的过滤条件，某些比率会出现或消失（因此存在间隙）。 一般来说，二元过滤运算符在图形中并不常见，大多数在报警条件中出现，用来表示阈值。  这种过滤方式不仅适用于单个数字，PromQL 还允许你用一组时间序列过滤另一组序列。与上面的二元运算一样，比较运算符会自动应用于比较左侧和...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="消息队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">消息队列</div></div><div class="info-2"><div class="info-item-1">核心构成一个典型的消息队列系统主要由以下几部分组成：  消息（Message）： 传输的数据单元，通常是结构化的二进制数据、JSON 或 XML。 生产者（Producer）： 消息的发送方，负责创建消息并将消息发送到消息队列。 消费者（Consumer）： 消息的接收方，负责从消息队列中获取消息并进行处理。 消息队列（Queue&#x2F;Broker）： 消息存储和转发的核心组件。它接收生产者发送的消息，将消息持久化存储，并管理消息的投递和确认。大型 MQ 系统通常由一个或多个 Broker 组成集群。 主题&#x2F;队列（Topic&#x2F;Queue）： 消息的逻辑分类。 Queue（队列式）： 一条消息通常只能被一个消费者组中的一个消费者消费（点对点模式）。 Topic（主题式）： 一条消息可以被多个消费者组（订阅者）的消费者同时消费（发布&#x2F;订阅模式）。     工作原理 生产者发送消息： 生产者将业务数据（消息）封装后，发送到指定的消息队列（Broker 的某个 Topic 或 Queue）。 消息存储： 消息队列接收到消息后，将消息持久化存储起来，并根...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="网络模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">网络模型</div></div><div class="info-2"><div class="info-item-1">1. Kubernetes CNI 网络模型简介K8s 的网络模型核心要求：  Pod-to-Pod 互通：每个 Pod 都有唯一 IP，Pod 之间不需要 NAT 就能通信。 Pod-to-Service 互通：通过 Service ClusterIP 或者 kube-proxy&#x2F;ipvs 实现。 跨节点通信：不同 Node 上的 Pod 必须能直接通信。  CNI（Container Network Interface）是一套标准，K8s 通过调用不同的 CNI 插件来实现具体的网络。  2. Flannel🔹 定位：最早、最简单的 CNI，主要实现 Pod-to-Pod 的三层网络连通性。 🔹 特点：  提供 Overlay 网络（VXLAN、UDP、Host-GW 等模式）。 只管连通性，不提供 NetworkPolicy（安全策略）。 架构简单、易于部署，适合小规模或对网络安全需求不高的场景。  ✅ 优点：  部署简单，稳定成熟。 占用资源少。  ❌ 缺点：  功能单一，无安全策略支持。 性能一般（Overlay 会带来额外开销）。   3. Calico...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ingress-nginx/" title="ingress-nginx"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ingress-nginx</div></div><div class="info-2"><div class="info-item-1">ingress-nginx我们已经了解了 Ingress 资源对象只是一个路由请求描述配置文件，要让其真正生效还需要对应的 Ingress 控制器才行，Ingress 控制器有很多，这里我们先介绍使用最多的 ingress-nginx，它是基于 Nginx 的 Ingress 控制器。 运行原理ingress-nginx 控制器主要是用来组装一个 nginx.conf 的配置文件，当配置文件发生任何变动的时候就需要重新加载 Nginx 来生效，但是并不会只在影响 upstream 配置的变更后就重新加载 Nginx，控制器内部会使用一个 lua-nginx-module 来实现该功能。 我们知道 Kubernetes 控制器使用控制循环模式来检查控制器中所需的状态是否已更新或是否需要变更，所以 ingress-nginx 需要使用集群中的不同对象来构建模型，比如 Ingress、Service、Endpoints、Secret、ConfigMap 等可以生成反映集群状态的配置文件的对象，控制器需要一直 Watch 这些资源对象的变化，但是并没有办法知道特定的更改是否会影响到最终生...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Pod%20%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/" title="Pod 使用进阶"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Pod 使用进阶</div></div><div class="info-2"><div class="info-item-1">Pod 使用进阶-深入理解 Pod 对象Pod 资源配置实际上上面几个步骤就是影响一个 Pod 生命周期的大的部分，但是还有一些细节也会在 Pod 的启动过程进行设置，比如在容器启动之前还会为当前的容器设置分配的 CPU、内存等资源，我们知道我们可以通过 CGroup 来对容器的资源进行限制，同样的，在 Pod 中我们也可以直接配置某个容器的使用的 CPU 或者内存的上限。那么 Pod 是如何来使用和控制这些资源的分配的呢？ 首先对于 CPU，我们知道计算机里 CPU 的资源是按“时间片”的方式来进行分配的，系统里的每一个操作都需要 CPU 的处理，所以，哪个任务要是申请的 CPU 时间片越多，那么它得到的 CPU 资源就越多，这个很容器理解。 然后还需要了解下 CGroup 里面对于 CPU 资源的单位换算： 121 CPU =  1000 millicpu（1 Core = 1000m）0.5 CPU = 500 millicpu （0.5 Core = 500m）  这里的 m 就是毫、毫核的意思，Kubernetes 集群中的每一个节点可以通过操作系统的命令来确认本节点的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/StatefulSet/" title="StatefulSet"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">StatefulSet</div></div><div class="info-2"><div class="info-item-1">StatefulSet 控制器前面我们学习了 Deployment 和 ReplicaSet 两种资源对象得使用，在实际使用的过程中，Deployment 并不能编排所有类型的应用，对无状态服务编排是非常容易的，但是对于有状态服务就无能为力了。我们需要先明白一个概念：什么是有状态服务，什么是无状态服务。  无状态服务（Stateless Service）：该服务运行的实例不会在本地存储需要持久化的数据，并且多个实例对于同一个请求响应的结果是完全一致的，比如前面我们讲解的 WordPress 实例，我们是不是可以同时启动多个实例，但是我们访问任意一个实例得到的结果都是一样的吧？因为他唯一需要持久化的数据是存储在 MySQL 数据库中的，所以我们可以说 WordPress 这个应用是无状态服务，但是 MySQL 数据库就不是了，因为他需要把数据持久化到本地。 有状态服务（Stateful Service）：就和上面的概念是对立的了，该服务运行的实例需要在本地存储持久化数据，比如上面的 MySQL 数据库，你现在运行在节点 A，那么他的数据就存储在节点 A 上面的，如果这个时候你把该服...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B/" title="常见的消息队列模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">常见的消息队列模型</div></div><div class="info-2"><div class="info-item-1">两种主要的模型：点对点模式（Point-to-Point, PTP） 和 发布&#x2F;订阅模式（Publish&#x2F;Subscribe, Pub&#x2F;Sub），并介绍现代消息队列是如何融合它们，以及一些重要的扩展模型。  一、 点对点模式（Point-to-Point, PTP） &#x2F; 队列模型（Queue Model）1. 核心思想点对点模式基于队列（Queue）的概念。生产者将消息发送到一个特定的队列，消费者从该队列中接收消息。 2. 特点 一对一消费： 一条消息只能被一个消费者接收。当有多个消费者订阅同一个队列时，它们之间是竞争关系，消息会由这些消费者中的一个进行消费（通常是轮询、随机或其它负载均衡策略）。 消息删除： 消息一旦被消费者消费并确认（Ack），就会从队列中移除，不会再被其他消费者接收。 负载均衡： 适用于需要将任务分发给多个处理者并行处理的场景，每个任务只处理一次。 持久性： 队列通常会持久化消息，即使消费者宕机，消息也不会丢失，待消费者恢复后仍可继续消费。  3. 适用场景 异步任务处理： 例如，订单系统将创建订单的任务发送到队列，支...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8-Nginx-%E5%81%9A%E9%99%90%E6%B5%81%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">如何用 Nginx 做限流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84%E7%A7%8D%E7%B1%BB%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">限流算法的种类和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E8%AF%B7%E6%B1%82%E9%80%9F%E7%8E%87%E7%9A%84%E9%99%90%E6%B5%81-limit-req-module-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">1. 基于请求速率的限流 (limit_req_module) - 令牌桶算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%9A%84%E9%99%90%E6%B5%81-limit-conn-module-%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">2. 基于并发连接数的限流 (limit_conn_module) - 计数器算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">总结和最佳实践：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>