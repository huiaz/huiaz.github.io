<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP vs. UDP | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP 和 UDP 有什么区别？TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）都是互联网协议（IP）之上的传输层协议，它们都负责在应用程序之间传输数据。然而，它们的设计理念和提供的服务截然不同，因此适用于不同的应用场景。  \：核心区别概览   特性 TCP (传输控制协议) UDP (用">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP vs. UDP">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/TCP%20vs.%20UDP/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="TCP 和 UDP 有什么区别？TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）都是互联网协议（IP）之上的传输层协议，它们都负责在应用程序之间传输数据。然而，它们的设计理念和提供的服务截然不同，因此适用于不同的应用场景。  \：核心区别概览   特性 TCP (传输控制协议) UDP (用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:07:15.122Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP vs. UDP",
  "url": "https://huiaz.github.io/2025/09/11/TCP%20vs.%20UDP/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:07:15.122Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/TCP%20vs.%20UDP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP vs. UDP',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP vs. UDP</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP vs. UDP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:07:15.122Z" title="更新于 2025-09-11 22:07:15">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="TCP-和-UDP-有什么区别？"><a href="#TCP-和-UDP-有什么区别？" class="headerlink" title="TCP 和 UDP 有什么区别？"></a>TCP 和 UDP 有什么区别？</h3><p>TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）都是互联网协议（IP）之上的传输层协议，它们都负责在应用程序之间传输数据。然而，它们的设计理念和提供的服务截然不同，因此适用于不同的应用场景。</p>
<hr>
<h3 id="：核心区别概览"><a href="#：核心区别概览" class="headerlink" title="\：核心区别概览"></a>\：核心区别概览</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">TCP (传输控制协议)</th>
<th align="left">UDP (用户数据报协议)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可靠性</strong></td>
<td align="left"><strong>可靠</strong>：保证数据传输的完整性、顺序性，无重复、无丢失。</td>
<td align="left"><strong>不可靠</strong>：尽力而为传输，不保证数据是否到达、顺序、是否重复。</td>
</tr>
<tr>
<td align="left"><strong>连接状态</strong></td>
<td align="left"><strong>面向连接</strong>：数据传输前需进行“三次握手”建立连接，结束时需“四次挥手”断开连接。</td>
<td align="left"><strong>无连接</strong>：直接发送数据报，无需建立或断开连接。</td>
</tr>
<tr>
<td align="left"><strong>传输方式</strong></td>
<td align="left">**字节流 (Byte Stream)**：将应用数据视为一串无结构的字节流，发送时分割成段。</td>
<td align="left">**数据报 (Datagram)**：将应用数据视为独立的、带有边界的数据包。</td>
</tr>
<tr>
<td align="left"><strong>顺序性</strong></td>
<td align="left"><strong>有顺序保证</strong>：接收方会根据序列号重新排序，确保数据按发送顺序交付。</td>
<td align="left"><strong>无顺序保证</strong>：数据包可能乱序到达。</td>
</tr>
<tr>
<td align="left"><strong>错误控制</strong></td>
<td align="left"><strong>有</strong>：通过校验和、确认机制、重传机制来检测并纠正错误。</td>
<td align="left"><strong>无</strong>：只有校验和，用于检测数据损坏，但不纠正或重传。</td>
</tr>
<tr>
<td align="left"><strong>流量控制</strong></td>
<td align="left"><strong>有</strong>：通过滑动窗口机制，防止发送方数据发送过快，导致接收方缓冲区溢出。</td>
<td align="left"><strong>无</strong>：不控制发送速率。</td>
</tr>
<tr>
<td align="left"><strong>拥塞控制</strong></td>
<td align="left"><strong>有</strong>：根据网络拥堵情况动态调整发送速率，防止网络崩溃。</td>
<td align="left"><strong>无</strong>：不控制发送速率，可能加剧网络拥堵。</td>
</tr>
<tr>
<td align="left"><strong>头部开销</strong></td>
<td align="left">较大 (通常 20 字节)，因为它需要包含序列号、确认号、窗口大小等信息。</td>
<td align="left">较小 (固定 8 字节)，只包含源端口、目的端口、长度和校验和。</td>
</tr>
<tr>
<td align="left"><strong>传输速度</strong></td>
<td align="left">相对较慢，因为有大量机制保证可靠性。</td>
<td align="left">相对较快，因为开销小，无复杂的控制逻辑。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>需要高可靠性的应用</strong>：文件传输、网页浏览、电子邮件、安全通信。</td>
<td align="left"><strong>允许少量数据丢失、对实时性要求高、对延迟敏感的应用</strong>：在线音视频、游戏、DNS 查询。</td>
</tr>
<tr>
<td align="left"><strong>典型应用协议</strong></td>
<td align="left">HTTP, HTTPS, FTP, SSH, SMTP, POP3, IMAP, Telnet.</td>
<td align="left">DNS, DHCP, SNMP, RTP (多用于音视频流传输), VoIP, 在线游戏。</td>
</tr>
</tbody></table>
<hr>
<h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><h4 id="1-可靠性"><a href="#1-可靠性" class="headerlink" title="1. 可靠性"></a>1. 可靠性</h4><ul>
<li><strong>TCP：</strong> <strong>可靠</strong>。通过序列号、确认应答、超时重传、流量控制和拥塞控制等机制，TCP 保证了数据<strong>不丢失、不重复、按顺序到达</strong>。如果网络拥塞或数据包丢失，TCP 会自动处理重传，确保数据的完整性。</li>
<li><strong>UDP：</strong> <strong>不可靠</strong>。UDP 只是简单地将数据报从应用层传输到网络层，尽力而为地发送。它<strong>不保证</strong>数据报一定能到达目的地，<strong>不保证</strong>到达的顺序，也<strong>不提供</strong>任何错误重传机制。如果数据报丢失或乱序，应用程序需要自己处理。</li>
</ul>
<h4 id="2-连接状态"><a href="#2-连接状态" class="headerlink" title="2. 连接状态"></a>2. 连接状态</h4><ul>
<li><strong>TCP：</strong> <strong>面向连接</strong>。在数据传输开始之前，客户端和服务器之间必须使用著名的“三次握手”过程建立一个逻辑上的连接。数据传输完成后，需要“四次挥手”来断开连接。这种连接的建立和维护需要额外的开销。</li>
<li><strong>UDP：</strong> <strong>无连接</strong>。UDP 发送数据无需事先建立连接。每个 UDP 数据报都是一个独立的实体，直接从发送方传输到接收方，彼此之间没有关联。这减少了协议开销和延迟。</li>
</ul>
<h4 id="3-传输方式"><a href="#3-传输方式" class="headerlink" title="3. 传输方式"></a>3. 传输方式</h4><ul>
<li><strong>TCP：</strong> **字节流 (Byte Stream)**。TCP 将应用层的数据视为一个连续的字节流，并将其分割成适合网络传输的“段”（Segment）。它不保留应用层数据的消息边界。例如，如果你发送了两次 <code>write(&quot;hello&quot;); write(&quot;world&quot;);</code>，TCP 可能会将其合并为一次 <code>hello world</code> 传输。</li>
<li><strong>UDP：</strong> **数据报 (Datagram)**。UDP 保留了应用层数据的消息边界。每个 <code>sendto()</code> 调用都会发送一个独立的 UDP 数据报。例如，如果你发送了两次 <code>send(&quot;hello&quot;); send(&quot;world&quot;);</code>，接收方也会收到两个独立的数据报，一个包含 “hello”，一个包含 “world”。</li>
</ul>
<h4 id="4-头部开销"><a href="#4-头部开销" class="headerlink" title="4. 头部开销"></a>4. 头部开销</h4><ul>
<li><strong>TCP：</strong> 头部（Header）通常至少有 <strong>20 字节</strong>，还可能包含可选字段。这额外的字节用于携带序列号、确认号、窗口大小、标志位等用于实现可靠性和流控制的信息。</li>
<li><strong>UDP：</strong> 头部只有固定的 <strong>8 字节</strong>，包含源端口号、目的端口号、数据报长度和校验和。结构非常简单。</li>
</ul>
<h4 id="5-速度与性能"><a href="#5-速度与性能" class="headerlink" title="5. 速度与性能"></a>5. 速度与性能</h4><ul>
<li><strong>TCP：</strong> 由于其复杂的可靠性机制（确认、重传、流控、拥塞控制），TCP 的传输速度相对较慢，延迟也可能更高。但它确保了数据传输的完整性和正确性。</li>
<li><strong>UDP：</strong> 由于其简单的无状态、无连接特性，UDP 的传输速度通常更快，延迟更低。然而，它不保证数据的可靠性，可能会导致数据丢失或乱序。</li>
</ul>
<hr>
<h3 id="选择-TCP-还是-UDP？"><a href="#选择-TCP-还是-UDP？" class="headerlink" title="选择 TCP 还是 UDP？"></a>选择 TCP 还是 UDP？</h3><p>选择哪种协议取决于你的应用程序的需求：</p>
<ul>
<li><p><strong>选择 TCP 如果：</strong></p>
<ul>
<li><strong>数据完整性至关重要：</strong> 你不能容忍任何数据丢失或损坏（例如，文件下载、网页加载、电子邮件）。</li>
<li><strong>需要顺序交付：</strong> 数据必须以发送时的顺序到达（例如，在线支付、数据库同步）。</li>
<li><strong>对网络拥堵不敏感或需要自动处理：</strong> 你希望协议能自动调整发送速率以适应网络状况。</li>
</ul>
</li>
<li><p><strong>选择 UDP 如果：</strong></p>
<ul>
<li><strong>实时性要求高，允许少量数据丢失：</strong> 延迟是关键，偶尔丢失一些数据包可以接受（例如，实时语音通话、视频会议、在线游戏）。</li>
<li><strong>需要广播或多播：</strong> UDP 支持一对多通信。</li>
<li><strong>应用程序自己实现可靠性：</strong> 应用层可以根据需要添加自己的错误检测和纠正机制，以获得更大的灵活性。</li>
<li><strong>低开销：</strong> 对协议头部开销和连接建立&#x2F;维护的开销有严格限制时。</li>
</ul>
</li>
</ul>
<p>在实践中，许多复杂的应用程序会结合使用两种协议，例如，WebRTC（用于音视频通话）就可能使用 UDP 传输媒体流以降低延迟，而使用 TCP 来建立信令通道。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/TCP%20vs.%20UDP/">https://huiaz.github.io/2025/09/11/TCP%20vs.%20UDP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Service/" title="Service"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Service</div></div><div class="info-2"><div class="info-item-1">Service我们前面的课程中学习了一些常用控制器的基本用法，我们也了解到 Pod 的生命是有限的，死亡过后不会复活了。然后我们知道可以用 ReplicaSet 和 Deployment 来动态的创建和销毁 Pod，每个 Pod 都有自己的 IP 地址，但是如果 Pod 重建了的话那么他的 IP 很有可能也就变化了。这就会带来一个问题：比如我们有一些后端的 Pod 集合为集群中的其他应用提供 API 服务，如果我们在前端应用中把所有的这些后端的 Pod 的地址都写死，然后以某种方式去访问其中一个 Pod 的服务，这样看上去是可以工作的，对吧？但是如果这个 Pod 挂掉了，然后重新启动起来了，是不是 IP 地址非常有可能就变了，这个时候前端就极大可能访问不到后端的服务了。 遇到这样的问题该怎么解决呢？在没有使用 Kubernetes 之前，我相信可能很多同学都遇到过这样的问题，不一定是 IP 变化的问题，比如我们在部署一个 WEB 服务的时候，前端一般部署一个 Nginx 作为服务的入口，然后 Nginx 后面肯定就是挂载的这个服务的大量后端服务，很早以前我们可能是去手动更改 Ng...</div></div></div></a><a class="pagination-related" href="/2025/09/11/StatefulSet/" title="StatefulSet"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">StatefulSet</div></div><div class="info-2"><div class="info-item-1">StatefulSet 控制器前面我们学习了 Deployment 和 ReplicaSet 两种资源对象得使用，在实际使用的过程中，Deployment 并不能编排所有类型的应用，对无状态服务编排是非常容易的，但是对于有状态服务就无能为力了。我们需要先明白一个概念：什么是有状态服务，什么是无状态服务。  无状态服务（Stateless Service）：该服务运行的实例不会在本地存储需要持久化的数据，并且多个实例对于同一个请求响应的结果是完全一致的，比如前面我们讲解的 WordPress 实例，我们是不是可以同时启动多个实例，但是我们访问任意一个实例得到的结果都是一样的吧？因为他唯一需要持久化的数据是存储在 MySQL 数据库中的，所以我们可以说 WordPress 这个应用是无状态服务，但是 MySQL 数据库就不是了，因为他需要把数据持久化到本地。 有状态服务（Stateful Service）：就和上面的概念是对立的了，该服务运行的实例需要在本地存储持久化数据，比如上面的 MySQL 数据库，你现在运行在节点 A，那么他的数据就存储在节点 A 上面的，如果这个时候你把该服...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/" title="路由算法与协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">路由算法与协议</div></div><div class="info-2"><div class="info-item-1">路由协议 (Routing Protocols) 和路由选择算法 (Routing Algorithms) 是网络路由领域紧密相关但又截然不同的两个概念。理解它们之间的区别对于掌握网络路由的精髓至关重要。 路由选择算法 (Routing Algorithms)核心： 路由选择算法是决定数据包在网络中从源到目的地最佳路径的逻辑或计算过程。它关注的是“如何计算出最佳路径”。 特点：  数学模型&#x2F;逻辑： 它们是一套定义了如何根据特定度量（如跳数、延迟、带宽、成本等）来计算最优路径的数学模型或逻辑步骤。 通用性： 许多路由算法是通用的计算机科学概念，不局限于特定的网络设备或协议。 独立于实现： 算法本身只是一套理论，它不关心具体如何被实现或在哪个设备上运行。 输入： 它们通常需要网络拓扑信息（节点和链路）以及链路成本&#x2F;度量作为输入。 输出： 输出是到达网络中各个目的地的最佳路径。  常见的路由选择算法：  Dijkstra (迪克斯特拉) 算法： 经典的最短路径算法，常用于链路状态路由（如 OSPF）。它计算从单个源到所有其他节点的单源最短路径。 Bellman-Fo...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E4%B8%BA%E4%BB%80%E4%B9%88%20TCP%20%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E6%9C%89%20TIME_WAIT%20%E7%8A%B6%E6%80%81/" title="为什么 TCP 挥手需要有 TIME_WAIT 状态"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">为什么 TCP 挥手需要有 TIME_WAIT 状态</div></div><div class="info-2"><div class="info-item-1">TIME_WAIT 状态是 TCP 四次挥手过程中一个非常关键且必要的阶段，它主要位于主动关闭连接的一方。它的存在是为了解决两个核心问题： 问题一：确保四次挥手最后一个 ACK 报文可靠到达，防止服务器端重传 FIN 报文。 场景： 假设 TCP 没有 TIME_WAIT 状态，客户端（主动关闭方）发送了最后一个 ACK 后立即关闭连接，进入 CLOSED 状态。 潜在问题： 如果最后一个 ACK 在网络中丢失了，服务器端就没有收到这个 ACK。根据 TCP 的可靠性机制，服务器会认为它的 FIN 报文没有被确认，就会尝试重传 FIN 报文。 后果： 如果客户端已经立即进入 CLOSED 状态并释放了端口，而服务器重传的 FIN 报文到达时，如果客户端的该端口已经被新的连接占用（或直接拒绝接收），服务器将永远无法收到对 FIN 的确认，它会一直停留在 LAST_ACK 状态，耗尽资源并最终超时。 TIME_WAIT 状态让客户端保持一个足够长的时间（2 MSL，通常是 1-4 分钟），如果服务器重传 FIN 报文，客户端依然可以发送新的 ACK 报文作为回应，并重置 TIME_W...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81/" title="HTTP 状态码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 状态码</div></div><div class="info-2"><div class="info-item-1">HTTP 状态码HTTP 状态码是服务器对请求的响应。它们是三位数字，分为五个类别，指示请求是否已成功处理，或者是否存在错误。理解这些状态码对于调试网络问题和理解Web应用程序的行为至关重要。 以下是常见的 HTTP 状态码及其简要说明：  1xx - 信息响应 (Informational Responses)指示请求已被接收，继续处理。这些是临时响应，不带任何内容。  100 Continue: 客户端应继续其请求。通常用于客户端发送一个大型请求体到服务器之前，先发送头部，服务器如果允许，则返回 100 Continue，然后客户端再发送请求体。   2xx - 成功响应 (Successful Responses)指示请求已被成功接收、理解和接受。  200 OK: 请求已成功。这是最常见的状态码，表示请求的一切正常，服务器已返回所请求的数据。 201 Created: 请求已成功，并因此创建了一个新的资源。这通常是 PUT 或 POST 请求的响应。响应体中通常包含新创建资源的URI。 202 Accepted: 请求已被接受进行处理，但处理尚未完成。请求可能最终被执行，...</div></div></div></a><a class="pagination-related" href="/2025/09/11/CoreDNS/" title="CoreDNS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">CoreDNS</div></div><div class="info-2"><div class="info-item-1">服务发现上面我们讲解了 Service 的用法，我们可以通过 Service 生成的 ClusterIP(VIP) 来访问 Pod 提供的服务，但是在使用的时候还有一个问题：我们怎么知道某个应用的 VIP 呢？比如我们有两个应用，一个是 api 应用，一个是 db 应用，两个应用都是通过 Deployment 进行管理的，并且都通过 Service 暴露出了端口提供服务。api 需要连接到 db 这个应用，我们只知道 db 应用的名称和 db 对应的 Service 的名称，但是并不知道它的 VIP 地址，我们前面的 Service 课程中是不是学习到我们通过 ClusterIP 就可以访问到后面的 Pod 服务，如果我们知道了 VIP 的地址是不是就行了？ 环境变量为了解决上面的问题，在之前的版本中，Kubernetes 采用了环境变量的方法，每个 Pod 启动的时候，会通过环境变量设置所有服务的 IP 和 port 信息，这样 Pod 中的应用可以通过读取环境变量来获取依赖服务的地址信息，这种方法使用起来相对简单，但是有一个很大的问题就是依赖的服务必须在 Pod 启动之前就存...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/" title="TCP 的粘包和拆包"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 的粘包和拆包</div></div><div class="info-2"><div class="info-item-1">好的，我们来深入讨论 TCP 的“粘包”和“拆包”问题。这两个概念是 TCP 编程中非常基础但又极其重要的，理解它们是正确处理 TCP 数据流的关键。  1. 为什么会出现粘包和拆包？根本原因在于 TCP 是一个“面向字节流”（Byte Stream）的协议，而不是“面向消息&#x2F;数据报”（Message&#x2F;Datagram Oriented）的协议。  TCP 的特性：  缓冲区： TCP 有自己的发送缓冲区和接收缓冲区。 全双工： 数据可以双向独立传输。 可靠的、按序的、无界限的字节流： TCP 传输的只是字节序列，它不关心你在应用层发送了多少次数据，每次发送了多少字节，或者每次发送的内容之间有什么逻辑边界。   发送方： 当应用程序调用 send() 或 write() 发送数据时，数据首先被复制到 TCP 的发送缓冲区。TCP 协议栈会根据自身的拥塞控制、流量控制以及发送缓冲区的大小，决定何时、发送多少数据到网络上。它可能会：  将多次小的发送请求合并成一个大的 TCP 段发送（粘包）。 将一次大的发送请求拆分成多个小的 TCP 段发送（拆包）。 将不同应用...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP 超时重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 超时重传机制</div></div><div class="info-2"><div class="info-item-1">除了标准的 TCP 四次挥手，还有一些其他方法或特殊情况可以导致连接断开，但它们通常不如四次挥手那样优雅和受控，可能会伴随数据丢失或异常。 1. RST 报文断开连接 (Reset)RST (Reset) 报文是一种 TCP 错误或异常的指示，它会立即终止连接，不会进行标准的四次挥手过程，也不会等待任何未发送或未确认的数据。 RST 报文的常见使用场景：  连接被拒绝： 当客户端尝试连接到一个不存在的端口或一个拒绝连接的服务器端口时，服务器通常会回复一个 RST 报文，表示连接无法建立。 中止连接： 当一方决定突然中止一个连接，而不是通过正常的挥手过程关闭时，会发送 RST。这意味着不再关心对方是否已收到所有数据，也不希望进一步的通信。例如，应用程序调用 SO_LINGER 且 l_onoff 为真，l_linger 为 0 时。 检测半开连接： 如果一方的连接已经关闭（比如进程崩溃），而另一方在试图向已关闭的连接发送数据时，操作系统会检测到这个异常并回复一个 RST 报文。 端口扫描： 端口扫描工具通常会向目标端口发送 SYN 包，根据收到的响应（SYN-ACK 或 RST）来...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">TCP 和 UDP 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E6%A6%82%E8%A7%88"><span class="toc-number">2.</span> <span class="toc-text">\：核心区别概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">详细解释：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">1. 可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81"><span class="toc-number">3.2.</span> <span class="toc-text">2. 连接状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3. 传输方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%B4%E9%83%A8%E5%BC%80%E9%94%80"><span class="toc-number">3.4.</span> <span class="toc-text">4. 头部开销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%80%9F%E5%BA%A6%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="toc-number">3.5.</span> <span class="toc-text">5. 速度与性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-TCP-%E8%BF%98%E6%98%AF-UDP%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">选择 TCP 还是 UDP？</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>