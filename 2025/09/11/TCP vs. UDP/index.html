<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP vs. UDP | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP 和 UDP 有什么区别？TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）都是互联网协议（IP）之上的传输层协议，它们都负责在应用程序之间传输数据。然而，它们的设计理念和提供的服务截然不同，因此适用于不同的应用场景。  \：核心区别概览   特性 TCP (传输控制协议) UDP (用">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP vs. UDP">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/TCP%20vs.%20UDP/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="TCP 和 UDP 有什么区别？TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）都是互联网协议（IP）之上的传输层协议，它们都负责在应用程序之间传输数据。然而，它们的设计理念和提供的服务截然不同，因此适用于不同的应用场景。  \：核心区别概览   特性 TCP (传输控制协议) UDP (用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:07:15.122Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP vs. UDP",
  "url": "https://huiaz.github.io/2025/09/11/TCP%20vs.%20UDP/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:07:15.122Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/TCP%20vs.%20UDP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP vs. UDP',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP vs. UDP</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP vs. UDP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:07:15.122Z" title="更新于 2025-09-11 22:07:15">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="TCP-和-UDP-有什么区别？"><a href="#TCP-和-UDP-有什么区别？" class="headerlink" title="TCP 和 UDP 有什么区别？"></a>TCP 和 UDP 有什么区别？</h3><p>TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）都是互联网协议（IP）之上的传输层协议，它们都负责在应用程序之间传输数据。然而，它们的设计理念和提供的服务截然不同，因此适用于不同的应用场景。</p>
<hr>
<h3 id="：核心区别概览"><a href="#：核心区别概览" class="headerlink" title="\：核心区别概览"></a>\：核心区别概览</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">TCP (传输控制协议)</th>
<th align="left">UDP (用户数据报协议)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可靠性</strong></td>
<td align="left"><strong>可靠</strong>：保证数据传输的完整性、顺序性，无重复、无丢失。</td>
<td align="left"><strong>不可靠</strong>：尽力而为传输，不保证数据是否到达、顺序、是否重复。</td>
</tr>
<tr>
<td align="left"><strong>连接状态</strong></td>
<td align="left"><strong>面向连接</strong>：数据传输前需进行“三次握手”建立连接，结束时需“四次挥手”断开连接。</td>
<td align="left"><strong>无连接</strong>：直接发送数据报，无需建立或断开连接。</td>
</tr>
<tr>
<td align="left"><strong>传输方式</strong></td>
<td align="left">**字节流 (Byte Stream)**：将应用数据视为一串无结构的字节流，发送时分割成段。</td>
<td align="left">**数据报 (Datagram)**：将应用数据视为独立的、带有边界的数据包。</td>
</tr>
<tr>
<td align="left"><strong>顺序性</strong></td>
<td align="left"><strong>有顺序保证</strong>：接收方会根据序列号重新排序，确保数据按发送顺序交付。</td>
<td align="left"><strong>无顺序保证</strong>：数据包可能乱序到达。</td>
</tr>
<tr>
<td align="left"><strong>错误控制</strong></td>
<td align="left"><strong>有</strong>：通过校验和、确认机制、重传机制来检测并纠正错误。</td>
<td align="left"><strong>无</strong>：只有校验和，用于检测数据损坏，但不纠正或重传。</td>
</tr>
<tr>
<td align="left"><strong>流量控制</strong></td>
<td align="left"><strong>有</strong>：通过滑动窗口机制，防止发送方数据发送过快，导致接收方缓冲区溢出。</td>
<td align="left"><strong>无</strong>：不控制发送速率。</td>
</tr>
<tr>
<td align="left"><strong>拥塞控制</strong></td>
<td align="left"><strong>有</strong>：根据网络拥堵情况动态调整发送速率，防止网络崩溃。</td>
<td align="left"><strong>无</strong>：不控制发送速率，可能加剧网络拥堵。</td>
</tr>
<tr>
<td align="left"><strong>头部开销</strong></td>
<td align="left">较大 (通常 20 字节)，因为它需要包含序列号、确认号、窗口大小等信息。</td>
<td align="left">较小 (固定 8 字节)，只包含源端口、目的端口、长度和校验和。</td>
</tr>
<tr>
<td align="left"><strong>传输速度</strong></td>
<td align="left">相对较慢，因为有大量机制保证可靠性。</td>
<td align="left">相对较快，因为开销小，无复杂的控制逻辑。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>需要高可靠性的应用</strong>：文件传输、网页浏览、电子邮件、安全通信。</td>
<td align="left"><strong>允许少量数据丢失、对实时性要求高、对延迟敏感的应用</strong>：在线音视频、游戏、DNS 查询。</td>
</tr>
<tr>
<td align="left"><strong>典型应用协议</strong></td>
<td align="left">HTTP, HTTPS, FTP, SSH, SMTP, POP3, IMAP, Telnet.</td>
<td align="left">DNS, DHCP, SNMP, RTP (多用于音视频流传输), VoIP, 在线游戏。</td>
</tr>
</tbody></table>
<hr>
<h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><h4 id="1-可靠性"><a href="#1-可靠性" class="headerlink" title="1. 可靠性"></a>1. 可靠性</h4><ul>
<li><strong>TCP：</strong> <strong>可靠</strong>。通过序列号、确认应答、超时重传、流量控制和拥塞控制等机制，TCP 保证了数据<strong>不丢失、不重复、按顺序到达</strong>。如果网络拥塞或数据包丢失，TCP 会自动处理重传，确保数据的完整性。</li>
<li><strong>UDP：</strong> <strong>不可靠</strong>。UDP 只是简单地将数据报从应用层传输到网络层，尽力而为地发送。它<strong>不保证</strong>数据报一定能到达目的地，<strong>不保证</strong>到达的顺序，也<strong>不提供</strong>任何错误重传机制。如果数据报丢失或乱序，应用程序需要自己处理。</li>
</ul>
<h4 id="2-连接状态"><a href="#2-连接状态" class="headerlink" title="2. 连接状态"></a>2. 连接状态</h4><ul>
<li><strong>TCP：</strong> <strong>面向连接</strong>。在数据传输开始之前，客户端和服务器之间必须使用著名的“三次握手”过程建立一个逻辑上的连接。数据传输完成后，需要“四次挥手”来断开连接。这种连接的建立和维护需要额外的开销。</li>
<li><strong>UDP：</strong> <strong>无连接</strong>。UDP 发送数据无需事先建立连接。每个 UDP 数据报都是一个独立的实体，直接从发送方传输到接收方，彼此之间没有关联。这减少了协议开销和延迟。</li>
</ul>
<h4 id="3-传输方式"><a href="#3-传输方式" class="headerlink" title="3. 传输方式"></a>3. 传输方式</h4><ul>
<li><strong>TCP：</strong> **字节流 (Byte Stream)**。TCP 将应用层的数据视为一个连续的字节流，并将其分割成适合网络传输的“段”（Segment）。它不保留应用层数据的消息边界。例如，如果你发送了两次 <code>write(&quot;hello&quot;); write(&quot;world&quot;);</code>，TCP 可能会将其合并为一次 <code>hello world</code> 传输。</li>
<li><strong>UDP：</strong> **数据报 (Datagram)**。UDP 保留了应用层数据的消息边界。每个 <code>sendto()</code> 调用都会发送一个独立的 UDP 数据报。例如，如果你发送了两次 <code>send(&quot;hello&quot;); send(&quot;world&quot;);</code>，接收方也会收到两个独立的数据报，一个包含 “hello”，一个包含 “world”。</li>
</ul>
<h4 id="4-头部开销"><a href="#4-头部开销" class="headerlink" title="4. 头部开销"></a>4. 头部开销</h4><ul>
<li><strong>TCP：</strong> 头部（Header）通常至少有 <strong>20 字节</strong>，还可能包含可选字段。这额外的字节用于携带序列号、确认号、窗口大小、标志位等用于实现可靠性和流控制的信息。</li>
<li><strong>UDP：</strong> 头部只有固定的 <strong>8 字节</strong>，包含源端口号、目的端口号、数据报长度和校验和。结构非常简单。</li>
</ul>
<h4 id="5-速度与性能"><a href="#5-速度与性能" class="headerlink" title="5. 速度与性能"></a>5. 速度与性能</h4><ul>
<li><strong>TCP：</strong> 由于其复杂的可靠性机制（确认、重传、流控、拥塞控制），TCP 的传输速度相对较慢，延迟也可能更高。但它确保了数据传输的完整性和正确性。</li>
<li><strong>UDP：</strong> 由于其简单的无状态、无连接特性，UDP 的传输速度通常更快，延迟更低。然而，它不保证数据的可靠性，可能会导致数据丢失或乱序。</li>
</ul>
<hr>
<h3 id="选择-TCP-还是-UDP？"><a href="#选择-TCP-还是-UDP？" class="headerlink" title="选择 TCP 还是 UDP？"></a>选择 TCP 还是 UDP？</h3><p>选择哪种协议取决于你的应用程序的需求：</p>
<ul>
<li><p><strong>选择 TCP 如果：</strong></p>
<ul>
<li><strong>数据完整性至关重要：</strong> 你不能容忍任何数据丢失或损坏（例如，文件下载、网页加载、电子邮件）。</li>
<li><strong>需要顺序交付：</strong> 数据必须以发送时的顺序到达（例如，在线支付、数据库同步）。</li>
<li><strong>对网络拥堵不敏感或需要自动处理：</strong> 你希望协议能自动调整发送速率以适应网络状况。</li>
</ul>
</li>
<li><p><strong>选择 UDP 如果：</strong></p>
<ul>
<li><strong>实时性要求高，允许少量数据丢失：</strong> 延迟是关键，偶尔丢失一些数据包可以接受（例如，实时语音通话、视频会议、在线游戏）。</li>
<li><strong>需要广播或多播：</strong> UDP 支持一对多通信。</li>
<li><strong>应用程序自己实现可靠性：</strong> 应用层可以根据需要添加自己的错误检测和纠正机制，以获得更大的灵活性。</li>
<li><strong>低开销：</strong> 对协议头部开销和连接建立&#x2F;维护的开销有严格限制时。</li>
</ul>
</li>
</ul>
<p>在实践中，许多复杂的应用程序会结合使用两种协议，例如，WebRTC（用于音视频通话）就可能使用 UDP 传输媒体流以降低延迟，而使用 TCP 来建立信令通道。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/TCP%20vs.%20UDP/">https://huiaz.github.io/2025/09/11/TCP%20vs.%20UDP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Service/" title="Service"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Service</div></div><div class="info-2"><div class="info-item-1">Service我们前面的课程中学习了一些常用控制器的基本用法，我们也了解到 Pod 的生命是有限的，死亡过后不会复活了。然后我们知道可以用 ReplicaSet 和 Deployment 来动态的创建和销毁 Pod，每个 Pod 都有自己的 IP 地址，但是如果 Pod 重建了的话那么他的 IP 很有可能也就变化了。这就会带来一个问题：比如我们有一些后端的 Pod 集合为集群中的其他应用提供 API 服务，如果我们在前端应用中把所有的这些后端的 Pod 的地址都写死，然后以某种方式去访问其中一个 Pod 的服务，这样看上去是可以工作的，对吧？但是如果这个 Pod 挂掉了，然后重新启动起来了，是不是 IP 地址非常有可能就变了，这个时候前端就极大可能访问不到后端的服务了。 遇到这样的问题该怎么解决呢？在没有使用 Kubernetes 之前，我相信可能很多同学都遇到过这样的问题，不一定是 IP 变化的问题，比如我们在部署一个 WEB 服务的时候，前端一般部署一个 Nginx 作为服务的入口，然后 Nginx 后面肯定就是挂载的这个服务的大量后端服务，很早以前我们可能是去手动更改 Ng...</div></div></div></a><a class="pagination-related" href="/2025/09/11/StatefulSet/" title="StatefulSet"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">StatefulSet</div></div><div class="info-2"><div class="info-item-1">StatefulSet 控制器前面我们学习了 Deployment 和 ReplicaSet 两种资源对象得使用，在实际使用的过程中，Deployment 并不能编排所有类型的应用，对无状态服务编排是非常容易的，但是对于有状态服务就无能为力了。我们需要先明白一个概念：什么是有状态服务，什么是无状态服务。  无状态服务（Stateless Service）：该服务运行的实例不会在本地存储需要持久化的数据，并且多个实例对于同一个请求响应的结果是完全一致的，比如前面我们讲解的 WordPress 实例，我们是不是可以同时启动多个实例，但是我们访问任意一个实例得到的结果都是一样的吧？因为他唯一需要持久化的数据是存储在 MySQL 数据库中的，所以我们可以说 WordPress 这个应用是无状态服务，但是 MySQL 数据库就不是了，因为他需要把数据持久化到本地。 有状态服务（Stateful Service）：就和上面的概念是对立的了，该服务运行的实例需要在本地存储持久化数据，比如上面的 MySQL 数据库，你现在运行在节点 A，那么他的数据就存储在节点 A 上面的，如果这个时候你把该服...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP-四次挥手"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP-四次挥手</div></div><div class="info-2"><div class="info-item-1">TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。 假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。 四次挥手过程详解：第一次挥手：FIN 报文段（客户端 A → 服务器 B）  客户端 A (主动关闭方)：  当客户端 A 的应用层想要关闭连接时（例如调用 close() 或 shutdown()），客户端 A 的 TCP 会发送一个带有 FIN (Finish) 标志的报文段给服务器 B。 这个 FIN 报文段的序列号通常是它发送的最后一个数据字节的序列号的下一个。 发送 FIN 后，客户端 A 进入 FIN_WAIT_1 状态。这意味着客户端 A 不再发送数据，但仍然可以接收数据。  状态变化： ESTABLISHED → FIN_WAIT_1   第二次挥手：ACK 报文段（服务器 B → 客户端 A）  服务器 B (被动关闭方)：  当...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%E8%BF%9E%E6%8E%A5/" title="TCP连接"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP连接</div></div><div class="info-2"><div class="info-item-1">好的，我们来深入理解一下 TCP 连接。 TCP (Transmission Control Protocol，传输控制协议) 连接是计算机网络中一种可靠的、面向连接的、基于字节流的通信方式。它是互联网的基础协议之一，位于 OSI 模型的传输层。 要理解 TCP 连接，首先要明白它解决了哪些问题，以及它是如何解决的。  TCP 解决了什么问题？想象一下你给朋友寄包裹。如果你想确保包裹一定能送到、顺序不错乱、没有丢失、没有重复，并且能知道朋友是否收到了，这就是 TCP 试图在数据传输中实现的目标。 具体来说，TCP 针对底层的 IP (Internet Protocol，网际协议) 的局限性，提供了以下关键服务：  可靠性 (Reliability)： IP 是不可靠的，它只负责尽力而为地转发数据包，不保证数据包是否到达，也不保证顺序。TCP通过以下机制确保可靠性：  确认机制 (Acknowledgements - ACK)： 接收方收到数据后会发送确认包给发送方。 重传机制 (Retransmission)： 如果发送方在一定时间内没有收到确认包，它会认为数据包丢失，并重新发送...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP快速重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP快速重传机制</div></div><div class="info-2"><div class="info-item-1">TCP 引入快速重传（Fast Retransmit）机制，是为了弥补仅仅依靠超时重传的不足，提高网络吞吐量和链路利用率，尤其是在数据包丢失不严重但仍存在的情况下。 让我们来详细了解一下： 超时重传的不足：超时重传是 TCP 可靠性最基本的保障，但它有一个致命的弱点：等待时间过长。  重传超时时间 (RTO) 的计算： RTO 是根据网络中的往返时间 (RTT) 动态调整的，通常比 RTT 要长一些。即使网络状况良好，RTO 至少也得几十毫秒甚至几百毫秒。 等待 RTO 的代价： 吞吐量下降： 如果一个数据包丢失了，发送方必须一直等到 RTO 到期才能重传。在这漫长的等待期间，发送方可能无法发送新的数据（如果拥塞窗口和接收窗口限制），导致网络带宽得不到充分利用，吞吐量显著下降。 延迟增加： 对于实时性要求较高的应用，长时间的等待会导致明显的延迟增加。 可能触发不必要的拥塞控制： 当超时发生时，TCP 会认为发生了一次严重的丢包事件，通常会大幅度降低拥塞窗口（例如，将拥塞窗口降到 1 MSS），这会极大地限制后续的数据发送，加剧吞吐量下降，即便实际上可能只丢失了一个包。    快速...</div></div></div></a><a class="pagination-related" href="/2025/09/11/NAT/" title="NAT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">NAT</div></div><div class="info-2"><div class="info-item-1">什么是网络地址转换（NAT）？NAT (Network Address Translation)，即网络地址转换，是一种在 IP 网络中改变数据包的 IP 地址信息的技术。它的主要目的是解决 IPv4 地址枯竭的问题，同时也能提供一定程度的网络安全隔离。 简单来说，NAT 允许一个拥有私有 IP 地址的网络（如家庭网络或企业内部网络）连接到使用公共 IP 地址的外部网络（如互联网），而无需为内部的每台设备都分配一个唯一的公共 IP 地址。 核心概念：  私有 IP 地址： 在私有网络内部使用的 IP 地址，它们不能直接在公共互联网上路由。RFC 1918 定义了以下私有 IP 地址范围： 10.0.0.0 到 10.255.255.255 (10&#x2F;8) 172.16.0.0 到 172.31.255.255 (172.16&#x2F;12) 192.168.0.0 到 192.168.255.255 (192.168&#x2F;16)   公共 IP 地址： 在公共互联网上可寻址的全球唯一的 IP 地址。 NAT 设备： 通常是路由器或防火墙，负责执行 IP 地址的转换...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP 超时重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 超时重传机制</div></div><div class="info-2"><div class="info-item-1">除了标准的 TCP 四次挥手，还有一些其他方法或特殊情况可以导致连接断开，但它们通常不如四次挥手那样优雅和受控，可能会伴随数据丢失或异常。 1. RST 报文断开连接 (Reset)RST (Reset) 报文是一种 TCP 错误或异常的指示，它会立即终止连接，不会进行标准的四次挥手过程，也不会等待任何未发送或未确认的数据。 RST 报文的常见使用场景：  连接被拒绝： 当客户端尝试连接到一个不存在的端口或一个拒绝连接的服务器端口时，服务器通常会回复一个 RST 报文，表示连接无法建立。 中止连接： 当一方决定突然中止一个连接，而不是通过正常的挥手过程关闭时，会发送 RST。这意味着不再关心对方是否已收到所有数据，也不希望进一步的通信。例如，应用程序调用 SO_LINGER 且 l_onoff 为真，l_linger 为 0 时。 检测半开连接： 如果一方的连接已经关闭（比如进程崩溃），而另一方在试图向已关闭的连接发送数据时，操作系统会检测到这个异常并回复一个 RST 报文。 端口扫描： 端口扫描工具通常会向目标端口发送 SYN 包，根据收到的响应（SYN-ACK 或 RST）来...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%A7%A3%E6%9E%90%20HTTP%20%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/" title="服务端解析 HTTP 请求数据"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">服务端解析 HTTP 请求数据</div></div><div class="info-2"><div class="info-item-1">服务端解析 HTTP 请求数据是一个多步的、结构化的过程，它依赖于 HTTP 请求的严格格式定义。理解这个过程，有助于我们更好地进行网络编程和故障排查。 HTTP 请求通常由以下几个部分组成：  请求行 (Request Line) 请求头 (Request Headers) 空行 (Empty Line) 请求体 (Request Body) (可选，通常用于 POST&#x2F;PUT 请求)  服务端（通常是 Web 服务器如 Nginx, Apache, Tomcat, Node.js Express，或自定义的网络应用）在底层接收到客户端发送的原始字节流后，会按照这些部分的定义逐步解析。  服务端解析 HTTP 请求数据的步骤：步骤 1：建立 TCP 连接并接收原始字节流 底层网络通信： 客户端通过 TCP&#x2F;IP 协议向服务器的指定端口（HTTP 默认 80，HTTPS 默认 443）发起连接。 服务器监听： 服务器程序（如 Apache, Nginx 或 Node.js 应用）在这些端口上监听传入连接。 数据接收： 一旦 TCP 连接建立，服务器开始从这个连...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">TCP 和 UDP 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E6%A6%82%E8%A7%88"><span class="toc-number">2.</span> <span class="toc-text">\：核心区别概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">详细解释：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">1. 可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81"><span class="toc-number">3.2.</span> <span class="toc-text">2. 连接状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3. 传输方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%B4%E9%83%A8%E5%BC%80%E9%94%80"><span class="toc-number">3.4.</span> <span class="toc-text">4. 头部开销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%80%9F%E5%BA%A6%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="toc-number">3.5.</span> <span class="toc-text">5. 速度与性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-TCP-%E8%BF%98%E6%98%AF-UDP%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">选择 TCP 还是 UDP？</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>