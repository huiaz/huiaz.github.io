<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>docker介绍 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 什么是 Docker？从运维工程师的角度看，Docker 是一种轻量级的操作系统级虚拟化技术，它允许我们将应用程序及其所有依赖（库、配置文件、运行时环境等）打包到一个标准化的、可移植的单元中，这个单元被称为“容器”（Container）。 与传统的虚拟机（VM）相比，Docker 有本质的不同：  虚拟机 (VM)：虚拟化了一整套硬件（CPU、内存、硬盘、网卡），然后在上面运行一个完整的客户">
<meta property="og:type" content="article">
<meta property="og:title" content="docker介绍">
<meta property="og:url" content="http://example.com/2025/09/11/docker/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="1. 什么是 Docker？从运维工程师的角度看，Docker 是一种轻量级的操作系统级虚拟化技术，它允许我们将应用程序及其所有依赖（库、配置文件、运行时环境等）打包到一个标准化的、可移植的单元中，这个单元被称为“容器”（Container）。 与传统的虚拟机（VM）相比，Docker 有本质的不同：  虚拟机 (VM)：虚拟化了一整套硬件（CPU、内存、硬盘、网卡），然后在上面运行一个完整的客户">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:31:40.475Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "docker介绍",
  "url": "http://example.com/2025/09/11/docker/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:31:40.475Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/11/docker/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'docker介绍',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">docker介绍</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">docker介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:31:40.475Z" title="更新于 2025-09-11 22:31:40">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/docker/">docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="1-什么是-Docker？"><a href="#1-什么是-Docker？" class="headerlink" title="1. 什么是 Docker？"></a>1. 什么是 Docker？</h3><p>从运维工程师的角度看，<strong>Docker 是一种轻量级的操作系统级虚拟化技术，它允许我们将应用程序及其所有依赖（库、配置文件、运行时环境等）打包到一个标准化的、可移植的单元中，这个单元被称为“容器”（Container）。</strong></p>
<p>与传统的虚拟机（VM）相比，Docker 有本质的不同：</p>
<ul>
<li><strong>虚拟机 (VM)<strong>：虚拟化了一整套硬件（CPU、内存、硬盘、网卡），然后在上面运行一个完整的客户机操作系统（Guest OS），最后才在客户机操作系统里运行我们的应用。这导致它</strong>启动慢、资源占用高、隔离性强</strong>。</li>
<li><strong>Docker 容器 (Container)<strong>：直接运行在宿主机的操作系统内核之上，共享宿主机的内核。它只虚拟化了应用的运行环境（文件系统、进程、网络空间等）。这使得它</strong>启动极快（秒级甚至毫秒级）、资源占用极低、隔离性适中</strong>。</li>
</ul>
<p>简单来说，<strong>Docker 就是一个标准化的“集装箱”，无论里面装的是什么应用（Web 服务、数据库、消息队列），都可以用同样的方式来打包、运输（分发）、启动和管理，而不用关心底层服务器的环境差异。</strong></p>
<h3 id="2-为什么要在项目中用到-Docker？"><a href="#2-为什么要在项目中用到-Docker？" class="headerlink" title="2. 为什么要在项目中用到 Docker？"></a>2. 为什么要在项目中用到 Docker？</h3><p>在项目中引入 Docker，主要是为了解决一系列长期困扰开发、测试和运维的痛点。核心优势体现在以下几个方面：</p>
<ol>
<li><p><strong>环境一致性：终结“在我电脑上是好的”</strong></p>
<ul>
<li><strong>痛点</strong>：开发人员在自己的 Windows&#x2F;macOS 上开发，测试人员在测试环境的 Linux 上测试，生产环境又是另一个版本的 Linux。由于环境差异（如库版本、系统配置不同），应用经常出现意想不到的 Bug。</li>
<li><strong>Docker 解决方案</strong>：通过 <code>Dockerfile</code> 将应用和其所有依赖打包成一个镜像（Image）。这个镜像包含了完整的、固定的运行环境。无论是在开发、测试还是生产环境，都运行同一个镜像，从而确保了环境的绝对一致性。</li>
</ul>
</li>
<li><p><strong>快速部署与弹性伸缩</strong></p>
<ul>
<li><strong>痛点</strong>：传统的应用部署流程复杂且耗时，需要手动安装依赖、配置环境、启动服务。当流量高峰来临时，快速扩容新服务器是一个巨大挑战。</li>
<li><strong>Docker 解决方案</strong>：部署一个新实例，只需要一行命令 <code>docker run ...</code>。结合容器编排工具（如 Kubernetes、Docker Swarm），可以轻松实现服务的自动化、秒级弹性伸缩，从容应对流量洪峰。</li>
</ul>
</li>
<li><p><strong>资源利用率最大化</strong></p>
<ul>
<li><strong>痛点</strong>：一台物理服务器通常只运行少数几个应用，因为担心应用之间产生依赖冲突或资源抢占。这导致了大量的硬件资源闲置和浪费。</li>
<li><strong>Docker 解决方案</strong>：由于容器的轻量级特性，可以在同一台宿主机上运行数十甚至数百个相互隔离的容器。这极大地提高了服务器的资源利用率，为公司节省了大量的硬件成本。</li>
</ul>
</li>
<li><p><strong>简化运维与标准化流程</strong></p>
<ul>
<li><strong>痛点</strong>：运维需要为不同的应用（Java, Python, Node.js…）维护不同的部署和管理手册，学习成本高，操作易出错。</li>
<li><strong>Docker 解决方案</strong>：所有应用都被打包成 Docker 镜像。运维人员不再需要关心应用的内部技术细节，只需要掌握一套标准的 Docker 命令（<code>build</code>, <code>run</code>, <code>stop</code>, <code>logs</code>, <code>exec</code>）即可管理所有服务。这大大简化了运维工作，降低了人为错误的风险。</li>
</ul>
</li>
<li><p><strong>促进微服务架构</strong></p>
<ul>
<li><strong>痛点</strong>：在微服务架构中，一个系统被拆分成多个独立的服务。如果为每个服务都部署一台虚拟机，成本太高；如果部署在同一台机器上，又面临环境隔离和管理复杂性的问题。</li>
<li><strong>Docker 解决方案</strong>：Docker 是实现微服务架构的理想选择。每个微服务都可以打包成一个独立的镜像，独立部署、独立伸缩、独立升级，互不影响。</li>
</ul>
</li>
</ol>
<h3 id="3-我在项目中是如何使用-Docker-的？"><a href="#3-我在项目中是如何使用-Docker-的？" class="headerlink" title="3. 我在项目中是如何使用 Docker 的？"></a>3. 我在项目中是如何使用 Docker 的？</h3><p>在我的实际工作中，Docker 已经渗透到了从开发到生产的整个软件生命周期（CI&#x2F;CD）中。</p>
<h4 id="阶段一：开发与测试环境"><a href="#阶段一：开发与测试环境" class="headerlink" title="阶段一：开发与测试环境"></a><strong>阶段一：开发与测试环境</strong></h4><ol>
<li><p><strong>编写 <code>Dockerfile</code></strong>: 我会为项目中的每个服务（例如，<code>backend-api</code>, <code>frontend-web</code>, <code>redis-cache</code>）编写一个 <code>Dockerfile</code>。这个文件定义了如何构建该服务的镜像，包括：</p>
<ul>
<li>指定一个基础镜像（如 <code>python:3.9-slim</code> 或 <code>nginx:latest</code>）。</li>
<li>复制应用程序代码和配置文件到镜像中。</li>
<li>安装所有必要的系统和语言库（如 <code>apt-get install</code>、<code>pip install</code>）。</li>
<li>暴露服务端口（如 <code>EXPOSE 80</code>）。</li>
<li>定义容器启动时要执行的命令（<code>CMD [&quot;python&quot;, &quot;app.py&quot;]</code>）。</li>
</ul>
</li>
<li><p><strong>使用 <code>Docker Compose</code> 管理本地开发环境</strong>: 为了在本地一键启动整个应用（包含多个服务），我会编写一个 <code>docker-compose.yml</code> 文件。</p>
<ul>
<li>它定义了项目中所有的服务（<code>services</code>）、它们之间的依赖关系（<code>depends_on</code>）、网络配置（<code>networks</code>）以及数据卷挂载（<code>volumes</code>），这样代码修改可以实时同步到容器内，无需重新构建镜像。</li>
<li>开发人员只需执行 <code>docker-compose up</code>，就能在本地拉起一套与生产环境高度一致的完整开发环境。</li>
</ul>
</li>
</ol>
<h4 id="阶段二：持续集成-持续部署-CI-CD"><a href="#阶段二：持续集成-持续部署-CI-CD" class="headerlink" title="阶段二：持续集成&#x2F;持续部署 (CI&#x2F;CD)"></a><strong>阶段二：持续集成&#x2F;持续部署 (CI&#x2F;CD)</strong></h4><ol>
<li><strong>构建与推送镜像</strong>: 在 CI&#x2F;CD 流水线（如 Jenkins, GitLab CI）中，当代码被推送到 Git 仓库时，流水线会自动执行：<ul>
<li><code>docker build -t my-registry.com/my-app:git-commit-hash .</code>：使用 <code>Dockerfile</code> 构建镜像，并用 Git 的提交哈希作为标签，保证版本可追溯。</li>
<li><code>docker push my-registry.com/my-app:git-commit-hash</code>：将构建好的镜像推送到公司的私有镜像仓库（如 Harbor、AWS ECR）。</li>
</ul>
</li>
</ol>
<h4 id="阶段三：生产环境部署与运维"><a href="#阶段三：生产环境部署与运维" class="headerlink" title="阶段三：生产环境部署与运维"></a><strong>阶段三：生产环境部署与运维</strong></h4><ol>
<li><p><strong>服务部署</strong>:</p>
<ul>
<li>在生产服务器上，我们不再手动执行 <code>docker run</code>。而是使用<strong>容器编排工具</strong>，最常用的是 **Kubernetes (K8s)**。</li>
<li>我会编写 K8s 的部署文件（Deployment YAML），在其中指定要使用的镜像（就是 CI 流水线中构建的那个）、所需的副本数量、健康检查策略、资源限制（CPU&#x2F;Memory）等。</li>
<li>当需要更新服务时，我只需要修改 Deployment YAML 中的镜像标签，然后 <code>kubectl apply -f deployment.yaml</code>，K8s 会自动以滚动更新（Rolling Update）的方式平滑地升级服务，保证业务不中断。</li>
</ul>
</li>
<li><p><strong>日常运维</strong>:</p>
<ul>
<li><strong>监控</strong>：使用 Prometheus 抓取容器和应用的监控指标，用 Grafana 进行可视化展示，设置告警规则。</li>
<li><strong>日志管理</strong>：配置 Docker 的日志驱动（如 <code>json-file</code> 或 <code>fluentd</code>），将所有容器的日志统一收集到 ELK（Elasticsearch, Logstash, Kibana）或 Loki 日志系统中，方便集中查询和分析。</li>
<li><strong>故障排查</strong>：<ul>
<li><code>kubectl logs &lt;pod-name&gt;</code>: 查看容器日志。</li>
<li><code>kubectl exec -it &lt;pod-name&gt; -- /bin/bash</code>: 进入正在运行的容器内部进行调试。</li>
<li><code>kubectl describe pod &lt;pod-name&gt;</code>: 查看容器的详细状态和事件，排查启动失败等问题。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>通过这样一整套流程，Docker 实现了从开发到生产的全面贯通，极大地提升了我们团队的交付速度、系统的稳定性和运维的效率。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/docker/">http://example.com/2025/09/11/docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/go%20map%20key%20%E6%97%A0%E5%BA%8F/" title="go map key 无序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">go map key 无序</div></div><div class="info-2"><div class="info-item-1">您好。这个问题揭示了 Go 语言设计中一个非常重要的权衡：性能与特性之间的选择。Go 语言的 map key 是无序的，这并非一个疏忽或缺陷，而是一个经过深思熟虑的设计决策。 作为后端开发专家，我将从三个层面为您深入剖析这个问题：数据结构的基础、Go 语言的特定设计以及实际开发的应对策略。  1. 核心原因：底层数据结构是哈希表 (Hash Table)Go 语言的 map 是基于哈希表实现的。哈希表是计算机科学中一种极其高效的数据结构，它的核心工作原理如下：  哈希函数 (Hash Function): 当你向 map 中插入一个键值对 (key-value) 时，系统会首先对 key 应用一个哈希函数，生成一个哈希值（一个整数）。 定位桶 (Bucket): 系统使用这个哈希值来计算出一个索引，这个索引指向一个内部数组，数组的每个元素被称为“桶 (bucket)”。 存储数据: 键值对就存储在定位到的那个桶里。如果多个不同的 key 经过哈希计算后定位到了同一个桶（这被称为“哈希冲突”），它们会以链表或其他形式共同存储在这个桶中。  关键点在于： 哈希函数的设计目标是让键尽可...</div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-swarm/" title="docker-swarm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">docker-swarm</div></div><div class="info-2"><div class="info-item-1">————– | :———————————————– || 集群管理       | 将多台机器整合成单一资源池，简化管理。           || 声明式服务     | 从命令式操作转变为期望状态管理，更可靠、自动化。 || 伸缩与负载均衡 | 轻松应对流量变化，实现服务高可用。               || 服务发现       | 解耦服务间的依赖，容器间通信无需硬编码 IP。      || 自我修复       | 自动处理节点或容器故障，提升系统韧性。           || 滚动更新       | 实现平滑、零停机的应用升级。                     | 总而言之，Docker Swarm 是一个轻量级但功能完备的容器编排器。对于中小型集群或希望快速上手容器编排的团队来说，它是一个非常优秀的选择，能够极大地提升部署效率和系统的可靠性。 </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%9E%8B/" title="消息队列推拉模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">消息队列推拉模型</div></div><div class="info-2"><div class="info-item-1">您好！在消息队列的设计中，采用“推消息（Push）”还是“拉消息（Pull）”模式是核心考量之一，每种模式都有其独特的优缺点和适用场景。理解这些差异对于我们选择或设计合适的MQ系统至关重要。  一、 推消息模式（Push Mode &#x2F; Server Push）1. 核心思想Broker（消息队列服务器）主动将消息推送给消费者（Consumer）。一旦有新消息到达，Broker会立即将消息发送给订阅了该消息的消费者。 2. 工作原理Broker维护与消费者的TCP连接，当消息写入Broker后，Broker会检查哪些消费者订阅了该消息，然后将消息数据包通过网络主动发送给这些消费者。 3. 优点 实时性高 &#x2F; 低延迟： 消息一到达Broker，就能立即被消费者接收和处理，响应速度快。 简化消费者逻辑： 消费者只需要启动一个监听器或注册一个回调函数来接收消息，处理逻辑相对简单，无需主动发起请求。 适合高实时性、小并发场景： 例如即时通讯、在线通知等对消息延迟有严格要求的业务。 快速失败反馈： Broker能更快感知到消费者连接中断或处理异常，便于进行消息重投或错误处...</div></div></div></a><a class="pagination-related" href="/2025/09/11/POD%20Pending/" title="POD Pending"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">POD Pending</div></div><div class="info-2"><div class="info-item-1">彻底搞懂 K8S Pod Pending 故障原因及解决方案即使在高成熟度级别 Kubernetes 集群中 pod pending 也是无处不在。 如果您随机询问任何使用 Kubernetes DevOps 工程师来确定折磨他们噩梦的最常见错误，pod pending 可能是非常常见的问题（可能仅次于 CrashLoopBackOff）。 尝试推送更新并看到它卡住会使 DevOps 紧张。即使解决方案相当简单，找到 pod 挂起的原因并了解您需要应用的更改也很重要（Kubernetes 故障排除很少是微不足道的）。  在本文中，我们将阐明导致此问题的不同情况，让 DevOps 团队能够快速找到解决方案，最重要的是，尽可能避免它。 Kubernetes Pod pending 是什么意思？Kubernetes 中的 Pod 的生命周期由几个不同的阶段组成：  创建 pod 时，它从Pending阶段开始。 一旦 pod 被调度并且容器已经启动，pod 就会进入Running阶段。  大多数 pod 只需要几秒钟就可以从 Pending 到 Running 并在该状态下度过大部分时...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20iostat/" title="Linux iostat"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux iostat</div></div><div class="info-2"><div class="info-item-1">iostat 是 Linux sysstat 工具集中的一个命令，主要用于 CPU 使用情况 和 磁盘 I&#x2F;O 统计。 它通常用来排查 磁盘性能瓶颈 或 CPU 负载问题。  一、基本语法1iostat [选项] [间隔] [次数]   间隔：两次采样之间的秒数 次数：采样次数 如果不加参数，只显示一次从系统启动以来的平均统计   二、常用选项 **-c**：只显示 CPU 统计信息 **-d**：只显示磁盘设备统计信息 **-x**：显示扩展统计信息（更详细的磁盘指标） **-p [设备]**：显示指定设备的分区统计 **-k &#x2F; -m**：以 KB&#x2F;s 或 MB&#x2F;s 显示数据传输速率 **-N**：显示 LVM 的统计信息 **-t**：显示时间戳   三、示例 查看所有 CPU 和磁盘的 I&#x2F;O 统计  1iostat   每隔 2 秒更新一次 CPU 和磁盘统计，显示 5 次  1iostat 2 5   只看 CPU 使用率  1iostat -c 1 3   只看磁盘 I&#x2F;O  1iostat -d 1 3 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E4%B8%AD%E7%9A%84%20%60RST%60%EF%BC%88Reset%EF%BC%89%E6%8A%A5%E6%96%87/" title="TCP 中的 &#96;RST&#96;（Reset）报文"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 中的 &#96;RST&#96;（Reset）报文</div></div><div class="info-2"><div class="info-item-1">TCP 中的 RST（Reset）报文是一种特殊的控制报文，它表示连接的异常终止或拒绝。与正常关闭连接的 FIN 报文不同，RST 是一种“硬”关闭，它强制终止连接，不进行正常的四次挥手过程，也不保证任何未发送或未确认的数据被可靠传递。 以下是 TCP 中出现 RST 报文的几种常见情况： 1. 端口未开放（连接被拒绝）当客户端向一个服务器的某个端口发起 TCP 连接（发送 SYN 报文），但该端口并没有任何进程在监听（即端口未开放或服务器不接受该连接），或者服务器明确拒绝接收该连接时，服务器会立即返回一个 RST 报文作为对 SYN 报文的响应。  场景： 你尝试 telnet 192.168.1.100 80，但服务器上没有 web 服务运行在 80 端口。 表现： 客户端收到 RST 后，会报告“Connection refused”之类的错误。  2. 半开连接或无效连接当一方的 TCP 连接意外关闭（例如，进程崩溃、拔掉网线、操作系统重启等），而另一方没有意识到连接已经中断，仍然尝试向此已关闭的连接发送数据时，已关闭的一方（或其操作系统）会发送一个 RST 报文，告知对...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Cookie%E3%80%81Session%20%E5%92%8C%20Token%20/" title="Cookie、Session 和 Token"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Cookie、Session 和 Token</div></div><div class="info-2"><div class="info-item-1">Cookie、Session 和 Token 都是在 Web 开发中用于管理用户状态、实现身份认证和授权的关键机制，但它们在存储位置、工作原理、安全性、无状态性等方面存在显著差异。 1. Cookie 定义： Cookie 是存储在用户浏览器（客户端） 的一小段文本信息。 作用： 会话管理： 记录用户的登录状态、购物车内容等。 个性化设置： 记住用户的偏好（如语言、主题）。 追踪： 记录用户行为，用于数据分析和广告推送。   工作原理： 当用户第一次访问服务器时，服务器在响应头中包含 Set-Cookie 字段，将 Cookie 发送给浏览器。 浏览器接收到 Cookie 后，将其存储起来。 之后，浏览器每次向同一个域发送请求时，都会在请求头中自动带上该域相关的所有 Cookie。 服务器接收到请求后，从 Cookie 中读取信息。   特点： 存储位置： 客户端（浏览器）。 由谁管理： 浏览器自动发送，服务器设置。 安全性： 易受 CSRF 攻击： 因为浏览器会自动发送 Cookie，攻击者可能利用这一点伪造请求。 易受 XSS 攻击： 如果未设置 HttpOnly 标志，JS...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" title="负载均衡"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">负载均衡</div></div><div class="info-2"><div class="info-item-1">什么是负载均衡（Load Balancing）？在 Web 服务器环境中，负载均衡是一种将网络请求（流量）有效地分发到多个服务器（通常称为后端服务器或上游服务器）上的技术。其核心目标是：  提高系统可用性： 当某台后端服务器出现故障时，负载均衡器可以将流量自动路由到健康的服务器，避免服务中断。 提高系统性能： 通过将请求分散到多台服务器上，可以避免单台服务器过载，缩短响应时间，提高处理能力。 提高系统可伸缩性： 随着业务增长，可以通过简单地增加后端服务器来扩展系统的处理能力，而无需升级单台服务器。 优化资源利用： 确保所有后端服务器都能得到合理的利用，而不是某些服务器空闲而另一些过载。  简单来说，负载均衡器就像一个交通指挥官，它接收到客户端的请求后，不会让请求直接去某一台具体的服务器，而是根据预设的算法和规则，将其导向当前最合适（或下一个）的后端服务器去处理，并将处理结果返回给客户端。 负载均衡的常见算法负载均衡器会根据不同的算法来决定将请求分发给哪台后端服务器。Nginx 支持多种算法：  轮询 (Round Robin)： 原理： 默认算法。请求按时间顺序依次分发到后端服务...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-Docker%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. 什么是 Docker？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0-Docker%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2. 为什么要在项目中用到 Docker？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%88%91%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Docker-%E7%9A%84%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3. 我在项目中是如何使用 Docker 的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E5%BC%80%E5%8F%91%E4%B8%8E%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="toc-number">3.1.</span> <span class="toc-text">阶段一：开发与测试环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2-CI-CD"><span class="toc-number">3.2.</span> <span class="toc-text">阶段二：持续集成&#x2F;持续部署 (CI&#x2F;CD)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%BF%90%E7%BB%B4"><span class="toc-number">3.3.</span> <span class="toc-text">阶段三：生产环境部署与运维</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>