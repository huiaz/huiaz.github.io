<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>docker介绍 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 什么是 Docker？从运维工程师的角度看，Docker 是一种轻量级的操作系统级虚拟化技术，它允许我们将应用程序及其所有依赖（库、配置文件、运行时环境等）打包到一个标准化的、可移植的单元中，这个单元被称为“容器”（Container）。 与传统的虚拟机（VM）相比，Docker 有本质的不同：  虚拟机 (VM)：虚拟化了一整套硬件（CPU、内存、硬盘、网卡），然后在上面运行一个完整的客户">
<meta property="og:type" content="article">
<meta property="og:title" content="docker介绍">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/docker/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="1. 什么是 Docker？从运维工程师的角度看，Docker 是一种轻量级的操作系统级虚拟化技术，它允许我们将应用程序及其所有依赖（库、配置文件、运行时环境等）打包到一个标准化的、可移植的单元中，这个单元被称为“容器”（Container）。 与传统的虚拟机（VM）相比，Docker 有本质的不同：  虚拟机 (VM)：虚拟化了一整套硬件（CPU、内存、硬盘、网卡），然后在上面运行一个完整的客户">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:31:40.475Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "docker介绍",
  "url": "https://huiaz.github.io/2025/09/11/docker/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:31:40.475Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/docker/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'docker介绍',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">docker介绍</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">docker介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:31:40.475Z" title="更新于 2025-09-11 22:31:40">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/docker/">docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="1-什么是-Docker？"><a href="#1-什么是-Docker？" class="headerlink" title="1. 什么是 Docker？"></a>1. 什么是 Docker？</h3><p>从运维工程师的角度看，<strong>Docker 是一种轻量级的操作系统级虚拟化技术，它允许我们将应用程序及其所有依赖（库、配置文件、运行时环境等）打包到一个标准化的、可移植的单元中，这个单元被称为“容器”（Container）。</strong></p>
<p>与传统的虚拟机（VM）相比，Docker 有本质的不同：</p>
<ul>
<li><strong>虚拟机 (VM)<strong>：虚拟化了一整套硬件（CPU、内存、硬盘、网卡），然后在上面运行一个完整的客户机操作系统（Guest OS），最后才在客户机操作系统里运行我们的应用。这导致它</strong>启动慢、资源占用高、隔离性强</strong>。</li>
<li><strong>Docker 容器 (Container)<strong>：直接运行在宿主机的操作系统内核之上，共享宿主机的内核。它只虚拟化了应用的运行环境（文件系统、进程、网络空间等）。这使得它</strong>启动极快（秒级甚至毫秒级）、资源占用极低、隔离性适中</strong>。</li>
</ul>
<p>简单来说，<strong>Docker 就是一个标准化的“集装箱”，无论里面装的是什么应用（Web 服务、数据库、消息队列），都可以用同样的方式来打包、运输（分发）、启动和管理，而不用关心底层服务器的环境差异。</strong></p>
<h3 id="2-为什么要在项目中用到-Docker？"><a href="#2-为什么要在项目中用到-Docker？" class="headerlink" title="2. 为什么要在项目中用到 Docker？"></a>2. 为什么要在项目中用到 Docker？</h3><p>在项目中引入 Docker，主要是为了解决一系列长期困扰开发、测试和运维的痛点。核心优势体现在以下几个方面：</p>
<ol>
<li><p><strong>环境一致性：终结“在我电脑上是好的”</strong></p>
<ul>
<li><strong>痛点</strong>：开发人员在自己的 Windows&#x2F;macOS 上开发，测试人员在测试环境的 Linux 上测试，生产环境又是另一个版本的 Linux。由于环境差异（如库版本、系统配置不同），应用经常出现意想不到的 Bug。</li>
<li><strong>Docker 解决方案</strong>：通过 <code>Dockerfile</code> 将应用和其所有依赖打包成一个镜像（Image）。这个镜像包含了完整的、固定的运行环境。无论是在开发、测试还是生产环境，都运行同一个镜像，从而确保了环境的绝对一致性。</li>
</ul>
</li>
<li><p><strong>快速部署与弹性伸缩</strong></p>
<ul>
<li><strong>痛点</strong>：传统的应用部署流程复杂且耗时，需要手动安装依赖、配置环境、启动服务。当流量高峰来临时，快速扩容新服务器是一个巨大挑战。</li>
<li><strong>Docker 解决方案</strong>：部署一个新实例，只需要一行命令 <code>docker run ...</code>。结合容器编排工具（如 Kubernetes、Docker Swarm），可以轻松实现服务的自动化、秒级弹性伸缩，从容应对流量洪峰。</li>
</ul>
</li>
<li><p><strong>资源利用率最大化</strong></p>
<ul>
<li><strong>痛点</strong>：一台物理服务器通常只运行少数几个应用，因为担心应用之间产生依赖冲突或资源抢占。这导致了大量的硬件资源闲置和浪费。</li>
<li><strong>Docker 解决方案</strong>：由于容器的轻量级特性，可以在同一台宿主机上运行数十甚至数百个相互隔离的容器。这极大地提高了服务器的资源利用率，为公司节省了大量的硬件成本。</li>
</ul>
</li>
<li><p><strong>简化运维与标准化流程</strong></p>
<ul>
<li><strong>痛点</strong>：运维需要为不同的应用（Java, Python, Node.js…）维护不同的部署和管理手册，学习成本高，操作易出错。</li>
<li><strong>Docker 解决方案</strong>：所有应用都被打包成 Docker 镜像。运维人员不再需要关心应用的内部技术细节，只需要掌握一套标准的 Docker 命令（<code>build</code>, <code>run</code>, <code>stop</code>, <code>logs</code>, <code>exec</code>）即可管理所有服务。这大大简化了运维工作，降低了人为错误的风险。</li>
</ul>
</li>
<li><p><strong>促进微服务架构</strong></p>
<ul>
<li><strong>痛点</strong>：在微服务架构中，一个系统被拆分成多个独立的服务。如果为每个服务都部署一台虚拟机，成本太高；如果部署在同一台机器上，又面临环境隔离和管理复杂性的问题。</li>
<li><strong>Docker 解决方案</strong>：Docker 是实现微服务架构的理想选择。每个微服务都可以打包成一个独立的镜像，独立部署、独立伸缩、独立升级，互不影响。</li>
</ul>
</li>
</ol>
<h3 id="3-我在项目中是如何使用-Docker-的？"><a href="#3-我在项目中是如何使用-Docker-的？" class="headerlink" title="3. 我在项目中是如何使用 Docker 的？"></a>3. 我在项目中是如何使用 Docker 的？</h3><p>在我的实际工作中，Docker 已经渗透到了从开发到生产的整个软件生命周期（CI&#x2F;CD）中。</p>
<h4 id="阶段一：开发与测试环境"><a href="#阶段一：开发与测试环境" class="headerlink" title="阶段一：开发与测试环境"></a><strong>阶段一：开发与测试环境</strong></h4><ol>
<li><p><strong>编写 <code>Dockerfile</code></strong>: 我会为项目中的每个服务（例如，<code>backend-api</code>, <code>frontend-web</code>, <code>redis-cache</code>）编写一个 <code>Dockerfile</code>。这个文件定义了如何构建该服务的镜像，包括：</p>
<ul>
<li>指定一个基础镜像（如 <code>python:3.9-slim</code> 或 <code>nginx:latest</code>）。</li>
<li>复制应用程序代码和配置文件到镜像中。</li>
<li>安装所有必要的系统和语言库（如 <code>apt-get install</code>、<code>pip install</code>）。</li>
<li>暴露服务端口（如 <code>EXPOSE 80</code>）。</li>
<li>定义容器启动时要执行的命令（<code>CMD [&quot;python&quot;, &quot;app.py&quot;]</code>）。</li>
</ul>
</li>
<li><p><strong>使用 <code>Docker Compose</code> 管理本地开发环境</strong>: 为了在本地一键启动整个应用（包含多个服务），我会编写一个 <code>docker-compose.yml</code> 文件。</p>
<ul>
<li>它定义了项目中所有的服务（<code>services</code>）、它们之间的依赖关系（<code>depends_on</code>）、网络配置（<code>networks</code>）以及数据卷挂载（<code>volumes</code>），这样代码修改可以实时同步到容器内，无需重新构建镜像。</li>
<li>开发人员只需执行 <code>docker-compose up</code>，就能在本地拉起一套与生产环境高度一致的完整开发环境。</li>
</ul>
</li>
</ol>
<h4 id="阶段二：持续集成-持续部署-CI-CD"><a href="#阶段二：持续集成-持续部署-CI-CD" class="headerlink" title="阶段二：持续集成&#x2F;持续部署 (CI&#x2F;CD)"></a><strong>阶段二：持续集成&#x2F;持续部署 (CI&#x2F;CD)</strong></h4><ol>
<li><strong>构建与推送镜像</strong>: 在 CI&#x2F;CD 流水线（如 Jenkins, GitLab CI）中，当代码被推送到 Git 仓库时，流水线会自动执行：<ul>
<li><code>docker build -t my-registry.com/my-app:git-commit-hash .</code>：使用 <code>Dockerfile</code> 构建镜像，并用 Git 的提交哈希作为标签，保证版本可追溯。</li>
<li><code>docker push my-registry.com/my-app:git-commit-hash</code>：将构建好的镜像推送到公司的私有镜像仓库（如 Harbor、AWS ECR）。</li>
</ul>
</li>
</ol>
<h4 id="阶段三：生产环境部署与运维"><a href="#阶段三：生产环境部署与运维" class="headerlink" title="阶段三：生产环境部署与运维"></a><strong>阶段三：生产环境部署与运维</strong></h4><ol>
<li><p><strong>服务部署</strong>:</p>
<ul>
<li>在生产服务器上，我们不再手动执行 <code>docker run</code>。而是使用<strong>容器编排工具</strong>，最常用的是 **Kubernetes (K8s)**。</li>
<li>我会编写 K8s 的部署文件（Deployment YAML），在其中指定要使用的镜像（就是 CI 流水线中构建的那个）、所需的副本数量、健康检查策略、资源限制（CPU&#x2F;Memory）等。</li>
<li>当需要更新服务时，我只需要修改 Deployment YAML 中的镜像标签，然后 <code>kubectl apply -f deployment.yaml</code>，K8s 会自动以滚动更新（Rolling Update）的方式平滑地升级服务，保证业务不中断。</li>
</ul>
</li>
<li><p><strong>日常运维</strong>:</p>
<ul>
<li><strong>监控</strong>：使用 Prometheus 抓取容器和应用的监控指标，用 Grafana 进行可视化展示，设置告警规则。</li>
<li><strong>日志管理</strong>：配置 Docker 的日志驱动（如 <code>json-file</code> 或 <code>fluentd</code>），将所有容器的日志统一收集到 ELK（Elasticsearch, Logstash, Kibana）或 Loki 日志系统中，方便集中查询和分析。</li>
<li><strong>故障排查</strong>：<ul>
<li><code>kubectl logs &lt;pod-name&gt;</code>: 查看容器日志。</li>
<li><code>kubectl exec -it &lt;pod-name&gt; -- /bin/bash</code>: 进入正在运行的容器内部进行调试。</li>
<li><code>kubectl describe pod &lt;pod-name&gt;</code>: 查看容器的详细状态和事件，排查启动失败等问题。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>通过这样一整套流程，Docker 实现了从开发到生产的全面贯通，极大地提升了我们团队的交付速度、系统的稳定性和运维的效率。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/docker/">https://huiaz.github.io/2025/09/11/docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/go%20map%20key%20%E6%97%A0%E5%BA%8F/" title="go map key 无序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">go map key 无序</div></div><div class="info-2"><div class="info-item-1">您好。这个问题揭示了 Go 语言设计中一个非常重要的权衡：性能与特性之间的选择。Go 语言的 map key 是无序的，这并非一个疏忽或缺陷，而是一个经过深思熟虑的设计决策。 作为后端开发专家，我将从三个层面为您深入剖析这个问题：数据结构的基础、Go 语言的特定设计以及实际开发的应对策略。  1. 核心原因：底层数据结构是哈希表 (Hash Table)Go 语言的 map 是基于哈希表实现的。哈希表是计算机科学中一种极其高效的数据结构，它的核心工作原理如下：  哈希函数 (Hash Function): 当你向 map 中插入一个键值对 (key-value) 时，系统会首先对 key 应用一个哈希函数，生成一个哈希值（一个整数）。 定位桶 (Bucket): 系统使用这个哈希值来计算出一个索引，这个索引指向一个内部数组，数组的每个元素被称为“桶 (bucket)”。 存储数据: 键值对就存储在定位到的那个桶里。如果多个不同的 key 经过哈希计算后定位到了同一个桶（这被称为“哈希冲突”），它们会以链表或其他形式共同存储在这个桶中。  关键点在于： 哈希函数的设计目标是让键尽可...</div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-swarm/" title="docker-swarm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">docker-swarm</div></div><div class="info-2"><div class="info-item-1">————– | :———————————————– || 集群管理       | 将多台机器整合成单一资源池，简化管理。           || 声明式服务     | 从命令式操作转变为期望状态管理，更可靠、自动化。 || 伸缩与负载均衡 | 轻松应对流量变化，实现服务高可用。               || 服务发现       | 解耦服务间的依赖，容器间通信无需硬编码 IP。      || 自我修复       | 自动处理节点或容器故障，提升系统韧性。           || 滚动更新       | 实现平滑、零停机的应用升级。                     | 总而言之，Docker Swarm 是一个轻量级但功能完备的容器编排器。对于中小型集群或希望快速上手容器编排的团队来说，它是一个非常优秀的选择，能够极大地提升部署效率和系统的可靠性。 </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/n9e/" title="n9e"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">n9e</div></div><div class="info-2"><div class="info-item-1">123n9e_v87vfwNNFsGPAYcheujZUy    1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980version: &quot;3.7&quot;services:  mysql:    image: &quot;mysql:8&quot;    container_name: mysql    hostname: mysql    restart: always    environment:      TZ: Asia/Shanghai      MYSQL_ROOT_PASSWORD: 1234    volumes:      - ./mysqldata:/var/lib/mysql/      - ../initsql:/docker-entrypoint-initdb.d/      - ./etc-m...</div></div></div></a><a class="pagination-related" href="/2025/09/11/CoreDNS/" title="CoreDNS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">CoreDNS</div></div><div class="info-2"><div class="info-item-1">服务发现上面我们讲解了 Service 的用法，我们可以通过 Service 生成的 ClusterIP(VIP) 来访问 Pod 提供的服务，但是在使用的时候还有一个问题：我们怎么知道某个应用的 VIP 呢？比如我们有两个应用，一个是 api 应用，一个是 db 应用，两个应用都是通过 Deployment 进行管理的，并且都通过 Service 暴露出了端口提供服务。api 需要连接到 db 这个应用，我们只知道 db 应用的名称和 db 对应的 Service 的名称，但是并不知道它的 VIP 地址，我们前面的 Service 课程中是不是学习到我们通过 ClusterIP 就可以访问到后面的 Pod 服务，如果我们知道了 VIP 的地址是不是就行了？ 环境变量为了解决上面的问题，在之前的版本中，Kubernetes 采用了环境变量的方法，每个 Pod 启动的时候，会通过环境变量设置所有服务的 IP 和 port 信息，这样 Pod 中的应用可以通过读取环境变量来获取依赖服务的地址信息，这种方法使用起来相对简单，但是有一个很大的问题就是依赖的服务必须在 Pod 启动之前就存...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%202.0%20%E5%92%8C%203.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" title="HTTP 2.0 和 3.0 有什么区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 2.0 和 3.0 有什么区别</div></div><div class="info-2"><div class="info-item-1">HTTP 2.0 和 3.0 有什么区别？HTTP 2.0 和 HTTP 3.0 在核心传输协议、解决的问题以及它们所针对的应用场景上存在革命性的差异。HTTP 3.0 不仅仅是 HTTP 2.0 的简单升级，它是一个范式转变，因为它彻底抛弃了 TCP，转而使用 UDP 作为其底层传输协议。 HTTP 2.0 (基于 TCP 的增强)  底层协议： 基于 TCP（传输控制协议）。 主要目标： 解决 HTTP 1.x 的队头阻塞（Head-of-Line Blocking）问题以及效率低下。 主要特性（回顾）： 多路复用 (Multiplexing)： 在单个 TCP 连接上同时发送和接收多个独立的请求和响应流。这解决了应用层的队头阻塞。 头部压缩 (HPACK)： 减少请求和响应头部的大小。 服务器推送 (Server Push)： 服务器主动将客户端可能需要的资源推送到客户端。 二进制分帧： 数据以二进制格式传输，提高解析效率。    HTTP 3.0 (基于 UDP&#x2F;QUIC 的革命)  底层协议： 基于 UDP（用户数据报协议）之上的 QUIC (Quick UD...</div></div></div></a><a class="pagination-related" href="/2025/09/11/python-%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD/" title="python-增量备份"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">python-增量备份</div></div><div class="info-2"><div class="info-item-1">Python 实现的、生产级别的文件增量备份脚本。这个方案的核心是基于文件大小（偏移量）进行追踪，这对于 append-only（只追加写入）的文件（如日志）来说是最高效的。 核心机制 状态追踪文件（State File）: 我们需要一个地方记录上次备份到了源文件的哪个位置。最简单可靠的方法就是创建一个与备份文件关联的状态文件（例如 my_app.log.state），里面只存一个数字：上次备份完成时源文件的字节大小（offset）。 备份逻辑: 首次运行: 状态文件不存在。脚本会从头（偏移量 0）开始，完整备份整个源文件，然后将源文件的当前大小写入状态文件。 后续运行: 脚本首先读取状态文件，获取上次备份的偏移量 last_offset。 然后获取源文件当前的实际大小 current_size。 情况 A (文件增长): 如果 current_size &gt; last_offset，说明有新内容。脚本会打开源文件，将文件指针移动（seek）到 last_offset，然后读取从该位置到文件末尾的所有新数据，并将其追加（append）到备份文件中。成功后，更新状态文件为 cu...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP快速重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP快速重传机制</div></div><div class="info-2"><div class="info-item-1">TCP 引入快速重传（Fast Retransmit）机制，是为了弥补仅仅依靠超时重传的不足，提高网络吞吐量和链路利用率，尤其是在数据包丢失不严重但仍存在的情况下。 让我们来详细了解一下： 超时重传的不足：超时重传是 TCP 可靠性最基本的保障，但它有一个致命的弱点：等待时间过长。  重传超时时间 (RTO) 的计算： RTO 是根据网络中的往返时间 (RTT) 动态调整的，通常比 RTT 要长一些。即使网络状况良好，RTO 至少也得几十毫秒甚至几百毫秒。 等待 RTO 的代价： 吞吐量下降： 如果一个数据包丢失了，发送方必须一直等到 RTO 到期才能重传。在这漫长的等待期间，发送方可能无法发送新的数据（如果拥塞窗口和接收窗口限制），导致网络带宽得不到充分利用，吞吐量显著下降。 延迟增加： 对于实时性要求较高的应用，长时间的等待会导致明显的延迟增加。 可能触发不必要的拥塞控制： 当超时发生时，TCP 会认为发生了一次严重的丢包事件，通常会大幅度降低拥塞窗口（例如，将拥塞窗口降到 1 MSS），这会极大地限制后续的数据发送，加剧吞吐量下降，即便实际上可能只丢失了一个包。    快速...</div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-volume/" title="docker-volume"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">docker-volume</div></div><div class="info-2"><div class="info-item-1">———— | :———————————– | :———————————– || 管理方       | Docker 引擎                          | 用户&#x2F;宿主机                          || 宿主机位置   | Docker 管理的特定目录                | 用户指定的任意路径                   || 可移植性     | 高，不依赖宿主机路径             | 低，依赖宿主机特定路径           || 安全性       | 高，与宿主机文件系统隔离         | 较低，容器可修改宿主机文件       || 推荐使用场景 | 生产环境、数据库、应用数据持久化 | 开发环境、共享配置文件、代码同步 | 作为运维工程师，我的核心建议是：  **首选命名数据卷 (Named Volumes)**：为所有生产数据的持久化使用命名数据卷，因为它们清晰、易于管理且安全。 谨慎使用绑定挂载：仅在开发、调试或需要明确操作宿主机文件的受控场景下使用。在生产环境中要严格审查...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-Docker%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. 什么是 Docker？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0-Docker%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2. 为什么要在项目中用到 Docker？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%88%91%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Docker-%E7%9A%84%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3. 我在项目中是如何使用 Docker 的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E5%BC%80%E5%8F%91%E4%B8%8E%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="toc-number">3.1.</span> <span class="toc-text">阶段一：开发与测试环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2-CI-CD"><span class="toc-number">3.2.</span> <span class="toc-text">阶段二：持续集成&#x2F;持续部署 (CI&#x2F;CD)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%BF%90%E7%BB%B4"><span class="toc-number">3.3.</span> <span class="toc-text">阶段三：生产环境部署与运维</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>