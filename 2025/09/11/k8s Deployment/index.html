<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>k8s Deployment | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Kubernetes 中的 Deployment 和 StatefulSet 有什么区别？🤔 分析过程：该问题旨在考察对Kubernetes中两种核心工作负载控制器（Workload Controllers）的理解和区分能力。一个优秀的回答不仅要罗列出功能上的差异，更要阐明这两种控制器在设计哲学上的根本不同，即它们分别是为了解决无状态应用（Stateless）和有状态应用（Stateful）这两">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s Deployment">
<meta property="og:url" content="http://example.com/2025/09/11/k8s%20Deployment/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="Kubernetes 中的 Deployment 和 StatefulSet 有什么区别？🤔 分析过程：该问题旨在考察对Kubernetes中两种核心工作负载控制器（Workload Controllers）的理解和区分能力。一个优秀的回答不仅要罗列出功能上的差异，更要阐明这两种控制器在设计哲学上的根本不同，即它们分别是为了解决无状态应用（Stateless）和有状态应用（Stateful）这两">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:43:26.349Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "k8s Deployment",
  "url": "http://example.com/2025/09/11/k8s%20Deployment/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:43:26.349Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/11/k8s%20Deployment/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'k8s Deployment',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">k8s Deployment</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">k8s Deployment</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:43:26.349Z" title="更新于 2025-09-11 21:43:26">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="Kubernetes-中的-Deployment-和-StatefulSet-有什么区别？"><a href="#Kubernetes-中的-Deployment-和-StatefulSet-有什么区别？" class="headerlink" title="Kubernetes 中的 Deployment 和 StatefulSet 有什么区别？"></a>Kubernetes 中的 Deployment 和 StatefulSet 有什么区别？</h3><h3 id="🤔-分析过程："><a href="#🤔-分析过程：" class="headerlink" title="🤔 分析过程："></a>🤔 分析过程：</h3><p>该问题旨在考察对Kubernetes中两种核心工作负载控制器（Workload Controllers）的理解和区分能力。一个优秀的回答不仅要罗列出功能上的差异，更要阐明这两种控制器在设计哲学上的根本不同，即它们分别是为了解决<strong>无状态应用（Stateless）</strong>和<strong>有状态应用（Stateful）</strong>这两大类问题的。本回答将通过一个清晰的对比表格来突出核心区别，并结合应用场景和选型指南，帮助面试者建立深刻的理解。</p>
<h3 id="💡-答案生成："><a href="#💡-答案生成：" class="headerlink" title="💡 答案生成："></a>💡 答案生成：</h3><h4 id="1-核心概念定义"><a href="#1-核心概念定义" class="headerlink" title="1. 核心概念定义"></a>1. 核心概念定义</h4><ul>
<li><p><strong>Deployment:</strong> 是Kubernetes中用于管理<strong>无状态应用</strong>的控制器。它确保指定数量的、完全相同的Pod副本（Replicas）处于运行状态。这些Pod是<strong>可互换的（Interchangeable&#x2F;Fungible）</strong>，可以被随意地创建和销毁，而不会影响应用的整体状态。</p>
</li>
<li><p><strong>StatefulSet:</strong> 是用于管理<strong>有状态应用</strong>的控制器。它为每个Pod提供<strong>唯一的、稳定的身份标识</strong>，并保证Pod的部署、伸缩和更新是有序的。这些Pod不是可互换的，它们各自拥有需要持久化的状态。</p>
</li>
</ul>
<p>这是云计算中经典的<strong>“Cattle vs. Pets”</strong>（牛群 vs. 宠物）比喻的体现：</p>
<ul>
<li><strong>Deployments管理的是“牛群（Cattle）”：</strong> 所有牛都一样，一只生病了，就用另一只健康的替换掉，无需在意它是哪一只。</li>
<li><strong>StatefulSets管理的是“宠物（Pets）”：</strong> 每只宠物都有自己的名字和独特性格。如果“小猫咪-0”生病了，你需要治好它，或者用一只新的、但同样叫做“小猫咪-0”的宠物来替换它，并确保它能找回自己原来的猫窝（存储）。</li>
</ul>
<hr>
<h4 id="2-核心区别对比"><a href="#2-核心区别对比" class="headerlink" title="2. 核心区别对比"></a>2. 核心区别对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Deployment (用于无状态应用)</th>
<th align="left">StatefulSet (用于有状态应用)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Pod 身份</strong></td>
<td align="left"><strong>动态且随机</strong>。Pod名称是随机生成的（如<code>myapp-deploy-7d5f...</code>），Pod被销毁后，新创建的Pod会有全新的名字和身份。</td>
<td align="left"><strong>稳定且唯一</strong>。Pod名称是可预测且有序的（如<code>db-0</code>, <code>db-1</code>, <code>db-2</code>）。Pod被销毁后，新创建的Pod会继承相同的名字和身份。</td>
</tr>
<tr>
<td align="left"><strong>网络标识</strong></td>
<td align="left"><strong>不唯一</strong>。Pod IP地址是临时的。通常通过一个ClusterIP Service来暴露一组Pod，客户端只与Service通信，不关心具体是哪个Pod。</td>
<td align="left"><strong>稳定且唯一</strong>。通过<strong>Headless Service</strong>，每个Pod都会获得一个<strong>稳定的、唯一的DNS记录</strong>（如 <code>db-0.my-headless-service.default.svc.cluster.local</code>）。这使得其他应用可以精确地寻址到特定的Pod。</td>
</tr>
<tr>
<td align="left"><strong>存储 (PVC)</strong></td>
<td align="left">Pod通常共享同一个PersistentVolumeClaim (PVC)，或者使用临时存储。当Pod被替换时，新的Pod不会自动挂载旧Pod的存储卷。</td>
<td align="left">每个Pod副本都会获得一个<strong>与之绑定的、唯一的PVC</strong>。例如，<code>db-0</code>会绑定到<code>data-db-0</code>这个PVC。即使<code>db-0</code>被重建，新的<code>db-0</code>也会重新挂载回<code>data-db-0</code>，从而<strong>保持了数据的持久化和状态的连续性</strong>。</td>
</tr>
<tr>
<td align="left"><strong>伸缩与更新</strong></td>
<td align="left"><strong>并行且无序</strong>。默认情况下，可以同时创建或销毁多个Pod以快速响应扩缩容。滚动更新也是无序的，只要保证可用Pod数量即可。</td>
<td align="left"><strong>有序且逐个进行</strong>。无论是部署、扩容还是更新，都严格按照Pod的序号进行。例如，扩容时必须先创建好<code>db-0</code>并使其Ready，然后才能创建<code>db-1</code>。缩容时则相反（从<code>db-N</code>开始）。这对于需要有序启动和关闭的集群应用（如数据库主从同步）至关重要。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h4><ul>
<li><p><strong>Deployment 的理想场景:</strong></p>
<ul>
<li>Web服务器（Nginx, Apache）</li>
<li>API网关、无状态的微服务</li>
<li>缓存服务（如果状态可以丢失或重建）</li>
<li>任何可以轻松进行水平扩展且实例之间无需区分彼此的应用。</li>
</ul>
</li>
<li><p><strong>StatefulSet 的理想场景:</strong></p>
<ul>
<li><strong>数据库集群:</strong> MySQL&#x2F;PostgreSQL (主从复制), MongoDB (副本集), Cassandra, CockroachDB。</li>
<li><strong>消息队列:</strong> Kafka, RabbitMQ。</li>
<li><strong>分布式文件系统:</strong> GlusterFS, Ceph。</li>
<li>任何需要稳定网络标识、持久化存储和有序部署的应用。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-何时选择-选型指南"><a href="#4-何时选择-选型指南" class="headerlink" title="4. 何时选择 (选型指南)"></a>4. 何时选择 (选型指南)</h4><p>在选择使用哪种控制器时，可以问自己以下几个问题：</p>
<ol>
<li><strong>应用实例是否需要唯一的身份？</strong> 如果是的，选择 <strong>StatefulSet</strong>。</li>
<li><strong>应用是否需要稳定的、可预测的网络地址？</strong> 如果是的，选择 <strong>StatefulSet</strong>。</li>
<li><strong>应用是否需要为每个实例绑定一个独有的、持久化的存储卷？</strong> 如果是的，选择 <strong>StatefulSet</strong>。</li>
<li><strong>应用的启动、关闭或更新是否有严格的顺序要求？</strong> 如果是的，选择 <strong>StatefulSet</strong>。</li>
<li>如果以上问题的答案都是“否”，那么 <strong>Deployment</strong> 通常是更简单、更合适的选择。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/k8s%20Deployment/">http://example.com/2025/09/11/k8s%20Deployment/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/k8s%20Logs/" title="k8s Logs"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">k8s Logs</div></div><div class="info-2"><div class="info-item-1">描述在 Kubernetes 中如何进行日志管理，并解释常用的方法。 Of course. Log management is a cornerstone of observability in any production system, and Kubernetes presents unique challenges and solutions. This is a great question to assess a candidate’s operational maturity. 🤔 分析过程：该问题旨在考察对Kubernetes中日志生命周期和集中式日志解决方案的理解。一个全面的回答需要首先解释为什么基础的kubectl logs命令在生产环境中不足够，从而引出集中式日志管理的需求。接着，需要清晰地描述最主流的实现架构（节点级日志代理），并能解释其工作流程。提及Sidecar模式作为补充方案，以及介绍市面上流行的工具栈（如EFK、PLG），可以充分展现面试者在该领域的知识广度和深度。 💡 答案生成：1. 概念或定义Kubernetes日志管理是指一套系统性的方法...</div></div></div></a><a class="pagination-related" href="/2025/09/11/jenkins-k8s/" title="jenkins-k8s"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">jenkins-k8s</div></div><div class="info-2"><div class="info-item-1">Jenkins 与 Kubernetes 集成的核心价值 弹性伸缩的构建环境： Jenkins 可以根据构建需求动态创建 Kubernetes Pod 作为 Jenkins Agent，构建完成后自动销毁，节省资源。 构建环境隔离与一致性： 每个构建都在独立的、预定义的 Pod 中运行，确保环境的纯净和一致性，避免“污染”和冲突。 资源利用率最大化： Kubernetes 负责调度 Agent Pod 到可用节点，优化集群资源利用。 云原生部署： 将应用程序打包成 Docker 镜像后，通过 Jenkins Pipeline 直接部署到 Kubernetes 集群。 自动化且可靠的部署： 利用 Kubernetes 的原生部署（Deployment）、服务发现（Service）、配置管理（ConfigMap&#x2F;Secret）等能力，实现声明式、不可变的基础设施部署。 可观测性与回滚： 结合 Kubernetes 的滚动更新和回滚机制，Jenkins Pipeline 可以轻松实现零停机部署和快速回滚。  Jenkins 与 Kubernetes 集成方式Jenkins 与...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Admission%20webhooks/" title="Admission webhooks"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Admission webhooks</div></div><div class="info-2"><div class="info-item-1">准入控制器Kubernetes 提供了需要扩展其内置功能的方法，最常用的可能是自定义资源类型和自定义控制器了，除此之外，Kubernetes 还有一些其他非常有趣的功能，比如 admission webhooks 就可以用于扩展 API，用于修改某些 Kubernetes 资源的基本行为。 准入控制器是在对象持久化之前用于对 Kubernetes API Server 的请求进行拦截的代码段，在请求经过身份验证和授权之后放行通过。准入控制器可能正在 validating、mutating 或者都在执行，Mutating 控制器可以修改他们处理的资源对象，Validating 控制器不会，如果任何一个阶段中的任何控制器拒绝了请求，则会立即拒绝整个请求，并将错误返回给最终的用户。 这意味着有一些特殊的控制器可以拦截 Kubernetes API 请求，并根据自定义的逻辑修改或者拒绝它们。Kubernetes 有自己实现的一个控制器列表：https://kubernetes.io/docs/reference/access-authn-authz/admission-controlle...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Pod%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="Pod 生命周期"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Pod 生命周期</div></div><div class="info-2"><div class="info-item-1">Pod 生命周期 前面我们已经了解了 Pod 的设计原理，接下来我们来了解下 Pod 的生命周期。下图展示了一个 Pod 的完整生命周期过程，其中包含 Init Container、Pod Hook、健康检查 三个主要部分，接下来我们就来分别介绍影响 Pod 生命周期的部分： 首先在介绍 Pod 的生命周期之前，我们先了解下 Pod 的状态，因为 Pod 状态可以反应出当前我们的 Pod 的具体状态信息，也是我们分析排错的一个必备的方式。 Pod 状态首先先了解下 Pod 的状态值，我们可以通过 kubectl explain pod.status 命令来了解关于 Pod 状态的一些信息，Pod 的状态定义在 PodStatus 对象中，其中有一个 phase 字段，下面是 phase 的可能取值：  挂起（Pending）：Pod 信息已经提交给了集群，但是还没有被调度器调度到合适的节点或者 Pod 里的镜像正在下载 运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态 成功（Succee...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7/" title="容器监控"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">容器监控</div></div><div class="info-2"><div class="info-item-1">容器监控说到容器监控我们自然会想到 cAdvisor，我们前面也说过 cAdvisor 已经内置在了 kubelet 组件之中，所以我们不需要单独去安装，cAdvisor 的数据路径为 /api/v1/nodes/&lt;node&gt;/proxy/metrics，但是我们不推荐使用这种方式，因为这种方式是通过 APIServer 去代理访问的，对于大规模的集群会对 APIServer 造成很大的压力，所以我们可以直接通过访问 kubelet 的 /metrics/cadvisor 这个端点来获取 cAdvisor 的数据。 cAdvisor我们这里使用 node 的服务发现模式，因为每一个节点下面都有 kubelet，自然都有 cAdvisor 采集到的数据指标，配置如下： 12345678910111213141516171819- job_name: &#x27;cadvisor&#x27;  kubernetes_sd_configs:    - role: node  scheme: https  tls_config:    ca_file: /var/run/se...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" title="基于文件的服务发现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">基于文件的服务发现</div></div><div class="info-2"><div class="info-item-1">基于文件的服务发现除了基于 Consul 的服务发现之外，Prometheus 也允许我们进行自定义的发现集成，可以通过 watch 一组本地文件来获取抓取目标以及标签信息，也就是我们常说的基于文件的服务发现方式。  基于文件的服务发现提供了一种更通用的方式来配置静态目标，并作为一个接口插入自定义服务发现机制。 它读取一组包含零个或多个 &lt;static_config&gt; 列表的文件，对所有定义的文件的变更通过磁盘监视被检测到并立即应用，文件可以以 YAML 或 JSON 格式提供。文件必须包含一个静态配置的列表: 123JSON json [ &#123; &quot;targets&quot;: [ &quot;&lt;host&gt;&quot;, ... ], &quot;labels&quot;: &#123; &quot;&lt;labelname&gt;&quot;: &quot;&lt;labelvalue&gt;&quot;, ... &#125; &#125;, ... ]YAML yaml - targets: [ - &#x27;&lt;host&...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Thanos%20Compactor/" title="Thanos Compactor"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Thanos Compactor</div></div><div class="info-2"><div class="info-item-1">Compactor 组件现在历史监控数据已经上传到对象存储中去了，但是由于监控数据量非常庞大，所以一般情况下我们会去安装一个 Thanos 的 Compactor 组件，用来将对象存储中的数据进行压缩。Compactor 组件只与对象存储交互，是唯一拥有删除对象存储数据权限的组件，主要有两个作用：压缩 block（将多个 block 合并成一个）、降采样（可禁用，5m&#x2F;1h 采样数据）。可设置数据保留时长，原始数据、5m&#x2F;1h 降采样数据可分别设置保留时长。 下采样Compactor 用于定时对远端对象存储中的历史数据块进行下采样，Compactor 会将小的存储块合并为大的存储块，提升在做大时间跨度查询时的速度。 下采样有三个主要的配置参数：  --retention.resolution-raw（单位：d，默认 0d） --retention.resolution-5m（单位：d，默认 0d） --retention.resolution-1h（单位：d，默认 0d）  当开启 raw 之后，原有的历史数据会以该项所配置的时间长度保留于远端对象存储中，超过...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Deployment/" title="Deployment"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Deployment</div></div><div class="info-2"><div class="info-item-1">Deployment 控制器前面我们学习了 ReplicaSet 控制器，了解到该控制器是用来维护集群中运行的 Pod 数量的，但是往往在实际操作的时候，我们反而不会去直接使用 RS，而是会使用更上层的控制器，比如我们今天要学习的主角 Deployment，Deployment 一个非常重要的功能就是实现了 Pod 的滚动更新，比如我们应用更新了，我们只需要更新我们的容器镜像，然后修改 Deployment 里面的 Pod 模板镜像，那么 Deployment 就会用滚动更新（Rolling Update）的方式来升级现在的 Pod，这个能力是非常重要的，因为对于线上的服务我们需要做到不中断服务，所以滚动更新就成了必须的一个功能。而 Deployment 这个能力的实现，依赖的就是上节课我们学习的 ReplicaSet 这个资源对象，实际上我们可以通俗的理解就是每个 Deployment 就对应集群中的一次部署，这样就更好理解了。 Deployment 概述Deployment 资源对象的格式和 ReplicaSet 几乎一致，如下资源对象就是一个常见的 Deployment 资...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes-%E4%B8%AD%E7%9A%84-Deployment-%E5%92%8C-StatefulSet-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">Kubernetes 中的 Deployment 和 StatefulSet 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%94-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">🤔 分析过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E7%AD%94%E6%A1%88%E7%94%9F%E6%88%90%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">💡 答案生成：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">1. 核心概念定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94"><span class="toc-number">3.2.</span> <span class="toc-text">2. 核心区别对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.</span> <span class="toc-text">3. 应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%95%E6%97%B6%E9%80%89%E6%8B%A9-%E9%80%89%E5%9E%8B%E6%8C%87%E5%8D%97"><span class="toc-number">3.4.</span> <span class="toc-text">4. 何时选择 (选型指南)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>