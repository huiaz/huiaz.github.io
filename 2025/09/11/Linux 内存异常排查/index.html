<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 内存异常排查 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、什么是 Linux 系统中的内存泄漏？简单来说，内存泄漏（Memory Leak） 指的是程序在运行过程中，动态地申请了内存空间（例如 C 语言的 malloc() 或 Java 的 new），但在使用完毕后，没有按预期释放（或无法被垃圾回收器回收）。 结果是，这部分内存既不能被当前程序再次使用，也无法被操作系统回收分配给其他程序。从操作系统的视角看，这块内存一直被该程序“合法”地占用着。随着">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内存异常排查">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="一、什么是 Linux 系统中的内存泄漏？简单来说，内存泄漏（Memory Leak） 指的是程序在运行过程中，动态地申请了内存空间（例如 C 语言的 malloc() 或 Java 的 new），但在使用完毕后，没有按预期释放（或无法被垃圾回收器回收）。 结果是，这部分内存既不能被当前程序再次使用，也无法被操作系统回收分配给其他程序。从操作系统的视角看，这块内存一直被该程序“合法”地占用着。随着">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:46:51.576Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 内存异常排查",
  "url": "https://huiaz.github.io/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:46:51.576Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 内存异常排查',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 内存异常排查</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux 内存异常排查</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:46:51.576Z" title="更新于 2025-09-11 21:46:51">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/Command/">Command</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="一、什么是-Linux-系统中的内存泄漏？"><a href="#一、什么是-Linux-系统中的内存泄漏？" class="headerlink" title="一、什么是 Linux 系统中的内存泄漏？"></a>一、什么是 Linux 系统中的内存泄漏？</h3><p>简单来说，<strong>内存泄漏（Memory Leak）</strong> 指的是程序在运行过程中，动态地申请了内存空间（例如 C 语言的 <code>malloc()</code> 或 Java 的 <code>new</code>），但在使用完毕后，没有按预期释放（或无法被垃圾回收器回收）。</p>
<p>结果是，这部分内存既不能被当前程序再次使用，也无法被操作系统回收分配给其他程序。从操作系统的视角看，这块内存一直被该程序“合法”地占用着。随着时间的推移，泄漏的内存积少成多，最终会耗尽系统的可用物理内存和交换空间（Swap）。</p>
<p><strong>一个常见的误解：</strong><br>很多时候，新手会把 Linux 的<strong>文件系统缓存（Cache）</strong>误认为是内存泄漏。Linux 内核会尽可能地利用空闲内存来缓存磁盘读写数据，以提高性能。在 <code>free -h</code> 命令中，这部分内存会显示在 <code>buff/cache</code> 列。这是正常且有益的行为，当应用程序需要更多内存时，内核会自动收缩这部分缓存来满足需求。</p>
<p><strong>真正的内存泄漏迹象是 <code>available</code>（可用内存）持续、不可逆地减少，而不是 <code>free</code>（空闲内存）的减少。</strong></p>
<h3 id="二、内存泄漏的典型症状"><a href="#二、内存泄漏的典型症状" class="headerlink" title="二、内存泄漏的典型症状"></a>二、内存泄漏的典型症状</h3><p>作为运维，我们通常不是直接看到代码，而是通过以下系统现象来感知到内存泄漏的存在：</p>
<ol>
<li><strong>系统性能逐渐下降：</strong> 服务器运行一段时间后（几天、几周甚至几个月），响应越来越慢，处理请求的延迟越来越高。</li>
<li><strong>可用内存持续减少：</strong> 通过监控工具（如 Prometheus + Grafana, Zabbix）观察，服务器的可用内存曲线呈现出一种缓慢、稳定下降的趋势，即使在业务低谷期也无法恢复。</li>
<li><strong>Swap 使用量增加：</strong> 当物理内存耗尽时，系统开始频繁使用交换空间（Swap），导致磁盘 I&#x2F;O 飙升，系统性能急剧恶化。</li>
<li><strong>OOM Killer 介入：</strong> 当物理内存和交换空间都耗尽时，Linux 内核的 <strong>OOM Killer (Out-of-Memory Killer)</strong> 机制会被触发，它会选择一个进程（通常是占用内存最多的那个）并将其“杀死”（kill），以释放内存，保障系统至少能继续运行。你可以在系统日志中看到 OOM Killer 的“作案记录”。<ul>
<li><strong>检查命令：</strong> <code>dmesg | grep -i &quot;out of memory&quot;</code> 或检查 <code>/var/log/messages</code>、<code>/var/log/syslog</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、内存泄漏的排查方法和工具"><a href="#三、内存泄漏的排查方法和工具" class="headerlink" title="三、内存泄漏的排查方法和工具"></a>三、内存泄漏的排查方法和工具</h3><p>排查内存泄漏遵循一个从宏观到微观的“漏斗模型”：<strong>系统层面 -&gt; 进程层面 -&gt; 代码层面</strong>。</p>
<h4 id="步骤-1：确认是否存在泄漏并定位系统"><a href="#步骤-1：确认是否存在泄漏并定位系统" class="headerlink" title="步骤 1：确认是否存在泄漏并定位系统"></a><strong>步骤 1：确认是否存在泄漏并定位系统</strong></h4><ul>
<li><strong>工具：</strong> <code>free</code>, <code>vmstat</code>, <code>sar</code>, 以及监控系统（如 Prometheus）。</li>
<li><strong>方法：</strong><ol>
<li><strong>长期观察：</strong> 查看监控系统中服务器的<strong>可用内存 (Available Memory)</strong> 历史图表。如果它呈现出随时间推移稳步下降且从不完全恢复的“下坡”趋势，就高度怀疑是内存泄漏。</li>
<li><strong>实时检查：</strong> 使用 <code>free -h</code> 命令，持续关注 <code>available</code> 列的变化。同时，使用 <code>vmstat 1</code> 可以每秒输出一行系统状态，观察 <code>swpd</code> (交换区使用) 和 <code>si</code>, <code>so</code> (换入换出) 列，如果这些值持续很高，说明内存压力巨大。</li>
</ol>
</li>
</ul>
<h4 id="步骤-2：定位具体的泄漏进程"><a href="#步骤-2：定位具体的泄漏进程" class="headerlink" title="步骤 2：定位具体的泄漏进程"></a><strong>步骤 2：定位具体的泄漏进程</strong></h4><p>一旦确认系统存在内存泄漏，下一步就是找出是哪个进程干的。</p>
<ul>
<li><strong>工具：</strong> <code>top</code>, <code>htop</code>, <code>ps</code>。</li>
<li><strong>方法：</strong><ol>
<li><strong><code>top</code> 或 <code>htop</code>：</strong> 在命令行中运行 <code>top</code>，然后按 <code>M</code> (大写) 或 <code>htop</code> 中按 <code>F6</code> 选择 <code>PERCENT_MEM</code>，将进程按内存使用率排序。</li>
<li><strong>观察：</strong> 长期观察列表，哪个进程的 <code>%MEM</code> (内存使用百分比) 和 <code>RES</code> (Resident Memory, 物理内存占用) 在持续、缓慢地增长，那个进程就是最大的嫌疑犯。</li>
<li><strong>静态快照：</strong> 使用 <code>ps aux --sort=-%mem | head -n 10</code> 可以列出当前内存使用最高的前几个进程，适合做成脚本定时记录。</li>
</ol>
</li>
</ul>
<h4 id="步骤-3：深入分析嫌疑进程-关键步骤"><a href="#步骤-3：深入分析嫌疑进程-关键步骤" class="headerlink" title="步骤 3：深入分析嫌疑进程 (关键步骤)"></a><strong>步骤 3：深入分析嫌疑进程 (关键步骤)</strong></h4><p>定位到具体进程后，需要使用更专业的工具来分析其内部的内存分配情况。这通常需要根据进程的开发语言来选择合适的工具。</p>
<ul>
<li><p><strong>对于 C&#x2F;C++ 等编译型语言程序：</strong></p>
<ul>
<li><strong><code>valgrind (memcheck)</code>：</strong><ul>
<li><strong>描述：</strong> 这是最强大的内存调试工具，可以精确报告每一处内存泄漏发生的位置（代码行）。</li>
<li><strong>用法：</strong> <code>valgrind --leak-check=full ./your_program</code>。</li>
<li><strong>缺点：</strong> 它会使程序运行速度降低 10-50 倍，<strong>不适用于生产环境</strong>，通常在开发或测试环境中使用。</li>
</ul>
</li>
<li><strong><code>pmap</code>：</strong><ul>
<li><strong>描述：</strong> 显示一个进程的内存映射。</li>
<li><strong>用法：</strong> <code>pmap -x &lt;PID&gt;</code>。通过定时对同一个进程执行 <code>pmap</code> 并对输出进行 <code>diff</code>，可以发现是哪些内存地址段在持续增长。这能提供一些线索。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对于 Java 程序 (JVM)：</strong></p>
<ul>
<li><strong><code>jmap</code>：</strong><ul>
<li><strong>描述：</strong> JVM 自带的内存映像工具，非常实用。</li>
<li><strong>用法：</strong><ol>
<li><strong>查看堆中对象统计信息：</strong> <code>jmap -histo:live &lt;PID&gt; | head -n 20</code>。这个命令会触发一次 Full GC，然后打印出当前存活对象的直方图。定时执行并 <code>diff</code> 两次的结果，可以清晰地看到哪种类型的对象数量在不断增加。这是<strong>生产环境中最常用的快速定位方法</strong>。</li>
<li><strong>生成堆转储快照 (Heap Dump)：</strong> <code>jmap -dump:live,format=b,file=heap.bin &lt;PID&gt;</code>。这个命令会生成一个完整的堆快照文件。</li>
</ol>
</li>
</ul>
</li>
<li><strong><code>jstat</code>：</strong><ul>
<li><strong>描述：</strong> 监控 JVM 的垃圾回收(GC)活动。</li>
<li><strong>用法：</strong> <code>jstat -gcutil &lt;PID&gt; 1000</code>。观察 <code>E</code> (Eden), <code>S0</code>, <code>S1</code> (Survivor), <code>O</code> (Old Gen) 的使用率和 <code>YGC</code>, <code>FGC</code> (GC次数) 的变化。如果老年代(<code>O</code>)的使用率持续增长且 <code>FGC</code> 后也不下降，就是典型的泄漏迹象。</li>
</ul>
</li>
<li><strong>MAT (Memory Analyzer Tool) 或 VisualVM：</strong><ul>
<li><strong>描述：</strong> 离线分析工具。将 <code>jmap</code> 生成的 <code>heap.bin</code> 文件下载到本地，用这些图形化工具打开进行深入分析。它们可以帮你找到“支配树”（Dominator Tree），直接定位到持有大量内存且无法被回收的对象及其引用链。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对于 Python&#x2F;Node.js&#x2F;Go 等语言：</strong></p>
<ul>
<li>这些语言通常有各自的生态工具，例如 Python 的 <code>tracemalloc</code>, <code>objgraph</code>，Node.js 的 <code>heapdump</code> 模块和 Chrome DevTools。</li>
</ul>
</li>
<li><p><strong>对于内核级别的内存泄漏 (罕见)：</strong></p>
<ul>
<li><strong><code>slabtop</code>：</strong><ul>
<li><strong>描述：</strong> 如果怀疑是内核模块或驱动程序泄漏（非常罕见），可以使用此工具。</li>
<li><strong>用法：</strong> 运行 <code>slabtop -s c</code> 按缓存大小排序，观察是否有某个 slab cache 的 <code>OBJ</code> (对象数) 和 <code>ACTIVE</code> (活动对象) 在不正常地持续增长。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、解决方案和预防"><a href="#四、解决方案和预防" class="headerlink" title="四、解决方案和预防"></a>四、解决方案和预防</h3><ol>
<li><p><strong>短期缓解 (运维侧)：</strong></p>
<ul>
<li><strong>重启服务：</strong> 最简单粗暴但有效的方法是定期重启泄漏的进程，释放其所有占用的内存。这只能作为临时解决方案。</li>
<li><strong>资源隔离和限制：</strong> 使用 cgroups (或通过 Docker&#x2F;Kubernetes) 为进程设置内存上限。当内存使用达到上限时，容器会被 OOM-killed 并自动重启，从而将故障影响限制在单个服务内，避免拖垮整个宿主机。</li>
</ul>
</li>
<li><p><strong>长期根治 (开发侧)：</strong></p>
<ul>
<li><strong>代码修复：</strong> 运维工程师需要将上述排查过程中收集到的证据（如进程名、jmap直方图、heap dump文件、valgrind报告等）提供给开发团队。</li>
<li><strong>开发人员根据这些线索定位到具体的代码逻辑错误并进行修复。</strong></li>
</ul>
</li>
</ol>
<p>作为一名运维工程师，我们的核心职责是<strong>保障系统稳定</strong>，并<strong>高效地定位问题、提供数据</strong>。在内存泄漏问题上，我们的任务就是通过上述工具和方法，准确地找出“元凶”，然后将“案宗”交给“侦探”（开发人员）去破案。</p>
<hr>
<h3 id="场景解读：你在看什么？"><a href="#场景解读：你在看什么？" class="headerlink" title="场景解读：你在看什么？"></a>场景解读：你在看什么？</h3><p><strong>例如：Java 容器内存异常分析，RSS 内存使用率为 53%，WSS 内存使用率为 95%</strong></p>
<p>首先，我们必须精确理解这两个指标的含义，以及它们在容器环境下的特殊性。</p>
<ol>
<li><p><strong>RSS (Resident Set Size - 物理内存使用量):</strong></p>
<ul>
<li><strong>含义：</strong> 这是操作系统内核视角下，该容器（或进程）当前<strong>实际占用</strong>了多少物理内存（RAM）。它包括了 JVM 的堆内存（Heap）、元空间（Metaspace）、JIT 编译缓存、线程栈以及程序加载的本地库（Native Libraries）等所有部分。</li>
<li><strong>关键点：</strong> 这是容器调度器（如 Kubernetes）和 OOM Killer <strong>唯一关心</strong>的指标。当 RSS 超过容器的内存限制 (<code>memory.limit_in_bytes</code>) 时，容器就会被 OOM-killed。</li>
<li><strong>现状（53%）：</strong> 表面上看，容器的物理内存使用量只占了一半多一点的配额，似乎高枕无忧。</li>
</ul>
</li>
<li><p><strong>WSS (Working Set Size - 工作集大小):</strong></p>
<ul>
<li><strong>含义：</strong> 这是 RSS 的一个<strong>子集</strong>，指的是在最近一个时间窗口内，进程<strong>实际访问过（读&#x2F;写）</strong>的内存页。你可以把它理解为“热数据”或“活跃内存”。</li>
<li><strong>关键点：</strong> WSS 是衡量一个应用<strong>内存活跃度</strong>的绝佳指标。它预示了应用在不久的将来最可能需要访问的内存量。</li>
<li><strong>现状（95%）：</strong> 这是问题的<strong>核心</strong>。WSS 占 RSS 的 95%，意味着该容器当前占用的物理内存（那 53% 的配额），几乎全部都是“热”的，正在被高频访问。<strong>几乎没有“冷”的、可以被安全换出或回收的内存。</strong></li>
</ul>
</li>
</ol>
<h3 id="综合分析：危险的信号"><a href="#综合分析：危险的信号" class="headerlink" title="综合分析：危险的信号"></a>综合分析：危险的信号</h3><p>将这两个指标结合起来，我们得到的画像就不再是“内存充裕”，而是“<strong>高度活跃且逼近性能悬崖</strong>”。</p>
<ul>
<li><strong>表象 vs. 实质：</strong> 虽然 RSS 只有 53%，但因为 WSS 高达 95%，说明 Java 应用正在疯狂地使用它已分配到的大部分内存。内存使用效率极高，但反过来说，也<strong>毫无缓冲余地。</strong></li>
<li><strong>潜在风险：</strong><ol>
<li><strong>极易触发 OOM：</strong> 任何一个新的业务请求、一次性的数据加载、甚至是 Full GC 前的内存拷贝，只要需要一点点额外的内存，都会立即导致 RSS 上升。由于没有“冷”内存可供置换，应用会立刻向操作系统申请新的物理内存。RSS 的增长会非常“刚性”，从 53% 迅速攀升，一旦业务流量稍有波动，就可能在短时间内触及 100% 的限制而被杀死。</li>
<li><strong>GC 压力巨大：</strong> 高 WSS 通常意味着堆内对象存活率高，或者新对象分配速度极快。这会导致频繁的 Young GC，并且存活对象会快速晋升到老年代。最终可能引发耗时更长的 Full GC，造成应用卡顿（Stop-the-World）。</li>
<li><strong>性能抖动：</strong> 即使没被 OOM，高内存活跃度也可能导致 minor page faults（当内核需要将之前临时移出的内存页重新载入时），带来微小的性能抖动。</li>
</ol>
</li>
</ul>
<p><strong>结论：该 Java 容器正处于一种“稳定但脆弱”的状态。它当前还能正常工作，但对任何内存需求的增长都极其敏感，离故障（OOM 或性能雪崩）仅一步之遥。</strong></p>
<hr>
<h3 id="排查与行动计划"><a href="#排查与行动计划" class="headerlink" title="排查与行动计划"></a>排查与行动计划</h3><p>作为运维，我们的职责是防患于未然。以下是我的行动步骤：</p>
<h4 id="阶段一：立即行动与数据采集-Ops-Lead"><a href="#阶段一：立即行动与数据采集-Ops-Lead" class="headerlink" title="阶段一：立即行动与数据采集 (Ops Lead)"></a><strong>阶段一：立即行动与数据采集 (Ops Lead)</strong></h4><ol>
<li><p><strong>告警阈值调整：</strong></p>
<ul>
<li>立即为该容器设置更灵敏的告警。除了<code>container_memory_rss &gt; 85%</code>这种常规告警，更应该设置一个<strong>组合告警</strong>或<strong>基于 WSS 的告警</strong>，例如 <code>container_memory_working_set_bytes / container_memory_rss &gt; 0.9 AND container_memory_rss &gt; 50%</code>。这能让我们在危险真正来临前获得预警。</li>
</ul>
</li>
<li><p><strong>关联监控数据：</strong></p>
<ul>
<li><strong>JVM 监控：</strong> 立即查看 APM 系统（如 SkyWalking, Prometheus JMX Exporter）中的 JVM 指标。重点关注：<ul>
<li><strong>堆内存使用率 (Heap Usage)：</strong> 老年代（Old Gen）是否已经很高？</li>
<li><strong>GC 活动 (GC Count &amp; Time)：</strong> <code>Full GC</code> 的频率和耗时是否在增加？<code>Young GC</code> 是否异常频繁？</li>
<li><strong>线程数 (Thread Count)：</strong> 线程数是否过多？（每个线程都有自己的栈，占用 RSS）</li>
</ul>
</li>
<li><strong>业务指标：</strong> 查看应用的 QPS、RT 和错误率。内存问题最终会反映在业务指标上。</li>
</ul>
</li>
<li><p><strong>深入取证 (准备好“弹药”给开发)：</strong></p>
<ul>
<li><p><strong>执行 <code>jstat</code>：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it &lt;pod_name&gt; -c &lt;container_name&gt; -- /bin/bash</span><br><span class="line"><span class="comment"># 找到 Java 进程的 PID</span></span><br><span class="line">ps -ef | grep java</span><br><span class="line"><span class="comment"># 持续观察 GC 情况，每秒一次，共 10 次</span></span><br><span class="line">jstat -gcutil &lt;PID&gt; 1000 10</span><br></pre></td></tr></table></figure>
<p>观察 <code>O</code> (Old Gen) 列是否持续高位，<code>FGC</code> (Full GC 次数) 是否在短时间内增加。</p>
</li>
<li><p><strong>执行 <code>jmap</code> 分析对象：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在非高峰期，或如果情况紧急</span></span><br><span class="line"><span class="comment"># 打印存活对象的直方图，查看是哪种对象占用了最多内存</span></span><br><span class="line">jmap -histo:live &lt;PID&gt; | <span class="built_in">head</span> -n 30</span><br></pre></td></tr></table></figure>
<p>将输出结果保存下来。重复几次，对比是什么对象在持续增长。这是定位内存泄漏的关键证据。</p>
</li>
</ul>
</li>
</ol>
<h4 id="阶段二：问题分析与协同-Ops-Dev"><a href="#阶段二：问题分析与协同-Ops-Dev" class="headerlink" title="阶段二：问题分析与协同 (Ops + Dev)"></a><strong>阶段二：问题分析与协同 (Ops + Dev)</strong></h4><ol>
<li><p><strong>组织分析会：</strong> 将上述收集到的所有数据（RSS&#x2F;WSS 趋势图、JVM 监控截图、<code>jstat</code> 和 <code>jmap</code> 的输出）提交给开发团队。</p>
</li>
<li><p><strong>引导分析方向：</strong></p>
<ul>
<li><strong>场景一：内存泄漏 (Memory Leak)。</strong> 如果 <code>jmap -histo</code> 显示特定业务对象的数量随时间持续增长，且无法被 GC 回收，这基本就是内存泄漏。需要开发人员检查代码，找出是哪里持有了对象的引用。</li>
<li><strong>场景二：内存使用不当 (Inefficient Memory Usage)。</strong><ul>
<li>可能是程序中存在一个巨大的缓存，且缓存内容更新非常频繁，导致 WSS 居高不下。</li>
<li>可能是单个请求处理了过大的数据量（如一次性从数据库查询 100 万条记录到内存中），导致瞬间内存暴增。</li>
<li>可能是 JSON 解析、文件处理等库使用不当，产生了大量临时对象。</li>
</ul>
</li>
<li><strong>场景三：容量不足 (Insufficient Capacity)。</strong> 也许应用本身就是内存密集型的，在当前的业务负载下，它就是需要这么多活跃内存。</li>
</ul>
</li>
</ol>
<h4 id="阶段三：解决方案-Dev-Lead-Ops-Support"><a href="#阶段三：解决方案-Dev-Lead-Ops-Support" class="headerlink" title="阶段三：解决方案 (Dev Lead, Ops Support)"></a><strong>阶段三：解决方案 (Dev Lead, Ops Support)</strong></h4><ol>
<li><p><strong>短期缓解 (Ops)：</strong></p>
<ul>
<li>如果业务非常关键且 OOM 风险极高，作为临时措施，可以<strong>垂直扩容</strong>，即增加容器的 <code>memory.limit</code>。但这只是“续命”，不能解决根本问题。</li>
</ul>
</li>
<li><p><strong>长期根治 (Dev + Ops)：</strong></p>
<ul>
<li><strong>代码优化：</strong> 开发人员根据分析结果修复内存泄漏或优化内存使用逻辑（如使用更小的对象、流式处理数据、优化缓存策略等）。</li>
<li><strong>JVM 调优：</strong><ul>
<li>审视 <code>-Xmx</code>, <code>-Xms</code> 等参数是否合理。</li>
<li>考虑更换垃圾回收器（如 G1GC, ZGC），它们在处理大堆和控制停顿方面有更好的表现。</li>
</ul>
</li>
<li><strong>容量重新评估：</strong> 如果确认是容量问题，需要和开发一起重新评估应用的基准内存需求，并调整容器的 <code>request</code> 和 <code>limit</code>，进行合理的容量规划。</li>
</ul>
</li>
</ol>
<p>通过这样一套组合拳，我们不仅能解决眼前的危机，更能推动应用的健康度和稳定性迈上一个新的台阶。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/">https://huiaz.github.io/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Linux%20%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4/" title="Linux 排查命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux 排查命令</div></div><div class="info-2"><div class="info-item-1">(1) 如何在 Linux 中查看系统资源使用情况？比如内存、CPU、网络端口。  一、 CPU 使用情况1. top 命令 (实时交互式)top 命令是最常用的 CPU 监控工具，它提供了一个实时更新的进程列表，并显示 CPU 使用率、内存使用率、进程 ID (PID)、用户、运行时间等信息。 1top  关键信息解读：  第一行（top line）： load average 显示了过去 1、5、15 分钟的系统平均负载。这是衡量系统忙碌程度的重要指标，数值大于 CPU 核心数时通常表示系统存在瓶颈。 第二行（Tasks）： 显示进程总数，以及运行、睡眠、停止和僵尸进程的数量。 第三行（Cpu(s)）： 显示 CPU 的使用率，各项指标含义如下： us (user): 用户空间程序的 CPU 使用率。 sy (system): 内核空间程序的 CPU 使用率。 ni (nice): 改变过优先级的用户进程的 CPU 使用率。 id (idle): 空闲 CPU 百分比。 wa (iowait): CPU 等待 I&#x2F;O 操作完成的百分比。 hi (hardware i...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20pidstat/" title="Linux pidstat"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux pidstat</div></div><div class="info-2"><div class="info-item-1">pidstat 是 Linux 下 sysstat 工具集中的一个命令，用来监控指定进程（PID）的各种运行指标，常用于排查性能问题。它比 top 更细粒度，可以按进程或线程输出统计信息。  一、基本语法1pidstat [选项] [时间间隔] [次数]   时间间隔：两次采样之间的秒数 次数：采样的次数 如果不加时间间隔和次数，只输出一次快照   二、常用选项 **-u**：显示 CPU 使用情况（默认） **-r**：显示内存使用情况（RSS、VSZ、内存比例等） **-d**：显示 I&#x2F;O 使用情况（读写速率） **-w**：显示上下文切换情况（自愿&#x2F;非自愿） **-t**：显示线程级别统计（默认是进程级别） **-p &lt;pid&gt;**：指定进程 PID（否则显示所有进程） **-h**：以更易读的方式显示时间（hh:mm:ss 格式）   三、示例 监控所有进程的 CPU 使用情况，每隔 2 秒，采集 5 次  1pidstat -u 2 5   监控某个进程（PID&#x3D;1234）的 CPU 和内存情况  1pidstat -u -r...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/docker-network/" title="Docker Network"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Docker Network</div></div><div class="info-2"><div class="info-item-1">|————— | :——- | :——- | :——- | :——————————— || Bridge (自定义) | 高   | 好   | 低   | 绝大多数应用，特别是多容器应用 || Host            | 无       | 最佳 | 极低 | 追求极致性能，端口不冲突的场景     || Overlay         | 高       | 中等     | 中等     | 多主机&#x2F;Docker Swarm 集群通信   || Macvlan         | 高       | 好       | 中等     | 需要容器作为物理网络独立设备的场景 || None            | 完全 | N&#x2F;A      | 极低     | 无网络需求的任务                   | 作为运维工程师，我的首选建议是：为你的多容器应用创建一个自定义的 bridge 网络。这提供了最好的平衡点——良好的隔离性、服务发现能力、可接受的性能和简单的管理。仅在有特殊需求时，才考虑其他网络模式。 </div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%B1%82%E6%AC%A1/" title="Linux的文件系统目录层次"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux的文件系统目录层次</div></div><div class="info-2"><div class="info-item-1">Linux 文件系统层次结构 一、Linux 文件系统层次结构 (FHS) 概述Linux 的文件系统是一个单一的、统一的目录树，所有文件和目录都从根目录 / 开始。这与 Windows 系统中每个分区（如 C:, D:）都有自己的目录树不同。即使系统有多个硬盘或分区，它们也会被“挂载”到这个统一的目录树的某个点上，成为其中的一部分。 FHS 的主要目标是：  标准化： 确保不同 Linux 发行版的文件和目录位置保持一致，方便用户和开发人员。 可移植性： 简化软件在不同 Linux 系统间的移植。 层次性： 清晰地划分系统文件、程序、用户数据、可变数据等，方便管理和备份。 清晰性： 目录名称大多具有描述性，使其用途一目了然。  二、重要目录及其用途示例下面我们将详细介绍 Linux 系统中一些重要的目录及其常见用途。 1. / (根目录) 用途： 整个文件系统的最顶层，所有其他目录和文件都位于其下。系统启动所需的核心文件位于此目录，或者通过其下的子目录链接。 示例内容： 常见子目录如 /bin, /etc, /home, /usr, /var 等。  2. /bin (二进制可...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20tcpdump%20%E5%91%BD%E4%BB%A4/" title="Linux tcpdump 命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux tcpdump 命令</div></div><div class="info-2"><div class="info-item-1">作为一名运维工程师，tcpdump 是我进行网络故障排查和性能分析时不可或缺的“瑞士军刀”。它是一个基于命令行的数据包捕获工具，能够截获并显示通过网络接口的数据包。无论是在诊断网络连接问题、分析协议行为、检测异常流量，还是验证防火墙规则时，tcpdump 都扮演着至关重要的角色。  一、tcpdump 简介 功能： 捕获网络接口上符合指定条件的数据包，并将其内容打印到标准输出或保存到文件中。 原理： tcpdump 使用 libpcap 库来与网络接口进行交互，接收、过滤和解析流经接口的数据包。它工作在数据链路层，能够看到IP层及以上的所有协议数据。 应用场景： 诊断连通性问题： 验证客户端&#x2F;服务器之间是否有数据包传输。 分析协议行为： 深入了解 HTTP、DNS、SSH 等协议的具体交互过程。 排查防火墙问题： 确认流量是否被防火墙阻拦。 检测异常流量： 发现端口扫描、拒绝服务攻击（DoS）的迹象。 性能瓶颈分析： 识别延迟、丢包等网络性能问题。 验证流量转发： 检查路由和 NAT 是否按预期工作。 安全审计： 监控关键系统的网络活动。     二、tcpdump 的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%E4%B8%AD%20crontab/" title="Linux 系统中 crontab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 系统中 crontab</div></div><div class="info-2"><div class="info-item-1">Linux 系统中 crontab Crontab 的工作原理crontab（cron table） 是 Linux&#x2F;Unix 系统用于设置周期性执行任务的工具。它的核心是 cron 服务（或称为 crond 守护进程），这个服务在系统启动时就会自动运行，并且会一直在后台持续运行，它的主要职责是：  读取定时任务配置： cron 服务会周期性地（通常是每分钟）扫描特定的配置文件，这些文件包含了用户定义的定时任务列表。主要的配置文件位置包括：  系统级别的定时任务： /etc/crontab：系统主 cron 表，通常用于定义系统级的任务。 /etc/cron.d/：该目录下的所有文件都会被 cron 服务读取，每个文件可以定义独立的定时任务。 /etc/cron.hourly/, /etc/cron.daily/, /etc/cron.weekly/, /etc/cron.monthly/：这些目录下的脚本会分别每小时、每天、每周、每月被 cron 服务执行一次。   用户级别的定时任务： /var/spool/cron/：每个用户的 crontab -e 命令编辑的任...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E4%B8%AD%20df%20%E4%B8%8E%20du%20%E5%8C%BA%E5%88%AB/" title="Linux 中 df 与 du 区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 中 df 与 du 区别</div></div><div class="info-2"><div class="info-item-1">df 和 du 是日常工作中用于查看磁盘使用情况的两个最基本也是最重要的命令。它们都与磁盘空间有关，但它们的工作原理、关注点以及提供的信息维度截然不同。理解这两者的区别至关重要，因为它能帮助我们准确地判断磁盘空间问题，而不是被表象所迷惑。  一、df (disk free)df 命令用于报告文件系统的磁盘空间使用情况。它读取的是文件系统的超级块（superblock）信息，反映的是文件系统层面上的整体空间统计。 1. 核心特点： 报告文件系统总览： 关注的是整个文件系统（分区、挂载点）的使用情况。 读取文件系统元数据： 它直接查询文件系统的元数据（如 inode 表、块位图等），来得知已用、可用空间和总容量。 速度快： 由于只读取元数据，不遍历文件，所以执行速度通常很快。 计算已挂载文件系统： 只能报告已挂载的文件系统，包括本地磁盘、网络文件系统（NFS, Samba&#x2F;CIFS）、虚拟文件系统等。 显示已分配但未释放的空间： 如果文件被删除但仍被进程占用（即文件句柄未释放），df 会将这部分空间计入“已用”空间，因为它对文件系统来说这部分空间是“被占用的”。  2. 常...</div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-dockerfile/" title="Dockerfile"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Dockerfile</div></div><div class="info-2"><div class="info-item-1">一、Dockerfile 的作用Dockerfile 是一个文本文件，其核心作用是定义了构建一个 Docker 镜像所需的所有步骤和指令。它就像一份自动化的“安装说明书”或“烹饪菜谱”，Docker 根据这份说明书，就能一步不差地构建出一个标准、一致的镜像。 它的主要作用体现在：  **自动化构建 (Automation)**：将手动配置环境的繁琐步骤（安装依赖、复制文件、设置环境变量等）代码化，实现了构建过程的全自动。 **可重复性 (Reproducibility)**：只要 Dockerfile 不变，无论在谁的机器上、在什么时间执行构建，最终得到的镜像内容都是完全一致的，这从根本上保证了环境的一致性。 **版本控制 (Versioning)**：Dockerfile 可以像代码一样存放在 Git 等版本控制系统中进行管理。每一次对环境的变更，都可以通过修改 Dockerfile 并提交记录来追溯，使得环境演进有迹可循。 **透明性与审查 (Transparency &amp; Auditing)**：任何团队成员都可以通过阅读 Dockerfile，清晰地了解到一个镜像是...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">一、什么是 Linux 系统中的内存泄漏？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%85%B8%E5%9E%8B%E7%97%87%E7%8A%B6"><span class="toc-number">2.</span> <span class="toc-text">二、内存泄漏的典型症状</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">3.</span> <span class="toc-text">三、内存泄漏的排查方法和工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E7%A1%AE%E8%AE%A4%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%B3%84%E6%BC%8F%E5%B9%B6%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.</span> <span class="toc-text">步骤 1：确认是否存在泄漏并定位系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E5%AE%9A%E4%BD%8D%E5%85%B7%E4%BD%93%E7%9A%84%E6%B3%84%E6%BC%8F%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">步骤 2：定位具体的泄漏进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E5%AB%8C%E7%96%91%E8%BF%9B%E7%A8%8B-%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.3.</span> <span class="toc-text">步骤 3：深入分析嫌疑进程 (关键步骤)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E9%A2%84%E9%98%B2"><span class="toc-number">4.</span> <span class="toc-text">四、解决方案和预防</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%A7%A3%E8%AF%BB%EF%BC%9A%E4%BD%A0%E5%9C%A8%E7%9C%8B%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">场景解读：你在看什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%88%86%E6%9E%90%EF%BC%9A%E5%8D%B1%E9%99%A9%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="toc-number">6.</span> <span class="toc-text">综合分析：危险的信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%92"><span class="toc-number">7.</span> <span class="toc-text">排查与行动计划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E7%AB%8B%E5%8D%B3%E8%A1%8C%E5%8A%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86-Ops-Lead"><span class="toc-number">7.1.</span> <span class="toc-text">阶段一：立即行动与数据采集 (Ops Lead)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E5%8D%8F%E5%90%8C-Ops-Dev"><span class="toc-number">7.2.</span> <span class="toc-text">阶段二：问题分析与协同 (Ops + Dev)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Dev-Lead-Ops-Support"><span class="toc-number">7.3.</span> <span class="toc-text">阶段三：解决方案 (Dev Lead, Ops Support)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>