<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、什么是 Linux 系统中的内存泄漏？简单来说，内存泄漏（Memory Leak） 指的是程序在运行过程中，动态地申请了内存空间（例如 C 语言的 malloc() 或 Java 的 new），但在使用完毕后，没有按预期释放（或无法被垃圾回收器回收）。 结果是，这部分内存既不能被当前程序再次使用，也无法被操作系统回收分配给其他程序。从操作系统的视角看，这块内存一直被该程序“合法”地占用着。随着">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内存异常排查">
<meta property="og:url" content="http://example.com/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="一、什么是 Linux 系统中的内存泄漏？简单来说，内存泄漏（Memory Leak） 指的是程序在运行过程中，动态地申请了内存空间（例如 C 语言的 malloc() 或 Java 的 new），但在使用完毕后，没有按预期释放（或无法被垃圾回收器回收）。 结果是，这部分内存既不能被当前程序再次使用，也无法被操作系统回收分配给其他程序。从操作系统的视角看，这块内存一直被该程序“合法”地占用着。随着">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:46:51.576Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux 内存异常排查 | Hui's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hui's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六一">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hui's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux 内存异常排查
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-11 20:32:34 / 修改时间：21:46:51" itemprop="dateCreated datePublished" datetime="2025-09-11T20:32:34+08:00">2025-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Command/" itemprop="url" rel="index"><span itemprop="name">Command</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="一、什么是-Linux-系统中的内存泄漏？"><a href="#一、什么是-Linux-系统中的内存泄漏？" class="headerlink" title="一、什么是 Linux 系统中的内存泄漏？"></a>一、什么是 Linux 系统中的内存泄漏？</h3><p>简单来说，<strong>内存泄漏（Memory Leak）</strong> 指的是程序在运行过程中，动态地申请了内存空间（例如 C 语言的 <code>malloc()</code> 或 Java 的 <code>new</code>），但在使用完毕后，没有按预期释放（或无法被垃圾回收器回收）。</p>
<p>结果是，这部分内存既不能被当前程序再次使用，也无法被操作系统回收分配给其他程序。从操作系统的视角看，这块内存一直被该程序“合法”地占用着。随着时间的推移，泄漏的内存积少成多，最终会耗尽系统的可用物理内存和交换空间（Swap）。</p>
<p><strong>一个常见的误解：</strong><br>很多时候，新手会把 Linux 的<strong>文件系统缓存（Cache）</strong>误认为是内存泄漏。Linux 内核会尽可能地利用空闲内存来缓存磁盘读写数据，以提高性能。在 <code>free -h</code> 命令中，这部分内存会显示在 <code>buff/cache</code> 列。这是正常且有益的行为，当应用程序需要更多内存时，内核会自动收缩这部分缓存来满足需求。</p>
<p><strong>真正的内存泄漏迹象是 <code>available</code>（可用内存）持续、不可逆地减少，而不是 <code>free</code>（空闲内存）的减少。</strong></p>
<h3 id="二、内存泄漏的典型症状"><a href="#二、内存泄漏的典型症状" class="headerlink" title="二、内存泄漏的典型症状"></a>二、内存泄漏的典型症状</h3><p>作为运维，我们通常不是直接看到代码，而是通过以下系统现象来感知到内存泄漏的存在：</p>
<ol>
<li><strong>系统性能逐渐下降：</strong> 服务器运行一段时间后（几天、几周甚至几个月），响应越来越慢，处理请求的延迟越来越高。</li>
<li><strong>可用内存持续减少：</strong> 通过监控工具（如 Prometheus + Grafana, Zabbix）观察，服务器的可用内存曲线呈现出一种缓慢、稳定下降的趋势，即使在业务低谷期也无法恢复。</li>
<li><strong>Swap 使用量增加：</strong> 当物理内存耗尽时，系统开始频繁使用交换空间（Swap），导致磁盘 I&#x2F;O 飙升，系统性能急剧恶化。</li>
<li><strong>OOM Killer 介入：</strong> 当物理内存和交换空间都耗尽时，Linux 内核的 <strong>OOM Killer (Out-of-Memory Killer)</strong> 机制会被触发，它会选择一个进程（通常是占用内存最多的那个）并将其“杀死”（kill），以释放内存，保障系统至少能继续运行。你可以在系统日志中看到 OOM Killer 的“作案记录”。<ul>
<li><strong>检查命令：</strong> <code>dmesg | grep -i &quot;out of memory&quot;</code> 或检查 <code>/var/log/messages</code>、<code>/var/log/syslog</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、内存泄漏的排查方法和工具"><a href="#三、内存泄漏的排查方法和工具" class="headerlink" title="三、内存泄漏的排查方法和工具"></a>三、内存泄漏的排查方法和工具</h3><p>排查内存泄漏遵循一个从宏观到微观的“漏斗模型”：<strong>系统层面 -&gt; 进程层面 -&gt; 代码层面</strong>。</p>
<h4 id="步骤-1：确认是否存在泄漏并定位系统"><a href="#步骤-1：确认是否存在泄漏并定位系统" class="headerlink" title="步骤 1：确认是否存在泄漏并定位系统"></a><strong>步骤 1：确认是否存在泄漏并定位系统</strong></h4><ul>
<li><strong>工具：</strong> <code>free</code>, <code>vmstat</code>, <code>sar</code>, 以及监控系统（如 Prometheus）。</li>
<li><strong>方法：</strong><ol>
<li><strong>长期观察：</strong> 查看监控系统中服务器的<strong>可用内存 (Available Memory)</strong> 历史图表。如果它呈现出随时间推移稳步下降且从不完全恢复的“下坡”趋势，就高度怀疑是内存泄漏。</li>
<li><strong>实时检查：</strong> 使用 <code>free -h</code> 命令，持续关注 <code>available</code> 列的变化。同时，使用 <code>vmstat 1</code> 可以每秒输出一行系统状态，观察 <code>swpd</code> (交换区使用) 和 <code>si</code>, <code>so</code> (换入换出) 列，如果这些值持续很高，说明内存压力巨大。</li>
</ol>
</li>
</ul>
<h4 id="步骤-2：定位具体的泄漏进程"><a href="#步骤-2：定位具体的泄漏进程" class="headerlink" title="步骤 2：定位具体的泄漏进程"></a><strong>步骤 2：定位具体的泄漏进程</strong></h4><p>一旦确认系统存在内存泄漏，下一步就是找出是哪个进程干的。</p>
<ul>
<li><strong>工具：</strong> <code>top</code>, <code>htop</code>, <code>ps</code>。</li>
<li><strong>方法：</strong><ol>
<li><strong><code>top</code> 或 <code>htop</code>：</strong> 在命令行中运行 <code>top</code>，然后按 <code>M</code> (大写) 或 <code>htop</code> 中按 <code>F6</code> 选择 <code>PERCENT_MEM</code>，将进程按内存使用率排序。</li>
<li><strong>观察：</strong> 长期观察列表，哪个进程的 <code>%MEM</code> (内存使用百分比) 和 <code>RES</code> (Resident Memory, 物理内存占用) 在持续、缓慢地增长，那个进程就是最大的嫌疑犯。</li>
<li><strong>静态快照：</strong> 使用 <code>ps aux --sort=-%mem | head -n 10</code> 可以列出当前内存使用最高的前几个进程，适合做成脚本定时记录。</li>
</ol>
</li>
</ul>
<h4 id="步骤-3：深入分析嫌疑进程-关键步骤"><a href="#步骤-3：深入分析嫌疑进程-关键步骤" class="headerlink" title="步骤 3：深入分析嫌疑进程 (关键步骤)"></a><strong>步骤 3：深入分析嫌疑进程 (关键步骤)</strong></h4><p>定位到具体进程后，需要使用更专业的工具来分析其内部的内存分配情况。这通常需要根据进程的开发语言来选择合适的工具。</p>
<ul>
<li><p><strong>对于 C&#x2F;C++ 等编译型语言程序：</strong></p>
<ul>
<li><strong><code>valgrind (memcheck)</code>：</strong><ul>
<li><strong>描述：</strong> 这是最强大的内存调试工具，可以精确报告每一处内存泄漏发生的位置（代码行）。</li>
<li><strong>用法：</strong> <code>valgrind --leak-check=full ./your_program</code>。</li>
<li><strong>缺点：</strong> 它会使程序运行速度降低 10-50 倍，<strong>不适用于生产环境</strong>，通常在开发或测试环境中使用。</li>
</ul>
</li>
<li><strong><code>pmap</code>：</strong><ul>
<li><strong>描述：</strong> 显示一个进程的内存映射。</li>
<li><strong>用法：</strong> <code>pmap -x &lt;PID&gt;</code>。通过定时对同一个进程执行 <code>pmap</code> 并对输出进行 <code>diff</code>，可以发现是哪些内存地址段在持续增长。这能提供一些线索。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对于 Java 程序 (JVM)：</strong></p>
<ul>
<li><strong><code>jmap</code>：</strong><ul>
<li><strong>描述：</strong> JVM 自带的内存映像工具，非常实用。</li>
<li><strong>用法：</strong><ol>
<li><strong>查看堆中对象统计信息：</strong> <code>jmap -histo:live &lt;PID&gt; | head -n 20</code>。这个命令会触发一次 Full GC，然后打印出当前存活对象的直方图。定时执行并 <code>diff</code> 两次的结果，可以清晰地看到哪种类型的对象数量在不断增加。这是<strong>生产环境中最常用的快速定位方法</strong>。</li>
<li><strong>生成堆转储快照 (Heap Dump)：</strong> <code>jmap -dump:live,format=b,file=heap.bin &lt;PID&gt;</code>。这个命令会生成一个完整的堆快照文件。</li>
</ol>
</li>
</ul>
</li>
<li><strong><code>jstat</code>：</strong><ul>
<li><strong>描述：</strong> 监控 JVM 的垃圾回收(GC)活动。</li>
<li><strong>用法：</strong> <code>jstat -gcutil &lt;PID&gt; 1000</code>。观察 <code>E</code> (Eden), <code>S0</code>, <code>S1</code> (Survivor), <code>O</code> (Old Gen) 的使用率和 <code>YGC</code>, <code>FGC</code> (GC次数) 的变化。如果老年代(<code>O</code>)的使用率持续增长且 <code>FGC</code> 后也不下降，就是典型的泄漏迹象。</li>
</ul>
</li>
<li><strong>MAT (Memory Analyzer Tool) 或 VisualVM：</strong><ul>
<li><strong>描述：</strong> 离线分析工具。将 <code>jmap</code> 生成的 <code>heap.bin</code> 文件下载到本地，用这些图形化工具打开进行深入分析。它们可以帮你找到“支配树”（Dominator Tree），直接定位到持有大量内存且无法被回收的对象及其引用链。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对于 Python&#x2F;Node.js&#x2F;Go 等语言：</strong></p>
<ul>
<li>这些语言通常有各自的生态工具，例如 Python 的 <code>tracemalloc</code>, <code>objgraph</code>，Node.js 的 <code>heapdump</code> 模块和 Chrome DevTools。</li>
</ul>
</li>
<li><p><strong>对于内核级别的内存泄漏 (罕见)：</strong></p>
<ul>
<li><strong><code>slabtop</code>：</strong><ul>
<li><strong>描述：</strong> 如果怀疑是内核模块或驱动程序泄漏（非常罕见），可以使用此工具。</li>
<li><strong>用法：</strong> 运行 <code>slabtop -s c</code> 按缓存大小排序，观察是否有某个 slab cache 的 <code>OBJ</code> (对象数) 和 <code>ACTIVE</code> (活动对象) 在不正常地持续增长。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、解决方案和预防"><a href="#四、解决方案和预防" class="headerlink" title="四、解决方案和预防"></a>四、解决方案和预防</h3><ol>
<li><p><strong>短期缓解 (运维侧)：</strong></p>
<ul>
<li><strong>重启服务：</strong> 最简单粗暴但有效的方法是定期重启泄漏的进程，释放其所有占用的内存。这只能作为临时解决方案。</li>
<li><strong>资源隔离和限制：</strong> 使用 cgroups (或通过 Docker&#x2F;Kubernetes) 为进程设置内存上限。当内存使用达到上限时，容器会被 OOM-killed 并自动重启，从而将故障影响限制在单个服务内，避免拖垮整个宿主机。</li>
</ul>
</li>
<li><p><strong>长期根治 (开发侧)：</strong></p>
<ul>
<li><strong>代码修复：</strong> 运维工程师需要将上述排查过程中收集到的证据（如进程名、jmap直方图、heap dump文件、valgrind报告等）提供给开发团队。</li>
<li><strong>开发人员根据这些线索定位到具体的代码逻辑错误并进行修复。</strong></li>
</ul>
</li>
</ol>
<p>作为一名运维工程师，我们的核心职责是<strong>保障系统稳定</strong>，并<strong>高效地定位问题、提供数据</strong>。在内存泄漏问题上，我们的任务就是通过上述工具和方法，准确地找出“元凶”，然后将“案宗”交给“侦探”（开发人员）去破案。</p>
<hr>
<h3 id="场景解读：你在看什么？"><a href="#场景解读：你在看什么？" class="headerlink" title="场景解读：你在看什么？"></a>场景解读：你在看什么？</h3><p><strong>例如：Java 容器内存异常分析，RSS 内存使用率为 53%，WSS 内存使用率为 95%</strong></p>
<p>首先，我们必须精确理解这两个指标的含义，以及它们在容器环境下的特殊性。</p>
<ol>
<li><p><strong>RSS (Resident Set Size - 物理内存使用量):</strong></p>
<ul>
<li><strong>含义：</strong> 这是操作系统内核视角下，该容器（或进程）当前<strong>实际占用</strong>了多少物理内存（RAM）。它包括了 JVM 的堆内存（Heap）、元空间（Metaspace）、JIT 编译缓存、线程栈以及程序加载的本地库（Native Libraries）等所有部分。</li>
<li><strong>关键点：</strong> 这是容器调度器（如 Kubernetes）和 OOM Killer <strong>唯一关心</strong>的指标。当 RSS 超过容器的内存限制 (<code>memory.limit_in_bytes</code>) 时，容器就会被 OOM-killed。</li>
<li><strong>现状（53%）：</strong> 表面上看，容器的物理内存使用量只占了一半多一点的配额，似乎高枕无忧。</li>
</ul>
</li>
<li><p><strong>WSS (Working Set Size - 工作集大小):</strong></p>
<ul>
<li><strong>含义：</strong> 这是 RSS 的一个<strong>子集</strong>，指的是在最近一个时间窗口内，进程<strong>实际访问过（读&#x2F;写）</strong>的内存页。你可以把它理解为“热数据”或“活跃内存”。</li>
<li><strong>关键点：</strong> WSS 是衡量一个应用<strong>内存活跃度</strong>的绝佳指标。它预示了应用在不久的将来最可能需要访问的内存量。</li>
<li><strong>现状（95%）：</strong> 这是问题的<strong>核心</strong>。WSS 占 RSS 的 95%，意味着该容器当前占用的物理内存（那 53% 的配额），几乎全部都是“热”的，正在被高频访问。<strong>几乎没有“冷”的、可以被安全换出或回收的内存。</strong></li>
</ul>
</li>
</ol>
<h3 id="综合分析：危险的信号"><a href="#综合分析：危险的信号" class="headerlink" title="综合分析：危险的信号"></a>综合分析：危险的信号</h3><p>将这两个指标结合起来，我们得到的画像就不再是“内存充裕”，而是“<strong>高度活跃且逼近性能悬崖</strong>”。</p>
<ul>
<li><strong>表象 vs. 实质：</strong> 虽然 RSS 只有 53%，但因为 WSS 高达 95%，说明 Java 应用正在疯狂地使用它已分配到的大部分内存。内存使用效率极高，但反过来说，也<strong>毫无缓冲余地。</strong></li>
<li><strong>潜在风险：</strong><ol>
<li><strong>极易触发 OOM：</strong> 任何一个新的业务请求、一次性的数据加载、甚至是 Full GC 前的内存拷贝，只要需要一点点额外的内存，都会立即导致 RSS 上升。由于没有“冷”内存可供置换，应用会立刻向操作系统申请新的物理内存。RSS 的增长会非常“刚性”，从 53% 迅速攀升，一旦业务流量稍有波动，就可能在短时间内触及 100% 的限制而被杀死。</li>
<li><strong>GC 压力巨大：</strong> 高 WSS 通常意味着堆内对象存活率高，或者新对象分配速度极快。这会导致频繁的 Young GC，并且存活对象会快速晋升到老年代。最终可能引发耗时更长的 Full GC，造成应用卡顿（Stop-the-World）。</li>
<li><strong>性能抖动：</strong> 即使没被 OOM，高内存活跃度也可能导致 minor page faults（当内核需要将之前临时移出的内存页重新载入时），带来微小的性能抖动。</li>
</ol>
</li>
</ul>
<p><strong>结论：该 Java 容器正处于一种“稳定但脆弱”的状态。它当前还能正常工作，但对任何内存需求的增长都极其敏感，离故障（OOM 或性能雪崩）仅一步之遥。</strong></p>
<hr>
<h3 id="排查与行动计划"><a href="#排查与行动计划" class="headerlink" title="排查与行动计划"></a>排查与行动计划</h3><p>作为运维，我们的职责是防患于未然。以下是我的行动步骤：</p>
<h4 id="阶段一：立即行动与数据采集-Ops-Lead"><a href="#阶段一：立即行动与数据采集-Ops-Lead" class="headerlink" title="阶段一：立即行动与数据采集 (Ops Lead)"></a><strong>阶段一：立即行动与数据采集 (Ops Lead)</strong></h4><ol>
<li><p><strong>告警阈值调整：</strong></p>
<ul>
<li>立即为该容器设置更灵敏的告警。除了<code>container_memory_rss &gt; 85%</code>这种常规告警，更应该设置一个<strong>组合告警</strong>或<strong>基于 WSS 的告警</strong>，例如 <code>container_memory_working_set_bytes / container_memory_rss &gt; 0.9 AND container_memory_rss &gt; 50%</code>。这能让我们在危险真正来临前获得预警。</li>
</ul>
</li>
<li><p><strong>关联监控数据：</strong></p>
<ul>
<li><strong>JVM 监控：</strong> 立即查看 APM 系统（如 SkyWalking, Prometheus JMX Exporter）中的 JVM 指标。重点关注：<ul>
<li><strong>堆内存使用率 (Heap Usage)：</strong> 老年代（Old Gen）是否已经很高？</li>
<li><strong>GC 活动 (GC Count &amp; Time)：</strong> <code>Full GC</code> 的频率和耗时是否在增加？<code>Young GC</code> 是否异常频繁？</li>
<li><strong>线程数 (Thread Count)：</strong> 线程数是否过多？（每个线程都有自己的栈，占用 RSS）</li>
</ul>
</li>
<li><strong>业务指标：</strong> 查看应用的 QPS、RT 和错误率。内存问题最终会反映在业务指标上。</li>
</ul>
</li>
<li><p><strong>深入取证 (准备好“弹药”给开发)：</strong></p>
<ul>
<li><p><strong>执行 <code>jstat</code>：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it &lt;pod_name&gt; -c &lt;container_name&gt; -- /bin/bash</span><br><span class="line"><span class="comment"># 找到 Java 进程的 PID</span></span><br><span class="line">ps -ef | grep java</span><br><span class="line"><span class="comment"># 持续观察 GC 情况，每秒一次，共 10 次</span></span><br><span class="line">jstat -gcutil &lt;PID&gt; 1000 10</span><br></pre></td></tr></table></figure>
<p>观察 <code>O</code> (Old Gen) 列是否持续高位，<code>FGC</code> (Full GC 次数) 是否在短时间内增加。</p>
</li>
<li><p><strong>执行 <code>jmap</code> 分析对象：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在非高峰期，或如果情况紧急</span></span><br><span class="line"><span class="comment"># 打印存活对象的直方图，查看是哪种对象占用了最多内存</span></span><br><span class="line">jmap -histo:live &lt;PID&gt; | <span class="built_in">head</span> -n 30</span><br></pre></td></tr></table></figure>
<p>将输出结果保存下来。重复几次，对比是什么对象在持续增长。这是定位内存泄漏的关键证据。</p>
</li>
</ul>
</li>
</ol>
<h4 id="阶段二：问题分析与协同-Ops-Dev"><a href="#阶段二：问题分析与协同-Ops-Dev" class="headerlink" title="阶段二：问题分析与协同 (Ops + Dev)"></a><strong>阶段二：问题分析与协同 (Ops + Dev)</strong></h4><ol>
<li><p><strong>组织分析会：</strong> 将上述收集到的所有数据（RSS&#x2F;WSS 趋势图、JVM 监控截图、<code>jstat</code> 和 <code>jmap</code> 的输出）提交给开发团队。</p>
</li>
<li><p><strong>引导分析方向：</strong></p>
<ul>
<li><strong>场景一：内存泄漏 (Memory Leak)。</strong> 如果 <code>jmap -histo</code> 显示特定业务对象的数量随时间持续增长，且无法被 GC 回收，这基本就是内存泄漏。需要开发人员检查代码，找出是哪里持有了对象的引用。</li>
<li><strong>场景二：内存使用不当 (Inefficient Memory Usage)。</strong><ul>
<li>可能是程序中存在一个巨大的缓存，且缓存内容更新非常频繁，导致 WSS 居高不下。</li>
<li>可能是单个请求处理了过大的数据量（如一次性从数据库查询 100 万条记录到内存中），导致瞬间内存暴增。</li>
<li>可能是 JSON 解析、文件处理等库使用不当，产生了大量临时对象。</li>
</ul>
</li>
<li><strong>场景三：容量不足 (Insufficient Capacity)。</strong> 也许应用本身就是内存密集型的，在当前的业务负载下，它就是需要这么多活跃内存。</li>
</ul>
</li>
</ol>
<h4 id="阶段三：解决方案-Dev-Lead-Ops-Support"><a href="#阶段三：解决方案-Dev-Lead-Ops-Support" class="headerlink" title="阶段三：解决方案 (Dev Lead, Ops Support)"></a><strong>阶段三：解决方案 (Dev Lead, Ops Support)</strong></h4><ol>
<li><p><strong>短期缓解 (Ops)：</strong></p>
<ul>
<li>如果业务非常关键且 OOM 风险极高，作为临时措施，可以<strong>垂直扩容</strong>，即增加容器的 <code>memory.limit</code>。但这只是“续命”，不能解决根本问题。</li>
</ul>
</li>
<li><p><strong>长期根治 (Dev + Ops)：</strong></p>
<ul>
<li><strong>代码优化：</strong> 开发人员根据分析结果修复内存泄漏或优化内存使用逻辑（如使用更小的对象、流式处理数据、优化缓存策略等）。</li>
<li><strong>JVM 调优：</strong><ul>
<li>审视 <code>-Xmx</code>, <code>-Xms</code> 等参数是否合理。</li>
<li>考虑更换垃圾回收器（如 G1GC, ZGC），它们在处理大堆和控制停顿方面有更好的表现。</li>
</ul>
</li>
<li><strong>容量重新评估：</strong> 如果确认是容量问题，需要和开发一起重新评估应用的基准内存需求，并调整容器的 <code>request</code> 和 <code>limit</code>，进行合理的容量规划。</li>
</ul>
</li>
</ol>
<p>通过这样一套组合拳，我们不仅能解决眼前的危机，更能推动应用的健康度和稳定性迈上一个新的台阶。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag"># 运维</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/09/11/Linux%20%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4/" rel="prev" title="Linux 排查命令">
      <i class="fa fa-chevron-left"></i> Linux 排查命令
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/09/11/Linux%20%E4%B8%AD%E7%9A%84%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/" rel="next" title="Linux 中的硬链接和软连接">
      Linux 中的硬链接和软连接 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">一、什么是 Linux 系统中的内存泄漏？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%85%B8%E5%9E%8B%E7%97%87%E7%8A%B6"><span class="nav-number">2.</span> <span class="nav-text">二、内存泄漏的典型症状</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="nav-number">3.</span> <span class="nav-text">三、内存泄漏的排查方法和工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E7%A1%AE%E8%AE%A4%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%B3%84%E6%BC%8F%E5%B9%B6%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.1.</span> <span class="nav-text">步骤 1：确认是否存在泄漏并定位系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E5%AE%9A%E4%BD%8D%E5%85%B7%E4%BD%93%E7%9A%84%E6%B3%84%E6%BC%8F%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">步骤 2：定位具体的泄漏进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E5%AB%8C%E7%96%91%E8%BF%9B%E7%A8%8B-%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.3.</span> <span class="nav-text">步骤 3：深入分析嫌疑进程 (关键步骤)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E9%A2%84%E9%98%B2"><span class="nav-number">4.</span> <span class="nav-text">四、解决方案和预防</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E8%A7%A3%E8%AF%BB%EF%BC%9A%E4%BD%A0%E5%9C%A8%E7%9C%8B%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">场景解读：你在看什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E5%88%86%E6%9E%90%EF%BC%9A%E5%8D%B1%E9%99%A9%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="nav-number">6.</span> <span class="nav-text">综合分析：危险的信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%92"><span class="nav-number">7.</span> <span class="nav-text">排查与行动计划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E7%AB%8B%E5%8D%B3%E8%A1%8C%E5%8A%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86-Ops-Lead"><span class="nav-number">7.1.</span> <span class="nav-text">阶段一：立即行动与数据采集 (Ops Lead)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E5%8D%8F%E5%90%8C-Ops-Dev"><span class="nav-number">7.2.</span> <span class="nav-text">阶段二：问题分析与协同 (Ops + Dev)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Dev-Lead-Ops-Support"><span class="nav-number">7.3.</span> <span class="nav-text">阶段三：解决方案 (Dev Lead, Ops Support)</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六一</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">273</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huiaz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huiaz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:34</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
