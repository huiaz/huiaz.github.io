<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 内存异常排查 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、什么是 Linux 系统中的内存泄漏？简单来说，内存泄漏（Memory Leak） 指的是程序在运行过程中，动态地申请了内存空间（例如 C 语言的 malloc() 或 Java 的 new），但在使用完毕后，没有按预期释放（或无法被垃圾回收器回收）。 结果是，这部分内存既不能被当前程序再次使用，也无法被操作系统回收分配给其他程序。从操作系统的视角看，这块内存一直被该程序“合法”地占用着。随着">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内存异常排查">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="一、什么是 Linux 系统中的内存泄漏？简单来说，内存泄漏（Memory Leak） 指的是程序在运行过程中，动态地申请了内存空间（例如 C 语言的 malloc() 或 Java 的 new），但在使用完毕后，没有按预期释放（或无法被垃圾回收器回收）。 结果是，这部分内存既不能被当前程序再次使用，也无法被操作系统回收分配给其他程序。从操作系统的视角看，这块内存一直被该程序“合法”地占用着。随着">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:46:51.576Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 内存异常排查",
  "url": "https://huiaz.github.io/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:46:51.576Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 内存异常排查',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 内存异常排查</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux 内存异常排查</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:46:51.576Z" title="更新于 2025-09-11 21:46:51">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/Command/">Command</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="一、什么是-Linux-系统中的内存泄漏？"><a href="#一、什么是-Linux-系统中的内存泄漏？" class="headerlink" title="一、什么是 Linux 系统中的内存泄漏？"></a>一、什么是 Linux 系统中的内存泄漏？</h3><p>简单来说，<strong>内存泄漏（Memory Leak）</strong> 指的是程序在运行过程中，动态地申请了内存空间（例如 C 语言的 <code>malloc()</code> 或 Java 的 <code>new</code>），但在使用完毕后，没有按预期释放（或无法被垃圾回收器回收）。</p>
<p>结果是，这部分内存既不能被当前程序再次使用，也无法被操作系统回收分配给其他程序。从操作系统的视角看，这块内存一直被该程序“合法”地占用着。随着时间的推移，泄漏的内存积少成多，最终会耗尽系统的可用物理内存和交换空间（Swap）。</p>
<p><strong>一个常见的误解：</strong><br>很多时候，新手会把 Linux 的<strong>文件系统缓存（Cache）</strong>误认为是内存泄漏。Linux 内核会尽可能地利用空闲内存来缓存磁盘读写数据，以提高性能。在 <code>free -h</code> 命令中，这部分内存会显示在 <code>buff/cache</code> 列。这是正常且有益的行为，当应用程序需要更多内存时，内核会自动收缩这部分缓存来满足需求。</p>
<p><strong>真正的内存泄漏迹象是 <code>available</code>（可用内存）持续、不可逆地减少，而不是 <code>free</code>（空闲内存）的减少。</strong></p>
<h3 id="二、内存泄漏的典型症状"><a href="#二、内存泄漏的典型症状" class="headerlink" title="二、内存泄漏的典型症状"></a>二、内存泄漏的典型症状</h3><p>作为运维，我们通常不是直接看到代码，而是通过以下系统现象来感知到内存泄漏的存在：</p>
<ol>
<li><strong>系统性能逐渐下降：</strong> 服务器运行一段时间后（几天、几周甚至几个月），响应越来越慢，处理请求的延迟越来越高。</li>
<li><strong>可用内存持续减少：</strong> 通过监控工具（如 Prometheus + Grafana, Zabbix）观察，服务器的可用内存曲线呈现出一种缓慢、稳定下降的趋势，即使在业务低谷期也无法恢复。</li>
<li><strong>Swap 使用量增加：</strong> 当物理内存耗尽时，系统开始频繁使用交换空间（Swap），导致磁盘 I&#x2F;O 飙升，系统性能急剧恶化。</li>
<li><strong>OOM Killer 介入：</strong> 当物理内存和交换空间都耗尽时，Linux 内核的 <strong>OOM Killer (Out-of-Memory Killer)</strong> 机制会被触发，它会选择一个进程（通常是占用内存最多的那个）并将其“杀死”（kill），以释放内存，保障系统至少能继续运行。你可以在系统日志中看到 OOM Killer 的“作案记录”。<ul>
<li><strong>检查命令：</strong> <code>dmesg | grep -i &quot;out of memory&quot;</code> 或检查 <code>/var/log/messages</code>、<code>/var/log/syslog</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、内存泄漏的排查方法和工具"><a href="#三、内存泄漏的排查方法和工具" class="headerlink" title="三、内存泄漏的排查方法和工具"></a>三、内存泄漏的排查方法和工具</h3><p>排查内存泄漏遵循一个从宏观到微观的“漏斗模型”：<strong>系统层面 -&gt; 进程层面 -&gt; 代码层面</strong>。</p>
<h4 id="步骤-1：确认是否存在泄漏并定位系统"><a href="#步骤-1：确认是否存在泄漏并定位系统" class="headerlink" title="步骤 1：确认是否存在泄漏并定位系统"></a><strong>步骤 1：确认是否存在泄漏并定位系统</strong></h4><ul>
<li><strong>工具：</strong> <code>free</code>, <code>vmstat</code>, <code>sar</code>, 以及监控系统（如 Prometheus）。</li>
<li><strong>方法：</strong><ol>
<li><strong>长期观察：</strong> 查看监控系统中服务器的<strong>可用内存 (Available Memory)</strong> 历史图表。如果它呈现出随时间推移稳步下降且从不完全恢复的“下坡”趋势，就高度怀疑是内存泄漏。</li>
<li><strong>实时检查：</strong> 使用 <code>free -h</code> 命令，持续关注 <code>available</code> 列的变化。同时，使用 <code>vmstat 1</code> 可以每秒输出一行系统状态，观察 <code>swpd</code> (交换区使用) 和 <code>si</code>, <code>so</code> (换入换出) 列，如果这些值持续很高，说明内存压力巨大。</li>
</ol>
</li>
</ul>
<h4 id="步骤-2：定位具体的泄漏进程"><a href="#步骤-2：定位具体的泄漏进程" class="headerlink" title="步骤 2：定位具体的泄漏进程"></a><strong>步骤 2：定位具体的泄漏进程</strong></h4><p>一旦确认系统存在内存泄漏，下一步就是找出是哪个进程干的。</p>
<ul>
<li><strong>工具：</strong> <code>top</code>, <code>htop</code>, <code>ps</code>。</li>
<li><strong>方法：</strong><ol>
<li><strong><code>top</code> 或 <code>htop</code>：</strong> 在命令行中运行 <code>top</code>，然后按 <code>M</code> (大写) 或 <code>htop</code> 中按 <code>F6</code> 选择 <code>PERCENT_MEM</code>，将进程按内存使用率排序。</li>
<li><strong>观察：</strong> 长期观察列表，哪个进程的 <code>%MEM</code> (内存使用百分比) 和 <code>RES</code> (Resident Memory, 物理内存占用) 在持续、缓慢地增长，那个进程就是最大的嫌疑犯。</li>
<li><strong>静态快照：</strong> 使用 <code>ps aux --sort=-%mem | head -n 10</code> 可以列出当前内存使用最高的前几个进程，适合做成脚本定时记录。</li>
</ol>
</li>
</ul>
<h4 id="步骤-3：深入分析嫌疑进程-关键步骤"><a href="#步骤-3：深入分析嫌疑进程-关键步骤" class="headerlink" title="步骤 3：深入分析嫌疑进程 (关键步骤)"></a><strong>步骤 3：深入分析嫌疑进程 (关键步骤)</strong></h4><p>定位到具体进程后，需要使用更专业的工具来分析其内部的内存分配情况。这通常需要根据进程的开发语言来选择合适的工具。</p>
<ul>
<li><p><strong>对于 C&#x2F;C++ 等编译型语言程序：</strong></p>
<ul>
<li><strong><code>valgrind (memcheck)</code>：</strong><ul>
<li><strong>描述：</strong> 这是最强大的内存调试工具，可以精确报告每一处内存泄漏发生的位置（代码行）。</li>
<li><strong>用法：</strong> <code>valgrind --leak-check=full ./your_program</code>。</li>
<li><strong>缺点：</strong> 它会使程序运行速度降低 10-50 倍，<strong>不适用于生产环境</strong>，通常在开发或测试环境中使用。</li>
</ul>
</li>
<li><strong><code>pmap</code>：</strong><ul>
<li><strong>描述：</strong> 显示一个进程的内存映射。</li>
<li><strong>用法：</strong> <code>pmap -x &lt;PID&gt;</code>。通过定时对同一个进程执行 <code>pmap</code> 并对输出进行 <code>diff</code>，可以发现是哪些内存地址段在持续增长。这能提供一些线索。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对于 Java 程序 (JVM)：</strong></p>
<ul>
<li><strong><code>jmap</code>：</strong><ul>
<li><strong>描述：</strong> JVM 自带的内存映像工具，非常实用。</li>
<li><strong>用法：</strong><ol>
<li><strong>查看堆中对象统计信息：</strong> <code>jmap -histo:live &lt;PID&gt; | head -n 20</code>。这个命令会触发一次 Full GC，然后打印出当前存活对象的直方图。定时执行并 <code>diff</code> 两次的结果，可以清晰地看到哪种类型的对象数量在不断增加。这是<strong>生产环境中最常用的快速定位方法</strong>。</li>
<li><strong>生成堆转储快照 (Heap Dump)：</strong> <code>jmap -dump:live,format=b,file=heap.bin &lt;PID&gt;</code>。这个命令会生成一个完整的堆快照文件。</li>
</ol>
</li>
</ul>
</li>
<li><strong><code>jstat</code>：</strong><ul>
<li><strong>描述：</strong> 监控 JVM 的垃圾回收(GC)活动。</li>
<li><strong>用法：</strong> <code>jstat -gcutil &lt;PID&gt; 1000</code>。观察 <code>E</code> (Eden), <code>S0</code>, <code>S1</code> (Survivor), <code>O</code> (Old Gen) 的使用率和 <code>YGC</code>, <code>FGC</code> (GC次数) 的变化。如果老年代(<code>O</code>)的使用率持续增长且 <code>FGC</code> 后也不下降，就是典型的泄漏迹象。</li>
</ul>
</li>
<li><strong>MAT (Memory Analyzer Tool) 或 VisualVM：</strong><ul>
<li><strong>描述：</strong> 离线分析工具。将 <code>jmap</code> 生成的 <code>heap.bin</code> 文件下载到本地，用这些图形化工具打开进行深入分析。它们可以帮你找到“支配树”（Dominator Tree），直接定位到持有大量内存且无法被回收的对象及其引用链。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对于 Python&#x2F;Node.js&#x2F;Go 等语言：</strong></p>
<ul>
<li>这些语言通常有各自的生态工具，例如 Python 的 <code>tracemalloc</code>, <code>objgraph</code>，Node.js 的 <code>heapdump</code> 模块和 Chrome DevTools。</li>
</ul>
</li>
<li><p><strong>对于内核级别的内存泄漏 (罕见)：</strong></p>
<ul>
<li><strong><code>slabtop</code>：</strong><ul>
<li><strong>描述：</strong> 如果怀疑是内核模块或驱动程序泄漏（非常罕见），可以使用此工具。</li>
<li><strong>用法：</strong> 运行 <code>slabtop -s c</code> 按缓存大小排序，观察是否有某个 slab cache 的 <code>OBJ</code> (对象数) 和 <code>ACTIVE</code> (活动对象) 在不正常地持续增长。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、解决方案和预防"><a href="#四、解决方案和预防" class="headerlink" title="四、解决方案和预防"></a>四、解决方案和预防</h3><ol>
<li><p><strong>短期缓解 (运维侧)：</strong></p>
<ul>
<li><strong>重启服务：</strong> 最简单粗暴但有效的方法是定期重启泄漏的进程，释放其所有占用的内存。这只能作为临时解决方案。</li>
<li><strong>资源隔离和限制：</strong> 使用 cgroups (或通过 Docker&#x2F;Kubernetes) 为进程设置内存上限。当内存使用达到上限时，容器会被 OOM-killed 并自动重启，从而将故障影响限制在单个服务内，避免拖垮整个宿主机。</li>
</ul>
</li>
<li><p><strong>长期根治 (开发侧)：</strong></p>
<ul>
<li><strong>代码修复：</strong> 运维工程师需要将上述排查过程中收集到的证据（如进程名、jmap直方图、heap dump文件、valgrind报告等）提供给开发团队。</li>
<li><strong>开发人员根据这些线索定位到具体的代码逻辑错误并进行修复。</strong></li>
</ul>
</li>
</ol>
<p>作为一名运维工程师，我们的核心职责是<strong>保障系统稳定</strong>，并<strong>高效地定位问题、提供数据</strong>。在内存泄漏问题上，我们的任务就是通过上述工具和方法，准确地找出“元凶”，然后将“案宗”交给“侦探”（开发人员）去破案。</p>
<hr>
<h3 id="场景解读：你在看什么？"><a href="#场景解读：你在看什么？" class="headerlink" title="场景解读：你在看什么？"></a>场景解读：你在看什么？</h3><p><strong>例如：Java 容器内存异常分析，RSS 内存使用率为 53%，WSS 内存使用率为 95%</strong></p>
<p>首先，我们必须精确理解这两个指标的含义，以及它们在容器环境下的特殊性。</p>
<ol>
<li><p><strong>RSS (Resident Set Size - 物理内存使用量):</strong></p>
<ul>
<li><strong>含义：</strong> 这是操作系统内核视角下，该容器（或进程）当前<strong>实际占用</strong>了多少物理内存（RAM）。它包括了 JVM 的堆内存（Heap）、元空间（Metaspace）、JIT 编译缓存、线程栈以及程序加载的本地库（Native Libraries）等所有部分。</li>
<li><strong>关键点：</strong> 这是容器调度器（如 Kubernetes）和 OOM Killer <strong>唯一关心</strong>的指标。当 RSS 超过容器的内存限制 (<code>memory.limit_in_bytes</code>) 时，容器就会被 OOM-killed。</li>
<li><strong>现状（53%）：</strong> 表面上看，容器的物理内存使用量只占了一半多一点的配额，似乎高枕无忧。</li>
</ul>
</li>
<li><p><strong>WSS (Working Set Size - 工作集大小):</strong></p>
<ul>
<li><strong>含义：</strong> 这是 RSS 的一个<strong>子集</strong>，指的是在最近一个时间窗口内，进程<strong>实际访问过（读&#x2F;写）</strong>的内存页。你可以把它理解为“热数据”或“活跃内存”。</li>
<li><strong>关键点：</strong> WSS 是衡量一个应用<strong>内存活跃度</strong>的绝佳指标。它预示了应用在不久的将来最可能需要访问的内存量。</li>
<li><strong>现状（95%）：</strong> 这是问题的<strong>核心</strong>。WSS 占 RSS 的 95%，意味着该容器当前占用的物理内存（那 53% 的配额），几乎全部都是“热”的，正在被高频访问。<strong>几乎没有“冷”的、可以被安全换出或回收的内存。</strong></li>
</ul>
</li>
</ol>
<h3 id="综合分析：危险的信号"><a href="#综合分析：危险的信号" class="headerlink" title="综合分析：危险的信号"></a>综合分析：危险的信号</h3><p>将这两个指标结合起来，我们得到的画像就不再是“内存充裕”，而是“<strong>高度活跃且逼近性能悬崖</strong>”。</p>
<ul>
<li><strong>表象 vs. 实质：</strong> 虽然 RSS 只有 53%，但因为 WSS 高达 95%，说明 Java 应用正在疯狂地使用它已分配到的大部分内存。内存使用效率极高，但反过来说，也<strong>毫无缓冲余地。</strong></li>
<li><strong>潜在风险：</strong><ol>
<li><strong>极易触发 OOM：</strong> 任何一个新的业务请求、一次性的数据加载、甚至是 Full GC 前的内存拷贝，只要需要一点点额外的内存，都会立即导致 RSS 上升。由于没有“冷”内存可供置换，应用会立刻向操作系统申请新的物理内存。RSS 的增长会非常“刚性”，从 53% 迅速攀升，一旦业务流量稍有波动，就可能在短时间内触及 100% 的限制而被杀死。</li>
<li><strong>GC 压力巨大：</strong> 高 WSS 通常意味着堆内对象存活率高，或者新对象分配速度极快。这会导致频繁的 Young GC，并且存活对象会快速晋升到老年代。最终可能引发耗时更长的 Full GC，造成应用卡顿（Stop-the-World）。</li>
<li><strong>性能抖动：</strong> 即使没被 OOM，高内存活跃度也可能导致 minor page faults（当内核需要将之前临时移出的内存页重新载入时），带来微小的性能抖动。</li>
</ol>
</li>
</ul>
<p><strong>结论：该 Java 容器正处于一种“稳定但脆弱”的状态。它当前还能正常工作，但对任何内存需求的增长都极其敏感，离故障（OOM 或性能雪崩）仅一步之遥。</strong></p>
<hr>
<h3 id="排查与行动计划"><a href="#排查与行动计划" class="headerlink" title="排查与行动计划"></a>排查与行动计划</h3><p>作为运维，我们的职责是防患于未然。以下是我的行动步骤：</p>
<h4 id="阶段一：立即行动与数据采集-Ops-Lead"><a href="#阶段一：立即行动与数据采集-Ops-Lead" class="headerlink" title="阶段一：立即行动与数据采集 (Ops Lead)"></a><strong>阶段一：立即行动与数据采集 (Ops Lead)</strong></h4><ol>
<li><p><strong>告警阈值调整：</strong></p>
<ul>
<li>立即为该容器设置更灵敏的告警。除了<code>container_memory_rss &gt; 85%</code>这种常规告警，更应该设置一个<strong>组合告警</strong>或<strong>基于 WSS 的告警</strong>，例如 <code>container_memory_working_set_bytes / container_memory_rss &gt; 0.9 AND container_memory_rss &gt; 50%</code>。这能让我们在危险真正来临前获得预警。</li>
</ul>
</li>
<li><p><strong>关联监控数据：</strong></p>
<ul>
<li><strong>JVM 监控：</strong> 立即查看 APM 系统（如 SkyWalking, Prometheus JMX Exporter）中的 JVM 指标。重点关注：<ul>
<li><strong>堆内存使用率 (Heap Usage)：</strong> 老年代（Old Gen）是否已经很高？</li>
<li><strong>GC 活动 (GC Count &amp; Time)：</strong> <code>Full GC</code> 的频率和耗时是否在增加？<code>Young GC</code> 是否异常频繁？</li>
<li><strong>线程数 (Thread Count)：</strong> 线程数是否过多？（每个线程都有自己的栈，占用 RSS）</li>
</ul>
</li>
<li><strong>业务指标：</strong> 查看应用的 QPS、RT 和错误率。内存问题最终会反映在业务指标上。</li>
</ul>
</li>
<li><p><strong>深入取证 (准备好“弹药”给开发)：</strong></p>
<ul>
<li><p><strong>执行 <code>jstat</code>：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it &lt;pod_name&gt; -c &lt;container_name&gt; -- /bin/bash</span><br><span class="line"><span class="comment"># 找到 Java 进程的 PID</span></span><br><span class="line">ps -ef | grep java</span><br><span class="line"><span class="comment"># 持续观察 GC 情况，每秒一次，共 10 次</span></span><br><span class="line">jstat -gcutil &lt;PID&gt; 1000 10</span><br></pre></td></tr></table></figure>
<p>观察 <code>O</code> (Old Gen) 列是否持续高位，<code>FGC</code> (Full GC 次数) 是否在短时间内增加。</p>
</li>
<li><p><strong>执行 <code>jmap</code> 分析对象：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在非高峰期，或如果情况紧急</span></span><br><span class="line"><span class="comment"># 打印存活对象的直方图，查看是哪种对象占用了最多内存</span></span><br><span class="line">jmap -histo:live &lt;PID&gt; | <span class="built_in">head</span> -n 30</span><br></pre></td></tr></table></figure>
<p>将输出结果保存下来。重复几次，对比是什么对象在持续增长。这是定位内存泄漏的关键证据。</p>
</li>
</ul>
</li>
</ol>
<h4 id="阶段二：问题分析与协同-Ops-Dev"><a href="#阶段二：问题分析与协同-Ops-Dev" class="headerlink" title="阶段二：问题分析与协同 (Ops + Dev)"></a><strong>阶段二：问题分析与协同 (Ops + Dev)</strong></h4><ol>
<li><p><strong>组织分析会：</strong> 将上述收集到的所有数据（RSS&#x2F;WSS 趋势图、JVM 监控截图、<code>jstat</code> 和 <code>jmap</code> 的输出）提交给开发团队。</p>
</li>
<li><p><strong>引导分析方向：</strong></p>
<ul>
<li><strong>场景一：内存泄漏 (Memory Leak)。</strong> 如果 <code>jmap -histo</code> 显示特定业务对象的数量随时间持续增长，且无法被 GC 回收，这基本就是内存泄漏。需要开发人员检查代码，找出是哪里持有了对象的引用。</li>
<li><strong>场景二：内存使用不当 (Inefficient Memory Usage)。</strong><ul>
<li>可能是程序中存在一个巨大的缓存，且缓存内容更新非常频繁，导致 WSS 居高不下。</li>
<li>可能是单个请求处理了过大的数据量（如一次性从数据库查询 100 万条记录到内存中），导致瞬间内存暴增。</li>
<li>可能是 JSON 解析、文件处理等库使用不当，产生了大量临时对象。</li>
</ul>
</li>
<li><strong>场景三：容量不足 (Insufficient Capacity)。</strong> 也许应用本身就是内存密集型的，在当前的业务负载下，它就是需要这么多活跃内存。</li>
</ul>
</li>
</ol>
<h4 id="阶段三：解决方案-Dev-Lead-Ops-Support"><a href="#阶段三：解决方案-Dev-Lead-Ops-Support" class="headerlink" title="阶段三：解决方案 (Dev Lead, Ops Support)"></a><strong>阶段三：解决方案 (Dev Lead, Ops Support)</strong></h4><ol>
<li><p><strong>短期缓解 (Ops)：</strong></p>
<ul>
<li>如果业务非常关键且 OOM 风险极高，作为临时措施，可以<strong>垂直扩容</strong>，即增加容器的 <code>memory.limit</code>。但这只是“续命”，不能解决根本问题。</li>
</ul>
</li>
<li><p><strong>长期根治 (Dev + Ops)：</strong></p>
<ul>
<li><strong>代码优化：</strong> 开发人员根据分析结果修复内存泄漏或优化内存使用逻辑（如使用更小的对象、流式处理数据、优化缓存策略等）。</li>
<li><strong>JVM 调优：</strong><ul>
<li>审视 <code>-Xmx</code>, <code>-Xms</code> 等参数是否合理。</li>
<li>考虑更换垃圾回收器（如 G1GC, ZGC），它们在处理大堆和控制停顿方面有更好的表现。</li>
</ul>
</li>
<li><strong>容量重新评估：</strong> 如果确认是容量问题，需要和开发一起重新评估应用的基准内存需求，并调整容器的 <code>request</code> 和 <code>limit</code>，进行合理的容量规划。</li>
</ul>
</li>
</ol>
<p>通过这样一套组合拳，我们不仅能解决眼前的危机，更能推动应用的健康度和稳定性迈上一个新的台阶。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/">https://huiaz.github.io/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Linux%20%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4/" title="Linux 排查命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux 排查命令</div></div><div class="info-2"><div class="info-item-1">(1) 如何在 Linux 中查看系统资源使用情况？比如内存、CPU、网络端口。  一、 CPU 使用情况1. top 命令 (实时交互式)top 命令是最常用的 CPU 监控工具，它提供了一个实时更新的进程列表，并显示 CPU 使用率、内存使用率、进程 ID (PID)、用户、运行时间等信息。 1top  关键信息解读：  第一行（top line）： load average 显示了过去 1、5、15 分钟的系统平均负载。这是衡量系统忙碌程度的重要指标，数值大于 CPU 核心数时通常表示系统存在瓶颈。 第二行（Tasks）： 显示进程总数，以及运行、睡眠、停止和僵尸进程的数量。 第三行（Cpu(s)）： 显示 CPU 的使用率，各项指标含义如下： us (user): 用户空间程序的 CPU 使用率。 sy (system): 内核空间程序的 CPU 使用率。 ni (nice): 改变过优先级的用户进程的 CPU 使用率。 id (idle): 空闲 CPU 百分比。 wa (iowait): CPU 等待 I&#x2F;O 操作完成的百分比。 hi (hardware i...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20pidstat/" title="Linux pidstat"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux pidstat</div></div><div class="info-2"><div class="info-item-1">pidstat 是 Linux 下 sysstat 工具集中的一个命令，用来监控指定进程（PID）的各种运行指标，常用于排查性能问题。它比 top 更细粒度，可以按进程或线程输出统计信息。  一、基本语法1pidstat [选项] [时间间隔] [次数]   时间间隔：两次采样之间的秒数 次数：采样的次数 如果不加时间间隔和次数，只输出一次快照   二、常用选项 **-u**：显示 CPU 使用情况（默认） **-r**：显示内存使用情况（RSS、VSZ、内存比例等） **-d**：显示 I&#x2F;O 使用情况（读写速率） **-w**：显示上下文切换情况（自愿&#x2F;非自愿） **-t**：显示线程级别统计（默认是进程级别） **-p &lt;pid&gt;**：指定进程 PID（否则显示所有进程） **-h**：以更易读的方式显示时间（hh:mm:ss 格式）   三、示例 监控所有进程的 CPU 使用情况，每隔 2 秒，采集 5 次  1pidstat -u 2 5   监控某个进程（PID&#x3D;1234）的 CPU 和内存情况  1pidstat -u -r...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Linux%20%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4/" title="Linux 排查命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 排查命令</div></div><div class="info-2"><div class="info-item-1">(1) 如何在 Linux 中查看系统资源使用情况？比如内存、CPU、网络端口。  一、 CPU 使用情况1. top 命令 (实时交互式)top 命令是最常用的 CPU 监控工具，它提供了一个实时更新的进程列表，并显示 CPU 使用率、内存使用率、进程 ID (PID)、用户、运行时间等信息。 1top  关键信息解读：  第一行（top line）： load average 显示了过去 1、5、15 分钟的系统平均负载。这是衡量系统忙碌程度的重要指标，数值大于 CPU 核心数时通常表示系统存在瓶颈。 第二行（Tasks）： 显示进程总数，以及运行、睡眠、停止和僵尸进程的数量。 第三行（Cpu(s)）： 显示 CPU 的使用率，各项指标含义如下： us (user): 用户空间程序的 CPU 使用率。 sy (system): 内核空间程序的 CPU 使用率。 ni (nice): 改变过优先级的用户进程的 CPU 使用率。 id (idle): 空闲 CPU 百分比。 wa (iowait): CPU 等待 I&#x2F;O 操作完成的百分比。 hi (hardware i...</div></div></div></a><a class="pagination-related" href="/2025/09/11/LInux%20%E5%AE%89%E5%85%A8/" title="LInux 安全"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">LInux 安全</div></div><div class="info-2"><div class="info-item-1">常见的网络攻击类型1. CC 攻击 (Challenge Collapsar)CC 攻击 是 应用层攻击 的一种，主要针对 Web 服务器的 应用层，通过模拟大量真实用户访问行为，耗尽服务器的处理资源。它的目标是让网站无法正常响应合法用户的请求。 攻击原理：CC 攻击通常会伪造大量的 IP 地址，向目标网站的同一个页面或多个页面发送大量合法的 HTTP 请求。这些请求通常是动态页面（如登录页面、搜索页面、提交表单页面等），因为动态页面的处理需要服务器执行复杂的计算、查询数据库、调用后端程序，这会消耗大量的 CPU、内存和数据库资源。  模拟真实用户行为： 攻击者会模拟用户的 GET 或 POST 请求，可能包括浏览器头、Referer 等信息，使得这些请求看起来像是正常的访问。 高并发请求： 在短时间内发送海量的请求，使服务器的连接数、并发处理能力达到上限。 耗尽服务器资源： 导致服务器处理请求队列堆积，CPU 负载过高，内存耗尽，数据库连接池饱和，最终表现为网站响应缓慢或直接崩溃，无法服务正常用户。  特点：  隐蔽性相对较高： 请求包本身是合法的 HTTP 请求，难以通过简单...</div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-env/" title="Docker ENV"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Docker ENV</div></div><div class="info-2"><div class="info-item-1">|—————- | :———————————- | :———————– | :——————————- || Docker Secrets   | 生产环境的敏感数据 (密码, Keys) | 最高安全性，集中管理 | 仅限 Docker Swarm 模式           || --env-file     | 开发&#x2F;测试环境，大量配置         | 可维护、清晰         | 文件内容默认明文，不适合敏感信息 || -e &#x2F; --env   | 少量、非敏感、临时变量          | 简单直接             | 命令行冗长、暴露配置、不安全     || Dockerfile ENV | 为镜像设置通用的默认值          | 提供开箱即用的默认配置   | 不灵活，不安全，修改需重建镜像   | 我的标准运维流程是：  开发&#x2F;测试环境: 使用 .env 文件（通过 --env-file 加载），并将 .env 文件加入 .gitignore，开发人员各自维护本地配置。 生产环境 (Swarm): 敏感信息: 必...</div></div></div></a><a class="pagination-related" href="/2025/09/11/top/" title="top"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">top</div></div><div class="info-2"><div class="info-item-1">Linux top 命令top 命令是什么？top（Table of Processes 的缩写）是 Linux 和其他类 Unix 操作系统中最常用的性能监控工具之一。它提供了一个动态、实时的系统进程视图，可以帮助系统管理员和开发者监控系统负载、识别资源占用高的进程，从而进行性能分析和故障排查。  top 命令界面详解当您在终端输入 top 并回车后，会看到一个全屏的、持续更新的界面。这个界面主要分为两部分：系统摘要信息区 和 进程列表区。 12345678910top - 14:30:50 up 3 days, 21:22,  1 user,  load average: 0.05, 0.08, 0.09Tasks: 236 total,   1 running, 235 sleeping,   0 stopped,   0 zombie%Cpu(s):  1.5 us,  0.5 sy,  0.0 ni, 98.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :  15833.6 total,   7938.4 free,  ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Linux 操作系统中的进程与线程的区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 操作系统中的进程与线程的区别</div></div><div class="info-2"><div class="info-item-1">Linux 操作系统中的进程与线程的区别 进程 (Process)在 Linux 中，进程 是操作系统进行资源分配的最小单位。它是一个程序的执行实例，拥有独立的内存空间、文件描述符、打开的文件、信号处理、堆栈、程序计数器等资源。每个进程都是相互独立的。 核心特点：  独立性： 每个进程都有自己独立的地址空间，这意味着一个进程的内存崩溃不会直接影响到另一个进程。这提供了强大的隔离性。 资源拥有者： 进程是系统资源的分配单位，它拥有代码段、数据段、堆、栈、文件描述符、信号、权限等。 上下文切换开销大： 进程之间的切换需要保存和恢复完整的上下文（包括所有寄存器、内存映射、打开的文件等），开销相对较大。 通信复杂： 进程间通信（IPC，Inter-Process Communication）需要通过特定的机制（如管道、消息队列、共享内存、信号量、套接字等）进行，相对复杂且通常涉及内核介入。   线程 (Thread)线程 是操作系统进行调度的最小单位。一个进程可以包含一个或多个线程。线程是在进程内部执行的独立序列，它们共享进程的地址空间和大部分资源，但拥有独立的程序计数器、栈、寄存器集合...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20pidstat/" title="Linux pidstat"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux pidstat</div></div><div class="info-2"><div class="info-item-1">pidstat 是 Linux 下 sysstat 工具集中的一个命令，用来监控指定进程（PID）的各种运行指标，常用于排查性能问题。它比 top 更细粒度，可以按进程或线程输出统计信息。  一、基本语法1pidstat [选项] [时间间隔] [次数]   时间间隔：两次采样之间的秒数 次数：采样的次数 如果不加时间间隔和次数，只输出一次快照   二、常用选项 **-u**：显示 CPU 使用情况（默认） **-r**：显示内存使用情况（RSS、VSZ、内存比例等） **-d**：显示 I&#x2F;O 使用情况（读写速率） **-w**：显示上下文切换情况（自愿&#x2F;非自愿） **-t**：显示线程级别统计（默认是进程级别） **-p &lt;pid&gt;**：指定进程 PID（否则显示所有进程） **-h**：以更易读的方式显示时间（hh:mm:ss 格式）   三、示例 监控所有进程的 CPU 使用情况，每隔 2 秒，采集 5 次  1pidstat -u 2 5   监控某个进程（PID&#x3D;1234）的 CPU 和内存情况  1pidstat -u -r...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">一、什么是 Linux 系统中的内存泄漏？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%85%B8%E5%9E%8B%E7%97%87%E7%8A%B6"><span class="toc-number">2.</span> <span class="toc-text">二、内存泄漏的典型症状</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">3.</span> <span class="toc-text">三、内存泄漏的排查方法和工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E7%A1%AE%E8%AE%A4%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%B3%84%E6%BC%8F%E5%B9%B6%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.</span> <span class="toc-text">步骤 1：确认是否存在泄漏并定位系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E5%AE%9A%E4%BD%8D%E5%85%B7%E4%BD%93%E7%9A%84%E6%B3%84%E6%BC%8F%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">步骤 2：定位具体的泄漏进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E5%AB%8C%E7%96%91%E8%BF%9B%E7%A8%8B-%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.3.</span> <span class="toc-text">步骤 3：深入分析嫌疑进程 (关键步骤)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E9%A2%84%E9%98%B2"><span class="toc-number">4.</span> <span class="toc-text">四、解决方案和预防</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%A7%A3%E8%AF%BB%EF%BC%9A%E4%BD%A0%E5%9C%A8%E7%9C%8B%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">场景解读：你在看什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%88%86%E6%9E%90%EF%BC%9A%E5%8D%B1%E9%99%A9%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="toc-number">6.</span> <span class="toc-text">综合分析：危险的信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%92"><span class="toc-number">7.</span> <span class="toc-text">排查与行动计划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E7%AB%8B%E5%8D%B3%E8%A1%8C%E5%8A%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86-Ops-Lead"><span class="toc-number">7.1.</span> <span class="toc-text">阶段一：立即行动与数据采集 (Ops Lead)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E5%8D%8F%E5%90%8C-Ops-Dev"><span class="toc-number">7.2.</span> <span class="toc-text">阶段二：问题分析与协同 (Ops + Dev)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Dev-Lead-Ops-Support"><span class="toc-number">7.3.</span> <span class="toc-text">阶段三：解决方案 (Dev Lead, Ops Support)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>