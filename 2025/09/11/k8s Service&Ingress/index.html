<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>k8s Service&amp;Ingress | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="请解释 Kubernetes 中的 Service 和 Ingress 的区别，并描述各自的用途。	 🤔 分析过程：该问题旨在考察面试者对Kubernetes中两种核心网络资源——Service和Ingress的理解。核心考察点在于它们分别在哪个网络层级工作（L4 vs L7），各自解决了什么问题，以及它们如何协同工作。一个优秀的答案需要清晰地定义两者，对比其功能，并能结合实际应用场景说明何时使">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s Service&amp;Ingress">
<meta property="og:url" content="http://example.com/2025/09/11/k8s%20Service&Ingress/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="请解释 Kubernetes 中的 Service 和 Ingress 的区别，并描述各自的用途。	 🤔 分析过程：该问题旨在考察面试者对Kubernetes中两种核心网络资源——Service和Ingress的理解。核心考察点在于它们分别在哪个网络层级工作（L4 vs L7），各自解决了什么问题，以及它们如何协同工作。一个优秀的答案需要清晰地定义两者，对比其功能，并能结合实际应用场景说明何时使">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:44:10.727Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "k8s Service&Ingress",
  "url": "http://example.com/2025/09/11/k8s%20Service&Ingress/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:44:10.727Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/11/k8s%20Service&amp;Ingress/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'k8s Service&Ingress',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">k8s Service&amp;Ingress</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">k8s Service&amp;Ingress</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:44:10.727Z" title="更新于 2025-09-11 21:44:10">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>请解释 Kubernetes 中的 Service 和 Ingress 的区别，并描述各自的用途。	</p>
<h3 id="🤔-分析过程："><a href="#🤔-分析过程：" class="headerlink" title="🤔 分析过程："></a>🤔 分析过程：</h3><p>该问题旨在考察面试者对Kubernetes中两种核心网络资源——<code>Service</code>和<code>Ingress</code>的理解。核心考察点在于它们分别在哪个网络层级工作（L4 vs L7），各自解决了什么问题，以及它们如何协同工作。一个优秀的答案需要清晰地定义两者，对比其功能，并能结合实际应用场景说明何时使用哪一个。</p>
<h3 id="💡-答案生成："><a href="#💡-答案生成：" class="headerlink" title="💡 答案生成："></a>💡 答案生成：</h3><h4 id="1-概念或定义"><a href="#1-概念或定义" class="headerlink" title="1. 概念或定义"></a>1. 概念或定义</h4><ul>
<li><p><strong>Service (服务):</strong> 是Kubernetes中的一个核心API对象，它定义了一组逻辑上的Pod，并为它们提供了一个单一、稳定的访问入口（一个虚拟IP地址和DNS名称）。<strong>Service主要工作在网络模型的第四层（L4 - TCP&#x2F;UDP）</strong>，它关心的是如何将网络流量可靠地转发到后端的Pod，而不关心流量的具体内容。</p>
</li>
<li><p><strong>Ingress (入口):</strong> 是一个API对象，用于管理对集群内Service的外部访问，<strong>主要工作在网络模型的第七层（L7 - HTTP&#x2F;S）</strong>。Ingress可以提供基于主机名（Host-based）和URL路径（Path-based）的路由、TLS&#x2F;SSL终止以及负载均衡等高级功能。它本身不是一个服务，而是一组路由规则的集合，需要一个<strong>Ingress Controller</strong>来使这些规则生效。</p>
</li>
</ul>
<h4 id="2-工作原理-机制"><a href="#2-工作原理-机制" class="headerlink" title="2. 工作原理&#x2F;机制"></a>2. 工作原理&#x2F;机制</h4><ul>
<li><p><strong>Service 的工作原理:</strong></p>
<ol>
<li>当一个Service被创建时，它会获得一个虚拟的、稳定的IP地址（<code>ClusterIP</code>）。</li>
<li><code>kube-proxy</code>组件在集群的每个节点上运行，它会监视Service和其后端Pod（Endpoints）的变化。</li>
<li><code>kube-proxy</code>会根据这些信息，在节点上配置<code>iptables</code>规则或<code>IPVS</code>规则。</li>
<li>当流量被发送到Service的<code>ClusterIP</code>时，节点的网络协议栈会根据这些规则，将流量进行负载均衡并转发（DNAT）到一个健康的后端Pod的实际IP地址上。</li>
</ol>
</li>
<li><p><strong>Ingress 的工作原理:</strong></p>
<ol>
<li>管理员首先在集群中部署一个<strong>Ingress Controller</strong>（例如 NGINX Ingress Controller, Traefik, HAProxy Ingress等）。Ingress Controller本身是一个或一组Pod，其中运行着一个反向代理和负载均衡器。</li>
<li>当用户创建一个Ingress资源（一个YAML文件，定义了路由规则）时，Ingress Controller会监听到这个资源的创建或变更。</li>
<li>Ingress Controller会解析Ingress资源中的规则（例如，<code>host: foo.bar.com, path: /bar</code> 路由到 <code>service-a</code>）。</li>
<li>然后，Ingress Controller会动态地更新其内部的反向代理配置（如<code>nginx.conf</code>），使其能够根据这些规则来路由外部流量。</li>
<li>外部流量首先到达Ingress Controller的入口（通常是一个<code>LoadBalancer</code>类型的Service），然后由Ingress Controller根据HTTP请求的主机名和路径，将流量智能地转发到对应的后端Service。</li>
</ol>
</li>
</ul>
<h4 id="3-应用场景-作用-核心区别对比"><a href="#3-应用场景-作用-核心区别对比" class="headerlink" title="3. 应用场景&#x2F;作用 (核心区别对比)"></a>3. 应用场景&#x2F;作用 (核心区别对比)</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Service</th>
<th align="left">Ingress</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工作层级</strong></td>
<td align="left"><strong>L4 (TCP&#x2F;UDP)</strong></td>
<td align="left"><strong>L7 (HTTP&#x2F;S)</strong></td>
</tr>
<tr>
<td align="left"><strong>主要作用</strong></td>
<td align="left">在集群内部提供<strong>服务发现</strong>和<strong>负载均衡</strong></td>
<td align="left">提供从集群外部到内部的<strong>HTTP&#x2F;S路由</strong></td>
</tr>
<tr>
<td align="left"><strong>路由能力</strong></td>
<td align="left">只能根据IP和端口进行转发，无法识别HTTP路径或主机名</td>
<td align="left">可根据HTTP主机名和URL路径进行智能路由</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">1. 集群内部微服务之间的通信<br>2. 通过<code>NodePort</code>或<code>LoadBalancer</code>暴露单个非HTTP服务</td>
<td align="left">1. 使用一个公网IP暴露多个HTTP&#x2F;S服务<br>2. 实现灰度发布、蓝绿部署的流量切分<br>3. 集中进行TLS&#x2F;SSL证书管理和卸载</td>
</tr>
<tr>
<td align="left"><strong>依赖关系</strong></td>
<td align="left">Kubernetes核心组件，无需额外部署</td>
<td align="left"><strong>必须依赖一个Ingress Controller</strong>才能工作</td>
</tr>
</tbody></table>
<p><strong>简单来说：</strong> 你需要先有一个<code>Service</code>来暴露你的应用（哪怕只是<code>ClusterIP</code>类型），然后才能创建一个<code>Ingress</code>规则，告诉Ingress Controller“当某个URL被访问时，请把流量转发给这个<code>Service</code>”。</p>
<h4 id="4-优势-劣势（如适用）"><a href="#4-优势-劣势（如适用）" class="headerlink" title="4. 优势&#x2F;劣势（如适用）"></a>4. 优势&#x2F;劣势（如适用）</h4><ul>
<li><p><strong>Service (<code>LoadBalancer</code> 类型) 的劣势:</strong></p>
<ul>
<li><strong>成本高昂:</strong> 每暴露一个<code>LoadBalancer</code>类型的Service，通常都需要云服务商提供一个公网IP和一个负载均衡器实例，这会带来额外的成本。</li>
<li><strong>功能单一:</strong> 只能做简单的L4流量转发，无法满足复杂的路由需求。</li>
</ul>
</li>
<li><p><strong>Ingress 的优势:</strong></p>
<ul>
<li><strong>成本效益高:</strong> 只需一个公网IP（通过Ingress Controller的LoadBalancer），就可以为无数个后端Service提供入口，极大节省了IP资源和成本。</li>
<li><strong>功能强大:</strong> 提供了丰富的L7路由能力，配置灵活，是现代化Web应用架构的事实标准。</li>
</ul>
</li>
</ul>
<h4 id="5-扩展知识-最佳实践"><a href="#5-扩展知识-最佳实践" class="headerlink" title="5. 扩展知识&#x2F;最佳实践"></a>5. 扩展知识&#x2F;最佳实践</h4><ul>
<li><strong>Gateway API:</strong> Ingress正在被功能更强大、角色更清晰的<strong>Gateway API</strong>所逐步取代。Gateway API将路由功能分解为<code>GatewayClass</code>, <code>Gateway</code>和<code>HTTPRoute</code>等角色，使得基础设施团队、集群管理员和应用开发者可以更好地协同工作。了解Gateway API是展现你知识前沿性的一个加分项。</li>
<li><strong>最佳实践:</strong> 在生产环境中，对于需要对外暴露的HTTP&#x2F;S服务，<strong>标准做法</strong>是使用<code>Ingress</code>。后端Service的类型应设置为<code>ClusterIP</code>，而不是<code>NodePort</code>，这样可以避免不必要地在节点上暴露端口，增强安全性。<code>Service (LoadBalancer)</code>通常只用于暴露单个TCP服务（如数据库、消息队列等）。</li>
<li><strong>选择Ingress Controller:</strong> NGINX Ingress Controller因其稳定性和广泛的社区支持成为最常见的选择。Traefik在自动化和动态配置方面表现优异，尤其适合云原生环境。</li>
</ul>
<p><strong>结论：</strong> Service是实现集群内Pod间通信和负载均衡的L4抽象，而Ingress是管理外部HTTP&#x2F;S流量到内部服务的L7路由规则集合，两者协同工作，构成了Kubernetes强大的网络服务暴露能力。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/k8s%20Service&amp;Ingress/">http://example.com/2025/09/11/k8s%20Service&amp;Ingress/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/k8s%20service/" title="k8s service"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">k8s service</div></div><div class="info-2"><div class="info-item-1">Service 主要有以下几种类型：  ClusterIP (默认类型) NodePort LoadBalancer ExternalName  接下来，我将分别详细介绍每种类型及其应用场景。  1. ClusterIP (默认类型) 作用： 为 Service 在 Kubernetes 集群内部分配一个唯一的、虚拟的 IP 地址（ClusterIP）。这个 IP 地址只在集群内部可达。  访问方式： 集群内部的其他 Pod 或组件可以通过这个 ClusterIP 和端口来访问该 Service 后端的 Pod。  特点：  内部可见： 只能在集群内部访问，外部无法直接访问。 负载均衡： Pod 流量通过 kube-proxy 代理转发到后端的 Pod，并自动进行简单的轮询式负载均衡。 稳定性： 提供了稳定的 IP 地址和 DNS 名称， Pod 的 IP 变化不会影响 Service 的可访问性。   使用场景：  内部服务通信： 最常见的用于微服务之间互相调用的场景。例如，前端服务访问后端服务，或其他服务访问数据库服务等。 集群内部调试。   示例 YAML 片段: 1234...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20Rolling%20Update/" title="k8s Rolling Update"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">k8s Rolling Update</div></div><div class="info-2"><div class="info-item-1">描述在 Kubernetes 中如何进行滚动更新和回滚操作。	 🤔 分析过程：此问题考察的是Kubernetes中最重要的功能之一：无停机更新和快速回滚。核心考察点是Deployment控制器如何通过管理ReplicaSet来实现这一过程。一个优秀的回答需要清晰地阐述”滚动更新”的内部机制（特别是maxSurge和maxUnavailable参数）、回滚是如何利用历史版本（旧的ReplicaSet）实现的，并能提供完整的命令行操作示例。 💡 答案生成：1. 概念或定义 滚动更新 (Rolling Update): 是Kubernetes中默认的部署策略，旨在实现零停机时间（Zero-Downtime）的应用升级。它通过逐个地用新版本的Pod替换旧版本的Pod，而不是一次性地销毁所有旧Pod再创建新Pod，从而保证在整个更新过程中，应用服务始终是可用的。  回滚 (Rollback): 是一个恢复操作。当新版本的应用部署后出现问题时，回滚操作可以将应用快速地恢复到之前一个稳定、可用的版本。Kubernetes通过保留历史部署版本（以ReplicaSet的形式）来实现这一功能。 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/k8s_10/" title="k8s_10"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s_10</div></div><div class="info-2"><div class="info-item-1">请描述 Kubernetes 中的 Helm 的作用，并解释其使用场景。Of course. Helm is an indispensable tool in the Kubernetes ecosystem, and understanding its role is crucial for anyone managing applications at scale. Let’s dive into its purpose and common use cases. 🤔 分析过程：此问题旨在考察对Kubernetes应用部署和管理工具——Helm的理解。一个优秀的回答不能仅仅说“它是一个包管理器”，而需要深入解释它解决了什么核心痛点。核心痛点是：Kubernetes原生YAML文件缺乏模板化、版本控制和依赖管理能力，导致在多环境、复杂应用场景下难以管理。因此，回答的重点应围绕Helm如何通过打包（Charts）、模板化（Templating）和版本发布（Releases）来解决这些问题。 💡 答案生成：1. 概念或定义Helm 是Kubernetes的官方包管理器。它可以被...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Karmada/" title="Karmada"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Karmada</div></div><div class="info-2"><div class="info-item-1">Kubernetes 多集群管理系统 KarmadaKarmada（Kubernetes Armada）是 CNCF 孵化的一个 Kubernetes 管理系统，使您能够在多个 Kubernetes 集群和云中运行云原生应用程序，而无需更改应用程序。通过使用 Kubernetes 原生 API 并提供先进的调度功能，Karmada 实现了真正的开放式、多云 Kubernetes。  Karmada 旨在为多云和混合云场景下的多集群应用程序管理提供即插即用的自动化，具有集中式多云管理、高可用性、故障恢复和流量调度等关键功能。 特性 兼容 K8s 原生 API 从单集群到多集群的无侵入式升级 现有 K8s 工具链的无缝集成   开箱即用 针对场景内置策略集，包括：Active-active、Remote DR、Geo Redundant 等。 在多集群上进行跨集群应用程序自动伸缩、故障转移和负载均衡。   避免供应商锁定 与主流云提供商集成 在集群之间自动分配、迁移 未绑定专有供应商编排   集中式管理 位置无关的集群管理 支持公有云、本地或边缘上的集群。   丰富多集群调度策略 集...</div></div></div></a><a class="pagination-related" href="/2025/09/11/kube-state-metrics/" title="kube-state-metrics"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">kube-state-metrics</div></div><div class="info-2"><div class="info-item-1">kube-state-metrics上面我们配置了自动发现 Endpoints 的监控，但是这些监控数据都是应用内部的监控，需要应用本身提供一个 /metrics 接口，或者对应的 exporter 来暴露对应的指标数据，但是在 Kubernetes 集群上 Pod、DaemonSet、Deployment、Job、CronJob 等各种资源对象的状态也需要监控，这也反映了使用这些资源部署的应用的状态。比如：  我调度了多少个副本？现在可用的有几个？ 多少个 Pod 是 running/stopped/terminated 状态？ Pod 重启了多少次？ 我有多少 job 在运行中等等  通过查看前面从集群中拉取的指标(这些指标主要来自 apiserver 和 kubelet 中集成的 cAdvisor)，并没有具体的各种资源对象的状态指标。对于 Prometheus 来说，当然是需要引入新的 exporter 来暴露这些指标，Kubernetes 提供了一个kube-state-metrics 就是我们需要的。kube-state-metrics 关注于获取 Kubernete...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Descheduler/" title="Descheduler"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Descheduler</div></div><div class="info-2"><div class="info-item-1">Descheduler从 kube-scheduler 的角度来看，它是通过一系列算法计算出最佳节点运行 Pod，当出现新的 Pod 进行调度时，调度程序会根据其当时对 Kubernetes 集群的资源描述做出最佳调度决定，但是 Kubernetes 集群是非常动态的，由于整个集群范围内的变化，比如一个节点为了维护，我们先执行了驱逐操作，这个节点上的所有 Pod 会被驱逐到其他节点去，但是当我们维护完成后，之前的 Pod 并不会自动回到该节点上来，因为 Pod 一旦被绑定了节点是不会触发重新调度的，由于这些变化，Kubernetes 集群在一段时间内就可能会出现不均衡的状态，所以需要均衡器来重新平衡集群。 当然我们可以去手动做一些集群的平衡，比如手动去删掉某些 Pod，触发重新调度就可以了，但是显然这是一个繁琐的过程，也不是解决问题的方式。为了解决实际运行中集群资源无法充分利用或浪费的问题，可以使用 descheduler 组件对集群的 Pod 进行调度优化，descheduler 可以根据一些规则和配置策略来帮助我们重新平衡集群状态，其核心原理是根据其策略配置找到可以被移除的 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E7%9B%B4%E6%96%B9%E5%9B%BE/" title="直方图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">直方图</div></div><div class="info-2"><div class="info-item-1">直方图在这一节中，我们将学习直方图指标，了解如何根据这些指标来计算分位数。Prometheus 中的直方图指标允许一个服务记录一系列数值的分布。直方图通常用于跟踪请求的延迟或响应大小等指标值，当然理论上它是可以跟踪任何根据某种分布而产生波动数值的大小。Prometheus 直方图是在客户端对数据进行的采样，它们使用的一些可配置的（例如延迟）bucket 桶对观察到的值进行计数，然后将这些 bucket 作为单独的时间序列暴露出来。 下图是一个非累积直方图的例子：  在 Prometheus 内部，直方图被实现为一组时间序列，每个序列代表指定桶的计数（例如10ms以下的请求数、25ms以下的请求数、50ms以下的请求数等）。 在 Prometheus 中每个 bucket 桶的计数器是累加的，这意味着较大值的桶也包括所有低数值的桶的计数。在作为直方图一部分的每个时间序列上，相应的桶由特殊的 le 标签表示。le 代表的是小于或等于。 与上面相同的直方图在 Prometheus 中的累积直方图如下所示：  可以看到在 Prometheus 中直方图的计数是累计的，这是很奇怪的，因为通...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%96%B0/" title="证书更新"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">证书更新</div></div><div class="info-2"><div class="info-item-1">更新一个10年有效期的 Kubernetes 证书使用 kubeadm 安装 kubernetes 集群非常方便，但是也有一个比较烦人的问题就是默认的证书有效期只有一年时间，所以需要考虑证书升级的问题，本文的演示集群版本为 v1.16.2 版本，不保证下面的操作对其他版本也适用，在操作之前一定要先对证书目录进行备份，防止操作错误进行回滚。本文主要介绍两种方式来更新集群证书。 手动更新证书由 kubeadm 生成的客户端证书默认只有一年有效期，我们可以通过 check-expiration 命令来检查证书是否过期： 123456789101112$ kubeadm alpha certs check-expirationCERTIFICATE                EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGEDadmin.conf                 Nov 07, 2020 11:59 UTC   73d             noapiserver                  N...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%94-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">🤔 分析过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E7%AD%94%E6%A1%88%E7%94%9F%E6%88%90%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">💡 答案生成：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5%E6%88%96%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">1. 概念或定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">2. 工作原理&#x2F;机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-%E4%BD%9C%E7%94%A8-%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.</span> <span class="toc-text">3. 应用场景&#x2F;作用 (核心区别对比)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BC%98%E5%8A%BF-%E5%8A%A3%E5%8A%BF%EF%BC%88%E5%A6%82%E9%80%82%E7%94%A8%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">4. 优势&#x2F;劣势（如适用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.5.</span> <span class="toc-text">5. 扩展知识&#x2F;最佳实践</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>