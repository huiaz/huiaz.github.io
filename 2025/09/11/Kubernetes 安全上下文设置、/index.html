<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kubernetes 安全上下文设置、 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Kubernetes 安全上下文设置在 Kubernetes 中安全地运行工作负载是很困的，有很多配置都可能会影响到整个 Kubernetes API 的安全性，这需要我们有大量的知识积累来正确的实施。Kubernetes 在安全方面提供了一个强大的工具 securityContext，每个 Pod 和容器清单都可以使用这个属性。在本文中我们将了解各种 securityContext 的配置，探讨">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes 安全上下文设置、">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/Kubernetes%20%E5%AE%89%E5%85%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E7%BD%AE%E3%80%81/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="Kubernetes 安全上下文设置在 Kubernetes 中安全地运行工作负载是很困的，有很多配置都可能会影响到整个 Kubernetes API 的安全性，这需要我们有大量的知识积累来正确的实施。Kubernetes 在安全方面提供了一个强大的工具 securityContext，每个 Pod 和容器清单都可以使用这个属性。在本文中我们将了解各种 securityContext 的配置，探讨">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:46:00.404Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kubernetes 安全上下文设置、",
  "url": "https://huiaz.github.io/2025/09/11/Kubernetes%20%E5%AE%89%E5%85%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E7%BD%AE%E3%80%81/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:46:00.404Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/Kubernetes%20%E5%AE%89%E5%85%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E7%BD%AE%E3%80%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kubernetes 安全上下文设置、',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Kubernetes 安全上下文设置、</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Kubernetes 安全上下文设置、</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:46:00.404Z" title="更新于 2025-09-11 21:46:00">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Kubernetes-安全上下文设置"><a href="#Kubernetes-安全上下文设置" class="headerlink" title="Kubernetes 安全上下文设置"></a>Kubernetes 安全上下文设置</h1><p>在 Kubernetes 中安全地运行工作负载是很困的，有很多配置都可能会影响到整个 Kubernetes API 的安全性，这需要我们有大量的知识积累来正确的实施。Kubernetes 在安全方面提供了一个强大的工具 <code>securityContext</code>，每个 Pod 和容器清单都可以使用这个属性。在本文中我们将了解各种 <code>securityContext</code> 的配置，探讨它们的含义，以及我们应该如何使用它们。</p>
<blockquote>
<p><code>securityContext</code> 设置在 <code>PodSpec</code> 和<code>ContainerSpec</code> 规范中都有定义，这里我们分别用<code>[P]</code>和<code>[C]</code>来表示。需要注意的是，如果一个设置在两个作用域中都可以使用和配置，那么我们应该优先考虑设置容器级别的。</p>
</blockquote>
<h2 id="1-runAsNonRoot-P-C"><a href="#1-runAsNonRoot-P-C" class="headerlink" title="1. runAsNonRoot [P&#x2F;C]"></a>1. runAsNonRoot [P&#x2F;C]</h2><p>我们知道容器是使用 namespaces 和 cgroups 来限制其进程，但只要在部署的时候做了一次错误的配置，就可以让这些进程访问主机上的资源。如果该进程以 root 身份运行，它对这些资源的访问权限与主机 root 账户是相同的。此外，如果其他 pod 或容器设置被用来减少约束（比如 <code>procMount</code> 或 <code>capabilities</code>），拥有一个 <code>root UID</code> 就会提高风险，除非你有一个非常好的原因，否则你不应该以 root 身份运行一个容器。</p>
<p>那么，如果你有一个使用 root 的镜像需要部署，那应该怎么办呢？</p>
<h3 id="1-1-使用基础镜像中提供的用户"><a href="#1-1-使用基础镜像中提供的用户" class="headerlink" title="1.1 使用基础镜像中提供的用户"></a>1.1 使用基础镜像中提供的用户</h3><p>通常情况下，基础镜像已经创建并提供了一个用户，例如，官方的 Node.js 镜像带有一个 UID 为 1000 的名为 node 的用户，我们就可以使用该身份来运行容器，但他们并没有在 <code>Dockerfile</code> 中明确地设置当前用户。我们可以在运行时用 <code>runAsUser</code> 设置来配置它，或者用自定义的 <code>Dockerfile</code> 来更改镜像中的当前用户。这里我们来看看使用自定义的 <code>Dockerfile</code> 来构建我们自己的镜像的例子。</p>
<p>在不深入了解镜像构建的情况下，让我们假设我们有一个预先构建好的 npm 应用程序。这里是一个最小的 Dockerfile 文件，用来构建一个基于 <code>node:slim</code> 的镜像，并以提供的 node 用户身份运行。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=node . /home/node/app/   <span class="comment"># &lt;--- Copy app into the home directory with right ownership</span></span></span><br><span class="line"><span class="keyword">USER</span> <span class="number">1000</span>                             <span class="comment"># &lt;--- Switch active user to “node” (by UID)</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/node/app                <span class="comment"># &lt;--- Switch current directory to app</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]           <span class="comment"># &lt;--- This will now exec as the “node” user instead of root</span></span></span><br></pre></td></tr></table></figure>

<p>其中以 USER 开头的一行就是关键设置，这使得 node 成为从这个镜像启动的任何容器里面的默认用户。我们使用 UID 而不是用户的名字，因为 Kubernetes 无法在启动容器前将镜像的默认用户名映射到 UID 上，并且在部署时指定 <code>runAsNotRoot: true</code>，会返回有关错误。</p>
<h3 id="1-2-基础镜像没有提供用户"><a href="#1-2-基础镜像没有提供用户" class="headerlink" title="1.2 基础镜像没有提供用户"></a>1.2 基础镜像没有提供用户</h3><p>如果我们使用的基础镜像没有提供一个可以使用的用户，那么我们又应该怎么做呢？对于大部分进程来说，我们只需在自定义的 Dockerfile 中创建一个用户并使用它即可。如下所示：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd somebody -u 10001 --create-home --user-group  <span class="comment"># &lt;--- Create a user</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=somebody . /home/somebody/app/</span></span><br><span class="line"><span class="keyword">USER</span> <span class="number">10001</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/somebody/app</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>这里我们增加了一行创建用户的 <code>RUN</code> 命令即可。不过需要注意的是这对于 <code>node.js</code> 和 <code>npm</code> 来说，这很好用，但是其他工具可能需要文件系统的不同元素进行所有权变更。如果遇到任何问题，需要查阅对应工具的文档。</p>
<h2 id="2-runAsUser-runAsGroup-P-C"><a href="#2-runAsUser-runAsGroup-P-C" class="headerlink" title="2. runAsUser&#x2F;runAsGroup [P&#x2F;C]"></a>2. runAsUser&#x2F;runAsGroup [P&#x2F;C]</h2><p>容器镜像可能有一个特定的用户或组，我们可以用 <code>runAsUser</code> 和 <code>runAsGroup</code> 来进行覆盖。通常，这些设置与包含具有相同所有权 ID 的文件的卷挂载结合在一起。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">....</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mycorp/webapp:1.2.3</span></span><br><span class="line">  <span class="attr">securityContext:</span></span><br><span class="line">    <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">runAsUser:</span> <span class="number">10001</span></span><br><span class="line"><span class="string">....</span></span><br></pre></td></tr></table></figure>

<p>不过使用这些配置也是有风险的，因为你为容器做出的运行时决定可能与原始镜像不兼容。例如，<code>jenkins/jenkins</code> 镜像以名为 <code>jenkins:jenkins</code> 的<strong>组:用户</strong>身份运行，其应用文件全部由该用户拥有。如果我们配置一个不同的用户，它将无法启动，因为该用户不存在于镜像的 <code>/etc/passwd</code> 文件中。即使它以某种方式存在，它也很可能在读写 <code>jenkins:jenkins</code> 拥有的文件时出现问题。我们可以用一个简单的 docker 运行命令来验证这个问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --<span class="built_in">rm</span> -it -u eric:eric jenkins/jenkins</span></span><br><span class="line">docker: Error response from daemon: unable to find user eric: no matching entries in passwd file.</span><br></pre></td></tr></table></figure>

<p>上面我们提到确保容器进程不以 root 用户身份运行是一个非常好的主意，但不要依赖 <code>runAsUser</code> 或 <code>runAsGroup</code> 设置来保证这一点，未来有人可能会删除这些配置，请确保同时将 <code>runAsNonRoot</code> 设置为 true。</p>
<h2 id="3-seLinuxOptions-P-C"><a href="#3-seLinuxOptions-P-C" class="headerlink" title="3. seLinuxOptions [P&#x2F;C]"></a>3. seLinuxOptions [P&#x2F;C]</h2><p><code>SELinux</code> 是一个用于控制对 Linux 系统上的应用、进程和文件进行访问的策略驱动系统，它在 Linux 内核中实现了 Linux 安全模块框架。SELinux 是基于标签的策略，它将一些标签应用于系统中的所有元素，然后将元素进行分组。这些标签被称为<strong>安全上下文</strong>（不要和 Kubernetes 中的 <code>securityContext</code> 混淆了）- 由用户、角色、类型和可选的一些其他属性组成，格式为：<code>user:role:type:level</code>。</p>
<p>然后，SELinux 使用策略来定义特定上下文中的哪些进程可以访问系统中其他被标记的对象。SELinux 可以是严格执行 <code>enforced</code> 模式，在这种情况下，访问将被拒绝，如果被配置为允许的 <code>permissive</code> 模式，那么安全策略没有被强制执行，当安全策略规则应该拒绝访问时，访问仍然被允许，然而，此时会向日志文件发送一条消息，表示该访问应该被拒绝。在容器中，SELinux 通常给容器进程和容器镜像打上标签，以限制该进程只能访问镜像中的文件。</p>
<p>默认的 SELinux 策略将在实例化容器时由容器运行时应用，<code>securityContext</code> 中的 <code>seLinuxOptions</code> 允许配置自定义的 SELinux 策略标签，请注意，改变容器的 SELinux 策略标签有可能允许容器进程摆脱容器镜像并访问主机文件系统。</p>
<p>当然只有当宿主机操作系统支持 SELinux 时，这个功能才会起作用。</p>
<h2 id="4-seccompProfile-P-C"><a href="#4-seccompProfile-P-C" class="headerlink" title="4. seccompProfile [P&#x2F;C]"></a>4. seccompProfile [P&#x2F;C]</h2><p><code>Seccomp</code> 表示一种安全计算模式，是 Linux 内核的一项功能，它可以限制一个特定进程从用户空间到内核的调用。seccomp 配置文件是使用一个 JSON 文件进行定义的，通常由一组系统调用和发生这些系统调用时的默认动作组成。如下配置所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;defaultAction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCMP_ACT_ERRNO&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;architectures&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;SCMP_ARCH_X86_64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;SCMP_ARCH_X86&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;SCMP_ARCH_X32&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;syscalls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;accept&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCMP_ACT_ALLOW&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;accept4&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCMP_ACT_ALLOW&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>Kubernetes 通过在 <code>securityContext</code> 中的 <code>seccompProfile</code> 属性来提供一个使用自定义配置文件的机制。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seccompProfile:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">Localhost</span></span><br><span class="line">  <span class="attr">localhostProfile:</span> <span class="string">profiles/myprofile.json</span></span><br></pre></td></tr></table></figure>

<p>这里配置的 <code>type</code> 字段有三个可选的值：</p>
<ul>
<li><code>Localhost</code>：其中 <code>localhostProfile</code> 配置为容器内的 <code>seccomp</code> 配置文件路径。</li>
<li><code>Unconfined</code>：其中没有配置文件。</li>
<li><code>RuntimeDefault</code>：其中使用容器运行时的默认值–如果没有指定类型，就是默认值。</li>
</ul>
<p>我们可以在 <code>PodSecurityContext</code> 或 <code>securityContext</code> 中使用这些配置，如果两者都配置了，就会使用容器级别中的配置。</p>
<p>此外与大多数安全相关的设置一样，<strong>最小权限原则</strong>在此同样适用。只给你的容器访问它所需要的权限即可。首先创建一个配置文件，简单地记录哪些系统调用正在发生，然后测试你的应用程序，建立一套允许的系统调用规则。我们可以在 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/clusters/seccomp">Kubernetes 教程</a>中找到关于 <code>Seccomp</code> 的更多信息。</p>
<h2 id="5-避免使用特权容器-C"><a href="#5-避免使用特权容器-C" class="headerlink" title="5. 避免使用特权容器 [C]"></a>5. 避免使用特权容器 [C]</h2><p>给容器授予特权模式是非常危险的，一般会有一种更简单的方式来实现特定的权限，或者可以通过授予 <code>Linux Capabilities</code> 权限来控制。容器运行时控制器着特权模式的具体实现，但是它会授予容器所有的特权，并解除由 cgroup 控制器执行的限制，它还可以修改 Linux 安全模块的配置，并允许容器内的进程逃离容器。</p>
<p>容器在宿主机中提供了进程隔离，所以即使容器是使用 root 身份运行的，也有容器运行时不授予容器的 <code>Capabilities</code>。如果配置了特权模式，容器运行时就会授予系统 root 的所有能力，从安全角度来看，这是很危险的，因为它允许对底层宿主机系统的所有操作访问。</p>
<p>避免使用特权模式，如果你的容器确实需要额外的能力，只需通过添加 <code>capabilities</code> 来满足你的需求。除非你的容器需要控制主机内核中的系统级设置，如访问特定的硬件或重新配置网络，并且需要访问主机文件系统，那么它就不需要特权模式。</p>
<h2 id="6-Linux-Capabilities-C"><a href="#6-Linux-Capabilities-C" class="headerlink" title="6. Linux Capabilities [C]"></a>6. Linux Capabilities [C]</h2><p><code>Capabilities</code> 是一个内核级别的权限，它允许对内核调用权限进行更细粒度的控制，而不是简单地以 root 身份运行。<code>Capabilities</code> 包括更改文件权限、控制网络子系统和执行系统管理等功能。在 <code>securityContext</code> 中，Kubernetes 可以添加或删除 <code>Capabilities</code>，单个 <code>Capabilities</code> 或逗号分隔的列表可以作为一个字符串数组进行配置。另外，我们也可以使用 <code>all</code> 来添加或删除所有的配置。这种配置会被传递给容器运行时，在它创建容器的时候会配置上 <code>Capabilities</code> 集合，如果 <code>securityContext</code> 中没有配置，那么容器将会直接容器运行时提供的所有默认配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">securityContext:</span></span><br><span class="line">  <span class="attr">capabilities:</span></span><br><span class="line">    <span class="attr">drop:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">all</span></span><br><span class="line">    <span class="attr">add:</span> [<span class="string">&quot;MKNOD&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>一般推荐的做法是先删除所有的配置，然后只添加你的应用程序实际需要的，在大部分情况下，应用程序在正常运行中实际上不需要任何 <code>Capabilities</code>，通过删除所有配置来测试，并通过监控审计日志来调试问题，看看哪些功能被阻止了。</p>
<p>请注意，当在 <code>securityContext</code> 中列出要放弃或添加的 <code>Capabilities</code> 时，你要删除内核在命名 <code>Capabilities</code> 时使用的 <code>CAP_</code> 前缀。<code>capsh</code> 工具可以给我们一个比较友好的调试信息，可以来说明你的容器中到底启用了哪些 <code>Capabilities</code>，当然不要在生产容器中使用这个工具，因为这使得攻击者很容易弄清楚哪些 <code>Capabilities</code> 被启用了。</p>
<h2 id="7-以只读文件系统运行-C"><a href="#7-以只读文件系统运行-C" class="headerlink" title="7. 以只读文件系统运行 [C]"></a>7. 以只读文件系统运行 [C]</h2><p>如果你的容器被入侵，而且它有一个可读写的文件系统，那么攻击者就可以随意地改变它的配置、安装软件，并有可能启动其他的漏洞。拥有一个只读的文件系统有助于防止这些类型的安全问题，因为它限制了攻击者可以执行的操作。一般来说，容器不应该要求对容器文件系统进行写入，如果你的应用程序是有状态数据，那么你应该使用外部持久化方法，如数据库、volume 或其他一些服务。另外，确保所有的日志都写到 stdout 或日志转发器上。</p>
<h2 id="8-procMount-C"><a href="#8-procMount-C" class="headerlink" title="8. procMount [C]"></a>8. procMount [C]</h2><p>默认情况下，为了防止潜在的安全问题，容器运行时会屏蔽容器内 <code>/proc</code> 文件系统的某些部分文件。然而有时需要访问 <code>/proc</code> 的这些文件，特别是在使用嵌套容器时，因为它经常被用作集群内构建过程的一部分。该配置只有两个有效的选项：</p>
<ul>
<li><code>Default</code>：保持标准的容器运行时行为</li>
<li><code>Unmasked</code>：它删除 <code>/proc</code> 文件系统的所有屏蔽行为</li>
</ul>
<p>显然只有当我们知道在做什么的时候才应该使用这个配置，如果你是为了构建镜像而使用它，请检查构建工具的最新版本，因为许多工具不再需要这个设置了，最好升级下工具并设置为 <code>Default</code> 默认的 <code>procMount</code>。</p>
<h2 id="9-fsGroup-fsGroupChangePolicy-P"><a href="#9-fsGroup-fsGroupChangePolicy-P" class="headerlink" title="9. fsGroup&#x2F;fsGroupChangePolicy [P]"></a>9. fsGroup&#x2F;fsGroupChangePolicy [P]</h2><p><code>fsGroup</code> 设置定义了一个组，当卷被 pod 挂载时，Kubernetes 将把卷中所有文件的权限改为该组。这里的行为也由 <code>fsGroupChangePolicy</code> 控制，它可以被设置为 <code>onRootMismatch</code> 或 <code>Always</code>。如果设置为 <code>onRootMismatch</code> 则只有当权限与容器 root 的权限不匹配时才会被改变。</p>
<p>不过在使用 <code>fsGroup</code> 时也要慎重，改变整个 volume 卷的组所有权会导致<strong>变慢</strong>，如果是大型文件系统<strong>启动也会延迟</strong>。如果共享同一卷的其他进程没有对新的 GID 的访问权限，它也会对这些进程造成损害。由于这个原因，一些共享文件系统如 NFS，没有实现这个功能。这些设置也不影响临时的 ephemeral 卷。</p>
<h2 id="10-sysctls-P"><a href="#10-sysctls-P" class="headerlink" title="10. sysctls [P]"></a>10. sysctls [P]</h2><p><code>Sysctls</code> 是 Linux 内核的一个功能，它允许管理员修改内核配置。在一个完整的 Linux 操作系统中，这些是通过使用 <code>/etc/sysctl.conf</code> 定义的，也可以使用 <code>sysctl</code> 工具进行修改。</p>
<p><code>securityContext</code> 中的 <code>sysctls</code> 配置允许在容器中修改特定的 <code>sysctls</code>。只有一小部分的 <code>sysctls</code> 可以在每个容器的基础上进行修改，它们都在内核中被命名的。 在这个可以配置的子集中，有些被认为是安全的，而更多的则被认为是不安全的，这取决于对其他 pod 的潜在影响。在集群中，不安全的 <code>sysctls</code> 通常是被禁用，需要由集群管理员专门开启。</p>
<p>鉴于有可能破坏底层操作系统的稳定，除非你有非常特殊的要求，否则应该避免通过 <code>sysctls</code> 修改内核参数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在用 <code>securityContext</code> 加固你的应用时，有很多事情需要注意。如果使用得当，它们是一种非常有效的工具，我们希望这个列表能帮助你的团队为你的工作负载和环境进行正确的安全配置。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/Kubernetes%20%E5%AE%89%E5%85%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E7%BD%AE%E3%80%81/">https://huiaz.github.io/2025/09/11/Kubernetes%20%E5%AE%89%E5%85%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E7%BD%AE%E3%80%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Linux%20tcpdump%20%E5%91%BD%E4%BB%A4/" title="Linux tcpdump 命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux tcpdump 命令</div></div><div class="info-2"><div class="info-item-1">作为一名运维工程师，tcpdump 是我进行网络故障排查和性能分析时不可或缺的“瑞士军刀”。它是一个基于命令行的数据包捕获工具，能够截获并显示通过网络接口的数据包。无论是在诊断网络连接问题、分析协议行为、检测异常流量，还是验证防火墙规则时，tcpdump 都扮演着至关重要的角色。  一、tcpdump 简介 功能： 捕获网络接口上符合指定条件的数据包，并将其内容打印到标准输出或保存到文件中。 原理： tcpdump 使用 libpcap 库来与网络接口进行交互，接收、过滤和解析流经接口的数据包。它工作在数据链路层，能够看到IP层及以上的所有协议数据。 应用场景： 诊断连通性问题： 验证客户端&#x2F;服务器之间是否有数据包传输。 分析协议行为： 深入了解 HTTP、DNS、SSH 等协议的具体交互过程。 排查防火墙问题： 确认流量是否被防火墙阻拦。 检测异常流量： 发现端口扫描、拒绝服务攻击（DoS）的迹象。 性能瓶颈分析： 识别延迟、丢包等网络性能问题。 验证流量转发： 检查路由和 NAT 是否按预期工作。 安全审计： 监控关键系统的网络活动。     二、tcpdump 的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E4%B8%AD%20df%20%E4%B8%8E%20du%20%E5%8C%BA%E5%88%AB/" title="Linux 中 df 与 du 区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux 中 df 与 du 区别</div></div><div class="info-2"><div class="info-item-1">df 和 du 是日常工作中用于查看磁盘使用情况的两个最基本也是最重要的命令。它们都与磁盘空间有关，但它们的工作原理、关注点以及提供的信息维度截然不同。理解这两者的区别至关重要，因为它能帮助我们准确地判断磁盘空间问题，而不是被表象所迷惑。  一、df (disk free)df 命令用于报告文件系统的磁盘空间使用情况。它读取的是文件系统的超级块（superblock）信息，反映的是文件系统层面上的整体空间统计。 1. 核心特点： 报告文件系统总览： 关注的是整个文件系统（分区、挂载点）的使用情况。 读取文件系统元数据： 它直接查询文件系统的元数据（如 inode 表、块位图等），来得知已用、可用空间和总容量。 速度快： 由于只读取元数据，不遍历文件，所以执行速度通常很快。 计算已挂载文件系统： 只能报告已挂载的文件系统，包括本地磁盘、网络文件系统（NFS, Samba&#x2F;CIFS）、虚拟文件系统等。 显示已分配但未释放的空间： 如果文件被删除但仍被进程占用（即文件句柄未释放），df 会将这部分空间计入“已用”空间，因为它对文件系统来说这部分空间是“被占用的”。  2. 常...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/k8s%20Rolling%20Update/" title="k8s Rolling Update"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s Rolling Update</div></div><div class="info-2"><div class="info-item-1">描述在 Kubernetes 中如何进行滚动更新和回滚操作。	 🤔 分析过程：此问题考察的是Kubernetes中最重要的功能之一：无停机更新和快速回滚。核心考察点是Deployment控制器如何通过管理ReplicaSet来实现这一过程。一个优秀的回答需要清晰地阐述”滚动更新”的内部机制（特别是maxSurge和maxUnavailable参数）、回滚是如何利用历史版本（旧的ReplicaSet）实现的，并能提供完整的命令行操作示例。 💡 答案生成：1. 概念或定义 滚动更新 (Rolling Update): 是Kubernetes中默认的部署策略，旨在实现零停机时间（Zero-Downtime）的应用升级。它通过逐个地用新版本的Pod替换旧版本的Pod，而不是一次性地销毁所有旧Pod再创建新Pod，从而保证在整个更新过程中，应用服务始终是可用的。  回滚 (Rollback): 是一个恢复操作。当新版本的应用部署后出现问题时，回滚操作可以将应用快速地恢复到之前一个稳定、可用的版本。Kubernetes通过保留历史部署版本（以ReplicaSet的形式）来实现这一功能。 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Security%20Context/" title="Security Context"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Security Context</div></div><div class="info-2"><div class="info-item-1">Security Context 我们有时候在运行一个容器的时候，可能需要使用 sysctl 命令来修改内核参数，比如 net、vm、kernel 等参数，但是 systcl 需要容器拥有超级权限，才可以使用，在 Docker 容器启动的时候我们可以加上 --privileged 参数来使用特权模式。那么在 Kubernetes 中应该如何来使用呢？ 这个时候我们就需要使用到 Kubernetes 中的 Security Context，也就是常说的安全上下文，主要是来限制容器非法操作宿主节点的系统级别的内容，使得节点的系统或者节点上其他容器组受到影响。Kubernetes 提供了三种配置安全上下文级别的方法：  Container-level Security Context：仅应用到指定的容器 Pod-level Security Context：应用到 Pod 内所有容器以及 Volume Pod Security Policies（PSP，废弃）：应用到集群内部所有 Pod 以及 Volume  我们可以用如下几种方式来设置 Security Context：  访问权限...</div></div></div></a><a class="pagination-related" href="/2025/09/11/OpenKruise/" title="OpenKruise"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">OpenKruise</div></div><div class="info-2"><div class="info-item-1">OpenKruiseOpenKruise 是一个基于 Kubernetes 的扩展套件，主要聚焦于云原生应用的自动化，比如部署、发布、运维以及可用性防护。OpenKruise 提供的绝大部分能力都是基于 CRD 扩展来定义的，它们不存在于任何外部依赖，可以运行在任意纯净的 Kubernetes 集群中。Kubernetes 自身提供的一些应用部署管理功能，对于大规模应用与集群的场景这些功能是远远不够的，OpenKruise 弥补了 Kubernetes 在应用部署、升级、防护、运维等领域的不足。 OpenKruise 提供了以下的一些核心能力：  增强版本的 Workloads：OpenKruise 包含了一系列增强版本的工作负载，比如 CloneSet、Advanced StatefulSet、Advanced DaemonSet、BroadcastJob 等。它们不仅支持类似于 Kubernetes 原生 Workloads 的基础功能，还提供了如原地升级、可配置的扩缩容&#x2F;发布策略、并发操作等。其中，原地升级是一种升级应用容器镜像甚至环境变量的全新方式，它只会用新的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%9F%BA%E4%BA%8E%20Jenkins%E3%80%81Gitlab%E3%80%81Harbor%E3%80%81Helm%20%E5%92%8C%20Kubernetes%20%E7%9A%84%20CICD/" title="基于 Jenkins、Gitlab、Harbor、Helm 和 Kubernetes 的 CICD"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">基于 Jenkins、Gitlab、Harbor、Helm 和 Kubernetes 的 CICD</div></div><div class="info-2"><div class="info-item-1">基于 Jenkins、Gitlab、Harbor、Helm 和 Kubernetes 的 CI&#x2F;CD上节课和大家介绍了Gitlab CI结合Kubernetes进行 CI&#x2F;CD 的完整过程。这节课结合前面所学的知识点给大家介绍一个完整的示例：使用 Jenkins + Gitlab + Harbor + Helm + Kubernetes 来实现一个完整的 CI&#x2F;CD 流水线作业。 其实前面的课程中我们就已经学习了 Jenkins Pipeline 与 Kubernetes 的完美结合，我们利用 Kubernetes 来动态运行 Jenkins 的 Slave 节点，可以和好的来解决传统的 Jenkins Slave 浪费大量资源的缺点。之前的示例中我们是将项目放置在 Github 仓库上的，将 Docker 镜像推送到了 Docker Hub，这节课我们来结合我们前面学习的知识点来综合运用下，使用 Jenkins、Gitlab、Harbor、Helm、Kubernetes 来实现一个完整的持续集成和持续部署的流水线作业。 流程下图是我们当前示例的流程...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Deployment/" title="Deployment"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Deployment</div></div><div class="info-2"><div class="info-item-1">Deployment 控制器前面我们学习了 ReplicaSet 控制器，了解到该控制器是用来维护集群中运行的 Pod 数量的，但是往往在实际操作的时候，我们反而不会去直接使用 RS，而是会使用更上层的控制器，比如我们今天要学习的主角 Deployment，Deployment 一个非常重要的功能就是实现了 Pod 的滚动更新，比如我们应用更新了，我们只需要更新我们的容器镜像，然后修改 Deployment 里面的 Pod 模板镜像，那么 Deployment 就会用滚动更新（Rolling Update）的方式来升级现在的 Pod，这个能力是非常重要的，因为对于线上的服务我们需要做到不中断服务，所以滚动更新就成了必须的一个功能。而 Deployment 这个能力的实现，依赖的就是上节课我们学习的 ReplicaSet 这个资源对象，实际上我们可以通俗的理解就是每个 Deployment 就对应集群中的一次部署，这样就更好理解了。 Deployment 概述Deployment 资源对象的格式和 ReplicaSet 几乎一致，如下资源对象就是一个常见的 Deployment 资...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Service/" title="Service"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Service</div></div><div class="info-2"><div class="info-item-1">Service我们前面的课程中学习了一些常用控制器的基本用法，我们也了解到 Pod 的生命是有限的，死亡过后不会复活了。然后我们知道可以用 ReplicaSet 和 Deployment 来动态的创建和销毁 Pod，每个 Pod 都有自己的 IP 地址，但是如果 Pod 重建了的话那么他的 IP 很有可能也就变化了。这就会带来一个问题：比如我们有一些后端的 Pod 集合为集群中的其他应用提供 API 服务，如果我们在前端应用中把所有的这些后端的 Pod 的地址都写死，然后以某种方式去访问其中一个 Pod 的服务，这样看上去是可以工作的，对吧？但是如果这个 Pod 挂掉了，然后重新启动起来了，是不是 IP 地址非常有可能就变了，这个时候前端就极大可能访问不到后端的服务了。 遇到这样的问题该怎么解决呢？在没有使用 Kubernetes 之前，我相信可能很多同学都遇到过这样的问题，不一定是 IP 变化的问题，比如我们在部署一个 WEB 服务的时候，前端一般部署一个 Nginx 作为服务的入口，然后 Nginx 后面肯定就是挂载的这个服务的大量后端服务，很早以前我们可能是去手动更改 Ng...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-%E5%AE%89%E5%85%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">Kubernetes 安全上下文设置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-runAsNonRoot-P-C"><span class="toc-number">1.1.</span> <span class="toc-text">1. runAsNonRoot [P&#x2F;C]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E4%B8%AD%E6%8F%90%E4%BE%9B%E7%9A%84%E7%94%A8%E6%88%B7"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 使用基础镜像中提供的用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E6%B2%A1%E6%9C%89%E6%8F%90%E4%BE%9B%E7%94%A8%E6%88%B7"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 基础镜像没有提供用户</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-runAsUser-runAsGroup-P-C"><span class="toc-number">1.2.</span> <span class="toc-text">2. runAsUser&#x2F;runAsGroup [P&#x2F;C]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-seLinuxOptions-P-C"><span class="toc-number">1.3.</span> <span class="toc-text">3. seLinuxOptions [P&#x2F;C]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-seccompProfile-P-C"><span class="toc-number">1.4.</span> <span class="toc-text">4. seccompProfile [P&#x2F;C]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%89%B9%E6%9D%83%E5%AE%B9%E5%99%A8-C"><span class="toc-number">1.5.</span> <span class="toc-text">5. 避免使用特权容器 [C]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Linux-Capabilities-C"><span class="toc-number">1.6.</span> <span class="toc-text">6. Linux Capabilities [C]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BB%A5%E5%8F%AA%E8%AF%BB%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C-C"><span class="toc-number">1.7.</span> <span class="toc-text">7. 以只读文件系统运行 [C]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-procMount-C"><span class="toc-number">1.8.</span> <span class="toc-text">8. procMount [C]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-fsGroup-fsGroupChangePolicy-P"><span class="toc-number">1.9.</span> <span class="toc-text">9. fsGroup&#x2F;fsGroupChangePolicy [P]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-sysctls-P"><span class="toc-number">1.10.</span> <span class="toc-text">10. sysctls [P]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.11.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>