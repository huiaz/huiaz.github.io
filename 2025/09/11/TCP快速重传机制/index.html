<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP快速重传机制 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP 引入快速重传（Fast Retransmit）机制，是为了弥补仅仅依靠超时重传的不足，提高网络吞吐量和链路利用率，尤其是在数据包丢失不严重但仍存在的情况下。 让我们来详细了解一下： 超时重传的不足：超时重传是 TCP 可靠性最基本的保障，但它有一个致命的弱点：等待时间过长。  重传超时时间 (RTO) 的计算： RTO 是根据网络中的往返时间 (RTT) 动态调整的，通常比 RTT 要长一">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP快速重传机制">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="TCP 引入快速重传（Fast Retransmit）机制，是为了弥补仅仅依靠超时重传的不足，提高网络吞吐量和链路利用率，尤其是在数据包丢失不严重但仍存在的情况下。 让我们来详细了解一下： 超时重传的不足：超时重传是 TCP 可靠性最基本的保障，但它有一个致命的弱点：等待时间过长。  重传超时时间 (RTO) 的计算： RTO 是根据网络中的往返时间 (RTT) 动态调整的，通常比 RTT 要长一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:07:19.723Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP快速重传机制",
  "url": "https://huiaz.github.io/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:07:19.723Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP快速重传机制',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP快速重传机制</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP快速重传机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:07:19.723Z" title="更新于 2025-09-11 22:07:19">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>TCP 引入快速重传（Fast Retransmit）机制，是为了<strong>弥补仅仅依靠超时重传的不足，提高网络吞吐量和链路利用率，尤其是在数据包丢失不严重但仍存在的情况下</strong>。</p>
<p>让我们来详细了解一下：</p>
<h3 id="超时重传的不足："><a href="#超时重传的不足：" class="headerlink" title="超时重传的不足："></a>超时重传的不足：</h3><p>超时重传是 TCP 可靠性最基本的保障，但它有一个致命的弱点：<strong>等待时间过长</strong>。</p>
<ol>
<li><strong>重传超时时间 (RTO) 的计算：</strong> RTO 是根据网络中的往返时间 (RTT) 动态调整的，通常比 RTT 要长一些。即使网络状况良好，RTO 至少也得几十毫秒甚至几百毫秒。</li>
<li><strong>等待 RTO 的代价：</strong><ul>
<li><strong>吞吐量下降：</strong> 如果一个数据包丢失了，发送方必须一直等到 RTO 到期才能重传。在这漫长的等待期间，发送方可能无法发送新的数据（如果拥塞窗口和接收窗口限制），导致网络带宽得不到充分利用，吞吐量显著下降。</li>
<li><strong>延迟增加：</strong> 对于实时性要求较高的应用，长时间的等待会导致明显的延迟增加。</li>
<li><strong>可能触发不必要的拥塞控制：</strong> 当超时发生时，TCP 会认为发生了一次严重的丢包事件，通常会大幅度降低拥塞窗口（例如，将拥塞窗口降到 1 MSS），这会极大地限制后续的数据发送，加剧吞吐量下降，即便实际上可能只丢失了一个包。</li>
</ul>
</li>
</ol>
<h3 id="快速重传机制的诞生："><a href="#快速重传机制的诞生：" class="headerlink" title="快速重传机制的诞生："></a>快速重传机制的诞生：</h3><p>为了解决超时重传的上述缺点，TCP 引入了快速重传机制。它的核心思想是：<strong>不等到定时器超时，而是根据接收方发送的重复 ACK 报文来提前判断丢包并立即重传。</strong></p>
<p><strong>工作原理：</strong></p>
<ol>
<li><p><strong>重复 ACK：</strong> 当 TCP 接收方收到一个“乱序”的报文段时，它不会立即确认这个乱序的报文段，而是会<strong>立即发送一个重复的 ACK 报文</strong>。这个重复的 ACK 报文确认的是它期望收到的下一个按序的字节序列号。</p>
<ul>
<li>例如：发送方发送了 S1, S2, S3, S4, S5。</li>
<li>接收方收到了 S1，发送 ACK(S2)。</li>
<li>S2 丢失了。</li>
<li>接收方收到了 S3（乱序），它会再次发送 ACK(S2)。</li>
<li>接收方收到了 S4（乱序），它会再次发送 ACK(S2)。</li>
<li>接收方收到了 S5（乱序），它会再次发送 ACK(S2)。</li>
</ul>
</li>
<li><p><strong>触发快速重传：</strong> 当发送方连续收到<strong>三个或更多</strong>个对同一个数据包的重复 ACK 报文时，发送方就会认为这个 ACK 报文所确认的那个数据包（即期望收到的下一个数据包）很可能已经丢失了。<strong>它不会等待 RTO 超时，而是立即重传这个丢失的报文段。</strong></p>
</li>
</ol>
<h3 id="快速重传解决的问题："><a href="#快速重传解决的问题：" class="headerlink" title="快速重传解决的问题："></a>快速重传解决的问题：</h3><ul>
<li><strong>减少不必要的等待时间：</strong> 避免了超时定时器到期才重传的漫长等待，大大缩短了从丢包到重传的响应时间。</li>
<li><strong>提高吞吐量：</strong> 因为能够更快地发现和重传丢失的包，数据流的中断时间大大缩短，从而提高了有效吞吐量。</li>
<li><strong>避免更激进的拥塞控制：</strong> 快速重传通常与快速恢复（Fast Recovery）算法一起使用。当快速重传发生时，TCP 认为这只是一个“轻微”的丢包事件（因为收到了后续的 ACK），因此不会像超时重传那样将拥塞窗口降到很低，而是采取相对温和的拥塞窗口调整策略，从而保持更高的发送速率。这有助于在网络轻度拥塞或偶发丢包时避免性能骤降。</li>
</ul>
<p><strong>总结：</strong></p>
<p><strong>超时重传是确保可靠性的“最终防线”</strong>，它在任何情况下都能保证数据最终会被重传，即使所有后续的 ACK 都丢失了。但它的缺点是响应慢，效率低。</p>
<p><strong>快速重传是提高性能的“优化手段”</strong>，它通过利用重复 ACK 这一额外的信息，在不等待 RTO 的情况下提前发现丢包并迅速重传，从而大大提高了 TCP 在网络状况波动（特别是出现少量丢包）时的吞吐量和响应速度。它们两者是相辅相成，共同确保 TCP 的可靠性和高效性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/">https://huiaz.github.io/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Thanos%20Compactor/" title="Thanos Compactor"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Thanos Compactor</div></div><div class="info-2"><div class="info-item-1">Compactor 组件现在历史监控数据已经上传到对象存储中去了，但是由于监控数据量非常庞大，所以一般情况下我们会去安装一个 Thanos 的 Compactor 组件，用来将对象存储中的数据进行压缩。Compactor 组件只与对象存储交互，是唯一拥有删除对象存储数据权限的组件，主要有两个作用：压缩 block（将多个 block 合并成一个）、降采样（可禁用，5m&#x2F;1h 采样数据）。可设置数据保留时长，原始数据、5m&#x2F;1h 降采样数据可分别设置保留时长。 下采样Compactor 用于定时对远端对象存储中的历史数据块进行下采样，Compactor 会将小的存储块合并为大的存储块，提升在做大时间跨度查询时的速度。 下采样有三个主要的配置参数：  --retention.resolution-raw（单位：d，默认 0d） --retention.resolution-5m（单位：d，默认 0d） --retention.resolution-1h（单位：d，默认 0d）  当开启 raw 之后，原有的历史数据会以该项所配置的时间长度保留于远端对象存储中，超过...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%E8%BF%9E%E6%8E%A5/" title="TCP连接"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TCP连接</div></div><div class="info-2"><div class="info-item-1">好的，我们来深入理解一下 TCP 连接。 TCP (Transmission Control Protocol，传输控制协议) 连接是计算机网络中一种可靠的、面向连接的、基于字节流的通信方式。它是互联网的基础协议之一，位于 OSI 模型的传输层。 要理解 TCP 连接，首先要明白它解决了哪些问题，以及它是如何解决的。  TCP 解决了什么问题？想象一下你给朋友寄包裹。如果你想确保包裹一定能送到、顺序不错乱、没有丢失、没有重复，并且能知道朋友是否收到了，这就是 TCP 试图在数据传输中实现的目标。 具体来说，TCP 针对底层的 IP (Internet Protocol，网际协议) 的局限性，提供了以下关键服务：  可靠性 (Reliability)： IP 是不可靠的，它只负责尽力而为地转发数据包，不保证数据包是否到达，也不保证顺序。TCP通过以下机制确保可靠性：  确认机制 (Acknowledgements - ACK)： 接收方收到数据后会发送确认包给发送方。 重传机制 (Retransmission)： 如果发送方在一定时间内没有收到确认包，它会认为数据包丢失，并重新发送...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/TCP%20vs.%20UDP/" title="TCP vs. UDP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP vs. UDP</div></div><div class="info-2"><div class="info-item-1">TCP 和 UDP 有什么区别？TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）都是互联网协议（IP）之上的传输层协议，它们都负责在应用程序之间传输数据。然而，它们的设计理念和提供的服务截然不同，因此适用于不同的应用场景。  \：核心区别概览   特性 TCP (传输控制协议) UDP (用户数据报协议)    可靠性 可靠：保证数据传输的完整性、顺序性，无重复、无丢失。 不可靠：尽力而为传输，不保证数据是否到达、顺序、是否重复。   连接状态 面向连接：数据传输前需进行“三次握手”建立连接，结束时需“四次挥手”断开连接。 无连接：直接发送数据报，无需建立或断开连接。   传输方式 **字节流 (Byte Stream)**：将应用数据视为一串无结构的字节流，发送时分割成段。 **数据报 (Datagram)**：将应用数据视为独立的、带有边界的数据包。   顺序性 有顺序保证：接收方会根据序列号重新排序，确保数据按发送顺序交付。 无顺序保证：数据包可能乱序到达。   错误...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/" title="TCP 滑动窗口的作用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 滑动窗口的作用</div></div><div class="info-2"><div class="info-item-1">TCP 滑动窗口（Sliding Window）是 TCP 协议中一个核心且关键的机制，它主要实现了以下几个重要的作用：  实现流量控制 (Flow Control):  问题： 发送方发送数据的速度如果远超接收方的处理速度，接收方的缓冲区最终会被填满，导致数据溢出丢失。 解决方案： 接收方会通过 TCP 报文段中的窗口大小字段（Window size）告诉发送方，其当前还有多少接收缓冲区是可用的。发送方收到的窗口大小就是它当前可以发送的最大数据量，它绝对不能发送超过这个窗口大小的数据。 动态调整： 随着接收方处理数据的速度和可用缓冲区空间的变化，窗口大小会动态调整。如果接收方处理得慢，窗口就会变小；如果处理得快，窗口就会变大。这确保了发送方的发送速率能与接收方的处理速率相匹配，避免接收方缓冲区溢出。   实现可靠传输 (Reliable Transmission):  问题： 网络传输可能导致数据包丢失、乱序或错误。TCP 需要确保所有数据在发送方和接收方之间都能完整、按序地到达。 解决方案： 滑动窗口机制与确认（ACK）和重传机制紧密结合。 发送窗口： 发送窗口维护着一系列允...</div></div></div></a><a class="pagination-related" href="/2025/09/11/SNMP/" title="SNMP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">SNMP</div></div><div class="info-2"><div class="info-item-1">什么是 SNMP？SNMP (Simple Network Management Protocol)，即简单网络管理协议，是用于网络管理的标准协议。它允许网络管理员在 IP 网络上远程收集、组织和修改信息，以监控网络设备（如路由器、交换机、服务器、打印机、防火墙等）的运行状态、性能数据以及配置信息。 本质上，SNMP 提供了一种通用的语言和框架，让不同的网络设备能够向管理系统报告自己的状态，并接收管理系统的指令。 SNMP 的核心组件：SNMP 模型由三个主要组件组成：  SNMP 管理站 (NMS - Network Management System)：  通常是一个运行着特定网络管理软件的计算机。 它是网络管理员与 SNMP 协议交互的界面。 负责向代理发送请求、接收代理的响应、处理陷阱 (Traps) 和通知 (Informs)，并以图形或文本形式展示网络设备的健康状况和性能数据。 例如：Nagios, Zabbix, PRTG, SolarWinds 等监控软件都可以作为 NMS。   SNMP 代理 (SNMP Agent)：  运行在被管理网络设备（如路由器、交换机...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%202.0%20%E5%92%8C%203.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" title="HTTP 2.0 和 3.0 有什么区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 2.0 和 3.0 有什么区别</div></div><div class="info-2"><div class="info-item-1">HTTP 2.0 和 3.0 有什么区别？HTTP 2.0 和 HTTP 3.0 在核心传输协议、解决的问题以及它们所针对的应用场景上存在革命性的差异。HTTP 3.0 不仅仅是 HTTP 2.0 的简单升级，它是一个范式转变，因为它彻底抛弃了 TCP，转而使用 UDP 作为其底层传输协议。 HTTP 2.0 (基于 TCP 的增强)  底层协议： 基于 TCP（传输控制协议）。 主要目标： 解决 HTTP 1.x 的队头阻塞（Head-of-Line Blocking）问题以及效率低下。 主要特性（回顾）： 多路复用 (Multiplexing)： 在单个 TCP 连接上同时发送和接收多个独立的请求和响应流。这解决了应用层的队头阻塞。 头部压缩 (HPACK)： 减少请求和响应头部的大小。 服务器推送 (Server Push)： 服务器主动将客户端可能需要的资源推送到客户端。 二进制分帧： 数据以二进制格式传输，提高解析效率。    HTTP 3.0 (基于 UDP&#x2F;QUIC 的革命)  底层协议： 基于 UDP（用户数据报协议）之上的 QUIC (Quick UD...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP 超时重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 超时重传机制</div></div><div class="info-2"><div class="info-item-1">除了标准的 TCP 四次挥手，还有一些其他方法或特殊情况可以导致连接断开，但它们通常不如四次挥手那样优雅和受控，可能会伴随数据丢失或异常。 1. RST 报文断开连接 (Reset)RST (Reset) 报文是一种 TCP 错误或异常的指示，它会立即终止连接，不会进行标准的四次挥手过程，也不会等待任何未发送或未确认的数据。 RST 报文的常见使用场景：  连接被拒绝： 当客户端尝试连接到一个不存在的端口或一个拒绝连接的服务器端口时，服务器通常会回复一个 RST 报文，表示连接无法建立。 中止连接： 当一方决定突然中止一个连接，而不是通过正常的挥手过程关闭时，会发送 RST。这意味着不再关心对方是否已收到所有数据，也不希望进一步的通信。例如，应用程序调用 SO_LINGER 且 l_onoff 为真，l_linger 为 0 时。 检测半开连接： 如果一方的连接已经关闭（比如进程崩溃），而另一方在试图向已关闭的连接发送数据时，操作系统会检测到这个异常并回复一个 RST 报文。 端口扫描： 端口扫描工具通常会向目标端口发送 SYN 包，根据收到的响应（SYN-ACK 或 RST）来...</div></div></div></a><a class="pagination-related" href="/2025/09/11/CoreDNS/" title="CoreDNS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">CoreDNS</div></div><div class="info-2"><div class="info-item-1">服务发现上面我们讲解了 Service 的用法，我们可以通过 Service 生成的 ClusterIP(VIP) 来访问 Pod 提供的服务，但是在使用的时候还有一个问题：我们怎么知道某个应用的 VIP 呢？比如我们有两个应用，一个是 api 应用，一个是 db 应用，两个应用都是通过 Deployment 进行管理的，并且都通过 Service 暴露出了端口提供服务。api 需要连接到 db 这个应用，我们只知道 db 应用的名称和 db 对应的 Service 的名称，但是并不知道它的 VIP 地址，我们前面的 Service 课程中是不是学习到我们通过 ClusterIP 就可以访问到后面的 Pod 服务，如果我们知道了 VIP 的地址是不是就行了？ 环境变量为了解决上面的问题，在之前的版本中，Kubernetes 采用了环境变量的方法，每个 Pod 启动的时候，会通过环境变量设置所有服务的 IP 和 port 信息，这样 Pod 中的应用可以通过读取环境变量来获取依赖服务的地址信息，这种方法使用起来相对简单，但是有一个很大的问题就是依赖的服务必须在 Pod 启动之前就存...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E7%9A%84%E4%B8%8D%E8%B6%B3%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">超时重传的不足：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E7%9A%84%E8%AF%9E%E7%94%9F%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">快速重传机制的诞生：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">快速重传解决的问题：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>