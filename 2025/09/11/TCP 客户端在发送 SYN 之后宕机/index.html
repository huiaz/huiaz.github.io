<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP 客户端在发送 SYN 之后宕机 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。 假设客户端 A 尝试连接服务器 B。 1. 客户端发送 SYN (第一次握手) 客户端 A： 生成一个 SYN 包，Seq &#x3D; client_ISN，发送给服务器 B。 发送后，客户端 A 的 TCP 状态会从 CLOSED 变为 SYN_SENT。  2. 客户端">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP 客户端在发送 SYN 之后宕机">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。 假设客户端 A 尝试连接服务器 B。 1. 客户端发送 SYN (第一次握手) 客户端 A： 生成一个 SYN 包，Seq &#x3D; client_ISN，发送给服务器 B。 发送后，客户端 A 的 TCP 状态会从 CLOSED 变为 SYN_SENT。  2. 客户端">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:07:10.481Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP 客户端在发送 SYN 之后宕机",
  "url": "https://huiaz.github.io/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:07:10.481Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP 客户端在发送 SYN 之后宕机',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP 客户端在发送 SYN 之后宕机</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP 客户端在发送 SYN 之后宕机</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:07:10.481Z" title="更新于 2025-09-11 22:07:10">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。</p>
<p>假设客户端 A 尝试连接服务器 B。</p>
<h3 id="1-客户端发送-SYN-第一次握手"><a href="#1-客户端发送-SYN-第一次握手" class="headerlink" title="1. 客户端发送 SYN (第一次握手)"></a>1. 客户端发送 SYN (第一次握手)</h3><ul>
<li><strong>客户端 A：</strong> 生成一个 SYN 包，<code>Seq = client_ISN</code>，发送给服务器 B。</li>
<li>发送后，客户端 A 的 TCP 状态会从 <code>CLOSED</code> 变为 <code>SYN_SENT</code>。</li>
</ul>
<h3 id="2-客户端-A-宕机"><a href="#2-客户端-A-宕机" class="headerlink" title="2. 客户端 A 宕机"></a>2. 客户端 A 宕机</h3><ul>
<li>就在发送 SYN 包之后，客户端 A 突然崩溃（例如，操作系统蓝屏、电源故障、进程被杀掉等）。这意味着客户端 A 的所有网络状态、定时器、内存中的 TCP 控制块信息都瞬间丢失了。</li>
</ul>
<h3 id="3-服务器-B-的处理"><a href="#3-服务器-B-的处理" class="headerlink" title="3. 服务器 B 的处理"></a>3. 服务器 B 的处理</h3><ul>
<li><strong>服务器 B 收到 SYN：</strong> 服务器 B 收到了客户端 A 发送的 SYN 包。</li>
<li><strong>服务器 B 响应 SYN+ACK：</strong> 服务器 B 按照 TCP 握手流程，会进入 <code>SYN_RCVD</code> 状态，并向客户端 A 发送 SYN+ACK 包 (<code>Seq = server_ISN</code>, <code>Ack = client_ISN + 1</code>)。</li>
<li><strong>服务器 B 等待客户端 ACK：</strong> 服务器 B 此时会启动一个定时器（称为 SYN-ACK 重传定时器）。它在等待客户端 A 发送第三次握手的 ACK 报文。</li>
</ul>
<h3 id="4-客户端-A-的未来"><a href="#4-客户端-A-的未来" class="headerlink" title="4. 客户端 A 的未来"></a>4. 客户端 A 的未来</h3><ul>
<li>因为客户端 A 已经宕机，它<strong>不可能</strong>收到服务器 B 发来的 SYN+ACK 报文。</li>
<li>它<strong>更不可能</strong>发送第三次握手的 ACK 报文。</li>
</ul>
<h3 id="5-服务器-B-的超时处理"><a href="#5-服务器-B-的超时处理" class="headerlink" title="5. 服务器 B 的超时处理"></a>5. 服务器 B 的超时处理</h3><ul>
<li>服务器 B 会一直等待客户端 A 的 ACK。</li>
<li>当 SYN-ACK 重传定时器超时后，服务器 B 会<strong>重传</strong> SYN+ACK 报文。</li>
<li>这个重传过程会持续进行<strong>几次</strong>（通常是 3 到 5 次，具体次数取决于操作系统的 TCP 参数配置，例如 Linux 默认 <code>net.ipv4.tcp_synack_retries</code>）。</li>
<li>在每次重传之后，超时时间会呈指数级增长（例如，1秒，2秒，4秒，8秒…）。</li>
<li>如果经过多次重传后，服务器 B <strong>仍然没有收到</strong>客户端 A 的 ACK 报文：<ul>
<li>服务器 B 会认定客户端 A 不可达，或者客户端 A 根本没有响应意愿。</li>
<li>服务器 B 会<strong>放弃</strong>这个连接尝试，将为这个半开连接（Half-Open Connection，也称为 SYN 半连接）分配的所有资源（如端口、内存中的 TCP 控制块等）<strong>释放掉</strong>。</li>
<li>服务器 B 的这个连接状态会从 <code>SYN_RCVD</code> 最终回到 <code>CLOSED</code>。</li>
</ul>
</li>
</ul>
<h3 id="6-对双方的影响总结："><a href="#6-对双方的影响总结：" class="headerlink" title="6. 对双方的影响总结："></a>6. 对双方的影响总结：</h3><ul>
<li><strong>对客户端 A (宕机方)：</strong> 无后续影响。它已经崩溃，所有状态都消失了。当它重新启动并尝试建立新的连接时，那将是全新的连接，与之前失败的尝试无关。</li>
<li><strong>对服务器 B (接收方)：</strong><ul>
<li><strong>资源占用：</strong> 在客户端 A 宕机到服务器 B 超时释放资源这段时间内，服务器 B 会为这个未完成的半开连接占用一定的资源（主要是内存中的 TCP 控制块）。</li>
<li><strong>超时后释放：</strong> 一旦超时机制发挥作用，资源就会被释放，对服务器的正常运行不会造成长期影响。</li>
<li><strong>潜在的拒绝服务攻击 (DoS&#x2F;DDoS)：</strong> 如果恶意攻击者短时间内向服务器发送大量的 SYN 包，然后不响应 SYN+ACK（比如发送 SYN 后立即宕机，或者伪造源 IP），这就会导致服务器维护大量半开连接，耗尽服务器的资源，这就是著名的 <strong>SYN Flood 攻击</strong>。为了缓解这种攻击，操作系统通常会有一些保护机制，如 SYN Cookies、降低 SYN 半连接队列大小、或更快的超时释放等。</li>
</ul>
</li>
</ul>
<h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ul>
<li><strong>超时机制：</strong> TCP 的重传和超时机制是处理这种异常情况的关键。它确保服务器不会无限期地等待一个永远不会到来的响应。</li>
<li><strong>资源释放：</strong> 及时释放半开连接的资源对于服务器的稳定运行至关重要。</li>
<li><strong>SYN Flood 攻击：</strong> 这是这种场景的一个主要安全隐患。</li>
</ul>
<p>所以，总的来说，当客户端发送 SYN 后宕机，服务器会等待一段时间并重传几次 SYN+ACK，如果一直没有收到响应，最终会超时并释放为该连接分配的资源。这是一个 TCP 协议通过其超时和重传机制处理网络异常和不可靠性的典型例子。</p>
<p>TCP SYN Flood 攻击的目标是耗尽服务器的资源（主要是半开连接队列，也称 SYN backlog），使合法用户无法建立新的连接。服务器一般会等待的时间长度是其处理 SYN Flood 攻击能力的关键因素之一。</p>
<h3 id="服务器等待的时间（SYN-ACK-重传定时器）"><a href="#服务器等待的时间（SYN-ACK-重传定时器）" class="headerlink" title="服务器等待的时间（SYN-ACK 重传定时器）"></a>服务器等待的时间（SYN-ACK 重传定时器）</h3><p>服务器在收到 SYN 并发送 SYN-ACK 后，会启动一个定时器来等待客户端的 ACK。这个定时器就是 SYN-ACK 重传定时器。其行为如下：</p>
<ol>
<li><strong>初始超时：</strong> 第一次等待 ACK 的时间。这个值通常比较短，例如 1 秒或 3 秒。</li>
<li><strong>指数退避重传：</strong> 如果在初始超时时间内没有收到 ACK，服务器会重传 SYN-ACK，并将下一次的超时时间翻倍。例如，1秒 -&gt; 2秒 -&gt; 4秒 -&gt; 8秒…</li>
<li><strong>重传次数限制：</strong> 服务器不会无限重传。它会有一个最大重传次数限制（例如 5 次）。</li>
</ol>
<p>这些参数通常是操作系统级别的配置：</p>
<ul>
<li><strong>Linux 系统：</strong><ul>
<li><code>net.ipv4.tcp_synack_retries</code>: 控制 SYN-ACK 的最大重传次数。默认值通常是 5 或 6。</li>
<li><code>net.ipv4.tcp_syn_retries</code>: (主要是客户端) 控制 SYN 的最大重传次数。</li>
<li><code>net.ipv4.tcp_retries2</code>: 重传数据的最大重传次数 (不是指 SYN&#x2F;SYN-ACK)。</li>
<li><code>net.ipv4.tcp_rtos</code>: (很少直接调整) 连接超时时的初始 RTO (Retransmission Timeout) 值，会影响第一次重传的时间。</li>
</ul>
</li>
</ul>
<p><strong>举例 (Linux 默认 <code>tcp_synack_retries=5</code>)：</strong><br>假设初始超时时间为 1 秒。</p>
<ul>
<li>第一次 SYN-ACK 发送。等待 1 秒。</li>
<li>1 秒后未收到 ACK。重传 SYN-ACK。等待 2 秒。</li>
<li>2 秒后未收到 ACK。重传 SYN-ACK。等待 4 秒。</li>
<li>4 秒后未收到 ACK。重传 SYN-ACK。等待 8 秒。</li>
<li>8 秒后未收到 ACK。重传 SYN-ACK。等待 16 秒。</li>
<li>16 秒后未收到 ACK。放弃连接。</li>
</ul>
<p><strong>总共等待时间：</strong> 1 + 2 + 4 + 8 + 16 &#x3D; <strong>31 秒</strong> (这只是一个近似值，实际还可能受到 RTO min&#x2F;max 限制以及其他因素影响)。</p>
<p>这意味着，一个半开连接在服务器上<strong>最长可能占用三十秒左右</strong>的资源才会因为超时被释放。</p>
<h3 id="SYN-Flood-攻击如何利用这个时间？"><a href="#SYN-Flood-攻击如何利用这个时间？" class="headerlink" title="SYN Flood 攻击如何利用这个时间？"></a>SYN Flood 攻击如何利用这个时间？</h3><p>攻击者利用的就是这段“最长等待时间”和服务器<strong>半开连接队列</strong>的有限大小。</p>
<ol>
<li><strong>伪造源 IP：</strong> 攻击者发送 SYN 包时，伪造一个不存在的源 IP 地址。这样即使服务器回复 SYN-ACK，这个 SYN-ACK 也发送到了一个不存在的 IP，攻击者永远不会收到它，就无法完成三次握手。</li>
<li><strong>大量发送：</strong> 攻击者在短时间内向目标服务器发送巨量的这种伪造 SYN 包。</li>
<li><strong>耗尽队列：</strong> 服务器为每个收到的 SYN 包分配资源（半开连接条目），并回复 SYN-ACK。由于 ACK 永远不会到来，这些半开连接会一直占用队列中的位置，直到超时被释放。如果攻击发送 SYN 包的速度远超服务器释放半开连接的速度，那么半开连接队列很快就会被填满。</li>
<li><strong>拒绝服务：</strong> 一旦半开连接队列满了，服务器就无法再接受新的合法连接请求，导致拒绝服务。</li>
</ol>
<h3 id="防御-SYN-Flood-攻击的常见策略："><a href="#防御-SYN-Flood-攻击的常见策略：" class="headerlink" title="防御 SYN Flood 攻击的常见策略："></a>防御 SYN Flood 攻击的常见策略：</h3><p>为了对抗这种攻击，服务器和网络设备采取了多种防御机制：</p>
<ol>
<li><strong>减小 <code>net.ipv4.tcp_synack_retries</code>：</strong> 缩短半开连接的存活时间，例如设置为 2 或 3，这样可以在 7-15 秒内释放资源。但这可能增加在短暂网络拥塞时合法连接建立失败的风险。</li>
<li><strong>增大 <code>net.ipv4.tcp_max_syn_backlog</code>：</strong> 增大半开连接队列的大小，使其可以容纳更多的半开连接。但这会消耗更多内存，并且当攻击流量非常大时，效果有限。</li>
<li><strong>SYN Cookies (最常用和有效的方法之一)：</strong><ul>
<li>服务器在收到 SYN 后，不立即分配资源，而是计算一个包含客户端 IP、端口、服务器 IP、端口、时间戳以及一个秘密信息的散列值，将这个散列值作为 ISN 放入 SYN-ACK 包的序列号字段并发送。</li>
<li>当客户端发回 ACK 时，服务器会重新根据 ACK 包中的相关信息计算一次散列值，并与 ACK 报文中携带的序列号进行比对。如果匹配，就认为这是一个合法连接，然后才正式为该连接分配资源并进入 <code>ESTABLISHED</code> 状态。</li>
<li>这样，除非客户端发送最终的 ACK，否则服务器不会为半开连接消耗大量资源。大幅降低了 SYN Flood 的危害。</li>
</ul>
</li>
<li><strong>SYN Proxy &#x2F; SYN 防火墙：</strong> 中间设备（如防火墙、负载均衡器）代服务器完成三次握手。当它们收到客户端 SYN 后，先回复 SYN-ACK。只有当客户端回复 ACK 后，中间设备才认为这是合法连接，然后才将真正的 SYN 包发送给后端服务器。这样，后端服务器看到的都是已经建立握手的合法连接，减轻了服务器的压力。</li>
<li><strong>TCP Fast Open (TFO)：</strong> 虽然主要用于加速连接建立，但其原理（使用 Cookie 避免完整握手建立连接）在某种程度上也能间接缓解小规模的 SYN Flood。</li>
<li><strong>IP 信誉系统和黑名单：</strong> 识别并阻止来自已知恶意 IP 地址的流量。</li>
<li><strong>流量清洗：</strong> 将攻击流量重定向到专业的 DDoS 清洗服务进行过滤。</li>
</ol>
<p>总而言之，服务器为了应对 SYN Flood 攻击，会通过超时机制等待一段时间，以便判断连接是否能够建立，但这段时间也是攻击者利用的关键点。防御策略旨在缩短等待时间、减少资源占用或完全规避半开连接队列的消耗。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/">https://huiaz.github.io/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/" title="TCP 滑动窗口的作用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCP 滑动窗口的作用</div></div><div class="info-2"><div class="info-item-1">TCP 滑动窗口（Sliding Window）是 TCP 协议中一个核心且关键的机制，它主要实现了以下几个重要的作用：  实现流量控制 (Flow Control):  问题： 发送方发送数据的速度如果远超接收方的处理速度，接收方的缓冲区最终会被填满，导致数据溢出丢失。 解决方案： 接收方会通过 TCP 报文段中的窗口大小字段（Window size）告诉发送方，其当前还有多少接收缓冲区是可用的。发送方收到的窗口大小就是它当前可以发送的最大数据量，它绝对不能发送超过这个窗口大小的数据。 动态调整： 随着接收方处理数据的速度和可用缓冲区空间的变化，窗口大小会动态调整。如果接收方处理得慢，窗口就会变小；如果处理得快，窗口就会变大。这确保了发送方的发送速率能与接收方的处理速率相匹配，避免接收方缓冲区溢出。   实现可靠传输 (Reliable Transmission):  问题： 网络传输可能导致数据包丢失、乱序或错误。TCP 需要确保所有数据在发送方和接收方之间都能完整、按序地到达。 解决方案： 滑动窗口机制与确认（ACK）和重传机制紧密结合。 发送窗口： 发送窗口维护着一系列允...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/" title="TCP 初始序列号 ISN 怎么取值的？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TCP 初始序列号 ISN 怎么取值的？</div></div><div class="info-2"><div class="info-item-1">TCP 初始序列号 (Initial Sequence Number, ISN) 的取值是一个重要且精心设计的机制，它对于 TCP 连接的健壮性、安全性以及避免“历史连接”的干扰至关重要。 ISN 的生成方式TCP 规范 (RFC 793 和后来的 RFC 1948、RFC 6528) 规定，ISN 的选择算法应该随机化。具体来说：  基于时钟（时间戳）+ 递增计数器 + 随机偏移：  大多数现代操作系统实现采用的是一个32位的计数器，该计数器以一个固定的频率（例如，每4微秒或更短）递增。 当需要生成新的 ISN 时，取当前计数器的值。 为了增加随机性，通常还会加上一个伪随机数作为偏移量。 这样可以确保每次连接生成的 ISN 都是不同的，并且难以预测。   每隔一段时间随机增加一个偏移量：为了进一步增强安全性，通常会周期性地给这个递增计数器添加一个大的随机偏移量，或者在每次系统启动时初始化为不同的随机值。   核心思想：随机性和不可预测性。 为什么 ISN 必须是随机的？ISN 的随机性主要基于以下几个重要的原因：  防止“历史连接”对当前连接的干扰（最重要的原因）：这也是前面三...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP快速重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP快速重传机制</div></div><div class="info-2"><div class="info-item-1">TCP 引入快速重传（Fast Retransmit）机制，是为了弥补仅仅依靠超时重传的不足，提高网络吞吐量和链路利用率，尤其是在数据包丢失不严重但仍存在的情况下。 让我们来详细了解一下： 超时重传的不足：超时重传是 TCP 可靠性最基本的保障，但它有一个致命的弱点：等待时间过长。  重传超时时间 (RTO) 的计算： RTO 是根据网络中的往返时间 (RTT) 动态调整的，通常比 RTT 要长一些。即使网络状况良好，RTO 至少也得几十毫秒甚至几百毫秒。 等待 RTO 的代价： 吞吐量下降： 如果一个数据包丢失了，发送方必须一直等到 RTO 到期才能重传。在这漫长的等待期间，发送方可能无法发送新的数据（如果拥塞窗口和接收窗口限制），导致网络带宽得不到充分利用，吞吐量显著下降。 延迟增加： 对于实时性要求较高的应用，长时间的等待会导致明显的延迟增加。 可能触发不必要的拥塞控制： 当超时发生时，TCP 会认为发生了一次严重的丢包事件，通常会大幅度降低拥塞窗口（例如，将拥塞窗口降到 1 MSS），这会极大地限制后续的数据发送，加剧吞吐量下降，即便实际上可能只丢失了一个包。    快速...</div></div></div></a><a class="pagination-related" href="/2025/09/11/WebSocket%20%E5%92%8C%20HTTP/" title="WebSocket 和 HTTP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">WebSocket 和 HTTP</div></div><div class="info-2"><div class="info-item-1">WebSocket 和 HTTP 都是应用层协议，用于在客户端和服务器之间传输数据。然而，它们在通信模式、连接方式、数据流向和使用场景上存在根本性的区别。理解这些区别对于选择适合你应用的通信协议至关重要。  主要区别概览   特性 HTTP (通常指 HTTP&#x2F;1.1) WebSocket    通信模式 请求-响应 (Request-Response) 模型 全双工 (Full-duplex) 持久连接   连接方式 短连接 (默认)。每次请求-响应后连接通常关闭或保持短暂的 Keep-Alive 长连接。一次握手后连接持续开放，直到一方关闭   数据流向 单向。客户端发起请求，服务器响应，然后循环。 双向。客户端和服务器可以随时互相发送消息，无需等待请求。   开销 每次请求都包含完整的头部信息，开销较大。 初始握手开销较大，一旦建立，后续数据帧只有很小的头部开销。   传输效率 对于实时、高频数据交换效率低。 对于实时、高频数据交换效率高。   协议类型 无状态 (Stateless)。每次请求都是独立的。 有状态 (Stateful)。连接建立后，双方都知道彼此...</div></div></div></a><a class="pagination-related" href="/2025/09/11/websocket/" title="websocket"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">websocket</div></div><div class="info-2"><div class="info-item-1">什么是 WebSocket？HTTP 协议是无状态的，它是一种请求-响应模型：客户端发出请求，服务器响应，然后连接通常会关闭。这种模式对于静态资源、一次性数据交互非常高效。 然而，对于需要实时、双向通信的场景（如聊天应用、股票行情、在线游戏、协同编辑等），传统的 HTTP 循环请求（轮询、长轮询）效率低下，会导致大量不必要的请求和延迟。 WebSocket 协议正是为了解决这个问题而诞生的。 核心思想： WebSocket 协议提供了一种在单个 TCP 连接上进行全双工（Full-duplex）通信的机制。这意味着客户端和服务器可以在任意时间点互相发送消息，而不需要每次都建立和关闭连接，也不需要客户端不断地发起新的 HTTP 请求。 工作原理：  握手（Handshake）： 客户端首先通过标准的 HTTP 请求发起一个特殊的“握手”过程。这个 HTTP 请求会包含一些特殊的 Header，如 Upgrade: websocket 和 Connection: Upgrade，表示客户端希望将当前的 HTTP 连接升级为 WebSocket 连接。 服务器如果支持 WebSocke...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ARP%E5%8D%8F%E8%AE%AE/" title="ARP协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ARP协议</div></div><div class="info-2"><div class="info-item-1">好的，我们来详细了解一下 ARP 和 RARP。  1. ARP (Address Resolution Protocol) - 地址解析协议作用： 将网络层（IP 地址） 地址解析为数据链路层（MAC 地址） 的协议。 应用场景：当一个主机想与同一局域网内的另一个主机进行通信时，它知道目标主机的 IP 地址，但数据链路层（如以太网）需要目标主机的 MAC 地址来封装帧。此时就需要 ARP 来完成 IP 到 MAC 的映射。 工作原理（简化流程）：  ARP 请求： 主机 A（已知主机 B 的 IP 地址）希望获取主机 B 的 MAC 地址，它会构建一个 ARP 请求报文，其中包含自己的 IP 地址和 MAC 地址，以及目标主机 B 的 IP 地址。 广播： 主机 A 将这个 ARP 请求报文封装在一个以太网帧中，并将目的 MAC 地址设置为广播地址（FFFF.FFFF.FFFF），然后发送到局域网中。 接收与响应： 局域网中的所有主机都会收到这个广播帧。 每个主机都会检查 ARP 请求报文中的目标 IP 地址是否是自己的 IP 地址。 只有目标主机 B 会识别出这个 IP 地址...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E4%B8%BA%E4%BB%80%E4%B9%88%20TCP%20%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E6%9C%89%20TIME_WAIT%20%E7%8A%B6%E6%80%81/" title="为什么 TCP 挥手需要有 TIME_WAIT 状态"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">为什么 TCP 挥手需要有 TIME_WAIT 状态</div></div><div class="info-2"><div class="info-item-1">TIME_WAIT 状态是 TCP 四次挥手过程中一个非常关键且必要的阶段，它主要位于主动关闭连接的一方。它的存在是为了解决两个核心问题： 问题一：确保四次挥手最后一个 ACK 报文可靠到达，防止服务器端重传 FIN 报文。 场景： 假设 TCP 没有 TIME_WAIT 状态，客户端（主动关闭方）发送了最后一个 ACK 后立即关闭连接，进入 CLOSED 状态。 潜在问题： 如果最后一个 ACK 在网络中丢失了，服务器端就没有收到这个 ACK。根据 TCP 的可靠性机制，服务器会认为它的 FIN 报文没有被确认，就会尝试重传 FIN 报文。 后果： 如果客户端已经立即进入 CLOSED 状态并释放了端口，而服务器重传的 FIN 报文到达时，如果客户端的该端口已经被新的连接占用（或直接拒绝接收），服务器将永远无法收到对 FIN 的确认，它会一直停留在 LAST_ACK 状态，耗尽资源并最终超时。 TIME_WAIT 状态让客户端保持一个足够长的时间（2 MSL，通常是 1-4 分钟），如果服务器重传 FIN 报文，客户端依然可以发送新的 ACK 报文作为回应，并重置 TIME_W...</div></div></div></a><a class="pagination-related" href="/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/" title="DHCP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">DHCP 协议</div></div><div class="info-2"><div class="info-item-1">DHCP 协议的工作原理及应用场景什么是 DHCP 协议？DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 是一种网络协议，用于自动化管理和分配网络中的 IP 地址以及其他相关配置信息（如子网掩码、默认网关、DNS 服务器地址等）。它的核心思想是取代手动配置每台设备的网络参数，实现即插即用，大大简化了大型网络的管理。 DHCP 协议的工作原理 (DORA 过程)DHCP 协议通常通过四步过程（称为 DORA 过程）来完成 IP 地址分配：  Discover (发现)  客户端行为： 当一台新设备（或一台没有配置 IP 地址的设备）连接到网络时，它不知道网络中是否有 DHCP 服务器，也不知道自己的 IP 地址。因此，它会广播一个 DHCP Discover 消息到局域网内的所有设备（使用目的 IP 地址 255.255.255.255，源 IP 地址 0.0.0.0）。 目的： 寻找网络中的 DHCP 服务器。   Offer (提供)  服务器行为： 网络中的 DHCP 服务器收到 DHCP Discover 消息后，会从...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81-SYN-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.</span> <span class="toc-text">1. 客户端发送 SYN (第一次握手)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%A2%E6%88%B7%E7%AB%AF-A-%E5%AE%95%E6%9C%BA"><span class="toc-number">2.</span> <span class="toc-text">2. 客户端 A 宕机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%8D%E5%8A%A1%E5%99%A8-B-%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3. 服务器 B 的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF-A-%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="toc-number">4.</span> <span class="toc-text">4. 客户端 A 的未来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%8D%E5%8A%A1%E5%99%A8-B-%E7%9A%84%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">5. 服务器 B 的超时处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AF%B9%E5%8F%8C%E6%96%B9%E7%9A%84%E5%BD%B1%E5%93%8D%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">6. 对双方的影响总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">关键点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%88SYN-ACK-%E9%87%8D%E4%BC%A0%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">服务器等待的时间（SYN-ACK 重传定时器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN-Flood-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%BF%99%E4%B8%AA%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">SYN Flood 攻击如何利用这个时间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1-SYN-Flood-%E6%94%BB%E5%87%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">10.</span> <span class="toc-text">防御 SYN Flood 攻击的常见策略：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>