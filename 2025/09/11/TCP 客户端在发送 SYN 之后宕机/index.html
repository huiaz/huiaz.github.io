<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP 客户端在发送 SYN 之后宕机 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。 假设客户端 A 尝试连接服务器 B。 1. 客户端发送 SYN (第一次握手) 客户端 A： 生成一个 SYN 包，Seq &#x3D; client_ISN，发送给服务器 B。 发送后，客户端 A 的 TCP 状态会从 CLOSED 变为 SYN_SENT。  2. 客户端">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP 客户端在发送 SYN 之后宕机">
<meta property="og:url" content="http://example.com/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。 假设客户端 A 尝试连接服务器 B。 1. 客户端发送 SYN (第一次握手) 客户端 A： 生成一个 SYN 包，Seq &#x3D; client_ISN，发送给服务器 B。 发送后，客户端 A 的 TCP 状态会从 CLOSED 变为 SYN_SENT。  2. 客户端">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:07:10.481Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP 客户端在发送 SYN 之后宕机",
  "url": "http://example.com/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:07:10.481Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP 客户端在发送 SYN 之后宕机',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP 客户端在发送 SYN 之后宕机</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP 客户端在发送 SYN 之后宕机</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:07:10.481Z" title="更新于 2025-09-11 22:07:10">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。</p>
<p>假设客户端 A 尝试连接服务器 B。</p>
<h3 id="1-客户端发送-SYN-第一次握手"><a href="#1-客户端发送-SYN-第一次握手" class="headerlink" title="1. 客户端发送 SYN (第一次握手)"></a>1. 客户端发送 SYN (第一次握手)</h3><ul>
<li><strong>客户端 A：</strong> 生成一个 SYN 包，<code>Seq = client_ISN</code>，发送给服务器 B。</li>
<li>发送后，客户端 A 的 TCP 状态会从 <code>CLOSED</code> 变为 <code>SYN_SENT</code>。</li>
</ul>
<h3 id="2-客户端-A-宕机"><a href="#2-客户端-A-宕机" class="headerlink" title="2. 客户端 A 宕机"></a>2. 客户端 A 宕机</h3><ul>
<li>就在发送 SYN 包之后，客户端 A 突然崩溃（例如，操作系统蓝屏、电源故障、进程被杀掉等）。这意味着客户端 A 的所有网络状态、定时器、内存中的 TCP 控制块信息都瞬间丢失了。</li>
</ul>
<h3 id="3-服务器-B-的处理"><a href="#3-服务器-B-的处理" class="headerlink" title="3. 服务器 B 的处理"></a>3. 服务器 B 的处理</h3><ul>
<li><strong>服务器 B 收到 SYN：</strong> 服务器 B 收到了客户端 A 发送的 SYN 包。</li>
<li><strong>服务器 B 响应 SYN+ACK：</strong> 服务器 B 按照 TCP 握手流程，会进入 <code>SYN_RCVD</code> 状态，并向客户端 A 发送 SYN+ACK 包 (<code>Seq = server_ISN</code>, <code>Ack = client_ISN + 1</code>)。</li>
<li><strong>服务器 B 等待客户端 ACK：</strong> 服务器 B 此时会启动一个定时器（称为 SYN-ACK 重传定时器）。它在等待客户端 A 发送第三次握手的 ACK 报文。</li>
</ul>
<h3 id="4-客户端-A-的未来"><a href="#4-客户端-A-的未来" class="headerlink" title="4. 客户端 A 的未来"></a>4. 客户端 A 的未来</h3><ul>
<li>因为客户端 A 已经宕机，它<strong>不可能</strong>收到服务器 B 发来的 SYN+ACK 报文。</li>
<li>它<strong>更不可能</strong>发送第三次握手的 ACK 报文。</li>
</ul>
<h3 id="5-服务器-B-的超时处理"><a href="#5-服务器-B-的超时处理" class="headerlink" title="5. 服务器 B 的超时处理"></a>5. 服务器 B 的超时处理</h3><ul>
<li>服务器 B 会一直等待客户端 A 的 ACK。</li>
<li>当 SYN-ACK 重传定时器超时后，服务器 B 会<strong>重传</strong> SYN+ACK 报文。</li>
<li>这个重传过程会持续进行<strong>几次</strong>（通常是 3 到 5 次，具体次数取决于操作系统的 TCP 参数配置，例如 Linux 默认 <code>net.ipv4.tcp_synack_retries</code>）。</li>
<li>在每次重传之后，超时时间会呈指数级增长（例如，1秒，2秒，4秒，8秒…）。</li>
<li>如果经过多次重传后，服务器 B <strong>仍然没有收到</strong>客户端 A 的 ACK 报文：<ul>
<li>服务器 B 会认定客户端 A 不可达，或者客户端 A 根本没有响应意愿。</li>
<li>服务器 B 会<strong>放弃</strong>这个连接尝试，将为这个半开连接（Half-Open Connection，也称为 SYN 半连接）分配的所有资源（如端口、内存中的 TCP 控制块等）<strong>释放掉</strong>。</li>
<li>服务器 B 的这个连接状态会从 <code>SYN_RCVD</code> 最终回到 <code>CLOSED</code>。</li>
</ul>
</li>
</ul>
<h3 id="6-对双方的影响总结："><a href="#6-对双方的影响总结：" class="headerlink" title="6. 对双方的影响总结："></a>6. 对双方的影响总结：</h3><ul>
<li><strong>对客户端 A (宕机方)：</strong> 无后续影响。它已经崩溃，所有状态都消失了。当它重新启动并尝试建立新的连接时，那将是全新的连接，与之前失败的尝试无关。</li>
<li><strong>对服务器 B (接收方)：</strong><ul>
<li><strong>资源占用：</strong> 在客户端 A 宕机到服务器 B 超时释放资源这段时间内，服务器 B 会为这个未完成的半开连接占用一定的资源（主要是内存中的 TCP 控制块）。</li>
<li><strong>超时后释放：</strong> 一旦超时机制发挥作用，资源就会被释放，对服务器的正常运行不会造成长期影响。</li>
<li><strong>潜在的拒绝服务攻击 (DoS&#x2F;DDoS)：</strong> 如果恶意攻击者短时间内向服务器发送大量的 SYN 包，然后不响应 SYN+ACK（比如发送 SYN 后立即宕机，或者伪造源 IP），这就会导致服务器维护大量半开连接，耗尽服务器的资源，这就是著名的 <strong>SYN Flood 攻击</strong>。为了缓解这种攻击，操作系统通常会有一些保护机制，如 SYN Cookies、降低 SYN 半连接队列大小、或更快的超时释放等。</li>
</ul>
</li>
</ul>
<h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ul>
<li><strong>超时机制：</strong> TCP 的重传和超时机制是处理这种异常情况的关键。它确保服务器不会无限期地等待一个永远不会到来的响应。</li>
<li><strong>资源释放：</strong> 及时释放半开连接的资源对于服务器的稳定运行至关重要。</li>
<li><strong>SYN Flood 攻击：</strong> 这是这种场景的一个主要安全隐患。</li>
</ul>
<p>所以，总的来说，当客户端发送 SYN 后宕机，服务器会等待一段时间并重传几次 SYN+ACK，如果一直没有收到响应，最终会超时并释放为该连接分配的资源。这是一个 TCP 协议通过其超时和重传机制处理网络异常和不可靠性的典型例子。</p>
<p>TCP SYN Flood 攻击的目标是耗尽服务器的资源（主要是半开连接队列，也称 SYN backlog），使合法用户无法建立新的连接。服务器一般会等待的时间长度是其处理 SYN Flood 攻击能力的关键因素之一。</p>
<h3 id="服务器等待的时间（SYN-ACK-重传定时器）"><a href="#服务器等待的时间（SYN-ACK-重传定时器）" class="headerlink" title="服务器等待的时间（SYN-ACK 重传定时器）"></a>服务器等待的时间（SYN-ACK 重传定时器）</h3><p>服务器在收到 SYN 并发送 SYN-ACK 后，会启动一个定时器来等待客户端的 ACK。这个定时器就是 SYN-ACK 重传定时器。其行为如下：</p>
<ol>
<li><strong>初始超时：</strong> 第一次等待 ACK 的时间。这个值通常比较短，例如 1 秒或 3 秒。</li>
<li><strong>指数退避重传：</strong> 如果在初始超时时间内没有收到 ACK，服务器会重传 SYN-ACK，并将下一次的超时时间翻倍。例如，1秒 -&gt; 2秒 -&gt; 4秒 -&gt; 8秒…</li>
<li><strong>重传次数限制：</strong> 服务器不会无限重传。它会有一个最大重传次数限制（例如 5 次）。</li>
</ol>
<p>这些参数通常是操作系统级别的配置：</p>
<ul>
<li><strong>Linux 系统：</strong><ul>
<li><code>net.ipv4.tcp_synack_retries</code>: 控制 SYN-ACK 的最大重传次数。默认值通常是 5 或 6。</li>
<li><code>net.ipv4.tcp_syn_retries</code>: (主要是客户端) 控制 SYN 的最大重传次数。</li>
<li><code>net.ipv4.tcp_retries2</code>: 重传数据的最大重传次数 (不是指 SYN&#x2F;SYN-ACK)。</li>
<li><code>net.ipv4.tcp_rtos</code>: (很少直接调整) 连接超时时的初始 RTO (Retransmission Timeout) 值，会影响第一次重传的时间。</li>
</ul>
</li>
</ul>
<p><strong>举例 (Linux 默认 <code>tcp_synack_retries=5</code>)：</strong><br>假设初始超时时间为 1 秒。</p>
<ul>
<li>第一次 SYN-ACK 发送。等待 1 秒。</li>
<li>1 秒后未收到 ACK。重传 SYN-ACK。等待 2 秒。</li>
<li>2 秒后未收到 ACK。重传 SYN-ACK。等待 4 秒。</li>
<li>4 秒后未收到 ACK。重传 SYN-ACK。等待 8 秒。</li>
<li>8 秒后未收到 ACK。重传 SYN-ACK。等待 16 秒。</li>
<li>16 秒后未收到 ACK。放弃连接。</li>
</ul>
<p><strong>总共等待时间：</strong> 1 + 2 + 4 + 8 + 16 &#x3D; <strong>31 秒</strong> (这只是一个近似值，实际还可能受到 RTO min&#x2F;max 限制以及其他因素影响)。</p>
<p>这意味着，一个半开连接在服务器上<strong>最长可能占用三十秒左右</strong>的资源才会因为超时被释放。</p>
<h3 id="SYN-Flood-攻击如何利用这个时间？"><a href="#SYN-Flood-攻击如何利用这个时间？" class="headerlink" title="SYN Flood 攻击如何利用这个时间？"></a>SYN Flood 攻击如何利用这个时间？</h3><p>攻击者利用的就是这段“最长等待时间”和服务器<strong>半开连接队列</strong>的有限大小。</p>
<ol>
<li><strong>伪造源 IP：</strong> 攻击者发送 SYN 包时，伪造一个不存在的源 IP 地址。这样即使服务器回复 SYN-ACK，这个 SYN-ACK 也发送到了一个不存在的 IP，攻击者永远不会收到它，就无法完成三次握手。</li>
<li><strong>大量发送：</strong> 攻击者在短时间内向目标服务器发送巨量的这种伪造 SYN 包。</li>
<li><strong>耗尽队列：</strong> 服务器为每个收到的 SYN 包分配资源（半开连接条目），并回复 SYN-ACK。由于 ACK 永远不会到来，这些半开连接会一直占用队列中的位置，直到超时被释放。如果攻击发送 SYN 包的速度远超服务器释放半开连接的速度，那么半开连接队列很快就会被填满。</li>
<li><strong>拒绝服务：</strong> 一旦半开连接队列满了，服务器就无法再接受新的合法连接请求，导致拒绝服务。</li>
</ol>
<h3 id="防御-SYN-Flood-攻击的常见策略："><a href="#防御-SYN-Flood-攻击的常见策略：" class="headerlink" title="防御 SYN Flood 攻击的常见策略："></a>防御 SYN Flood 攻击的常见策略：</h3><p>为了对抗这种攻击，服务器和网络设备采取了多种防御机制：</p>
<ol>
<li><strong>减小 <code>net.ipv4.tcp_synack_retries</code>：</strong> 缩短半开连接的存活时间，例如设置为 2 或 3，这样可以在 7-15 秒内释放资源。但这可能增加在短暂网络拥塞时合法连接建立失败的风险。</li>
<li><strong>增大 <code>net.ipv4.tcp_max_syn_backlog</code>：</strong> 增大半开连接队列的大小，使其可以容纳更多的半开连接。但这会消耗更多内存，并且当攻击流量非常大时，效果有限。</li>
<li><strong>SYN Cookies (最常用和有效的方法之一)：</strong><ul>
<li>服务器在收到 SYN 后，不立即分配资源，而是计算一个包含客户端 IP、端口、服务器 IP、端口、时间戳以及一个秘密信息的散列值，将这个散列值作为 ISN 放入 SYN-ACK 包的序列号字段并发送。</li>
<li>当客户端发回 ACK 时，服务器会重新根据 ACK 包中的相关信息计算一次散列值，并与 ACK 报文中携带的序列号进行比对。如果匹配，就认为这是一个合法连接，然后才正式为该连接分配资源并进入 <code>ESTABLISHED</code> 状态。</li>
<li>这样，除非客户端发送最终的 ACK，否则服务器不会为半开连接消耗大量资源。大幅降低了 SYN Flood 的危害。</li>
</ul>
</li>
<li><strong>SYN Proxy &#x2F; SYN 防火墙：</strong> 中间设备（如防火墙、负载均衡器）代服务器完成三次握手。当它们收到客户端 SYN 后，先回复 SYN-ACK。只有当客户端回复 ACK 后，中间设备才认为这是合法连接，然后才将真正的 SYN 包发送给后端服务器。这样，后端服务器看到的都是已经建立握手的合法连接，减轻了服务器的压力。</li>
<li><strong>TCP Fast Open (TFO)：</strong> 虽然主要用于加速连接建立，但其原理（使用 Cookie 避免完整握手建立连接）在某种程度上也能间接缓解小规模的 SYN Flood。</li>
<li><strong>IP 信誉系统和黑名单：</strong> 识别并阻止来自已知恶意 IP 地址的流量。</li>
<li><strong>流量清洗：</strong> 将攻击流量重定向到专业的 DDoS 清洗服务进行过滤。</li>
</ol>
<p>总而言之，服务器为了应对 SYN Flood 攻击，会通过超时机制等待一段时间，以便判断连接是否能够建立，但这段时间也是攻击者利用的关键点。防御策略旨在缩短等待时间、减少资源占用或完全规避半开连接队列的消耗。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/">http://example.com/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/" title="TCP 滑动窗口的作用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCP 滑动窗口的作用</div></div><div class="info-2"><div class="info-item-1">TCP 滑动窗口（Sliding Window）是 TCP 协议中一个核心且关键的机制，它主要实现了以下几个重要的作用：  实现流量控制 (Flow Control):  问题： 发送方发送数据的速度如果远超接收方的处理速度，接收方的缓冲区最终会被填满，导致数据溢出丢失。 解决方案： 接收方会通过 TCP 报文段中的窗口大小字段（Window size）告诉发送方，其当前还有多少接收缓冲区是可用的。发送方收到的窗口大小就是它当前可以发送的最大数据量，它绝对不能发送超过这个窗口大小的数据。 动态调整： 随着接收方处理数据的速度和可用缓冲区空间的变化，窗口大小会动态调整。如果接收方处理得慢，窗口就会变小；如果处理得快，窗口就会变大。这确保了发送方的发送速率能与接收方的处理速率相匹配，避免接收方缓冲区溢出。   实现可靠传输 (Reliable Transmission):  问题： 网络传输可能导致数据包丢失、乱序或错误。TCP 需要确保所有数据在发送方和接收方之间都能完整、按序地到达。 解决方案： 滑动窗口机制与确认（ACK）和重传机制紧密结合。 发送窗口： 发送窗口维护着一系列允...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/" title="TCP 初始序列号 ISN 怎么取值的？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TCP 初始序列号 ISN 怎么取值的？</div></div><div class="info-2"><div class="info-item-1">TCP 初始序列号 (Initial Sequence Number, ISN) 的取值是一个重要且精心设计的机制，它对于 TCP 连接的健壮性、安全性以及避免“历史连接”的干扰至关重要。 ISN 的生成方式TCP 规范 (RFC 793 和后来的 RFC 1948、RFC 6528) 规定，ISN 的选择算法应该随机化。具体来说：  基于时钟（时间戳）+ 递增计数器 + 随机偏移：  大多数现代操作系统实现采用的是一个32位的计数器，该计数器以一个固定的频率（例如，每4微秒或更短）递增。 当需要生成新的 ISN 时，取当前计数器的值。 为了增加随机性，通常还会加上一个伪随机数作为偏移量。 这样可以确保每次连接生成的 ISN 都是不同的，并且难以预测。   每隔一段时间随机增加一个偏移量：为了进一步增强安全性，通常会周期性地给这个递增计数器添加一个大的随机偏移量，或者在每次系统启动时初始化为不同的随机值。   核心思想：随机性和不可预测性。 为什么 ISN 必须是随机的？ISN 的随机性主要基于以下几个重要的原因：  防止“历史连接”对当前连接的干扰（最重要的原因）：这也是前面三...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/PPP%20%E5%8D%8F%E8%AE%AE/" title="PPP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">PPP 协议</div></div><div class="info-2"><div class="info-item-1">PPP 协议（点对点协议 &#x2F; Point-to-Point Protocol）PPP (Point-to-Point Protocol) 是一种用于在两个网络节点之间建立直接连接的数据链路层协议。它主要用于通过串行线缆（如电话线、ISDN、DSL、光纤）连接计算机到互联网，或者在路由器之间建立点对点连接。它是替代早期的 SLIP (Serial Line Internet Protocol) 协议而生的，并解决了 SLIP 的许多限制。 核心作用： PPP 提供了一种标准的方法来：  封装网络层数据包（如 IP 数据包），以便在点对点链路上传输。 建立、配置和测试数据链路连接的可靠性。 提供网络层地址协商（例如，分配 IP 地址）。 提供身份验证机制（可选）。  简而言之，PPP 就是在两点之间架起一座数据传输的桥梁，并确保桥梁能正常工作和通信。  PPP 协议的基本工作流程PPP 的工作流程分为几个阶段，通过使用不同的子协议来完成：  **链路控制协议 (LCP - Link Control Protocol)**：负责建立、配置和测试数据链路。 **网络控制协议 (...</div></div></div></a><a class="pagination-related" href="/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/" title="DHCP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">DHCP 协议</div></div><div class="info-2"><div class="info-item-1">DHCP 协议的工作原理及应用场景什么是 DHCP 协议？DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 是一种网络协议，用于自动化管理和分配网络中的 IP 地址以及其他相关配置信息（如子网掩码、默认网关、DNS 服务器地址等）。它的核心思想是取代手动配置每台设备的网络参数，实现即插即用，大大简化了大型网络的管理。 DHCP 协议的工作原理 (DORA 过程)DHCP 协议通常通过四步过程（称为 DORA 过程）来完成 IP 地址分配：  Discover (发现)  客户端行为： 当一台新设备（或一台没有配置 IP 地址的设备）连接到网络时，它不知道网络中是否有 DHCP 服务器，也不知道自己的 IP 地址。因此，它会广播一个 DHCP Discover 消息到局域网内的所有设备（使用目的 IP 地址 255.255.255.255，源 IP 地址 0.0.0.0）。 目的： 寻找网络中的 DHCP 服务器。   Offer (提供)  服务器行为： 网络中的 DHCP 服务器收到 DHCP Discover 消息后，会从...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81/" title="HTTP 状态码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 状态码</div></div><div class="info-2"><div class="info-item-1">HTTP 状态码HTTP 状态码是服务器对请求的响应。它们是三位数字，分为五个类别，指示请求是否已成功处理，或者是否存在错误。理解这些状态码对于调试网络问题和理解Web应用程序的行为至关重要。 以下是常见的 HTTP 状态码及其简要说明：  1xx - 信息响应 (Informational Responses)指示请求已被接收，继续处理。这些是临时响应，不带任何内容。  100 Continue: 客户端应继续其请求。通常用于客户端发送一个大型请求体到服务器之前，先发送头部，服务器如果允许，则返回 100 Continue，然后客户端再发送请求体。   2xx - 成功响应 (Successful Responses)指示请求已被成功接收、理解和接受。  200 OK: 请求已成功。这是最常见的状态码，表示请求的一切正常，服务器已返回所请求的数据。 201 Created: 请求已成功，并因此创建了一个新的资源。这通常是 PUT 或 POST 请求的响应。响应体中通常包含新创建资源的URI。 202 Accepted: 请求已被接受进行处理，但处理尚未完成。请求可能最终被执行，...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E4%B8%AD%E7%9A%84%20%60RST%60%EF%BC%88Reset%EF%BC%89%E6%8A%A5%E6%96%87/" title="TCP 中的 &#96;RST&#96;（Reset）报文"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 中的 &#96;RST&#96;（Reset）报文</div></div><div class="info-2"><div class="info-item-1">TCP 中的 RST（Reset）报文是一种特殊的控制报文，它表示连接的异常终止或拒绝。与正常关闭连接的 FIN 报文不同，RST 是一种“硬”关闭，它强制终止连接，不进行正常的四次挥手过程，也不保证任何未发送或未确认的数据被可靠传递。 以下是 TCP 中出现 RST 报文的几种常见情况： 1. 端口未开放（连接被拒绝）当客户端向一个服务器的某个端口发起 TCP 连接（发送 SYN 报文），但该端口并没有任何进程在监听（即端口未开放或服务器不接受该连接），或者服务器明确拒绝接收该连接时，服务器会立即返回一个 RST 报文作为对 SYN 报文的响应。  场景： 你尝试 telnet 192.168.1.100 80，但服务器上没有 web 服务运行在 80 端口。 表现： 客户端收到 RST 后，会报告“Connection refused”之类的错误。  2. 半开连接或无效连接当一方的 TCP 连接意外关闭（例如，进程崩溃、拔掉网线、操作系统重启等），而另一方没有意识到连接已经中断，仍然尝试向此已关闭的连接发送数据时，已关闭的一方（或其操作系统）会发送一个 RST 报文，告知对...</div></div></div></a><a class="pagination-related" href="/2025/09/11/RIP%20(Routing%20Information%20Protocol)%20%E5%8D%8F%E8%AE%AE/" title="RIP (Routing Information Protocol) 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">RIP (Routing Information Protocol) 协议</div></div><div class="info-2"><div class="info-item-1">RIP (Routing Information Protocol) 协议的工作原理及特点RIP (Routing Information Protocol) 是一种经典的**距离向量路由协议 (Distance-Vector Routing Protocol)**，用于在内部网关 (Interior Gateway Protocol, IGP) 环境中交换路由信息。它历史悠久，简单易用，但存在一些固有的局限性。  RIP 的工作原理：RIP 的工作原理基于 Bellman-Ford 算法的变体，其核心思想是每个路由器维护一个到所有已知目的地的距离向量，并定期与邻居交换此信息。  里程 (Metric) - 跳数 (Hop Count)：  RIP 使用跳数 (Hop Count) 作为唯一的路由度量（metric）。 每经过一个路由器，跳数就增加 1。 最大跳数限制： RIP 的最大跳数限制为 15 跳。这意味着任何超过 15 跳的目的地都被认为是不可达的（即距离为无穷大）。这是 RIP 最大的局限性之一，使其不适合大型网络。   距离向量的维护：  每个 RIP 路由器维护一...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCPIP%204%20%E5%B1%82%E6%A8%A1%E5%9E%8B/" title="TCPIP 4 层模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCPIP 4 层模型</div></div><div class="info-2"><div class="info-item-1">TCP&#x2F;IP 四层模型（也称为 TCP&#x2F;IP 协议栈、TCP&#x2F;IP 参考模型）是计算机网络中最常用和最重要的分层模型之一。它将复杂的网络通信过程划分为若干个逻辑层，每层负责不同的功能。 这个模型与 OSI 七层模型有所不同，虽然它们都致力于解决网络通信的复杂性，但 TCP&#x2F;IP 模型更注重实际应用和协议实现。 TCP&#x2F;IP 四层模型的构成：TCP&#x2F;IP 模型通常被划分为以下四层：  应用层 (Application Layer) 传输层 (Transport Layer) 网络层 (Internet Layer) 网络接口层 (Network Access Layer) 或 数据链路层&#x2F;物理层  让我们逐一详细了解每一层的功能、协议和数据单元。  1. 应用层 (Application Layer) 功能： 提供应用程序之间的通信服务。它是用户与网络进行交互的最高层，负责处理特定应用程序的数据，并将其转换为通过网络传输的格式。 代表协议： HTTP&#x2F;HTTPS： (超文本传输协议) 用于网页浏览。 F...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81-SYN-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.</span> <span class="toc-text">1. 客户端发送 SYN (第一次握手)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%A2%E6%88%B7%E7%AB%AF-A-%E5%AE%95%E6%9C%BA"><span class="toc-number">2.</span> <span class="toc-text">2. 客户端 A 宕机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%8D%E5%8A%A1%E5%99%A8-B-%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3. 服务器 B 的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF-A-%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="toc-number">4.</span> <span class="toc-text">4. 客户端 A 的未来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%8D%E5%8A%A1%E5%99%A8-B-%E7%9A%84%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">5. 服务器 B 的超时处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AF%B9%E5%8F%8C%E6%96%B9%E7%9A%84%E5%BD%B1%E5%93%8D%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">6. 对双方的影响总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">关键点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%88SYN-ACK-%E9%87%8D%E4%BC%A0%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">服务器等待的时间（SYN-ACK 重传定时器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN-Flood-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%BF%99%E4%B8%AA%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">SYN Flood 攻击如何利用这个时间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1-SYN-Flood-%E6%94%BB%E5%87%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">10.</span> <span class="toc-text">防御 SYN Flood 攻击的常见策略：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>