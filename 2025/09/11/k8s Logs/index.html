<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>k8s Logs | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="描述在 Kubernetes 中如何进行日志管理，并解释常用的方法。 Of course. Log management is a cornerstone of observability in any production system, and Kubernetes presents unique challenges and solutions. This is a great questi">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s Logs">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/k8s%20Logs/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="描述在 Kubernetes 中如何进行日志管理，并解释常用的方法。 Of course. Log management is a cornerstone of observability in any production system, and Kubernetes presents unique challenges and solutions. This is a great questi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:43:34.682Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "k8s Logs",
  "url": "https://huiaz.github.io/2025/09/11/k8s%20Logs/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:43:34.682Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/k8s%20Logs/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'k8s Logs',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">k8s Logs</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">k8s Logs</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:43:34.682Z" title="更新于 2025-09-11 21:43:34">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>描述在 Kubernetes 中如何进行日志管理，并解释常用的方法。</p>
<p>Of course. Log management is a cornerstone of observability in any production system, and Kubernetes presents unique challenges and solutions. This is a great question to assess a candidate’s operational maturity.</p>
<h3 id="🤔-分析过程："><a href="#🤔-分析过程：" class="headerlink" title="🤔 分析过程："></a>🤔 分析过程：</h3><p>该问题旨在考察对Kubernetes中日志生命周期和集中式日志解决方案的理解。一个全面的回答需要首先解释为什么基础的<code>kubectl logs</code>命令在生产环境中不足够，从而引出集中式日志管理的需求。接着，需要清晰地描述最主流的实现架构（节点级日志代理），并能解释其工作流程。提及Sidecar模式作为补充方案，以及介绍市面上流行的工具栈（如EFK、PLG），可以充分展现面试者在该领域的知识广度和深度。</p>
<h3 id="💡-答案生成："><a href="#💡-答案生成：" class="headerlink" title="💡 答案生成："></a>💡 答案生成：</h3><h4 id="1-概念或定义"><a href="#1-概念或定义" class="headerlink" title="1. 概念或定义"></a>1. 概念或定义</h4><p><strong>Kubernetes日志管理</strong>是指一套系统性的方法和架构，用于从集群中所有运行的容器、应用程序以及节点本身<strong>收集、聚合、存储、和分析</strong>日志数据。其核心目标是克服Pod的<strong>临时性（ephemeral）</strong>和<strong>分布式</strong>特性，将分散的日志汇集到一个中心化的、持久化的存储后端，以便于进行故障排查、性能监控、安全审计和长期分析。</p>
<p>简单的<code>kubectl logs &lt;pod-name&gt;</code>命令只适用于实时调试，因为一旦Pod被删除或重启，其日志就会丢失。因此，生产级的日志管理是必不可少的。</p>
<h4 id="2-核心挑战"><a href="#2-核心挑战" class="headerlink" title="2. 核心挑战"></a>2. 核心挑战</h4><p>在讨论解决方案之前，理解Kubernetes日志管理的挑战至关重要：</p>
<ul>
<li><strong>Pod的临时性:</strong> Pod随时可能被销毁和重建，其本地日志也会随之消失。</li>
<li><strong>日志分散:</strong> 日志分布在集群的各个节点上，难以进行关联分析。</li>
<li><strong>缺乏上下文:</strong> 原始的容器日志不包含Kubernetes的元数据（如Pod名、命名空间、标签），这使得日志的筛选和定位非常困难。</li>
<li><strong>日志量巨大:</strong> 一个中大型集群每秒会产生海量的日志，对收集和存储系统是巨大的考验。</li>
</ul>
<h4 id="3-常用方法和架构"><a href="#3-常用方法和架构" class="headerlink" title="3. 常用方法和架构"></a>3. 常用方法和架构</h4><h5 id="方法一：节点级日志代理-Node-Level-Logging-Agent-业界标准方案"><a href="#方法一：节点级日志代理-Node-Level-Logging-Agent-业界标准方案" class="headerlink" title="方法一：节点级日志代理 (Node-Level Logging Agent) - 业界标准方案"></a>方法一：节点级日志代理 (Node-Level Logging Agent) - <strong>业界标准方案</strong></h5><p>这是最常用、最高效的日志收集方法。</p>
<ul>
<li><p><strong>工作原理:</strong></p>
<ol>
<li><strong>应用程序输出:</strong> 应用程序遵循云原生最佳实践，将日志输出到<strong>标准输出（<code>stdout</code>）和标准错误（<code>stderr</code>）</strong>。</li>
<li><strong>容器运行时捕获:</strong> 容器运行时（如containerd, CRI-O）会捕获这些标准输出流，并将其重定向到节点上的特定日志文件中。通常，这些日志文件位于 <code>/var/log/pods/</code> 或 <code>/var/log/containers/</code> 目录下，并以 <code>pod-name_namespace_container-name-container-id.log</code> 的格式命名。</li>
<li><strong>部署日志代理:</strong> 在集群的<strong>每一个节点</strong>上都通过 <strong><code>DaemonSet</code></strong> 部署一个日志收集代理（Logging Agent），例如 <strong>Fluent Bit</strong>, <strong>Fluentd</strong>, 或 <strong>Vector</strong>。</li>
<li><strong>日志收集与丰富:</strong><ul>
<li>这个日志代理会挂载节点上的日志目录（如 <code>/var/log/pods</code>）。</li>
<li>它会“监听”（tail）这些日志文件的变化，实时收集新的日志条目。</li>
<li><strong>最关键的一步</strong>：代理会与该节点上的Kubelet API或Kubernetes API Server通信，获取日志对应的Pod元数据（Pod名称、命名空间、标签、注解等），并将这些元数据<strong>附加（enrich）</strong>到日志记录中。</li>
</ul>
</li>
<li><strong>日志转发:</strong> 代理将这些经过丰富的、结构化的日志数据转发到一个中心化的日志存储和分析后端。</li>
</ol>
</li>
<li><p><strong>优点:</strong></p>
<ul>
<li>对应用程序透明，应用开发者只需关心标准输出。</li>
<li>高效且资源占用相对较低（特别是使用Fluent Bit）。</li>
<li>易于管理，通过一个DaemonSet即可覆盖整个集群。</li>
</ul>
</li>
<li><p><strong>缺点:</strong></p>
<ul>
<li>不适用于那些不向标准输出打印日志、而是写入自定义文件的传统应用。</li>
</ul>
</li>
</ul>
<h5 id="方法二：Sidecar-模式"><a href="#方法二：Sidecar-模式" class="headerlink" title="方法二：Sidecar 模式"></a>方法二：Sidecar 模式</h5><p>当应用程序无法修改以将日志写入标准输出时，Sidecar模式是一个很好的解决方案。</p>
<ul>
<li><p><strong>工作原理:</strong></p>
<ol>
<li><strong>共享卷:</strong> 在应用程序的Pod中，除了主应用容器外，再额外注入一个<strong>日志代理Sidecar容器</strong>（如一个轻量级的Fluent Bit）。同时，定义一个<code>emptyDir</code>类型的共享卷，并将其挂载到主应用容器和Sidecar容器中。</li>
<li><strong>应用写日志:</strong> 主应用容器将其日志写入到共享卷的某个文件里（例如 <code>/shared-logs/app.log</code>）。</li>
<li><strong>Sidecar读日志:</strong> Sidecar容器的任务就是读取共享卷中的这个日志文件（<code>tail -f /shared-logs/app.log</code>）。</li>
<li><strong>转发日志:</strong> Sidecar容器随后可以将这些日志：<ul>
<li><strong>A)</strong> 直接输出到它自己的标准输出，这样就可以被前述的<strong>节点级日志代理</strong>捕获。</li>
<li><strong>B)</strong> 直接推送到中心化的日志后端。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>优点:</strong></p>
<ul>
<li>解耦了应用的日志逻辑，无需修改老旧应用。</li>
<li>可以处理多行日志、特定格式日志的预处理。</li>
</ul>
</li>
<li><p><strong>缺点:</strong></p>
<ul>
<li>资源开销更大，因为每个需要此功能的Pod都增加了一个额外的容器。</li>
<li>配置更复杂。</li>
</ul>
</li>
</ul>
<h4 id="4-常用工具栈-Common-Tool-Stacks"><a href="#4-常用工具栈-Common-Tool-Stacks" class="headerlink" title="4. 常用工具栈 (Common Tool Stacks)"></a>4. 常用工具栈 (Common Tool Stacks)</h4><ol>
<li><p><strong>PLG&#x2F;FLG Stack (Prometheus, Loki, Grafana &#x2F; Fluent Bit, Loki, Grafana):</strong></p>
<ul>
<li><strong>Loki:</strong> 由Grafana Labs开发的日志聚合系统，设计理念是“像Prometheus一样查日志”。它只索引日志的元数据（标签），而不索引日志的全文内容，因此非常轻量、成本低廉。</li>
<li><strong>Grafana:</strong> 用于可视化展示Loki中的日志，并能与Prometheus的监控指标进行关联查询。</li>
<li><strong>Fluent Bit:</strong> 作为轻量级的日志代理（DaemonSet），负责收集日志并发送给Loki。</li>
<li><strong>特点:</strong> 现代、高效、低成本，是目前非常流行的选择。</li>
</ul>
</li>
<li><p><strong>EFK Stack (Elasticsearch, Fluentd&#x2F;Fluent Bit, Kibana):</strong></p>
<ul>
<li><strong>Elasticsearch:</strong> 一个功能强大的全文搜索引擎，用于存储和索引日志数据。</li>
<li><strong>Fluentd&#x2F;Fluent Bit:</strong> 作为日志收集代理。Fluentd功能更强、插件生态更丰富；Fluent Bit更轻量、性能更高。</li>
<li><strong>Kibana:</strong> 用于搜索、分析和可视化Elasticsearch中数据的Web UI。</li>
<li><strong>特点:</strong> 功能强大、生态成熟，但资源消耗较大，运维成本较高。</li>
</ul>
</li>
<li><p><strong>商业&#x2F;SaaS解决方案:</strong></p>
<ul>
<li><strong>Datadog, Splunk, New Relic, Logz.io</strong> 等。这些服务通常提供自己的Kubernetes日志代理，用户只需在集群中部署它们的agent (通常也是一个DaemonSet)，日志就会被自动收集并发送到它们的云平台进行存储和分析。</li>
<li><strong>特点:</strong> 开箱即用，功能强大，免运维，但会产生持续的服务费用。</li>
</ul>
</li>
</ol>
<h4 id="5-扩展知识-最佳实践"><a href="#5-扩展知识-最佳实践" class="headerlink" title="5. 扩展知识&#x2F;最佳实践"></a>5. 扩展知识&#x2F;最佳实践</h4><ul>
<li><strong>结构化日志 (Structured Logging):</strong> 强烈建议应用以<strong>JSON格式</strong>输出日志，而不是纯文本。结构化的日志无需复杂的正则表达式解析，可以被后端系统直接索引，极大地提高了查询效率和准确性。</li>
<li><strong>日志级别:</strong> 在应用中使用不同的日志级别（如<code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>DEBUG</code>），并配置日志代理根据级别进行过滤或路由。</li>
<li><strong>成本控制:</strong> 日志存储成本可能很高。应制定合理的日志保留策略（Retention Policy），并可以考虑对低优先级的日志（如DEBUG级别）进行采样。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/k8s%20Logs/">https://huiaz.github.io/2025/09/11/k8s%20Logs/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/k8s%20Namespace/" title="k8s Namespace"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">k8s Namespace</div></div><div class="info-2"><div class="info-item-1">请描述 Kubernetes 中的 Namespace 的作用，并解释其使用场景。 🤔 分析过程：此问题考察的是对Kubernetes基本组织单元——Namespace（命名空间）的理解。一个优秀的回答需要解释其核心功能，即逻辑隔离，并能从不同维度（名称、资源、权限）阐述这种隔离。更重要的是，要能结合实际工作场景，说明为什么以及如何使用命名空间来组织集群，这直接反映了面试者的集群治理和多租户管理经验。 💡 答案生成：1. 概念或定义Namespace（命名空间）是Kubernetes中一种实现逻辑隔离的机制，它能将一个物理的Kubernetes集群划分为多个虚拟集群。每个命名空间都是一个独立的作用域，用于组织和隔离集群中的资源对象。 需要强调的是，这种隔离是逻辑上的，而非物理上的。不同命名空间中的Pod可能会运行在同一个物理节点上，但它们在API层面、策略层面和名称层面是相互隔离的。 2. Namespace 的核心作用Namespace为一组资源提供了三个维度的隔离：  1. 名称范围隔离 (Scope for Names):  作用： 这是最基本的作用。在同一个命名空间内...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20Deployment/" title="k8s Deployment"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">k8s Deployment</div></div><div class="info-2"><div class="info-item-1">Kubernetes 中的 Deployment 和 StatefulSet 有什么区别？🤔 分析过程：该问题旨在考察对Kubernetes中两种核心工作负载控制器（Workload Controllers）的理解和区分能力。一个优秀的回答不仅要罗列出功能上的差异，更要阐明这两种控制器在设计哲学上的根本不同，即它们分别是为了解决无状态应用（Stateless）和有状态应用（Stateful）这两大类问题的。本回答将通过一个清晰的对比表格来突出核心区别，并结合应用场景和选型指南，帮助面试者建立深刻的理解。 💡 答案生成：1. 核心概念定义 Deployment: 是Kubernetes中用于管理无状态应用的控制器。它确保指定数量的、完全相同的Pod副本（Replicas）处于运行状态。这些Pod是可互换的（Interchangeable&#x2F;Fungible），可以被随意地创建和销毁，而不会影响应用的整体状态。  StatefulSet: 是用于管理有状态应用的控制器。它为每个Pod提供唯一的、稳定的身份标识，并保证Pod的部署、伸缩和更新是有序的。这些Pod不是可互换的...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/k8s_ConfigMap&Secret%20/" title="k8s_ConfigMap&amp;Secret"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s_ConfigMap&amp;Secret</div></div><div class="info-2"><div class="info-item-1">请解释 Kubernetes 中的 ConfigMap 和 Secret 的作用及其使用场景。	 🤔 分析过程：此问题旨在考察对Kubernetes中两种核心配置资源——ConfigMap和Secret的理解。一个全面的回答需要清晰地界定两者的用途、异同点，并能说明如何在Pod中使用它们。关键在于强调一个核心区别：**ConfigMap用于非敏感配置，Secret用于敏感配置**。展示具体的使用方法（如注入环境变量、挂载为卷）能体现出实际操作经验。 💡 答案生成：1. 概念或定义ConfigMap 和 Secret 都是Kubernetes中的API对象，它们的核心作用是将配置数据从应用程序的容器镜像中解耦出来。这使得应用程序更具可移植性，因为你可以在不同的环境中（如开发、测试、生产）部署同一个容器镜像，只需为其提供不同的ConfigMap或Secret即可，而无需重新构建镜像。  ConfigMap: 用于存储非敏感的、纯文本的配置数据，以键值对的形式存在。例如，应用的URL、功能开关、环境标识等。 Secret: 专门用于存储敏感数据，如密码、API密钥、TLS证书、OA...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Admission%20webhooks/" title="Admission webhooks"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Admission webhooks</div></div><div class="info-2"><div class="info-item-1">准入控制器Kubernetes 提供了需要扩展其内置功能的方法，最常用的可能是自定义资源类型和自定义控制器了，除此之外，Kubernetes 还有一些其他非常有趣的功能，比如 admission webhooks 就可以用于扩展 API，用于修改某些 Kubernetes 资源的基本行为。 准入控制器是在对象持久化之前用于对 Kubernetes API Server 的请求进行拦截的代码段，在请求经过身份验证和授权之后放行通过。准入控制器可能正在 validating、mutating 或者都在执行，Mutating 控制器可以修改他们处理的资源对象，Validating 控制器不会，如果任何一个阶段中的任何控制器拒绝了请求，则会立即拒绝整个请求，并将错误返回给最终的用户。 这意味着有一些特殊的控制器可以拦截 Kubernetes API 请求，并根据自定义的逻辑修改或者拒绝它们。Kubernetes 有自己实现的一个控制器列表：https://kubernetes.io/docs/reference/access-authn-authz/admission-controlle...</div></div></div></a><a class="pagination-related" href="/2025/09/11/POD%20Pending/" title="POD Pending"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">POD Pending</div></div><div class="info-2"><div class="info-item-1">彻底搞懂 K8S Pod Pending 故障原因及解决方案即使在高成熟度级别 Kubernetes 集群中 pod pending 也是无处不在。 如果您随机询问任何使用 Kubernetes DevOps 工程师来确定折磨他们噩梦的最常见错误，pod pending 可能是非常常见的问题（可能仅次于 CrashLoopBackOff）。 尝试推送更新并看到它卡住会使 DevOps 紧张。即使解决方案相当简单，找到 pod 挂起的原因并了解您需要应用的更改也很重要（Kubernetes 故障排除很少是微不足道的）。  在本文中，我们将阐明导致此问题的不同情况，让 DevOps 团队能够快速找到解决方案，最重要的是，尽可能避免它。 Kubernetes Pod pending 是什么意思？Kubernetes 中的 Pod 的生命周期由几个不同的阶段组成：  创建 pod 时，它从Pending阶段开始。 一旦 pod 被调度并且容器已经启动，pod 就会进入Running阶段。  大多数 pod 只需要几秒钟就可以从 Pending 到 Running 并在该状态下度过大部分时...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20Namespace/" title="k8s Namespace"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s Namespace</div></div><div class="info-2"><div class="info-item-1">请描述 Kubernetes 中的 Namespace 的作用，并解释其使用场景。 🤔 分析过程：此问题考察的是对Kubernetes基本组织单元——Namespace（命名空间）的理解。一个优秀的回答需要解释其核心功能，即逻辑隔离，并能从不同维度（名称、资源、权限）阐述这种隔离。更重要的是，要能结合实际工作场景，说明为什么以及如何使用命名空间来组织集群，这直接反映了面试者的集群治理和多租户管理经验。 💡 答案生成：1. 概念或定义Namespace（命名空间）是Kubernetes中一种实现逻辑隔离的机制，它能将一个物理的Kubernetes集群划分为多个虚拟集群。每个命名空间都是一个独立的作用域，用于组织和隔离集群中的资源对象。 需要强调的是，这种隔离是逻辑上的，而非物理上的。不同命名空间中的Pod可能会运行在同一个物理节点上，但它们在API层面、策略层面和名称层面是相互隔离的。 2. Namespace 的核心作用Namespace为一组资源提供了三个维度的隔离：  1. 名称范围隔离 (Scope for Names):  作用： 这是最基本的作用。在同一个命名空间内...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" title="服务发现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">服务发现</div></div><div class="info-2"><div class="info-item-1">服务发现由于我们这里每个节点上面都运行了 node-exporter 程序，当然我们也可以手动的把所有节点用静态的方式配置到 Prometheus 中去，但是以后要新增或者去掉节点的时候就还得手动去配置，那么有没有一种方式可以让 Prometheus 去自动发现我们节点的 node-exporter 程序，并且按节点进行分组呢？这就是 Prometheus 里面非常重要的服务发现功能了。 节点发现在 Kubernetes 下，Promethues 通过与 Kubernetes API 集成，主要支持 5 中服务发现模式，分别是：Node、Service、Pod、Endpoints、Ingress。 我们通过 kubectl 命令可以很方便的获取到当前集群中的所有节点信息： 12345☸ ➜ kubectl get nodesNAME      STATUS   ROLES                  AGE   VERSIONmaster1   Ready    control-plane,master   55d   v1.22.2node1     Ready    &...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Local%20%E5%AD%98%E5%82%A8/" title="Local 存储"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Local 存储</div></div><div class="info-2"><div class="info-item-1">Local 存储前面我们有通过 hostPath 或者 emptyDir 的方式来持久化我们的数据，但是显然我们还需要更加可靠的存储来保存应用的持久化数据，这样容器在重建后，依然可以使用之前的数据。但是存储资源和 CPU 资源以及内存资源有很大不同，为了屏蔽底层的技术实现细节，让用户更加方便的使用，Kubernetes 便引入了 PV 和 PVC 两个重要的资源对象来实现对存储的管理。 概念PV 的全称是：PersistentVolume（持久化卷），是对底层共享存储的一种抽象，PV 由管理员进行创建和配置，它和具体的底层的共享存储技术的实现方式有关，比如 Ceph、GlusterFS、NFS、hostPath 等，都是通过插件机制完成与共享存储的对接。 PVC 的全称是：PersistentVolumeClaim（持久化卷声明），PVC 是用户存储的一种声明，PVC 和 Pod 比较类似，Pod 消耗的是节点，PVC 消耗的是 PV 资源，Pod 可以请求 CPU 和内存，而 PVC 可以请求特定的存储空间和访问模式。对于真正使用存储的用户不需要关心底层的存储实现细节，只需要直...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%94-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">🤔 分析过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E7%AD%94%E6%A1%88%E7%94%9F%E6%88%90%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">💡 答案生成：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5%E6%88%96%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">1. 概念或定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98"><span class="toc-number">2.2.</span> <span class="toc-text">2. 核心挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%9E%B6%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">3. 常用方法和架构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%8A%82%E7%82%B9%E7%BA%A7%E6%97%A5%E5%BF%97%E4%BB%A3%E7%90%86-Node-Level-Logging-Agent-%E4%B8%9A%E7%95%8C%E6%A0%87%E5%87%86%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.1.</span> <span class="toc-text">方法一：节点级日志代理 (Node-Level Logging Agent) - 业界标准方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ASidecar-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.2.</span> <span class="toc-text">方法二：Sidecar 模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%A0%88-Common-Tool-Stacks"><span class="toc-number">2.4.</span> <span class="toc-text">4. 常用工具栈 (Common Tool Stacks)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.5.</span> <span class="toc-text">5. 扩展知识&#x2F;最佳实践</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>