<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PPP 协议 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="PPP 协议（点对点协议 &#x2F; Point-to-Point Protocol）PPP (Point-to-Point Protocol) 是一种用于在两个网络节点之间建立直接连接的数据链路层协议。它主要用于通过串行线缆（如电话线、ISDN、DSL、光纤）连接计算机到互联网，或者在路由器之间建立点对点连接。它是替代早期的 SLIP (Serial Line Internet Protoco">
<meta property="og:type" content="article">
<meta property="og:title" content="PPP 协议">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/PPP%20%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="PPP 协议（点对点协议 &#x2F; Point-to-Point Protocol）PPP (Point-to-Point Protocol) 是一种用于在两个网络节点之间建立直接连接的数据链路层协议。它主要用于通过串行线缆（如电话线、ISDN、DSL、光纤）连接计算机到互联网，或者在路由器之间建立点对点连接。它是替代早期的 SLIP (Serial Line Internet Protoco">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:52:08.611Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PPP 协议",
  "url": "https://huiaz.github.io/2025/09/11/PPP%20%E5%8D%8F%E8%AE%AE/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:52:08.611Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/PPP%20%E5%8D%8F%E8%AE%AE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PPP 协议',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">PPP 协议</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">PPP 协议</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:52:08.611Z" title="更新于 2025-09-11 21:52:08">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="PPP-协议（点对点协议-Point-to-Point-Protocol）"><a href="#PPP-协议（点对点协议-Point-to-Point-Protocol）" class="headerlink" title="PPP 协议（点对点协议 &#x2F; Point-to-Point Protocol）"></a>PPP 协议（点对点协议 &#x2F; Point-to-Point Protocol）</h3><p>PPP (Point-to-Point Protocol) 是一种用于在两个网络节点之间建立<strong>直接连接</strong>的数据链路层协议。它主要用于通过串行线缆（如电话线、ISDN、DSL、光纤）连接计算机到互联网，或者在路由器之间建立点对点连接。它是替代早期的 SLIP (Serial Line Internet Protocol) 协议而生的，并解决了 SLIP 的许多限制。</p>
<p><strong>核心作用：</strong></p>
<p>PPP 提供了一种标准的方法来：</p>
<ol>
<li><strong>封装</strong>网络层数据包（如 IP 数据包），以便在点对点链路上传输。</li>
<li><strong>建立、配置和测试</strong>数据链路连接的可靠性。</li>
<li>提供<strong>网络层地址协商</strong>（例如，分配 IP 地址）。</li>
<li>提供<strong>身份验证</strong>机制（可选）。</li>
</ol>
<p>简而言之，PPP 就是在两点之间架起一座数据传输的桥梁，并确保桥梁能正常工作和通信。</p>
<hr>
<h3 id="PPP-协议的基本工作流程"><a href="#PPP-协议的基本工作流程" class="headerlink" title="PPP 协议的基本工作流程"></a>PPP 协议的基本工作流程</h3><p>PPP 的工作流程分为几个阶段，通过使用不同的子协议来完成：</p>
<ol>
<li>**链路控制协议 (LCP - Link Control Protocol)**：负责建立、配置和测试数据链路。</li>
<li>**网络控制协议 (NCP - Network Control Protocol)**：负责协商和配置网络层协议（例如 IP）。</li>
<li>**身份验证协议 (Authentication Protocols)**：可选，例如 PAP (Password Authentication Protocol) 或 CHAP (Challenge-Handshake Authentication Protocol)。</li>
</ol>
<h4 id="PPP-工作流程的阶段："><a href="#PPP-工作流程的阶段：" class="headerlink" title="PPP 工作流程的阶段："></a>PPP 工作流程的阶段：</h4><h4 id="阶段-1：链路建立阶段-Link-Establishment-Phase-由-LCP-管理"><a href="#阶段-1：链路建立阶段-Link-Establishment-Phase-由-LCP-管理" class="headerlink" title="阶段 1：链路建立阶段 (Link Establishment Phase) - 由 LCP 管理"></a>阶段 1：链路建立阶段 (Link Establishment Phase) - 由 LCP 管理</h4><p>这个阶段的目标是建立一个可靠的、能传输数据的点对点链路。</p>
<ol>
<li><p><strong>LCP 配置帧交换：</strong></p>
<ul>
<li>当两个 PPP 设备（例如，用户的拨号软件和 ISP 的调制解调器&#x2F;路由器）连接建立后，它们会开始交换一系列 LCP 配置请求帧。</li>
<li>这些帧会协商各种链路参数，例如：<ul>
<li><strong>最大接收单元 (MRU - Maximum Receive Unit)：</strong> 决定了在链路上最大允许传输的数据包大小。</li>
<li><strong>认证协议：</strong> 协商使用哪种认证协议（如果需要认证）。</li>
<li><strong>魔术数字 (Magic Number)：</strong> 用于检测链路环回（loopback）情况。</li>
<li><strong>异步控制字符映射 (ACCM)：</strong> 处理控制字符的转义。</li>
</ul>
</li>
<li>双方会反复发送 <code>Configure-Request</code>，直到它们对所有参数达成一致，然后发送 <code>Configure-ACK</code>。如果无法接受某个参数，则发送 <code>Configure-Reject</code> 或 <code>Configure-Nak</code>。</li>
</ul>
</li>
<li><p><strong>链路测试（可选）：</strong></p>
<ul>
<li>LCP 还可以发送 <code>Echo-Request</code> 和 <code>Echo-Reply</code> 来测试链路的连通性和延迟。</li>
<li>如果链路质量不佳或出现故障，LCP 可以发送 <code>Terminate-Request</code> 来终止链路，并在双方确认后发送 <code>Terminate-ACK</code>。</li>
</ul>
</li>
<li><p><strong>链路开放：</strong></p>
<ul>
<li>一旦 LCP 协商成功，链路就进入 OPEN 状态，可以开始进行网络层配置。</li>
</ul>
</li>
</ol>
<h4 id="阶段-2：身份验证阶段-Authentication-Phase-可选，由-PAP-CHAP-管理"><a href="#阶段-2：身份验证阶段-Authentication-Phase-可选，由-PAP-CHAP-管理" class="headerlink" title="阶段 2：身份验证阶段 (Authentication Phase) - 可选，由 PAP&#x2F;CHAP 管理"></a>阶段 2：身份验证阶段 (Authentication Phase) - 可选，由 PAP&#x2F;CHAP 管理</h4><p>这个阶段的目标是验证连接发起方的身份，确保只有授权用户才能接入网络。</p>
<ol>
<li><p><strong>认证请求：</strong></p>
<ul>
<li>通常由服务器方向客户端发起或客户端主动发送认证信息。</li>
<li><strong>PAP (Password Authentication Protocol)：</strong><ul>
<li>客户端直接发送用户名和密码给服务器。</li>
<li>简单但不安全，因为用户名和密码是明文传输的。</li>
<li>服务器验证后发送 <code>Authenticate-ACK</code> 或 <code>Authenticate-NAK</code>。</li>
</ul>
</li>
<li><strong>CHAP (Challenge-Handshake Authentication Protocol)：</strong><ul>
<li>服务器向客户端发送一个“挑战 (Challenge)”消息（通常包含一个随机数）。</li>
<li>客户端使用用户名、密码（双方都知道的密钥）和随机数计算出一个哈希值作为“响应 (Response)”发送给服务器。</li>
<li>服务器独立计算一个哈希值，与客户端的响应进行比较。</li>
<li>更安全，因为密码永不以明文形式在链路上发送，且挑战值不断变化，防止了重放攻击。</li>
<li>服务器验证后发送 <code>Authentication-Success</code> 或 <code>Authentication-Failure</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>成功或失败：</strong></p>
<ul>
<li>如果身份验证成功，链路进入网络层阶段。</li>
<li>如果身份验证失败，LCP 会终止链路。</li>
</ul>
</li>
</ol>
<h4 id="阶段-3：网络层协议阶段-Network-Layer-Protocol-Phase-由-NCP-管理"><a href="#阶段-3：网络层协议阶段-Network-Layer-Protocol-Phase-由-NCP-管理" class="headerlink" title="阶段 3：网络层协议阶段 (Network-Layer Protocol Phase) - 由 NCP 管理"></a>阶段 3：网络层协议阶段 (Network-Layer Protocol Phase) - 由 NCP 管理</h4><p>这个阶段的目标是配置网络层协议，例如为客户端分配 IP 地址。</p>
<ol>
<li><p><strong>NCP 配置帧交换：</strong></p>
<ul>
<li>最常用的 NCP 是 **IP Control Protocol (IPCP)**，用于配置 IP 网络层。</li>
<li>客户端通常发送 <code>IPCP Configure-Request</code>，请求分配一个 IP 地址、DNS 服务器地址、默认网关等。</li>
<li>服务器接收请求后，会根据其策略分配这些参数，并发送 <code>IPCP Configure-ACK</code> 进行确认。</li>
<li>例如，客户端会通过 IPCP 协商：<ul>
<li><code>IP-Addresses</code>：获取自身的 IP 地址。</li>
<li><code>Primary-DNS</code>、<code>Secondary-DNS</code>：获取 DNS 服务器地址。</li>
<li><code>IP-Compression</code>：协商 IP 数据包压缩。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>网络层就绪：</strong></p>
<ul>
<li>一旦 IPCP 协商成功，客户端就获得了 IP 地址和其他必要的网络配置信息，可以开始像普通网络设备一样发送和接收 IP 数据包了。</li>
</ul>
</li>
</ol>
<h4 id="阶段-4：数据传输阶段-Data-Transfer-Phase"><a href="#阶段-4：数据传输阶段-Data-Transfer-Phase" class="headerlink" title="阶段 4：数据传输阶段 (Data Transfer Phase)"></a>阶段 4：数据传输阶段 (Data Transfer Phase)</h4><ul>
<li>链路建立并配置完成后，网络层数据包（如 IP 数据包）就可以通过 PPP 链路进行封装和传输了。</li>
</ul>
<h4 id="阶段-5：链路终止阶段-Link-Termination-Phase"><a href="#阶段-5：链路终止阶段-Link-Termination-Phase" class="headerlink" title="阶段 5：链路终止阶段 (Link Termination Phase)"></a>阶段 5：链路终止阶段 (Link Termination Phase)</h4><ul>
<li>当连接不再需要时（例如用户挂断电话，或会话超时），任意一方都可以发送 LCP <code>Terminate-Request</code> 帧。</li>
<li>另一方收到后，发送 LCP <code>Terminate-ACK</code> 帧，链路被关闭。</li>
<li>如果链路出现故障，LCP 也会负责将其终止。</li>
</ul>
<p><strong>总结：</strong></p>
<p>PPP 协议通过分阶段的协商和自动化流程，使得两个只能通过串行方式连接的设备能够建立起一个功能齐全、可传输 IP 数据包的网络链路。它的模块化设计（LCP 负责链路，NCP 负责网络层）使其非常灵活和可扩展。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/PPP%20%E5%8D%8F%E8%AE%AE/">https://huiaz.github.io/2025/09/11/PPP%20%E5%8D%8F%E8%AE%AE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Pod%20%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/" title="Pod 使用进阶"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Pod 使用进阶</div></div><div class="info-2"><div class="info-item-1">Pod 使用进阶-深入理解 Pod 对象Pod 资源配置实际上上面几个步骤就是影响一个 Pod 生命周期的大的部分，但是还有一些细节也会在 Pod 的启动过程进行设置，比如在容器启动之前还会为当前的容器设置分配的 CPU、内存等资源，我们知道我们可以通过 CGroup 来对容器的资源进行限制，同样的，在 Pod 中我们也可以直接配置某个容器的使用的 CPU 或者内存的上限。那么 Pod 是如何来使用和控制这些资源的分配的呢？ 首先对于 CPU，我们知道计算机里 CPU 的资源是按“时间片”的方式来进行分配的，系统里的每一个操作都需要 CPU 的处理，所以，哪个任务要是申请的 CPU 时间片越多，那么它得到的 CPU 资源就越多，这个很容器理解。 然后还需要了解下 CGroup 里面对于 CPU 资源的单位换算： 121 CPU =  1000 millicpu（1 Core = 1000m）0.5 CPU = 500 millicpu （0.5 Core = 500m）  这里的 m 就是毫、毫核的意思，Kubernetes 集群中的每一个节点可以通过操作系统的命令来确认本节点的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/POD%20Pending/" title="POD Pending"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">POD Pending</div></div><div class="info-2"><div class="info-item-1">彻底搞懂 K8S Pod Pending 故障原因及解决方案即使在高成熟度级别 Kubernetes 集群中 pod pending 也是无处不在。 如果您随机询问任何使用 Kubernetes DevOps 工程师来确定折磨他们噩梦的最常见错误，pod pending 可能是非常常见的问题（可能仅次于 CrashLoopBackOff）。 尝试推送更新并看到它卡住会使 DevOps 紧张。即使解决方案相当简单，找到 pod 挂起的原因并了解您需要应用的更改也很重要（Kubernetes 故障排除很少是微不足道的）。  在本文中，我们将阐明导致此问题的不同情况，让 DevOps 团队能够快速找到解决方案，最重要的是，尽可能避免它。 Kubernetes Pod pending 是什么意思？Kubernetes 中的 Pod 的生命周期由几个不同的阶段组成：  创建 pod 时，它从Pending阶段开始。 一旦 pod 被调度并且容器已经启动，pod 就会进入Running阶段。  大多数 pod 只需要几秒钟就可以从 Pending 到 Running 并在该状态下度过大部分时...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81/" title="HTTP 状态码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 状态码</div></div><div class="info-2"><div class="info-item-1">HTTP 状态码HTTP 状态码是服务器对请求的响应。它们是三位数字，分为五个类别，指示请求是否已成功处理，或者是否存在错误。理解这些状态码对于调试网络问题和理解Web应用程序的行为至关重要。 以下是常见的 HTTP 状态码及其简要说明：  1xx - 信息响应 (Informational Responses)指示请求已被接收，继续处理。这些是临时响应，不带任何内容。  100 Continue: 客户端应继续其请求。通常用于客户端发送一个大型请求体到服务器之前，先发送头部，服务器如果允许，则返回 100 Continue，然后客户端再发送请求体。   2xx - 成功响应 (Successful Responses)指示请求已被成功接收、理解和接受。  200 OK: 请求已成功。这是最常见的状态码，表示请求的一切正常，服务器已返回所请求的数据。 201 Created: 请求已成功，并因此创建了一个新的资源。这通常是 PUT 或 POST 请求的响应。响应体中通常包含新创建资源的URI。 202 Accepted: 请求已被接受进行处理，但处理尚未完成。请求可能最终被执行，...</div></div></div></a><a class="pagination-related" href="/2025/09/11/NAT/" title="NAT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">NAT</div></div><div class="info-2"><div class="info-item-1">什么是网络地址转换（NAT）？NAT (Network Address Translation)，即网络地址转换，是一种在 IP 网络中改变数据包的 IP 地址信息的技术。它的主要目的是解决 IPv4 地址枯竭的问题，同时也能提供一定程度的网络安全隔离。 简单来说，NAT 允许一个拥有私有 IP 地址的网络（如家庭网络或企业内部网络）连接到使用公共 IP 地址的外部网络（如互联网），而无需为内部的每台设备都分配一个唯一的公共 IP 地址。 核心概念：  私有 IP 地址： 在私有网络内部使用的 IP 地址，它们不能直接在公共互联网上路由。RFC 1918 定义了以下私有 IP 地址范围： 10.0.0.0 到 10.255.255.255 (10&#x2F;8) 172.16.0.0 到 172.31.255.255 (172.16&#x2F;12) 192.168.0.0 到 192.168.255.255 (192.168&#x2F;16)   公共 IP 地址： 在公共互联网上可寻址的全球唯一的 IP 地址。 NAT 设备： 通常是路由器或防火墙，负责执行 IP 地址的转换...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/" title="TCP 客户端在发送 SYN 之后宕机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 客户端在发送 SYN 之后宕机</div></div><div class="info-2"><div class="info-item-1">这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。 假设客户端 A 尝试连接服务器 B。 1. 客户端发送 SYN (第一次握手) 客户端 A： 生成一个 SYN 包，Seq = client_ISN，发送给服务器 B。 发送后，客户端 A 的 TCP 状态会从 CLOSED 变为 SYN_SENT。  2. 客户端 A 宕机 就在发送 SYN 包之后，客户端 A 突然崩溃（例如，操作系统蓝屏、电源故障、进程被杀掉等）。这意味着客户端 A 的所有网络状态、定时器、内存中的 TCP 控制块信息都瞬间丢失了。  3. 服务器 B 的处理 服务器 B 收到 SYN： 服务器 B 收到了客户端 A 发送的 SYN 包。 服务器 B 响应 SYN+ACK： 服务器 B 按照 TCP 握手流程，会进入 SYN_RCVD 状态，并向客户端 A 发送 SYN+ACK 包 (Seq = server_ISN, Ack = client_ISN + 1)。 服务器 B 等待客户端 ACK： 服务器 B 此时会启动一个定时...</div></div></div></a><a class="pagination-related" href="/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/" title="DHCP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">DHCP 协议</div></div><div class="info-2"><div class="info-item-1">DHCP 协议的工作原理及应用场景什么是 DHCP 协议？DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 是一种网络协议，用于自动化管理和分配网络中的 IP 地址以及其他相关配置信息（如子网掩码、默认网关、DNS 服务器地址等）。它的核心思想是取代手动配置每台设备的网络参数，实现即插即用，大大简化了大型网络的管理。 DHCP 协议的工作原理 (DORA 过程)DHCP 协议通常通过四步过程（称为 DORA 过程）来完成 IP 地址分配：  Discover (发现)  客户端行为： 当一台新设备（或一台没有配置 IP 地址的设备）连接到网络时，它不知道网络中是否有 DHCP 服务器，也不知道自己的 IP 地址。因此，它会广播一个 DHCP Discover 消息到局域网内的所有设备（使用目的 IP 地址 255.255.255.255，源 IP 地址 0.0.0.0）。 目的： 寻找网络中的 DHCP 服务器。   Offer (提供)  服务器行为： 网络中的 DHCP 服务器收到 DHCP Discover 消息后，会从...</div></div></div></a><a class="pagination-related" href="/2025/09/11/RIR%20%E5%8D%8F%E8%AE%AE/" title="RIR 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">RIR 协议</div></div><div class="info-2"><div class="info-item-1">RIP (Routing Information Protocol) 协议的工作原理及特点RIP (Routing Information Protocol) 是一种经典的**距离向量路由协议 (Distance-Vector Routing Protocol)**，用于在内部网关 (Interior Gateway Protocol, IGP) 环境中交换路由信息。它历史悠久，简单易用，但存在一些固有的局限性。  RIP 的工作原理：RIP 的工作原理基于 Bellman-Ford 算法的变体，其核心思想是每个路由器维护一个到所有已知目的地的距离向量，并定期与邻居交换此信息。  里程 (Metric) - 跳数 (Hop Count)：  RIP 使用跳数 (Hop Count) 作为唯一的路由度量（metric）。 每经过一个路由器，跳数就增加 1。 最大跳数限制： RIP 的最大跳数限制为 15 跳。这意味着任何超过 15 跳的目的地都被认为是不可达的（即距离为无穷大）。这是 RIP 最大的局限性之一，使其不适合大型网络。   距离向量的维护：  每个 RIP 路由器维护一...</div></div></div></a><a class="pagination-related" href="/2025/09/11/CoreDNS/" title="CoreDNS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">CoreDNS</div></div><div class="info-2"><div class="info-item-1">服务发现上面我们讲解了 Service 的用法，我们可以通过 Service 生成的 ClusterIP(VIP) 来访问 Pod 提供的服务，但是在使用的时候还有一个问题：我们怎么知道某个应用的 VIP 呢？比如我们有两个应用，一个是 api 应用，一个是 db 应用，两个应用都是通过 Deployment 进行管理的，并且都通过 Service 暴露出了端口提供服务。api 需要连接到 db 这个应用，我们只知道 db 应用的名称和 db 对应的 Service 的名称，但是并不知道它的 VIP 地址，我们前面的 Service 课程中是不是学习到我们通过 ClusterIP 就可以访问到后面的 Pod 服务，如果我们知道了 VIP 的地址是不是就行了？ 环境变量为了解决上面的问题，在之前的版本中，Kubernetes 采用了环境变量的方法，每个 Pod 启动的时候，会通过环境变量设置所有服务的 IP 和 port 信息，这样 Pod 中的应用可以通过读取环境变量来获取依赖服务的地址信息，这种方法使用起来相对简单，但是有一个很大的问题就是依赖的服务必须在 Pod 启动之前就存...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#PPP-%E5%8D%8F%E8%AE%AE%EF%BC%88%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE-Point-to-Point-Protocol%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">PPP 协议（点对点协议 &#x2F; Point-to-Point Protocol）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PPP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">PPP 协议的基本工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PPP-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%9A%84%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">PPP 工作流程的阶段：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-1%EF%BC%9A%E9%93%BE%E8%B7%AF%E5%BB%BA%E7%AB%8B%E9%98%B6%E6%AE%B5-Link-Establishment-Phase-%E7%94%B1-LCP-%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">阶段 1：链路建立阶段 (Link Establishment Phase) - 由 LCP 管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-2%EF%BC%9A%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5-Authentication-Phase-%E5%8F%AF%E9%80%89%EF%BC%8C%E7%94%B1-PAP-CHAP-%E7%AE%A1%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">阶段 2：身份验证阶段 (Authentication Phase) - 可选，由 PAP&#x2F;CHAP 管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-3%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%E9%98%B6%E6%AE%B5-Network-Layer-Protocol-Phase-%E7%94%B1-NCP-%E7%AE%A1%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">阶段 3：网络层协议阶段 (Network-Layer Protocol Phase) - 由 NCP 管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-4%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%98%B6%E6%AE%B5-Data-Transfer-Phase"><span class="toc-number">2.5.</span> <span class="toc-text">阶段 4：数据传输阶段 (Data Transfer Phase)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-5%EF%BC%9A%E9%93%BE%E8%B7%AF%E7%BB%88%E6%AD%A2%E9%98%B6%E6%AE%B5-Link-Termination-Phase"><span class="toc-number">2.6.</span> <span class="toc-text">阶段 5：链路终止阶段 (Link Termination Phase)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>