<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Go 枚举实现方法 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="其核心思想是：使用常量（const）和自定义类型（type）。  场景设定假设我们正在开发一个订单处理系统，订单有以下几种状态：  待处理 (Pending) 处理中 (InProgress) 已完成 (Completed) 已失败 (Failed)  第 1 步：使用常量（const）和 iota这是实现枚举的基础。iota 是一个特殊的常量，可以被编译器自动修改。在每个 const 声明中，i">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 枚举实现方法">
<meta property="og:url" content="http://example.com/2025/09/11/Go%20%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="其核心思想是：使用常量（const）和自定义类型（type）。  场景设定假设我们正在开发一个订单处理系统，订单有以下几种状态：  待处理 (Pending) 处理中 (InProgress) 已完成 (Completed) 已失败 (Failed)  第 1 步：使用常量（const）和 iota这是实现枚举的基础。iota 是一个特殊的常量，可以被编译器自动修改。在每个 const 声明中，i">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:32:40.803Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Go 枚举实现方法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go 枚举实现方法",
  "url": "http://example.com/2025/09/11/Go%20%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:32:40.803Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/11/Go%20%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go 枚举实现方法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Go 枚举实现方法</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Go 枚举实现方法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:32:40.803Z" title="更新于 2025-09-11 22:32:40">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go/">go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>其核心思想是：<strong>使用常量（<code>const</code>）和自定义类型（<code>type</code>）。</strong></p>
<hr>
<h3 id="场景设定"><a href="#场景设定" class="headerlink" title="场景设定"></a>场景设定</h3><p>假设我们正在开发一个订单处理系统，订单有以下几种状态：</p>
<ul>
<li>待处理 (Pending)</li>
<li>处理中 (InProgress)</li>
<li>已完成 (Completed)</li>
<li>已失败 (Failed)</li>
</ul>
<h3 id="第-1-步：使用常量（const）和-iota"><a href="#第-1-步：使用常量（const）和-iota" class="headerlink" title="第 1 步：使用常量（const）和 iota"></a>第 1 步：使用常量（<code>const</code>）和 <code>iota</code></h3><p>这是实现枚举的基础。<code>iota</code> 是一个特殊的常量，可以被编译器自动修改。在每个 <code>const</code> 声明中，<code>iota</code> 从 0 开始，每行递增 1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// iota 在这里是 0</span></span><br><span class="line">	StatusPending = <span class="literal">iota</span> </span><br><span class="line">    <span class="comment">// iota 在这里是 1</span></span><br><span class="line">	StatusInProgress</span><br><span class="line">    <span class="comment">// iota 在这里是 2</span></span><br><span class="line">	StatusCompleted</span><br><span class="line">    <span class="comment">// iota 在这里是 3</span></span><br><span class="line">	StatusFailed</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 输出: 0 1 2 3</span></span><br><span class="line">	fmt.Println(StatusPending, StatusInProgress, StatusCompleted, StatusFailed) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<ul>
<li>简洁，自动递增，避免手动设置 <code>0, 1, 2, 3...</code> 带来的“魔法数字”和潜在错误。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>缺乏类型安全</strong>。这些常量本质上都是 <code>int</code> 类型。这意味着任何 <code>int</code> 都可以被传递给需要订单状态的函数，编译器无法发现错误。例如： <code>processOrderStatus(99)</code> 是合法的，但逻辑上是错误的。</li>
</ul>
<hr>
<h3 id="第-2-步：引入自定义类型（实现类型安全）"><a href="#第-2-步：引入自定义类型（实现类型安全）" class="headerlink" title="第 2 步：引入自定义类型（实现类型安全）"></a>第 2 步：引入自定义类型（实现类型安全）</h3><p>为了解决类型安全问题，我们将为订单状态创建一个新的、独立的类型。这是 Go 中实现枚举的<strong>惯用（idiomatic）方法</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建一个自定义类型 OrderStatus，其底层类型是 int</span></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将常量与我们的新类型关联起来</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Pending OrderStatus = <span class="literal">iota</span> <span class="comment">// 现在是 OrderStatus 类型，值为 0</span></span><br><span class="line">	InProgress</span><br><span class="line">	Completed</span><br><span class="line">	Failed</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数现在只接受 OrderStatus 类型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processOrderStatus</span><span class="params">(status OrderStatus)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Processing status: %d\n&quot;</span>, status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	processOrderStatus(Completed) <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// processOrderStatus(2) // 编译错误！</span></span><br><span class="line">	<span class="comment">// 错误信息: cannot use 2 (untyped int constant) as OrderStatus value in argument to processOrderStatus</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// var someOtherInt int = 1</span></span><br><span class="line">    <span class="comment">// processOrderStatus(someOtherInt) // 同样会编译错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<ul>
<li><strong>类型安全</strong>：编译器会确保只有 <code>OrderStatus</code> 类型的值才能传递给相关函数，极大地减少了运行时错误。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>可读性差</strong>：当打印或记录日志时，我们看到的是 <code>0, 1, 2, 3</code>，而不是 <code>Pending</code>, <code>InProgress</code> 等有意义的字符串。</li>
</ul>
<hr>
<h3 id="第-3-步：实现-String-方法（提升可读性）"><a href="#第-3-步：实现-String-方法（提升可读性）" class="headerlink" title="第 3 步：实现 String() 方法（提升可读性）"></a>第 3 步：实现 <code>String()</code> 方法（提升可读性）</h3><p>为了解决可读性问题，我们可以为 <code>OrderStatus</code> 类型实现 <code>fmt.Stringer</code> 接口。该接口只有一个方法：<code>String() string</code>。<code>fmt</code> 包在打印值时会自动检查并调用这个方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Pending OrderStatus = <span class="literal">iota</span></span><br><span class="line">	InProgress</span><br><span class="line">	Completed</span><br><span class="line">	Failed</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 OrderStatus 类型实现 String() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s OrderStatus)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> s &#123;</span><br><span class="line">	<span class="keyword">case</span> Pending:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;PENDING&quot;</span></span><br><span class="line">	<span class="keyword">case</span> InProgress:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;IN_PROGRESS&quot;</span></span><br><span class="line">	<span class="keyword">case</span> Completed:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;COMPLETED&quot;</span></span><br><span class="line">	<span class="keyword">case</span> Failed:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;FAILED&quot;</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;UNKNOWN&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	status := Completed</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// fmt.Println 和 fmt.Printf(&quot;%v&quot;, ...) 会自动调用 String() 方法</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Current status is:&quot;</span>, status) <span class="comment">// 输出: Current status is: COMPLETED</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<ul>
<li><strong>可读性极佳</strong>：无论是打印到控制台还是写入日志文件，都能显示人类可读的字符串。</li>
<li>符合 Go 的接口设计哲学。</li>
</ul>
<hr>
<h3 id="第-4-步：生产级考量-JSON-序列化"><a href="#第-4-步：生产级考量-JSON-序列化" class="headerlink" title="第 4 步：生产级考量 (JSON 序列化)"></a>第 4 步：生产级考量 (JSON 序列化)</h3><p>在后端 API 开发中，枚举值经常需要在 JSON 中表示为字符串。默认情况下，Go 的 <code>json.Marshal</code> 会将 <code>OrderStatus</code> 序列化为其底层 <code>int</code> 值（<code>0, 1, 2...</code>）。这对于 API 客户端非常不友好。</p>
<p>我们可以通过实现 <code>json.Marshaler</code> 和 <code>json.Unmarshaler</code> 接口来自定义 JSON 行为。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// ... (同上)</span></span><br><span class="line">	Pending OrderStatus = <span class="literal">iota</span></span><br><span class="line">	InProgress</span><br><span class="line">	Completed</span><br><span class="line">	Failed</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s OrderStatus)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 将字符串列表存储在一个变量中以便复用</span></span><br><span class="line">	statuses := [...]<span class="type">string</span>&#123;<span class="string">&quot;PENDING&quot;</span>, <span class="string">&quot;IN_PROGRESS&quot;</span>, <span class="string">&quot;COMPLETED&quot;</span>, <span class="string">&quot;FAILED&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">	<span class="keyword">if</span> s &lt; <span class="number">0</span> || <span class="type">int</span>(s) &gt;= <span class="built_in">len</span>(statuses) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;UNKNOWN&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> statuses[s]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MarshalJSON 自定义如何将 OrderStatus 序列化为 JSON</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s OrderStatus)</span></span> MarshalJSON() ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 将状态转换为字符串，并用双引号包裹，使其成为合法的 JSON 字符串</span></span><br><span class="line">	<span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">`&quot;`</span> + s.String() + <span class="string">`&quot;`</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnmarshalJSON 自定义如何从 JSON 反序列化为 OrderStatus</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *OrderStatus)</span></span> UnmarshalJSON(data []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// data 包含双引号，例如 &quot;PENDING&quot;</span></span><br><span class="line">	str := <span class="type">string</span>(data)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 移除双引号</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(str) &lt; <span class="number">2</span> || str[<span class="number">0</span>] != <span class="string">&#x27;&quot;&#x27;</span> || str[<span class="built_in">len</span>(str)<span class="number">-1</span>] != <span class="string">&#x27;&quot;&#x27;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;OrderStatus: invalid JSON value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	str = str[<span class="number">1</span> : <span class="built_in">len</span>(str)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> str &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;PENDING&quot;</span>:</span><br><span class="line">		*s = Pending</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;IN_PROGRESS&quot;</span>:</span><br><span class="line">		*s = InProgress</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;COMPLETED&quot;</span>:</span><br><span class="line">		*s = Completed</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;FAILED&quot;</span>:</span><br><span class="line">		*s = Failed</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;OrderStatus: unknown value &quot;</span> + str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="type">int</span>         <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">	Status OrderStatus <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// --- 序列化演示 ---</span></span><br><span class="line">	order := Order&#123;ID: <span class="number">123</span>, Status: InProgress&#125;</span><br><span class="line">	jsonData, _ := json.Marshal(order)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出: &#123;&quot;id&quot;:123,&quot;status&quot;:&quot;IN_PROGRESS&quot;&#125;</span></span><br><span class="line">	fmt.Println(<span class="type">string</span>(jsonData)) </span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- 反序列化演示 ---</span></span><br><span class="line">	jsonInput := <span class="string">`&#123;&quot;id&quot;:456,&quot;status&quot;:&quot;COMPLETED&quot;&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> newOrder Order</span><br><span class="line">	json.Unmarshal([]<span class="type">byte</span>(jsonInput), &amp;newOrder)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出: Received Order: &#123;ID:456 Status:COMPLETED&#125;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Received Order: &#123;ID:%d Status:%v&#125;\n&quot;</span>, newOrder.ID, newOrder.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结与最终建议"><a href="#总结与最终建议" class="headerlink" title="总结与最终建议"></a>总结与最终建议</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">实现方法</th>
<th align="left">优点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>基础枚举</strong></td>
<td align="left"><code>const</code> 块 + <code>iota</code></td>
<td align="left">简洁，自动递增</td>
</tr>
<tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left"><code>type MyEnum int</code> + 将常量声明为该类型</td>
<td align="left">编译器保证类型正确性，防止滥用</td>
</tr>
<tr>
<td align="left"><strong>可读性</strong></td>
<td align="left">实现 <code>func (e MyEnum) String() string</code> (即 <code>fmt.Stringer</code>)</td>
<td align="left">日志和打印输出清晰</td>
</tr>
<tr>
<td align="left"><strong>API友好性</strong></td>
<td align="left">实现 <code>json.Marshaler</code> 和 <code>json.Unmarshaler</code> 接口</td>
<td align="left">在 JSON 中以字符串形式交互，而非数字</td>
</tr>
</tbody></table>
<p><strong>对于绝大多数后端应用，一个生产级的 Go 枚举应该包括以上所有四个步骤：</strong></p>
<ol>
<li><strong>使用 <code>type</code> 定义一个新类型。</strong></li>
<li><strong>使用 <code>const</code> 和 <code>iota</code> 定义枚举值。</strong></li>
<li><strong>实现 <code>String()</code> 方法以满足 <code>fmt.Stringer</code> 接口。</strong></li>
<li><strong>根据需要实现 <code>json.Marshaler</code> &#x2F; <code>Unmarshaler</code> 接口以获得友好的 API 行为。</strong></li>
</ol>
<p>这套组合拳虽然比单一的 <code>enum</code> 关键字步骤多，但它提供了无与伦比的灵活性、类型安全和可扩展性，完全符合 Go 语言的设计哲学。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/Go%20%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/">http://example.com/2025/09/11/Go%20%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Go-%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/">Go 枚举实现方法</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Go%20%E7%A9%BA%E5%88%87%E7%89%87%E4%B8%8E%20nil%20%E5%88%87%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Go 空切片与 nil 切片的区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Go 空切片与 nil 切片的区别</div></div><div class="info-2"><div class="info-item-1">核心区别：nil 切片的底层指针是 nil，而空切片的底层指针是一个有效的、指向 0 字节内存区域的地址。 虽然它们在很多操作上表现一致（如 len、cap、for range、append），但这个根本性的指针差异导致了他们在内存表示、JSON 序列化和语义表达上的关键不同。 让我们深入剖析。  1. 结构与定义要理解它们的区别，首先要看切片在 Go 底层的结构 SliceHeader： 12345type SliceHeader struct &#123;    Data uintptr // 指向底层数组的指针    Len  int     // 切片的长度    Cap  int     // 切片的容量&#125; nil 切片和空切片的区别就体现在这个 Data 指针上。 Nil 切片 (Nil Slice)一个 nil 切片是切片类型的零值。它的指针 Data 为 nil，并且 Len 和 Cap 都是 0。  声明方式：仅声明变量而不进行初始化。 12var s []int // 此时 s 就是一个 nil 切片  内部状态： 1234s (SliceHeade...</div></div></div></a><a class="pagination-related" href="/2025/09/11/GPUStack/" title="GPUStack"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">GPUStack</div></div><div class="info-2"><div class="info-item-1">GPUStack：打造企业级私有大模型服务的开源利器最近，一个国产开源项目凭借高质量的代码、飞快的迭代速度和简洁友好的操作体验正在悄然崛起。短短半年内，这个项目已经在国内外开源社区获得了众多的拥趸和生产用户。它就是今天要介绍的开源项目 - GPUStack。  GPUStack 是一个 100% 开源的大模型服务平台，用户只需要简单的设置，就可以高效整合包括 NVIDIA、Apple Metal、华为昇腾和摩尔线程在内的各种异构 GPU&#x2F;NPU 资源，构建异构 GPU 集群，在私有环境提供企业级的大模型部署解决方案。 GPUStack 支持私有化部署 RAG 系统和 AI Agent 系统所需的各种关键模型，包括 LLM 大语言模型、VLM 多模态模型、Embedding 文本嵌入模型、Rerank 重排序模型、Text-to-Image 文生图模型，以及 Speech-to-Text（STT）和 Text-to-Speech（TTS）语音模型等。并提供统一认证和高可用负载均衡的 OpenAI 兼容 API，供用户从各类大模型云服务无缝迁移到本地部署的私有大模型服务。 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%AF%94/" title="数据对比"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">数据对比</div></div><div class="info-2"><div class="info-item-1">数据对比有的时候我们可能需要去访问过去的数据，并和当前数据进行对比。例如，我们可能想比较今天的请求率和一周前的请求率之间的差异。我们可以在任何区间向量或瞬时向量选择器上附加一个偏移量 offset&lt;duration&gt; 的修饰符（比如 my_metric offset 5m 或者 my_metric[1m] offset 7d）。 让我们来看一个示例，在我们的 demo 服务中暴露了一个 Counter 指标 demo_items_shipped_total，该指标追踪物品的运输情况，用 5 分钟来模拟&quot;每日&quot;流量周期，所以我们不必等待一整天才能查看该时段的数据。 我们只使用第一个演示服务实例来测试即可，首先我们来看看它的速率： 1rate(demo_items_shipped_total&#123;instance=&quot;demo-service-0:10000&quot;&#125;[1m])   该服务还暴露了一个 0 或 1 的布尔指标，告诉我们现在是否是假期：  将假期与发货商品率进行比较，注意到节假日时它会减少!我们可以尝试将当前的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Local%20%E5%AD%98%E5%82%A8/" title="Local 存储"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Local 存储</div></div><div class="info-2"><div class="info-item-1">Local 存储前面我们有通过 hostPath 或者 emptyDir 的方式来持久化我们的数据，但是显然我们还需要更加可靠的存储来保存应用的持久化数据，这样容器在重建后，依然可以使用之前的数据。但是存储资源和 CPU 资源以及内存资源有很大不同，为了屏蔽底层的技术实现细节，让用户更加方便的使用，Kubernetes 便引入了 PV 和 PVC 两个重要的资源对象来实现对存储的管理。 概念PV 的全称是：PersistentVolume（持久化卷），是对底层共享存储的一种抽象，PV 由管理员进行创建和配置，它和具体的底层的共享存储技术的实现方式有关，比如 Ceph、GlusterFS、NFS、hostPath 等，都是通过插件机制完成与共享存储的对接。 PVC 的全称是：PersistentVolumeClaim（持久化卷声明），PVC 是用户存储的一种声明，PVC 和 Pod 比较类似，Pod 消耗的是节点，PVC 消耗的是 PV 资源，Pod 可以请求 CPU 和内存，而 PVC 可以请求特定的存储空间和访问模式。对于真正使用存储的用户不需要关心底层的存储实现细节，只需要直...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%E4%B8%AD%20crontab/" title="Linux 系统中 crontab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 系统中 crontab</div></div><div class="info-2"><div class="info-item-1">Linux 系统中 crontab Crontab 的工作原理crontab（cron table） 是 Linux&#x2F;Unix 系统用于设置周期性执行任务的工具。它的核心是 cron 服务（或称为 crond 守护进程），这个服务在系统启动时就会自动运行，并且会一直在后台持续运行，它的主要职责是：  读取定时任务配置： cron 服务会周期性地（通常是每分钟）扫描特定的配置文件，这些文件包含了用户定义的定时任务列表。主要的配置文件位置包括：  系统级别的定时任务： /etc/crontab：系统主 cron 表，通常用于定义系统级的任务。 /etc/cron.d/：该目录下的所有文件都会被 cron 服务读取，每个文件可以定义独立的定时任务。 /etc/cron.hourly/, /etc/cron.daily/, /etc/cron.weekly/, /etc/cron.monthly/：这些目录下的脚本会分别每小时、每天、每周、每月被 cron 服务执行一次。   用户级别的定时任务： /var/spool/cron/：每个用户的 crontab -e 命令编辑的任...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/" title="路由算法与协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">路由算法与协议</div></div><div class="info-2"><div class="info-item-1">路由协议 (Routing Protocols) 和路由选择算法 (Routing Algorithms) 是网络路由领域紧密相关但又截然不同的两个概念。理解它们之间的区别对于掌握网络路由的精髓至关重要。 路由选择算法 (Routing Algorithms)核心： 路由选择算法是决定数据包在网络中从源到目的地最佳路径的逻辑或计算过程。它关注的是“如何计算出最佳路径”。 特点：  数学模型&#x2F;逻辑： 它们是一套定义了如何根据特定度量（如跳数、延迟、带宽、成本等）来计算最优路径的数学模型或逻辑步骤。 通用性： 许多路由算法是通用的计算机科学概念，不局限于特定的网络设备或协议。 独立于实现： 算法本身只是一套理论，它不关心具体如何被实现或在哪个设备上运行。 输入： 它们通常需要网络拓扑信息（节点和链路）以及链路成本&#x2F;度量作为输入。 输出： 输出是到达网络中各个目的地的最佳路径。  常见的路由选择算法：  Dijkstra (迪克斯特拉) 算法： 经典的最短路径算法，常用于链路状态路由（如 OSPF）。它计算从单个源到所有其他节点的单源最短路径。 Bellman-Fo...</div></div></div></a><a class="pagination-related" href="/2025/09/11/shell/" title="shell-mail"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">shell-mail</div></div><div class="info-2"><div class="info-item-1">Shell 脚本，用于检查磁盘使用率并在超过阈值时发送告警邮件。 这个脚本考虑了几个重要的实践：  可配置性：阈值和收件人作为变量定义，方便修改。 明确性：邮件内容清晰地指明了问题服务器、挂载点和当前使用率。 排除项：可以轻松排除某些文件系统（如 tmpfs, devtmpfs）。 锁机制：防止脚本在前一个实例仍在运行时重复执行。   check_disk_usage.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#!/bin/bash# ==============================================================================# Script Name:...</div></div></div></a><a class="pagination-related" href="/2025/09/11/POD%20Pending/" title="POD Pending"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">POD Pending</div></div><div class="info-2"><div class="info-item-1">彻底搞懂 K8S Pod Pending 故障原因及解决方案即使在高成熟度级别 Kubernetes 集群中 pod pending 也是无处不在。 如果您随机询问任何使用 Kubernetes DevOps 工程师来确定折磨他们噩梦的最常见错误，pod pending 可能是非常常见的问题（可能仅次于 CrashLoopBackOff）。 尝试推送更新并看到它卡住会使 DevOps 紧张。即使解决方案相当简单，找到 pod 挂起的原因并了解您需要应用的更改也很重要（Kubernetes 故障排除很少是微不足道的）。  在本文中，我们将阐明导致此问题的不同情况，让 DevOps 团队能够快速找到解决方案，最重要的是，尽可能避免它。 Kubernetes Pod pending 是什么意思？Kubernetes 中的 Pod 的生命周期由几个不同的阶段组成：  创建 pod 时，它从Pending阶段开始。 一旦 pod 被调度并且容器已经启动，pod 就会进入Running阶段。  大多数 pod 只需要几秒钟就可以从 Pending 到 Running 并在该状态下度过大部分时...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A"><span class="toc-number">1.</span> <span class="toc-text">场景设定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E6%AD%A5%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%EF%BC%88const%EF%BC%89%E5%92%8C-iota"><span class="toc-number">2.</span> <span class="toc-text">第 1 步：使用常量（const）和 iota</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E6%AD%A5%EF%BC%9A%E5%BC%95%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">第 2 步：引入自定义类型（实现类型安全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E6%AD%A5%EF%BC%9A%E5%AE%9E%E7%8E%B0-String-%E6%96%B9%E6%B3%95%EF%BC%88%E6%8F%90%E5%8D%87%E5%8F%AF%E8%AF%BB%E6%80%A7%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">第 3 步：实现 String() 方法（提升可读性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E6%AD%A5%EF%BC%9A%E7%94%9F%E4%BA%A7%E7%BA%A7%E8%80%83%E9%87%8F-JSON-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">第 4 步：生产级考量 (JSON 序列化)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E7%BB%88%E5%BB%BA%E8%AE%AE"><span class="toc-number">6.</span> <span class="toc-text">总结与最终建议</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>