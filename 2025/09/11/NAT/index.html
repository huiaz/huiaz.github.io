<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>NAT | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是网络地址转换（NAT）？NAT (Network Address Translation)，即网络地址转换，是一种在 IP 网络中改变数据包的 IP 地址信息的技术。它的主要目的是解决 IPv4 地址枯竭的问题，同时也能提供一定程度的网络安全隔离。 简单来说，NAT 允许一个拥有私有 IP 地址的网络（如家庭网络或企业内部网络）连接到使用公共 IP 地址的外部网络（如互联网），而无需为内部的">
<meta property="og:type" content="article">
<meta property="og:title" content="NAT">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/NAT/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="什么是网络地址转换（NAT）？NAT (Network Address Translation)，即网络地址转换，是一种在 IP 网络中改变数据包的 IP 地址信息的技术。它的主要目的是解决 IPv4 地址枯竭的问题，同时也能提供一定程度的网络安全隔离。 简单来说，NAT 允许一个拥有私有 IP 地址的网络（如家庭网络或企业内部网络）连接到使用公共 IP 地址的外部网络（如互联网），而无需为内部的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:50:08.076Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "NAT",
  "url": "https://huiaz.github.io/2025/09/11/NAT/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:50:08.076Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/NAT/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NAT',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">NAT</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">NAT</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:50:08.076Z" title="更新于 2025-09-11 21:50:08">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="什么是网络地址转换（NAT）？"><a href="#什么是网络地址转换（NAT）？" class="headerlink" title="什么是网络地址转换（NAT）？"></a>什么是网络地址转换（NAT）？</h3><p><strong>NAT (Network Address Translation)<strong>，即</strong>网络地址转换</strong>，是一种在 IP 网络中改变数据包的 IP 地址信息的<strong>技术</strong>。它的主要目的是解决 IPv4 地址枯竭的问题，同时也能提供一定程度的网络安全隔离。</p>
<p>简单来说，NAT 允许一个拥有<strong>私有 IP 地址</strong>的网络（如家庭网络或企业内部网络）连接到使用<strong>公共 IP 地址</strong>的外部网络（如互联网），而无需为内部的每台设备都分配一个唯一的公共 IP 地址。</p>
<p><strong>核心概念：</strong></p>
<ul>
<li><strong>私有 IP 地址：</strong> 在私有网络内部使用的 IP 地址，它们不能直接在公共互联网上路由。RFC 1918 定义了以下私有 IP 地址范围：<ul>
<li><code>10.0.0.0</code> 到 <code>10.255.255.255</code> (10&#x2F;8)</li>
<li><code>172.16.0.0</code> 到 <code>172.31.255.255</code> (172.16&#x2F;12)</li>
<li><code>192.168.0.0</code> 到 <code>192.168.255.255</code> (192.168&#x2F;16)</li>
</ul>
</li>
<li><strong>公共 IP 地址：</strong> 在公共互联网上可寻址的全球唯一的 IP 地址。</li>
<li><strong>NAT 设备：</strong> 通常是路由器或防火墙，负责执行 IP 地址的转换。</li>
</ul>
<h3 id="NAT-的工作原理："><a href="#NAT-的工作原理：" class="headerlink" title="NAT 的工作原理："></a>NAT 的工作原理：</h3><p>NAT 的工作原理是当数据包在私有网络和公共网络之间传输时，修改其源 IP 地址或目的 IP 地址。具体的工作方式取决于 NAT 的类型。</p>
<p>让我们以最常见的<strong>端口地址转换 (PAT)<strong>，也称为</strong>网络地址端口转换 (NAPT)</strong> 或**多对一 NAT (Many-to-One NAT)**为例来描述其工作原理。这是家庭和小型办公室路由器最常用的 NAT 类型。</p>
<p><strong>场景描述：</strong></p>
<p>假设你家里有两个设备（PC1 和 PC2），它们都连接到同一个路由器，路由器有一个公共 IP 地址。</p>
<ul>
<li><strong>PC1：</strong> 私有 IP <code>192.168.1.10</code>，源端口 <code>1000</code></li>
<li><strong>PC2：</strong> 私有 IP <code>192.168.1.11</code>，源端口 <code>2000</code></li>
<li><strong>路由器：</strong> 私有接口 IP <code>192.168.1.1</code>，公共接口 IP <code>203.0.113.50</code> (你的公共 IP)</li>
<li><strong>外部服务器：</strong> IP <code>198.51.100.20</code>，端口 <code>80</code> (Web 服务器)</li>
</ul>
<hr>
<h4 id="1-私有网络到公共网络-出站流量-："><a href="#1-私有网络到公共网络-出站流量-：" class="headerlink" title="1. 私有网络到公共网络 (出站流量)："></a><strong>1. 私有网络到公共网络 (出站流量)：</strong></h4><ol>
<li><p><strong>PC1 发送请求：</strong></p>
<ul>
<li>PC1 想要访问外部服务器 <code>198.51.100.20</code> 的网页。</li>
<li>它生成一个 IP 数据包：<ul>
<li><strong>源 IP：</strong> <code>192.168.1.10</code></li>
<li><strong>源端口：</strong> <code>1000</code></li>
<li><strong>目的 IP：</strong> <code>198.51.100.20</code></li>
<li><strong>目的端口：</strong> <code>80</code></li>
</ul>
</li>
<li>这个数据包被发送到路由器。</li>
</ul>
</li>
<li><p><strong>路由器进行 NAT (地址和端口转换)：</strong></p>
<ul>
<li>路由器收到数据包后，检查其 NAT 表（也称为转换表或映射表）。</li>
<li>因为这是来自内部的连接请求第一次经过，路由器会：<ul>
<li><strong>记录：</strong> 在 NAT 表中创建一个新条目，记录 <code>192.168.1.10:1000</code> 将被转换为 <code>203.0.113.50:端口X</code>。</li>
<li><strong>选择公共端口：</strong> 路由器会选择一个自己公共 IP 地址上未被占用的端口（例如 <code>50000</code>）来代表 PC1 的请求。</li>
<li><strong>修改数据包头部：</strong><ul>
<li><strong>源 IP：</strong> 从 <code>192.168.1.10</code> 修改为 <code>203.0.113.50</code> (路由器的公共 IP)。</li>
<li><strong>源端口：</strong> 从 <code>1000</code> 修改为 <code>50000</code>。</li>
</ul>
</li>
</ul>
</li>
<li>转换后的数据包：<ul>
<li><strong>源 IP：</strong> <code>203.0.113.50</code></li>
<li><strong>源端口：</strong> <code>50000</code></li>
<li><strong>目的 IP：</strong> <code>198.51.100.20</code></li>
<li><strong>目的端口：</strong> <code>80</code></li>
</ul>
</li>
<li>路由器将这个新的数据包发送到公共互联网。</li>
</ul>
</li>
<li><p><strong>PC2 发送类似请求：</strong></p>
<ul>
<li>如果 PC2 同时访问外部服务器：<ul>
<li>数据包：源 IP <code>192.168.1.11</code>，源端口 <code>2000</code>。</li>
<li>路由器将它转换为：源 IP <code>203.0.113.50</code>，源端口 <code>50001</code> (例如)。</li>
</ul>
</li>
<li>路由器会为每个内部连接使用其公共 IP 上的不同源端口，以此来区分不同的内部主机。</li>
</ul>
</li>
</ol>
<h4 id="2-公共网络到私有网络-入站响应-："><a href="#2-公共网络到私有网络-入站响应-：" class="headerlink" title="2. 公共网络到私有网络 (入站响应)："></a><strong>2. 公共网络到私有网络 (入站响应)：</strong></h4><ol>
<li><p><strong>外部服务器发送响应：</strong></p>
<ul>
<li>外部服务器处理完 PC1 的请求后，发送响应数据包。</li>
<li>响应数据包的目的地是它收到的请求的源 IP 和源端口：<ul>
<li><strong>源 IP：</strong> <code>198.51.100.20</code></li>
<li><strong>源端口：</strong> <code>80</code></li>
<li><strong>目的 IP：</strong> <code>203.0.113.50</code> (路由器的公共 IP)</li>
<li><strong>目的端口：</strong> <code>50000</code> (路由器为 PC1 分配的端口)</li>
</ul>
</li>
<li>这个数据包被发送到互联网，最终到达你的路由器。</li>
</ul>
</li>
<li><p><strong>路由器进行反向 NAT (反向地址和端口转换)：</strong></p>
<ul>
<li>路由器收到响应数据包。</li>
<li>它根据响应数据包的<strong>目的端口 (<code>50000</code>)</strong> 以及<strong>源 IP (<code>198.51.100.20</code>)</strong> 到其 NAT 表中查找对应的内部映射。</li>
<li>它找到之前为 PC1 (<code>192.168.1.10:1000</code>) 创建的条目。</li>
<li><strong>修改数据包头部：</strong><ul>
<li><strong>目的 IP：</strong> 从 <code>203.0.113.50</code> 修改为 <code>192.168.1.10</code>。</li>
<li><strong>目的端口：</strong> 从 <code>50000</code> 修改为 <code>1000</code>。</li>
</ul>
</li>
<li>转换后的数据包：<ul>
<li><strong>源 IP：</strong> <code>198.51.100.20</code></li>
<li><strong>源端口：</strong> <code>80</code></li>
<li><strong>目的 IP：</strong> <code>192.168.1.10</code></li>
<li><strong>目的端口：</strong> <code>1000</code></li>
</ul>
</li>
<li>路由器将这个数据包发送到私有网络中的 PC1。</li>
</ul>
</li>
<li><p><strong>PC1 接收响应：</strong></p>
<ul>
<li>PC1 收到响应，其源和目的 IP&#x2F;端口都“看起来”是正常的，因为它不知道中间发生了 NAT 转换。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="NAT-的主要类型："><a href="#NAT-的主要类型：" class="headerlink" title="NAT 的主要类型："></a>NAT 的主要类型：</h3><p>虽然上述描述的是最常见的 PAT，但 NAT 还有其他几种类型，各有其应用场景：</p>
<ol>
<li><p><strong>静态 NAT (Static NAT &#x2F; One-to-One NAT)：</strong></p>
<ul>
<li><strong>原理：</strong> 将<strong>一个内部私有 IP 地址</strong>永久映射到<strong>一个外部公共 IP 地址</strong>。</li>
<li><strong>用途：</strong> 当内部服务器（如 Web 服务器、FTP 服务器）需要从外部互联网访问时使用。每个内部服务器都需要一个专用的公共 IP 地址。</li>
<li><strong>特点：</strong> 外部设备可以直接通过公共 IP 地址访问内部映射的服务器。</li>
</ul>
</li>
<li><p><strong>动态 NAT (Dynamic NAT)：</strong></p>
<ul>
<li><strong>原理：</strong> 维护一个<strong>公共 IP 地址池</strong>。当内部设备需要访问外部网络时，动态地从这个池中分配一个公共 IP 地址进行一对一转换。当连接结束或超时时，该公共 IP 地址被释放回池中。</li>
<li><strong>用途：</strong> 当有多个内部设备，但公共 IP 地址数量有限（但比内部设备数量多）时。</li>
<li><strong>特点：</strong> 仍然是“一对一”的转换，但映射是动态的。</li>
</ul>
</li>
<li><p><strong>端口地址转换 (PAT &#x2F; NAT Overload &#x2F; NAPT)：</strong></p>
<ul>
<li><strong>原理：</strong> 这是最常见的类型。允许<strong>多个私有 IP 地址</strong>共享<strong>同一个公共 IP 地址</strong>。通过使用不同的<strong>源端口号</strong>来区分不同的内部连接。</li>
<li><strong>用途：</strong> 家庭路由器、小型办公室网络，是解决 IPv4 地址枯竭的最有效措施。</li>
<li><strong>特点：</strong> 高效利用公共 IP 地址，安全性较高（外部无法直接发起连接到内部）。</li>
</ul>
</li>
</ol>
<h3 id="NAT-的优点："><a href="#NAT-的优点：" class="headerlink" title="NAT 的优点："></a>NAT 的优点：</h3><ul>
<li><strong>缓解 IPv4 地址枯竭：</strong> 允许多个设备共享少数公共 IP 地址，极大地扩展了 IPv4 地址的使用寿命。</li>
<li><strong>提高安全性：</strong> 默认情况下，内部网络（私有 IP）对外部网络是不可见的，外部设备无法直接发起与内部设备的连接，提供了一层基本的防火墙功能。</li>
<li><strong>网络隐藏性：</strong> 隐藏了内部网络的结构和拓扑细节。</li>
<li><strong>灵活性：</strong> 内部网络可以自由使用私有 IP 地址，无需担心与外部网络的冲突。</li>
</ul>
<h3 id="NAT-的缺点："><a href="#NAT-的缺点：" class="headerlink" title="NAT 的缺点："></a>NAT 的缺点：</h3><ul>
<li><strong>增加了复杂性：</strong> 对网络管理员维护和排除故障带来一定的复杂性。</li>
<li><strong>点对点应用限制：</strong> 某些点对点应用（如 VoIP、在线游戏、P2P 文件共享）可能难以在 NAT 后面工作，因为它们可能需要直接的端到端通信。这通常需要<strong>端口转发 (Port Forwarding)</strong> 来解决。</li>
<li><strong>端到端连接中断：</strong> 从理论上打破了 IP 协议的端到端透明性（数据包的源和目的 IP 地址不再保持不变），这可能对某些高级网络协议和安全机制（如 IPSec）造成影响。</li>
<li><strong>调试困难：</strong> 在日志或错误报告中，所有来自内部私有网络的流量都显示为来自同一个公共 IP 地址，这使得追踪具体是哪个内部设备导致的问题变得困难。</li>
</ul>
<p>尽管存在缺点，但在 IPv4 环境下，NAT 仍然是一种不可或缺且广泛使用的技术。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/NAT/">https://huiaz.github.io/2025/09/11/NAT/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/NFS%20%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8/" title="NFS 共享存储"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">NFS 共享存储</div></div><div class="info-2"><div class="info-item-1">NFS 共享存储前面我们学习了 hostPath 与 Local PV 两种本地存储方式，但是平时我们的应用更多的是无状态服务，可能会同时发布在不同的节点上，这个时候本地存储就不适用了，往往就需要使用到共享存储了，比如最简单常用的网络共享存储 NFS，本节课我们就来介绍下如何在 Kubernetes 下面使用 NFS 共享存储。 安装我们这里为了演示方便，先使用相对简单的 NFS 这种存储资源，接下来我们在节点 192.168.31.31 上来安装 NFS 服务，数据目录：/var/lib/k8s/data/ 关闭防火墙 12➜ systemctl stop firewalld.service➜ systemctl disable firewalld.service    安装配置 nfs 1➜ yum -y install nfs-utils rpcbind    共享目录设置权限： 12➜ mkdir -p /var/lib/k8s/data➜ chmod 755 /var/lib/k8s/data/    配置 nfs，nfs 的默认配置文件在 /etc/exports 文...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Longhorn/" title="Longhorn"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Longhorn</div></div><div class="info-2"><div class="info-item-1">Longhorn前面我们学习了本地存储、NFS 共享存储，除了这些存储类型之外，还有一个块存储，同样为 Kubernetes 提供块存储的方案有很多，比如 Ceph RBD，今天我们为大家介绍的是 Rancher 开源的一款 Kubernetes 的云原生分布式块存储方案 - Longhorn。 使用 Longhorn，可以：  使用 Longhorn 卷作为 Kubernetes 集群中分布式有状态应用程序的持久存储 将你的块存储分区为 Longhorn 卷，以便你可以在有或没有云提供商的情况下使用 Kubernetes 卷 跨多个节点和数据中心复制块存储以提高可用性 将备份数据存储在 NFS 或 AWS S3 等外部存储中 创建跨集群灾难恢复卷，以便可以从第二个 Kubernetes 集群中的备份中快速恢复主 Kubernetes 集群中的数据 调度一个卷的快照，并将备份调度到 NFS 或 S3 兼容的二级存储 从备份还原卷 不中断持久卷的情况下升级 Longhorn  Longhorn 还带有独立的 UI，可以使用 Helm、kubectl 或 Rancher 应用程序目录...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/ICMP/" title="ICMP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ICMP</div></div><div class="info-2"><div class="info-item-1">什么是 ICMP 协议？ICMP (Internet Control Message Protocol)，即互联网控制消息协议，是 IP 协议的辅助协议，是 TCP&#x2F;IP 协议族中的一个核心组成部分。ICMP 通常被认为是网络层的协议（与 IP 协议同层），因为它处理 IP 数据包的错误和控制信息。 核心特点：  控制和错误报告： ICMP 的主要作用是报告 IP 数据包传输过程中的错误以及提供网络诊断信息。它不传输用户数据，而是传输网络层面的控制和错误消息。 不可靠性： ICMP 报文本身不提供可靠传输机制。如果一个 ICMP 报文在传输过程中丢失，IP 层不会重传它。 承载于 IP： ICMP 报文是“封装”在 IP 数据包中的。换句话说，一个 ICMP 报文会作为 IP 数据包的有效载荷（payload）进行传输。  ICMP 的主要作用：ICMP 的主要作用可以归纳为以下几点，主要围绕错误报告和网络诊断：  报告差错信息 (Error Reporting):当 IP 数据包在传输过程中遇到问题时，ICMP 被用来向数据包的源主机报告这些错误。常见的 ICMP 差...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%202.0%20%E5%92%8C%203.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" title="HTTP 2.0 和 3.0 有什么区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 2.0 和 3.0 有什么区别</div></div><div class="info-2"><div class="info-item-1">HTTP 2.0 和 3.0 有什么区别？HTTP 2.0 和 HTTP 3.0 在核心传输协议、解决的问题以及它们所针对的应用场景上存在革命性的差异。HTTP 3.0 不仅仅是 HTTP 2.0 的简单升级，它是一个范式转变，因为它彻底抛弃了 TCP，转而使用 UDP 作为其底层传输协议。 HTTP 2.0 (基于 TCP 的增强)  底层协议： 基于 TCP（传输控制协议）。 主要目标： 解决 HTTP 1.x 的队头阻塞（Head-of-Line Blocking）问题以及效率低下。 主要特性（回顾）： 多路复用 (Multiplexing)： 在单个 TCP 连接上同时发送和接收多个独立的请求和响应流。这解决了应用层的队头阻塞。 头部压缩 (HPACK)： 减少请求和响应头部的大小。 服务器推送 (Server Push)： 服务器主动将客户端可能需要的资源推送到客户端。 二进制分帧： 数据以二进制格式传输，提高解析效率。    HTTP 3.0 (基于 UDP&#x2F;QUIC 的革命)  底层协议： 基于 UDP（用户数据报协议）之上的 QUIC (Quick UD...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/" title="TCP 客户端在发送 SYN 之后宕机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 客户端在发送 SYN 之后宕机</div></div><div class="info-2"><div class="info-item-1">这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。 假设客户端 A 尝试连接服务器 B。 1. 客户端发送 SYN (第一次握手) 客户端 A： 生成一个 SYN 包，Seq = client_ISN，发送给服务器 B。 发送后，客户端 A 的 TCP 状态会从 CLOSED 变为 SYN_SENT。  2. 客户端 A 宕机 就在发送 SYN 包之后，客户端 A 突然崩溃（例如，操作系统蓝屏、电源故障、进程被杀掉等）。这意味着客户端 A 的所有网络状态、定时器、内存中的 TCP 控制块信息都瞬间丢失了。  3. 服务器 B 的处理 服务器 B 收到 SYN： 服务器 B 收到了客户端 A 发送的 SYN 包。 服务器 B 响应 SYN+ACK： 服务器 B 按照 TCP 握手流程，会进入 SYN_RCVD 状态，并向客户端 A 发送 SYN+ACK 包 (Seq = server_ISN, Ack = client_ISN + 1)。 服务器 B 等待客户端 ACK： 服务器 B 此时会启动一个定时...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/" title="TCP 的粘包和拆包"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 的粘包和拆包</div></div><div class="info-2"><div class="info-item-1">好的，我们来深入讨论 TCP 的“粘包”和“拆包”问题。这两个概念是 TCP 编程中非常基础但又极其重要的，理解它们是正确处理 TCP 数据流的关键。  1. 为什么会出现粘包和拆包？根本原因在于 TCP 是一个“面向字节流”（Byte Stream）的协议，而不是“面向消息&#x2F;数据报”（Message&#x2F;Datagram Oriented）的协议。  TCP 的特性：  缓冲区： TCP 有自己的发送缓冲区和接收缓冲区。 全双工： 数据可以双向独立传输。 可靠的、按序的、无界限的字节流： TCP 传输的只是字节序列，它不关心你在应用层发送了多少次数据，每次发送了多少字节，或者每次发送的内容之间有什么逻辑边界。   发送方： 当应用程序调用 send() 或 write() 发送数据时，数据首先被复制到 TCP 的发送缓冲区。TCP 协议栈会根据自身的拥塞控制、流量控制以及发送缓冲区的大小，决定何时、发送多少数据到网络上。它可能会：  将多次小的发送请求合并成一个大的 TCP 段发送（粘包）。 将一次大的发送请求拆分成多个小的 TCP 段发送（拆包）。 将不同应用...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E4%B8%BA%E4%BB%80%E4%B9%88%20TCP%20%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E6%9C%89%20TIME_WAIT%20%E7%8A%B6%E6%80%81/" title="为什么 TCP 挥手需要有 TIME_WAIT 状态"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">为什么 TCP 挥手需要有 TIME_WAIT 状态</div></div><div class="info-2"><div class="info-item-1">TIME_WAIT 状态是 TCP 四次挥手过程中一个非常关键且必要的阶段，它主要位于主动关闭连接的一方。它的存在是为了解决两个核心问题： 问题一：确保四次挥手最后一个 ACK 报文可靠到达，防止服务器端重传 FIN 报文。 场景： 假设 TCP 没有 TIME_WAIT 状态，客户端（主动关闭方）发送了最后一个 ACK 后立即关闭连接，进入 CLOSED 状态。 潜在问题： 如果最后一个 ACK 在网络中丢失了，服务器端就没有收到这个 ACK。根据 TCP 的可靠性机制，服务器会认为它的 FIN 报文没有被确认，就会尝试重传 FIN 报文。 后果： 如果客户端已经立即进入 CLOSED 状态并释放了端口，而服务器重传的 FIN 报文到达时，如果客户端的该端口已经被新的连接占用（或直接拒绝接收），服务器将永远无法收到对 FIN 的确认，它会一直停留在 LAST_ACK 状态，耗尽资源并最终超时。 TIME_WAIT 状态让客户端保持一个足够长的时间（2 MSL，通常是 1-4 分钟），如果服务器重传 FIN 报文，客户端依然可以发送新的 ACK 报文作为回应，并重置 TIME_W...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP 超时重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 超时重传机制</div></div><div class="info-2"><div class="info-item-1">除了标准的 TCP 四次挥手，还有一些其他方法或特殊情况可以导致连接断开，但它们通常不如四次挥手那样优雅和受控，可能会伴随数据丢失或异常。 1. RST 报文断开连接 (Reset)RST (Reset) 报文是一种 TCP 错误或异常的指示，它会立即终止连接，不会进行标准的四次挥手过程，也不会等待任何未发送或未确认的数据。 RST 报文的常见使用场景：  连接被拒绝： 当客户端尝试连接到一个不存在的端口或一个拒绝连接的服务器端口时，服务器通常会回复一个 RST 报文，表示连接无法建立。 中止连接： 当一方决定突然中止一个连接，而不是通过正常的挥手过程关闭时，会发送 RST。这意味着不再关心对方是否已收到所有数据，也不希望进一步的通信。例如，应用程序调用 SO_LINGER 且 l_onoff 为真，l_linger 为 0 时。 检测半开连接： 如果一方的连接已经关闭（比如进程崩溃），而另一方在试图向已关闭的连接发送数据时，操作系统会检测到这个异常并回复一个 RST 报文。 端口扫描： 端口扫描工具通常会向目标端口发送 SYN 包，根据收到的响应（SYN-ACK 或 RST）来...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%88NAT%EF%BC%89%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是网络地址转换（NAT）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">NAT 的工作原理：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A7%81%E6%9C%89%E7%BD%91%E7%BB%9C%E5%88%B0%E5%85%AC%E5%85%B1%E7%BD%91%E7%BB%9C-%E5%87%BA%E7%AB%99%E6%B5%81%E9%87%8F-%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">1. 私有网络到公共网络 (出站流量)：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%AC%E5%85%B1%E7%BD%91%E7%BB%9C%E5%88%B0%E7%A7%81%E6%9C%89%E7%BD%91%E7%BB%9C-%E5%85%A5%E7%AB%99%E5%93%8D%E5%BA%94-%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">2. 公共网络到私有网络 (入站响应)：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">NAT 的主要类型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT-%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">NAT 的优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT-%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">NAT 的缺点：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>