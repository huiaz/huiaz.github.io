<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP 的 SACK | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP 的 SACK（Selective Acknowledgement，选择性确认）机制是为了解决快速重传机制的一个不足之处，尤其是在出现多个数据包丢失的情况下，SACK 能显著提高 TCP 的效率和吞吐量。 快速重传的局限性回顾：我们知道，快速重传在单个或少量数据包丢失时非常有效。它通过检测到三个重复 ACK 来推断丢失的报文段并立即重传。 然而，它的局限性在于：  只能推断一个丢失的报文段：">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP 的 SACK">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%20SACK/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="TCP 的 SACK（Selective Acknowledgement，选择性确认）机制是为了解决快速重传机制的一个不足之处，尤其是在出现多个数据包丢失的情况下，SACK 能显著提高 TCP 的效率和吞吐量。 快速重传的局限性回顾：我们知道，快速重传在单个或少量数据包丢失时非常有效。它通过检测到三个重复 ACK 来推断丢失的报文段并立即重传。 然而，它的局限性在于：  只能推断一个丢失的报文段：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:06:49.631Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP 的 SACK",
  "url": "https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%20SACK/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:06:49.631Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%20SACK/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP 的 SACK',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP 的 SACK</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP 的 SACK</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:06:49.631Z" title="更新于 2025-09-11 22:06:49">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>TCP 的 SACK（Selective Acknowledgement，选择性确认）机制是为了解决快速重传机制的一个<strong>不足之处</strong>，尤其是在<strong>出现多个数据包丢失</strong>的情况下，SACK 能显著提高 TCP 的效率和吞吐量。</p>
<h3 id="快速重传的局限性回顾："><a href="#快速重传的局限性回顾：" class="headerlink" title="快速重传的局限性回顾："></a>快速重传的局限性回顾：</h3><p>我们知道，快速重传在单个或少量数据包丢失时非常有效。它通过检测到三个重复 ACK 来推断丢失的报文段并立即重传。</p>
<p>然而，它的局限性在于：</p>
<ol>
<li><strong>只能推断一个丢失的报文段：</strong> 当发送方收到三个重复 ACK 时，它只能知道确认号所指向的那个（通常是被期望接收的）报文段丢失了。</li>
<li><strong>“笨拙”的重传序列：</strong> 如果<strong>多个不连续的报文段</strong>丢失，或者重传的报文段本身又丢失了，快速重传机制就显得力不从心。发送方只能一个接一个地重传，每重传一个丢失的包，都需要等待新的重复 ACK 来触发下一个重传，或者最终退化回超时重传。<ul>
<li>例如：发送了 1, 2, 3, 4, 5, 6。</li>
<li>假设 2 和 4 都丢失了。</li>
<li>接收方收到 1，ACK for 2。</li>
<li>接收方收到 3，重复 ACK for 2。</li>
<li>接收方收到 5，重复 ACK for 2。</li>
<li>接收方收到 6，重复 ACK for 2。</li>
<li>发送方收到 3 个重复 ACK for 2，快速重传 2。</li>
<li>现在发送方等待 2 的 ACK。如果又接收到 SACK 之前的报文，可能还会继续发送重复 ACK，但关于 4 丢失的信息并不能被高效地传递。等到 2 的 ACK 到达后，它才会发现 4 还没有被接收，然后重复这个过程，或者最终超时重传。</li>
<li>这种“盲目”的重传效率低下，会在网络中浪费大量带宽，并增加重传延迟。</li>
</ul>
</li>
</ol>
<h3 id="SACK-的引入目的："><a href="#SACK-的引入目的：" class="headerlink" title="SACK 的引入目的："></a>SACK 的引入目的：</h3><p>SACK 的引入就是为了解决上述“多个数据包丢失”场景下的效率问题。它的核心思想是：<strong>让接收方精确地告诉发送方，它已经成功接收了哪些“乱序”的数据块，从而让发送方只重传真正丢失的数据块，而不是盲目地猜测。</strong></p>
<p><strong>SACK 如何工作：</strong></p>
<ol>
<li><p><strong>SACK 选项：</strong> SACK 机制通过在 TCP 报文头部添加一个可选的 <code>SACK</code> 选项来实现。</p>
</li>
<li><p><strong>接收方报告：</strong> 当接收方发现收到的数据包是乱序的（即中间有缺失），它在发送 ACK 报文时，除了标准的确认号（表明期望收到的下一个按序字节）之外，<strong>还会利用 SACK 选项报告它已经成功接收到的、非连续的、按序的数据块的范围</strong>。</p>
<ul>
<li>这些数据块通常以 “起始序列号 - 结束序列号” 的形式报告。</li>
<li>例如，如果接收方收到了 1, 3, 4, 5, 6，而 2 丢失了。它会发送一个 ACK for 2，并在 SACK 选项中报告它收到了 [3-7]（SACK 块的结束序列号通常是最后一个被确认的字节的下一个字节，所以 6 意味着 SACK 块是 3 到 6，下一个字节是 7）。</li>
</ul>
</li>
<li><p><strong>发送方利用 SACK 信息：</strong> 发送方收到带有 SACK 选项的 ACK 后，它可以：</p>
<ul>
<li><strong>构建一个“缺失地图”：</strong> 根据标准 ACK 和 SACK 信息，发送方可以精确地知道哪些数据块已经到达接收方，哪些数据块是真正丢失的。</li>
<li><strong>精确重传：</strong> 发送方只会重传那些被 SACK 报告为“缺失”的数据块。这避免了重复发送接收方已经收到的数据。</li>
</ul>
</li>
</ol>
<h3 id="SACK-解决的具体问题："><a href="#SACK-解决的具体问题：" class="headerlink" title="SACK 解决的具体问题："></a>SACK 解决的具体问题：</h3><ul>
<li><strong>多包丢失时的低效率：</strong> 解决了传统快速重传在多个乱序包丢失时效率低下的问题，避免了所谓的“重传风暴”或多次触发快速重传才能恢复所有丢失包的情况。</li>
<li><strong>带宽浪费：</strong> 防止了无谓地重传那些接收方已经收到的数据包。</li>
<li><strong>提高吞吐量和降低延迟：</strong> 通过更高效的重传机制，减少了数据恢复时间，使得连接可以更快地恢复到全速传输状态，从而提升了整体吞吐量并降低了应用延迟。</li>
<li><strong>拥塞控制的优化：</strong> 配合 SACK 信息，TCP 的拥塞控制算法（例如 NewReno 或 SACK-based FACK&#x2F;Rate-Halving）可以更精确地判断网络拥塞程度，并进行更精细的拥塞窗口调整，进一步提高效率。</li>
</ul>
<p><strong>总结：</strong></p>
<p><strong>超时重传</strong>是“保底”的可靠性机制。<br><strong>快速重传</strong>是针对<strong>单个或少量丢包</strong>时提升效率的机制。<br><strong>SACK</strong> 则更进一步，是针对<strong>多个、不连续丢包</strong>时，通过提供<strong>更精确的接收方状态信息</strong>，从而实现<strong>更高效、更精确的重传</strong>，最大限度地减少了重传数据量和等待时间，显著提升了 TCP 在复杂网络环境下的性能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%20SACK/">https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%20SACK/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/TCP%20%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F/" title="TCP 的三次握手？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCP 的三次握手？</div></div><div class="info-2"><div class="info-item-1"> 好的，我们来详细解释 TCP 的三次握手（Three-Way Handshake）过程。这是 TCP 协议建立连接的关键步骤，确保客户端和服务器都准备好进行数据传输。 1. TCP 三次握手的目的三次握手的核心目的是：  确认双方的发送和接收能力正常： 确保客户端能够发送数据，也能接收数据；服务器也能发送数据，也能接收数据。 为会话同步初始序列号 (ISN)： TCP 会为发送的每一个字节数据编号。为了实现可靠传输和乱序重排，需要一个起始的序列号。双方需要知道对方的起始序列号，并在此基础上进行数据传输的确认和管理。 防止已失效的连接请求报文段（SYN）突然又传送到了服务器，从而产生错误： 后面会详细解释这一点。  2. TCP 三次握手的过程假设客户端是发起连接的一方，服务器是等待连接的一方。 第一次握手：客户端 -&gt; 服务器 (SYN) 客户端发送： SYN (Synchronize) 标志位设置为 1： 表示这是一个连接请求报文。 seq (Sequence Number) &#x3D; 客户端的初始序列号 (client_ISN)： 客户端随机选择一个初始序列号。 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/" title="TCP 滑动窗口的作用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TCP 滑动窗口的作用</div></div><div class="info-2"><div class="info-item-1">TCP 滑动窗口（Sliding Window）是 TCP 协议中一个核心且关键的机制，它主要实现了以下几个重要的作用：  实现流量控制 (Flow Control):  问题： 发送方发送数据的速度如果远超接收方的处理速度，接收方的缓冲区最终会被填满，导致数据溢出丢失。 解决方案： 接收方会通过 TCP 报文段中的窗口大小字段（Window size）告诉发送方，其当前还有多少接收缓冲区是可用的。发送方收到的窗口大小就是它当前可以发送的最大数据量，它绝对不能发送超过这个窗口大小的数据。 动态调整： 随着接收方处理数据的速度和可用缓冲区空间的变化，窗口大小会动态调整。如果接收方处理得慢，窗口就会变小；如果处理得快，窗口就会变大。这确保了发送方的发送速率能与接收方的处理速率相匹配，避免接收方缓冲区溢出。   实现可靠传输 (Reliable Transmission):  问题： 网络传输可能导致数据包丢失、乱序或错误。TCP 需要确保所有数据在发送方和接收方之间都能完整、按序地到达。 解决方案： 滑动窗口机制与确认（ACK）和重传机制紧密结合。 发送窗口： 发送窗口维护着一系列允...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/HTTP%20%E8%AF%B7%E6%B1%82%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9/" title="HTTP 请求包含哪些内容"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 请求包含哪些内容</div></div><div class="info-2"><div class="info-item-1">HTTP 请求包含哪些内容，请求头和请求体有哪些类型？一个 HTTP 请求通常包含三个主要部分：请求行 (Request Line)、请求头 (Request Headers) 和 **请求体 (Request Body)**。 HTTP 请求的组成部分 请求行 (Request Line)这是请求的第一行，它定义了请求的基本信息。它包含三部分：  **方法 (Method)**：指示对资源所执行的操作类型（例如 GET、POST、PUT 等）。 **URI (Uniform Resource Identifier)**：要访问的资源的路径。 **HTTP 版本 (HTTP Version)**：客户端使用的 HTTP 协议版本（例如 HTTP&#x2F;1.1、HTTP&#x2F;2.0）。  示例：GET /index.html HTTP/1.1  请求头 (Request Headers)请求头提供了关于请求的附加信息、客户端的信息以及响应的期望行为。每个请求头都是一个键值对，以冒号分隔，然后是回车换行符。 示例： 1234567Host: www.example.comU...</div></div></div></a><a class="pagination-related" href="/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/" title="DHCP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">DHCP 协议</div></div><div class="info-2"><div class="info-item-1">DHCP 协议的工作原理及应用场景什么是 DHCP 协议？DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 是一种网络协议，用于自动化管理和分配网络中的 IP 地址以及其他相关配置信息（如子网掩码、默认网关、DNS 服务器地址等）。它的核心思想是取代手动配置每台设备的网络参数，实现即插即用，大大简化了大型网络的管理。 DHCP 协议的工作原理 (DORA 过程)DHCP 协议通常通过四步过程（称为 DORA 过程）来完成 IP 地址分配：  Discover (发现)  客户端行为： 当一台新设备（或一台没有配置 IP 地址的设备）连接到网络时，它不知道网络中是否有 DHCP 服务器，也不知道自己的 IP 地址。因此，它会广播一个 DHCP Discover 消息到局域网内的所有设备（使用目的 IP 地址 255.255.255.255，源 IP 地址 0.0.0.0）。 目的： 寻找网络中的 DHCP 服务器。   Offer (提供)  服务器行为： 网络中的 DHCP 服务器收到 DHCP Discover 消息后，会从...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%20%E5%92%8C%20HTTPS%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" title="HTTP 和 HTTPS 有什么区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 和 HTTPS 有什么区别</div></div><div class="info-2"><div class="info-item-1">HTTP 和 HTTPS 有什么区别？HTTP (Hypertext Transfer Protocol) 和 HTTPS (Hypertext Transfer Protocol Secure) 的主要区别在于安全性。HTTPS 是 HTTP 的安全版本，通过在 HTTP 层和 TCP 层之间添加一个加密层（SSL&#x2F;TLS）来实现数据的加密和认证。 让我们详细分解它们的区别：  1. 安全性 (Security) HTTP:  不安全： HTTP 传输的数据是明文的。这意味着任何中间人（如网络运营商、ISP、恶意攻击者）都可以拦截、读取、甚至修改传输中的数据。 没有完整性： 无法验证数据在传输过程中是否被篡改。 没有认证： 无法验证你连接的服务器是否是你声称要连接的服务器。   HTTPS:  加密： HTTPS 对所有传输的数据进行加密。即使数据被拦截，攻击者也无法轻易理解其内容。这保护了用户隐私（如用户输入的密码、信用卡号、个人信息等）。 数据完整性： 传输的数据在到达目的地时会进行完整性校验。如果数据在传输过程中被篡改，客户端或服务器会检测到并拒绝该数据。 服务...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%202.0%20%E5%92%8C%203.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" title="HTTP 2.0 和 3.0 有什么区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 2.0 和 3.0 有什么区别</div></div><div class="info-2"><div class="info-item-1">HTTP 2.0 和 3.0 有什么区别？HTTP 2.0 和 HTTP 3.0 在核心传输协议、解决的问题以及它们所针对的应用场景上存在革命性的差异。HTTP 3.0 不仅仅是 HTTP 2.0 的简单升级，它是一个范式转变，因为它彻底抛弃了 TCP，转而使用 UDP 作为其底层传输协议。 HTTP 2.0 (基于 TCP 的增强)  底层协议： 基于 TCP（传输控制协议）。 主要目标： 解决 HTTP 1.x 的队头阻塞（Head-of-Line Blocking）问题以及效率低下。 主要特性（回顾）： 多路复用 (Multiplexing)： 在单个 TCP 连接上同时发送和接收多个独立的请求和响应流。这解决了应用层的队头阻塞。 头部压缩 (HPACK)： 减少请求和响应头部的大小。 服务器推送 (Server Push)： 服务器主动将客户端可能需要的资源推送到客户端。 二进制分帧： 数据以二进制格式传输，提高解析效率。    HTTP 3.0 (基于 UDP&#x2F;QUIC 的革命)  底层协议： 基于 UDP（用户数据报协议）之上的 QUIC (Quick UD...</div></div></div></a><a class="pagination-related" href="/2025/09/11/websocket/" title="websocket"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">websocket</div></div><div class="info-2"><div class="info-item-1">什么是 WebSocket？HTTP 协议是无状态的，它是一种请求-响应模型：客户端发出请求，服务器响应，然后连接通常会关闭。这种模式对于静态资源、一次性数据交互非常高效。 然而，对于需要实时、双向通信的场景（如聊天应用、股票行情、在线游戏、协同编辑等），传统的 HTTP 循环请求（轮询、长轮询）效率低下，会导致大量不必要的请求和延迟。 WebSocket 协议正是为了解决这个问题而诞生的。 核心思想： WebSocket 协议提供了一种在单个 TCP 连接上进行全双工（Full-duplex）通信的机制。这意味着客户端和服务器可以在任意时间点互相发送消息，而不需要每次都建立和关闭连接，也不需要客户端不断地发起新的 HTTP 请求。 工作原理：  握手（Handshake）： 客户端首先通过标准的 HTTP 请求发起一个特殊的“握手”过程。这个 HTTP 请求会包含一些特殊的 Header，如 Upgrade: websocket 和 Connection: Upgrade，表示客户端希望将当前的 HTTP 连接升级为 WebSocket 连接。 服务器如果支持 WebSocke...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP 超时重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 超时重传机制</div></div><div class="info-2"><div class="info-item-1">除了标准的 TCP 四次挥手，还有一些其他方法或特殊情况可以导致连接断开，但它们通常不如四次挥手那样优雅和受控，可能会伴随数据丢失或异常。 1. RST 报文断开连接 (Reset)RST (Reset) 报文是一种 TCP 错误或异常的指示，它会立即终止连接，不会进行标准的四次挥手过程，也不会等待任何未发送或未确认的数据。 RST 报文的常见使用场景：  连接被拒绝： 当客户端尝试连接到一个不存在的端口或一个拒绝连接的服务器端口时，服务器通常会回复一个 RST 报文，表示连接无法建立。 中止连接： 当一方决定突然中止一个连接，而不是通过正常的挥手过程关闭时，会发送 RST。这意味着不再关心对方是否已收到所有数据，也不希望进一步的通信。例如，应用程序调用 SO_LINGER 且 l_onoff 为真，l_linger 为 0 时。 检测半开连接： 如果一方的连接已经关闭（比如进程崩溃），而另一方在试图向已关闭的连接发送数据时，操作系统会检测到这个异常并回复一个 RST 报文。 端口扫描： 端口扫描工具通常会向目标端口发送 SYN 包，根据收到的响应（SYN-ACK 或 RST）来...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E5%9B%9E%E9%A1%BE%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">快速重传的局限性回顾：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SACK-%E7%9A%84%E5%BC%95%E5%85%A5%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">SACK 的引入目的：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SACK-%E8%A7%A3%E5%86%B3%E7%9A%84%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">SACK 解决的具体问题：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>