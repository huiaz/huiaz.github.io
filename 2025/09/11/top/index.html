<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>top | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux top 命令top 命令是什么？top（Table of Processes 的缩写）是 Linux 和其他类 Unix 操作系统中最常用的性能监控工具之一。它提供了一个动态、实时的系统进程视图，可以帮助系统管理员和开发者监控系统负载、识别资源占用高的进程，从而进行性能分析和故障排查。  top 命令界面详解当您在终端输入 top 并回车后，会看到一个全屏的、持续更新的界面。这个界面主">
<meta property="og:type" content="article">
<meta property="og:title" content="top">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/top/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="Linux top 命令top 命令是什么？top（Table of Processes 的缩写）是 Linux 和其他类 Unix 操作系统中最常用的性能监控工具之一。它提供了一个动态、实时的系统进程视图，可以帮助系统管理员和开发者监控系统负载、识别资源占用高的进程，从而进行性能分析和故障排查。  top 命令界面详解当您在终端输入 top 并回车后，会看到一个全屏的、持续更新的界面。这个界面主">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:08:29.792Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "top",
  "url": "https://huiaz.github.io/2025/09/11/top/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:08:29.792Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/top/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'top',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">top</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">top</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:08:29.792Z" title="更新于 2025-09-11 22:08:29">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/Command/">Command</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="Linux-top-命令"><a href="#Linux-top-命令" class="headerlink" title="Linux top 命令"></a>Linux <code>top</code> 命令</h3><h3 id="top-命令是什么？"><a href="#top-命令是什么？" class="headerlink" title="top 命令是什么？"></a><code>top</code> 命令是什么？</h3><p><code>top</code>（Table of Processes 的缩写）是 Linux 和其他类 Unix 操作系统中最常用的性能监控工具之一。它提供了一个动态、实时的系统进程视图，可以帮助系统管理员和开发者监控系统负载、识别资源占用高的进程，从而进行性能分析和故障排查。</p>
<hr>
<h3 id="top-命令界面详解"><a href="#top-命令界面详解" class="headerlink" title="top 命令界面详解"></a><code>top</code> 命令界面详解</h3><p>当您在终端输入 <code>top</code> 并回车后，会看到一个全屏的、持续更新的界面。这个界面主要分为两部分：<strong>系统摘要信息区</strong> 和 <strong>进程列表区</strong>。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">top - 14:30:50 up<span class="number"> 3 </span>days, 21:22, <span class="number"> 1 </span>user,  load average: 0.05, 0.08, 0.09</span><br><span class="line">Tasks:<span class="number"> 236 </span>total,  <span class="number"> 1 </span>running,<span class="number"> 235 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  1.5 us,  0.5 sy,  0.0 ni, 98.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :  15833.6 total,   7938.4 free,   4855.2 used,   3040.0 buff/cache</span><br><span class="line">MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.  10654.7 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line"> <span class="number"> 1234 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> 12.5g   1.1g   123m S   3.0   7.2   12:34.56 application</span><br><span class="line"> <span class="number"> 5678 </span>mysql    <span class="number"> 20 </span> <span class="number"> 0 </span>  8.2g 512.5m    12m S   1.5   3.2   5:43.21  mysqld</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>



<h4 id="第一部分：系统摘要信息-Summary-Area"><a href="#第一部分：系统摘要信息-Summary-Area" class="headerlink" title="第一部分：系统摘要信息 (Summary Area)"></a>第一部分：系统摘要信息 (Summary Area)</h4><ol>
<li><strong>第一行：任务队列信息</strong><ul>
<li><code>top - 14:30:50</code>：当前系统时间。</li>
<li><code>up 3 days, 21:22</code>：系统已运行时间。</li>
<li><code>1 user</code>：当前登录的用户数。</li>
<li><code>load average: 0.05, 0.08, 0.09</code>：系统负载平均值，分别对应过去 1 分钟、5 分钟、15 分钟的平均负载。这个值可以直观地表示系统的繁忙程度。<ul>
<li><strong>解读</strong>：如果这个值除以 CPU 核心数，结果持续大于 1，说明 CPU 可能存在瓶颈。</li>
</ul>
</li>
</ul>
</li>
<li><strong>第二行：任务（进程）状态</strong><ul>
<li><code>Tasks: 236 total</code>：当前总进程数。</li>
<li><code>1 running</code>：正在运行的进程数。</li>
<li><code>235 sleeping</code>：正在“睡眠”（等待事件或资源）的进程数。</li>
<li><code>0 stopped</code>：被停止的进程数（例如通过 <code>Ctrl+Z</code>）。</li>
<li><code>0 zombie</code>：僵尸进程数。如果这个值不为 0，需要关注，可能存在程序缺陷。</li>
</ul>
</li>
<li><strong>第三行：CPU 状态</strong><ul>
<li><code>%Cpu(s):</code> 显示了 CPU 时间的分配情况。</li>
<li><code>us</code> (user)：用户空间程序占用的 CPU 百分比。</li>
<li><code>sy</code> (system)：内核空间程序占用的 CPU 百分比。</li>
<li><code>ni</code> (nice)：被调整过优先级的用户进程占用的 CPU 百分比。</li>
<li><code>id</code> (idle)：空闲 CPU 百分比。<strong>这个值越高，说明 CPU 越空闲</strong>。</li>
<li><code>wa</code> (I&#x2F;O wait)：等待 I&#x2F;O 操作完成所占用的 CPU 百分比。<strong>这个值如果持续很高，表明磁盘 I&#x2F;O 可能存在瓶颈</strong>。</li>
<li><code>hi</code> (hardware interrupt)：处理硬件中断所占用的 CPU 百分比。</li>
<li><code>si</code> (software interrupt)：处理软件中断所占用的 CPU 百分比。</li>
<li><code>st</code> (steal time)：（主要用于虚拟机）被虚拟化管理程序“偷走”的 CPU 时间。</li>
</ul>
</li>
<li><strong>第四行：物理内存（RAM）使用情况</strong><ul>
<li><code>MiB Mem :</code></li>
<li><code>total</code>：总物理内存。</li>
<li><code>free</code>：空闲内存。</li>
<li><code>used</code>：已使用内存。</li>
<li><code>buff/cache</code>：用作内核缓冲区和页面缓存的内存。Linux 会尽可能利用空闲内存做缓存以提升性能，所以 <code>used</code> 高不一定代表内存不足。</li>
</ul>
</li>
<li><strong>第五行：交换空间（Swap）使用情况</strong><ul>
<li><code>MiB Swap:</code></li>
<li><code>total</code>：总交换空间大小。</li>
<li><code>free</code>：空闲交换空间。</li>
<li><code>used</code>：已使用交换空间。如果这个值持续增加，说明物理内存可能不足。</li>
<li><code>avail Mem</code>：可用的内存，是 <code>free</code> 和大部分 <code>buff/cache</code> 的总和，这个指标比 <code>free</code> 更能真实地反映系统可用内存。</li>
</ul>
</li>
</ol>
<h4 id="第二部分：进程列表区-Process-List-Area"><a href="#第二部分：进程列表区-Process-List-Area" class="headerlink" title="第二部分：进程列表区 (Process List Area)"></a>第二部分：进程列表区 (Process List Area)</h4><p>这里列出了当前系统中的各个进程信息，默认按 CPU 使用率降序排列。</p>
<ul>
<li><code>PID</code>：进程 ID。</li>
<li><code>USER</code>：进程所有者的用户名。</li>
<li><code>PR</code>：进程优先级（Priority）。</li>
<li><code>NI</code>：Nice 值。负值表示高优先级，正值表示低优先级。</li>
<li><code>VIRT</code> (Virtual Memory Size)：进程使用的虚拟内存总量 (KB)。</li>
<li><code>RES</code> (Resident Memory Size)：进程使用的、未被换出的物理内存大小 (KB)。<strong>这是衡量进程实际内存占用的重要指标</strong>。</li>
<li><code>SHR</code> (Shared Memory Size)：共享内存大小 (KB)。</li>
<li><code>S</code>：进程状态（D&#x3D;不可中断的睡眠状态, R&#x3D;运行, S&#x3D;睡眠, T&#x3D;跟踪&#x2F;停止, Z&#x3D;僵尸进程）。</li>
<li><code>%CPU</code>：自上次更新以来进程所使用的 CPU 时间百分比。</li>
<li><code>%MEM</code>：进程使用的物理内存百分比。</li>
<li><code>TIME+</code>：进程启动后累计使用的 CPU 时间，精确到百分之一秒。</li>
<li><code>COMMAND</code>：启动进程的命令名或命令行。</li>
</ul>
<hr>
<h3 id="日常使用交互命令"><a href="#日常使用交互命令" class="headerlink" title="日常使用交互命令"></a>日常使用交互命令</h3><p>在 <code>top</code> 运行界面，可以输入以下单字符命令进行交互，无需回车：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>P</code></td>
<td>按 <strong>CPU</strong> 使用率排序</td>
<td>(大写 P) 这是默认排序方式，用于快速找到最耗 CPU 的进程。</td>
</tr>
<tr>
<td><code>M</code></td>
<td>按 <strong>内存</strong> 使用率排序</td>
<td>(大写 M) 用于快速找到最耗内存的进程。</td>
</tr>
<tr>
<td><code>N</code></td>
<td>按 <strong>PID</strong> 排序</td>
<td>(大写 N)</td>
</tr>
<tr>
<td><code>T</code></td>
<td>按 <strong>运行时间</strong> 排序</td>
<td>(大写 T)</td>
</tr>
<tr>
<td><code>q</code></td>
<td><strong>退出</strong> <code>top</code></td>
<td></td>
</tr>
<tr>
<td><code>k</code></td>
<td><strong>终止</strong> (kill) 进程</td>
<td>会提示输入要终止的 PID 和发送的信号（默认是 15，即 SIGTERM）。</td>
</tr>
<tr>
<td><code>r</code></td>
<td><strong>重新设置</strong> (renice) 进程优先级</td>
<td>会提示输入要操作的 PID 和新的 nice 值。</td>
</tr>
<tr>
<td><code>h</code></td>
<td>显示<strong>帮助</strong>菜单</td>
<td></td>
</tr>
<tr>
<td><code>1</code></td>
<td>切换 <strong>CPU 核心</strong> 显示模式</td>
<td>在多核 CPU 系统上，按 <code>1</code> 可以在总览和各核心独立显示之间切换。这对于观察 CPU 核心负载是否均衡非常有用。</td>
</tr>
<tr>
<td><code>f</code></td>
<td><strong>字段管理</strong></td>
<td>进入字段选择界面，可以自定义显示或隐藏哪些列。</td>
</tr>
<tr>
<td><code>c</code></td>
<td>切换 <strong>命令</strong> 显示模式</td>
<td>在 <code>COMMAND</code> 列切换显示命令名和完整的命令行路径及参数。</td>
</tr>
<tr>
<td><code>z</code></td>
<td><strong>彩色</strong>显示</td>
<td>切换是否使用彩色高亮显示，便于观察。</td>
</tr>
<tr>
<td><code>u</code></td>
<td>按<strong>用户</strong>过滤</td>
<td>输入用户名，只显示该用户的进程。</td>
</tr>
</tbody></table>
<hr>
<h3 id="问题排查案例"><a href="#问题排查案例" class="headerlink" title="问题排查案例"></a>问题排查案例</h3><p><code>top</code> 是排查线上问题的“第一现场”，以下是几个经典案例。</p>
<h4 id="案例一：发现并处理-CPU-占用率过高的进程"><a href="#案例一：发现并处理-CPU-占用率过高的进程" class="headerlink" title="案例一：发现并处理 CPU 占用率过高的进程"></a>案例一：发现并处理 CPU 占用率过高的进程</h4><p><strong>问题场景</strong>：应用响应缓慢，感觉服务器很卡。</p>
<p><strong>排查步骤</strong>：</p>
<ol>
<li><p>打开 top：</p>
<p>在终端输入 top。默认就是按 CPU 使用率 %CPU 降序排列。</p>
</li>
<li><p>定位元凶：</p>
<p>观察列表顶部的几个进程。假设发现一个名为 java 的进程 %CPU 持续在 100% 甚至更高（在多核系统上可能超过 100%）。这通常就是问题的根源。记下它的 PID，例如 1234。</p>
</li>
<li><p><strong>分析进程（可选但推荐）</strong>：</p>
<ul>
<li><strong>查看完整命令</strong>：按 <code>c</code> 键，查看 <code>COMMAND</code> 列，确认这个 <code>java</code> 进程是哪个应用。例如，可能会显示为 <code>java -jar my-app.jar</code>。</li>
<li><strong>分析线程</strong>：在 <code>top</code> 界面按 <code>H</code>（大写），可以切换到线程视图，看到是该 <code>java</code> 进程下的哪个线程在消耗 CPU。这对于 Java 应用问题排查（结合 <code>jstack</code>）尤其有用。</li>
</ul>
</li>
<li><p><strong>处理进程</strong>：</p>
<ul>
<li><strong>优雅地终止</strong>：按 <code>k</code>，输入 <code>PID</code> <code>1234</code>，然后按回车（使用默认信号 15&#x2F;SIGTERM）。这会尝试让程序正常关闭。</li>
<li><strong>强制杀死</strong>：如果优雅终止无效，再次按 <code>k</code>，输入 <code>PID</code> <code>1234</code>，然后输入信号 <code>9</code> (SIGKILL)，回车强制杀死。</li>
<li><strong>重启服务</strong>：杀死进程后，根据业务需要，手动或通过服务管理工具（如 <code>systemctl</code>）重启应用。</li>
</ul>
</li>
</ol>
<h4 id="案例二：发现并处理内存泄漏"><a href="#案例二：发现并处理内存泄漏" class="headerlink" title="案例二：发现并处理内存泄漏"></a>案例二：发现并处理内存泄漏</h4><p><strong>问题场景</strong>：系统越来越慢，Swap 分区开始被使用，最终可能导致应用被 OOM Killer（Out of Memory Killer）杀死。</p>
<p><strong>排查步骤</strong>：</p>
<ol>
<li><p>打开 top 并按内存排序：</p>
<p>输入 top，然后按 M (大写 M)，进程列表会按 %MEM 或 RES (物理内存占用) 降序排列。</p>
</li>
<li><p>定位元凶：</p>
<p>观察列表顶部的进程。如果发现某个进程的 RES (物理内存占用) 和 %MEM (内存使用百分比) 持续、缓慢地增长，并且从不下降，那么这个进程很可能存在内存泄漏。同时，观察摘要区的 Swap used 是否在增加。</p>
</li>
<li><p>确认问题：</p>
<p>记下该进程的 PID。持续观察几分钟甚至几小时，确认内存占用确实是只增不减的趋势。</p>
</li>
<li><p><strong>处理与分析</strong>：</p>
<ul>
<li><strong>临时解决方案</strong>：如果系统濒临崩溃，可以先 <code>kill</code> 掉该进程并重启，暂时恢复服务。</li>
<li><strong>根本原因分析</strong>：内存泄漏需要代码层面的修复。你需要通知相关的开发人员，并提供你观察到的现象（哪个进程、内存增长情况等）。开发者可能会使用如 Valgrind (C&#x2F;C++)、MAT (Java) 或 memory-profiler (Python) 等更专业的工具来定位具体的泄漏点。</li>
</ul>
</li>
</ol>
<h4 id="案例三：排查-I-O-瓶颈"><a href="#案例三：排查-I-O-瓶颈" class="headerlink" title="案例三：排查 I&#x2F;O 瓶颈"></a>案例三：排查 I&#x2F;O 瓶颈</h4><p><strong>问题场景</strong>：应用响应慢，但 <code>top</code> 显示 CPU 空闲率 <code>%id</code> 很高，CPU 并没有跑满。</p>
<p><strong>排查步骤</strong>：</p>
<ol>
<li><p>观察 CPU 等待 I&#x2F;O (wa)：</p>
<p>在 top 的摘要信息区，重点关注 %Cpu(s) 这一行的 wa 值。如果这个值持续很高（例如，超过 20%），说明 CPU 有大量时间在等待磁盘或网络 I&#x2F;O 操作完成。</p>
</li>
<li><p>定位引起 I&#x2F;O 的进程：</p>
<p>虽然 top 本身不能直接按 I&#x2F;O 排序，但通常高 I&#x2F;O 的进程也会伴随一定的 sy (系统内核) CPU 占用。你可以观察 S (状态) 列，如果一个进程长时间处于 D (不可中断的睡眠) 状态，它很可能就在等待 I&#x2F;O。</p>
</li>
<li><p>使用更专业的工具确认：</p>
<p>当 top 指示出 I&#x2F;O 问题时，通常需要结合其他工具进一步分析。</p>
<ul>
<li><code>iotop</code>：一个类似 <code>top</code> 的工具，专门用来显示磁盘 I&#x2F;O 的使用情况，可以清晰地看到哪个进程正在进行大量的读写操作。</li>
<li><code>iostat -x 1</code>：可以详细地看到每个磁盘设备的读写速率、等待时间等关键指标。</li>
</ul>
</li>
<li><p><strong>解决问题</strong>：</p>
<ul>
<li><strong>数据库问题</strong>：可能是慢查询导致了大量的磁盘读。需要优化 SQL 或索引。</li>
<li><strong>日志写入过多</strong>：应用产生了大量日志，占满了磁盘带宽。可以调整日志级别或优化日志写入方式。</li>
<li><strong>磁盘性能不足</strong>：物理磁盘本身性能达到了瓶颈，考虑更换更快的磁盘（如 SSD）。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/top/">https://huiaz.github.io/2025/09/11/top/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/vmagent/" title="vmagent"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">vmagent</div></div><div class="info-2"><div class="info-item-1">vmagentvmagent 可以帮助我们从各种来源收集指标并将它们存储这 VM 或者任何其他支持 remote write 协议的 Prometheus 兼容的存储系统中。 特性vmagent 相比于 Prometheus 抓取指标来说具有更多的灵活性，比如除了拉取（pull）指标还可以推送（push）指标，此外还有很多其他特性：  可以替换 prometheus 的 scraping target 支持从 Kafka 读写数据 支持基于 prometheus relabeling 的模式添加、移除、修改 labels，可以在数据发送到远端存储之前进行数据的过滤 支持多种数据协议，influx line 协议，graphite 文本协议，opentsdb 协议，prometheus remote write 协议，json lines 协议，csv 数据等 支持收集数据的同时，并复制到多种远端存储系统 支持不可靠远端存储，如果远程存储不可用，收集的指标会在 -remoteWrite.tmpDataPath 缓冲，一旦与远程存储的连接被修复，缓冲的指标就会被发送到远程存储，缓冲区...</div></div></div></a><a class="pagination-related" href="/2025/09/11/shell/" title="shell-mail"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">shell-mail</div></div><div class="info-2"><div class="info-item-1">Shell 脚本，用于检查磁盘使用率并在超过阈值时发送告警邮件。 这个脚本考虑了几个重要的实践：  可配置性：阈值和收件人作为变量定义，方便修改。 明确性：邮件内容清晰地指明了问题服务器、挂载点和当前使用率。 排除项：可以轻松排除某些文件系统（如 tmpfs, devtmpfs）。 锁机制：防止脚本在前一个实例仍在运行时重复执行。   check_disk_usage.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#!/bin/bash# ==============================================================================# Script Name:...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Linux%20%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4/" title="Linux 排查命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 排查命令</div></div><div class="info-2"><div class="info-item-1">(1) 如何在 Linux 中查看系统资源使用情况？比如内存、CPU、网络端口。  一、 CPU 使用情况1. top 命令 (实时交互式)top 命令是最常用的 CPU 监控工具，它提供了一个实时更新的进程列表，并显示 CPU 使用率、内存使用率、进程 ID (PID)、用户、运行时间等信息。 1top  关键信息解读：  第一行（top line）： load average 显示了过去 1、5、15 分钟的系统平均负载。这是衡量系统忙碌程度的重要指标，数值大于 CPU 核心数时通常表示系统存在瓶颈。 第二行（Tasks）： 显示进程总数，以及运行、睡眠、停止和僵尸进程的数量。 第三行（Cpu(s)）： 显示 CPU 的使用率，各项指标含义如下： us (user): 用户空间程序的 CPU 使用率。 sy (system): 内核空间程序的 CPU 使用率。 ni (nice): 改变过优先级的用户进程的 CPU 使用率。 id (idle): 空闲 CPU 百分比。 wa (iowait): CPU 等待 I&#x2F;O 操作完成的百分比。 hi (hardware i...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E9%94%99%E8%AF%AF%E4%BF%AE%E6%8A%A4/" title="Linux 系统文件错误修护"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 系统文件错误修护</div></div><div class="info-2"><div class="info-item-1">修复 Linux 文件系统错误 一、文件系统错误的危害文件系统错误可能导致以下问题：  数据丢失或损坏： 文件内容错乱，甚至文件消失。 系统无法启动： 根文件系统损坏可能导致系统无法挂载核心目录。 应用程序崩溃： 读取到损坏文件或元数据引发应用程序错误。 性能下降： 文件系统需要花费额外时间处理错误，导致读写变慢。 挂载失败： 损坏的文件系统可能无法被正确挂载。   二、检查文件系统错误的工具：fsckLinux 中用于检查和修复文件系统错误的主要工具是 fsck （file system check）。它实际上是一个前端程序，会根据文件系统的类型（如 ext4, xfs, fat32 等）自动调用相应的特定工具，例如 fsck.ext4, fsck.xfs 等。 重要原则：绝对不要在已挂载（mounted）的文件系统上运行 fsck，特别是读写状态下挂载的文件系统。 这可能导致数据进一步损坏或丢失。唯一的例外是根文件系统 /，在某些情况下需要在运行时以只读方式进行检查，但通常更推荐在系统启动时或进入恢复模式进行检查。 1. 检查和修复未被挂载的文件系统这是最安全和推荐的方式。 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" title="Linux 系统中的日志管理机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 系统中的日志管理机制</div></div><div class="info-2"><div class="info-item-1">Linux 的日志管理机制 一、Linux 日志管理机制概述Linux 系统主要通过 rsyslog (或早期版本中的 syslog-ng, syslogd) 和 journald (systemd 日志管理器) 这两种机制来收集、处理和存储系统日志。 1. rsyslog (或 syslog-ng) 传统且广泛使用： rsyslog 是一个强大的日志处理工具，它能够从内核、应用程序和网络设备收集日志，并根据配置文件将日志写入到本地文件、转发到远程服务器或执行其他操作。 文件存储： 日志通常以纯文本形式存储在 /var/log 目录下，按类型分类。 配置文件： 主要配置文件是 /etc/rsyslog.conf。 日志轮转： 配合 logrotate 工具进行日志文件的轮转、压缩和清理，防止日志文件无限增长填满磁盘。  2. journald (systemd Journal) 现代 Linux 的核心日志系统： journald 是 systemd 组建的一部分，是现代 Linux 发行版（如 CentOS 7+, Ubuntu 15.04+）中默认的日志记录服务。 二进制存储...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20tcpdump%20%E5%91%BD%E4%BB%A4/" title="Linux tcpdump 命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux tcpdump 命令</div></div><div class="info-2"><div class="info-item-1">作为一名运维工程师，tcpdump 是我进行网络故障排查和性能分析时不可或缺的“瑞士军刀”。它是一个基于命令行的数据包捕获工具，能够截获并显示通过网络接口的数据包。无论是在诊断网络连接问题、分析协议行为、检测异常流量，还是验证防火墙规则时，tcpdump 都扮演着至关重要的角色。  一、tcpdump 简介 功能： 捕获网络接口上符合指定条件的数据包，并将其内容打印到标准输出或保存到文件中。 原理： tcpdump 使用 libpcap 库来与网络接口进行交互，接收、过滤和解析流经接口的数据包。它工作在数据链路层，能够看到IP层及以上的所有协议数据。 应用场景： 诊断连通性问题： 验证客户端&#x2F;服务器之间是否有数据包传输。 分析协议行为： 深入了解 HTTP、DNS、SSH 等协议的具体交互过程。 排查防火墙问题： 确认流量是否被防火墙阻拦。 检测异常流量： 发现端口扫描、拒绝服务攻击（DoS）的迹象。 性能瓶颈分析： 识别延迟、丢包等网络性能问题。 验证流量转发： 检查路由和 NAT 是否按预期工作。 安全审计： 监控关键系统的网络活动。     二、tcpdump 的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%B1%82%E6%AC%A1/" title="Linux的文件系统目录层次"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux的文件系统目录层次</div></div><div class="info-2"><div class="info-item-1">Linux 文件系统层次结构 一、Linux 文件系统层次结构 (FHS) 概述Linux 的文件系统是一个单一的、统一的目录树，所有文件和目录都从根目录 / 开始。这与 Windows 系统中每个分区（如 C:, D:）都有自己的目录树不同。即使系统有多个硬盘或分区，它们也会被“挂载”到这个统一的目录树的某个点上，成为其中的一部分。 FHS 的主要目标是：  标准化： 确保不同 Linux 发行版的文件和目录位置保持一致，方便用户和开发人员。 可移植性： 简化软件在不同 Linux 系统间的移植。 层次性： 清晰地划分系统文件、程序、用户数据、可变数据等，方便管理和备份。 清晰性： 目录名称大多具有描述性，使其用途一目了然。  二、重要目录及其用途示例下面我们将详细介绍 Linux 系统中一些重要的目录及其常见用途。 1. / (根目录) 用途： 整个文件系统的最顶层，所有其他目录和文件都位于其下。系统启动所需的核心文件位于此目录，或者通过其下的子目录链接。 示例内容： 常见子目录如 /bin, /etc, /home, /usr, /var 等。  2. /bin (二进制可...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/" title="Linux 内存异常排查"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 内存异常排查</div></div><div class="info-2"><div class="info-item-1">一、什么是 Linux 系统中的内存泄漏？简单来说，内存泄漏（Memory Leak） 指的是程序在运行过程中，动态地申请了内存空间（例如 C 语言的 malloc() 或 Java 的 new），但在使用完毕后，没有按预期释放（或无法被垃圾回收器回收）。 结果是，这部分内存既不能被当前程序再次使用，也无法被操作系统回收分配给其他程序。从操作系统的视角看，这块内存一直被该程序“合法”地占用着。随着时间的推移，泄漏的内存积少成多，最终会耗尽系统的可用物理内存和交换空间（Swap）。 一个常见的误解：很多时候，新手会把 Linux 的文件系统缓存（Cache）误认为是内存泄漏。Linux 内核会尽可能地利用空闲内存来缓存磁盘读写数据，以提高性能。在 free -h 命令中，这部分内存会显示在 buff/cache 列。这是正常且有益的行为，当应用程序需要更多内存时，内核会自动收缩这部分缓存来满足需求。 真正的内存泄漏迹象是 available（可用内存）持续、不可逆地减少，而不是 free（空闲内存）的减少。 二、内存泄漏的典型症状作为运维，我们通常不是直接看到代码，而是通过以下系统...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-top-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">Linux top 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top-%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">top 命令是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top-%E5%91%BD%E4%BB%A4%E7%95%8C%E9%9D%A2%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">top 命令界面详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%91%98%E8%A6%81%E4%BF%A1%E6%81%AF-Summary-Area"><span class="toc-number">3.1.</span> <span class="toc-text">第一部分：系统摘要信息 (Summary Area)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8%E5%8C%BA-Process-List-Area"><span class="toc-number">3.2.</span> <span class="toc-text">第二部分：进程列表区 (Process List Area)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BA%A4%E4%BA%92%E5%91%BD%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">日常使用交互命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%A1%88%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">问题排查案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%A4%84%E7%90%86-CPU-%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">案例一：发现并处理 CPU 占用率过高的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%A4%84%E7%90%86%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">案例二：发现并处理内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%89%EF%BC%9A%E6%8E%92%E6%9F%A5-I-O-%E7%93%B6%E9%A2%88"><span class="toc-number">5.3.</span> <span class="toc-text">案例三：排查 I&#x2F;O 瓶颈</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>