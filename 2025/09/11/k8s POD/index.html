<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>k8s POD | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="🤔 分析过程：该问题旨在考察对Kubernetes最基本操作的掌握程度，即如何创建一个Pod。一个完整的回答不仅要给出示例配置文件，还应该解释清楚创建Pod的两种主要方法（声明式和命令式）、各自的适用场景，以及为什么在生产环境中我们通常不直接创建“裸Pod”。这能体现出面试者是否具备实际的、规范的操作经验。 💡 答案生成：1. 概念或定义在Kubernetes中创建一个Pod，意味着你向集群下">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s POD">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/k8s%20POD/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="🤔 分析过程：该问题旨在考察对Kubernetes最基本操作的掌握程度，即如何创建一个Pod。一个完整的回答不仅要给出示例配置文件，还应该解释清楚创建Pod的两种主要方法（声明式和命令式）、各自的适用场景，以及为什么在生产环境中我们通常不直接创建“裸Pod”。这能体现出面试者是否具备实际的、规范的操作经验。 💡 答案生成：1. 概念或定义在Kubernetes中创建一个Pod，意味着你向集群下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:43:43.806Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "k8s POD",
  "url": "https://huiaz.github.io/2025/09/11/k8s%20POD/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:43:43.806Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/k8s%20POD/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'k8s POD',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">k8s POD</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">k8s POD</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:43:43.806Z" title="更新于 2025-09-11 21:43:43">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="🤔-分析过程："><a href="#🤔-分析过程：" class="headerlink" title="🤔 分析过程："></a>🤔 分析过程：</h3><p>该问题旨在考察对Kubernetes最基本操作的掌握程度，即如何创建一个Pod。一个完整的回答不仅要给出示例配置文件，还应该解释清楚创建Pod的两种主要方法（声明式和命令式）、各自的适用场景，以及为什么在生产环境中我们通常不直接创建“裸Pod”。这能体现出面试者是否具备实际的、规范的操作经验。</p>
<h3 id="💡-答案生成："><a href="#💡-答案生成：" class="headerlink" title="💡 答案生成："></a>💡 答案生成：</h3><h4 id="1-概念或定义"><a href="#1-概念或定义" class="headerlink" title="1. 概念或定义"></a>1. 概念或定义</h4><p>在Kubernetes中创建一个Pod，意味着你向集群下达一个指令，要求它运行一个或多个容器的实例。这个过程的核心是向API Server提交一个描述Pod期望状态的<strong>清单（Manifest）</strong>，通常是一个YAML或JSON格式的文件。</p>
<h4 id="2-创建方法"><a href="#2-创建方法" class="headerlink" title="2. 创建方法"></a>2. 创建方法</h4><p>创建Pod主要有两种方法：</p>
<ul>
<li><p><strong>1. 声明式方法 (Declarative Method) - 强烈推荐</strong></p>
<ul>
<li><strong>描述：</strong> 这是Kubernetes管理的<strong>标准和最佳实践</strong>。你首先编写一个YAML文件来“声明”你想要的Pod是什么样子的（例如，使用什么镜像、需要多少资源、开放哪个端口等）。然后，你使用<code>kubectl apply -f &lt;filename.yaml&gt;</code>命令将这个声明提交给集群。</li>
<li><strong>工作机制：</strong> Kubernetes会读取你的YAML文件，并持续工作以确保集群的实际状态与你的声明相匹配。如果Pod被意外删除，（虽然裸Pod不会，但Deployment会）控制器会重新创建一个。如果配置需要变更，你只需修改YAML文件并再次<code>apply</code>即可。</li>
<li><strong>优点：</strong> 配置可被版本控制（如Git）、可复用、可审计，是生产环境的唯一正确选择。</li>
</ul>
</li>
<li><p><strong>2. 命令式方法 (Imperative Method)</strong></p>
<ul>
<li><strong>描述：</strong> 你可以通过一个直接的命令来创建资源，而无需编写YAML文件。例如 <code>kubectl run my-nginx --image=nginx</code>。</li>
<li><strong>工作机制：</strong> 这条命令会直接向API Server发送一个创建Pod的请求。它跳过了文件管理的步骤。</li>
<li><strong>适用场景：</strong> 主要用于<strong>学习、开发或一次性的调试任务</strong>。因为它快速便捷，但配置不易于管理和复现。<strong>严禁在生产环境中使用此方法进行部署。</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-示例配置文件-YAML-Manifest"><a href="#3-示例配置文件-YAML-Manifest" class="headerlink" title="3. 示例配置文件 (YAML Manifest)"></a>3. 示例配置文件 (YAML Manifest)</h4><p>这是使用<strong>声明式方法</strong>创建一个简单Nginx Pod的示例YAML文件。将以下内容保存为 <code>my-nginx-pod.yaml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># API版本，Pod资源属于核心v1版本</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="comment"># 资源类型，这里是Pod</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="comment"># 元数据，包含Pod的名称、标签等信息</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># Pod的名称，在命名空间内必须唯一</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nginx-pod</span></span><br><span class="line">  <span class="comment"># 标签，用于标识和选择Pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">webserver</span></span><br><span class="line"><span class="comment"># 规格，定义Pod的期望状态，这是最重要的部分</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># Pod中包含的容器列表</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="comment"># 容器的名称，在Pod内必须唯一</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">      <span class="comment"># 要使用的容器镜像</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.21.6</span></span><br><span class="line">      <span class="comment"># 容器需要暴露的端口</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="comment"># 容器监听80端口</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h4 id="4-创建与验证步骤"><a href="#4-创建与验证步骤" class="headerlink" title="4. 创建与验证步骤"></a>4. 创建与验证步骤</h4><ol>
<li><p><strong>保存文件：</strong> 将上述YAML内容保存为 <code>my-nginx-pod.yaml</code> 文件。</p>
</li>
<li><p><strong>应用配置：</strong> 在终端中执行以下命令来创建Pod。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f my-nginx-pod.yaml</span><br></pre></td></tr></table></figure>
<p>你会看到输出：<code>pod/my-nginx-pod created</code></p>
</li>
<li><p><strong>验证状态：</strong> 检查Pod是否已成功创建并正在运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod my-nginx-pod</span><br><span class="line"><span class="comment"># 或者使用 &#x27;kubectl get pods -l app=webserver&#x27; 通过标签选择</span></span><br></pre></td></tr></table></figure>
<p>预期输出，<code>STATUS</code> 栏应为 <code>Running</code>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NAME</span>            READY   STATUS    RESTARTS   AGE</span><br><span class="line"><span class="attribute">my</span>-nginx-pod    <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">30</span>s</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看详情：</strong> 如果Pod状态不是<code>Running</code>（例如<code>Pending</code>或<code>Error</code>），可以使用<code>describe</code>命令查看详细事件和日志，以进行排查。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod my-nginx-pod</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-扩展知识-最佳实践"><a href="#5-扩展知识-最佳实践" class="headerlink" title="5. 扩展知识&#x2F;最佳实践"></a>5. 扩展知识&#x2F;最佳实践</h4><ul>
<li><strong>黄金法则：不要直接在生产环境中创建裸Pod (Naked Pod)！</strong><ul>
<li><strong>原因：</strong> 直接创建的Pod不具备自我修复能力。如果Pod所在的节点发生故障，或者Pod本身因为错误而退出，Kubernetes<strong>不会</strong>自动重新创建它。这个Pod就会永远消失。</li>
</ul>
</li>
<li><strong>正确的方式：使用高层级的控制器！</strong><ul>
<li>在实际应用中，你应该总是通过<strong>Deployment</strong>、<strong>StatefulSet</strong>或<strong>DaemonSet</strong>等控制器来管理Pod。</li>
<li><strong>Deployment:</strong> 是最常用的控制器，适用于无状态应用。它会创建一个<code>ReplicaSet</code>来确保指定数量的Pod副本始终在运行。如果Pod失败，Deployment的ReplicaSet会自动创建一个新的Pod来替代它，从而实现了<strong>自我修复</strong>和<strong>高可用</strong>。</li>
<li><strong>示例 (Deployment):</strong> 一个管理Nginx Pod的Deployment会是更好的选择，它能保证Pod的健壮性。</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong> 创建Pod是Kubernetes的基础操作，通过编写YAML文件并使用<code>kubectl apply</code>的声明式方法是标准实践。然而，在生产环境中，必须使用如Deployment这样的控制器来管理Pod，以确保应用的健壮性和高可用性。 </p>
<h3 id="💡-答案生成：-1"><a href="#💡-答案生成：-1" class="headerlink" title="💡 答案生成："></a>💡 答案生成：</h3><h4 id="1-概念或定义-1"><a href="#1-概念或定义-1" class="headerlink" title="1. 概念或定义"></a>1. 概念或定义</h4><p><strong>Pod</strong> 是 Kubernetes 中能够创建和管理的<strong>最小、最简单的部署单元</strong>。它代表了集群中一个正在运行的进程的实例。</p>
<p>一个Pod封装了一个或多个紧密耦合的<strong>容器</strong>，并为这些容器提供了共享的<strong>存储资源 (Volumes)</strong> 和共享的**网络命名空间 (Network Namespace)**。这意味着，在同一个Pod内的所有容器共享同一个IP地址和端口空间，并且可以通过<code>localhost</code>互相通信。它们还可以共享Pod级别定义的存储卷，实现数据交换。</p>
<p>可以把Pod想象成一个<strong>“豌豆荚”</strong>（Pod的英文原意），而里面的容器就是“豌豆”。这些豌豆被包裹在同一个环境中，共享资源，生命周期也紧密相连。</p>
<h4 id="2-作用与核心目的-Why-do-Pods-exist"><a href="#2-作用与核心目的-Why-do-Pods-exist" class="headerlink" title="2. 作用与核心目的 (Why do Pods exist?)"></a>2. 作用与核心目的 (Why do Pods exist?)</h4><p>Kubernetes不直接管理容器，而是通过Pod这个更高层次的抽象来管理。其核心作用主要有三点：</p>
<ul>
<li><p><strong>1. 提供最小的原子调度和管理单元 (Atomic Unit of Scheduling):</strong></p>
<ul>
<li>Kubernetes的调度器（Kube-scheduler）不会将单个容器调度到节点上，而是将整个Pod作为一个不可分割的<strong>原子单元</strong>进行调度。Pod内的所有容器总是会被一起调度到同一个节点上，并且它们的生命周期是绑定的——它们会一起启动、一起停止。</li>
</ul>
</li>
<li><p><strong>2. 实现容器间的紧密协作 (Enabling Co-location and Resource Sharing):</strong></p>
<ul>
<li>这是Pod设计的核心目的。当多个进程需要紧密协作、共享资源时，将它们放在同一个Pod中是最理想的模式。</li>
<li><strong>共享网络:</strong> 容器可以通过<code>localhost</code>直接访问彼此的端口，简化了服务发现和通信。</li>
<li><strong>共享存储:</strong> 容器可以通过挂载同一个<code>Volume</code>来共享文件，例如，一个主应用容器写入日志文件，另一个“边车（Sidecar）”容器读取并上报该日志文件。</li>
</ul>
</li>
<li><p><strong>3. 作为应用实例的抽象 (Abstraction for Application Instances):</strong></p>
<ul>
<li>对于Kubernetes来说，一个Pod就代表了你的应用的一个“实例”或“副本”。当你需要水平扩展应用时，你是在创建更多的Pod副本，而不是更多的单个容器。这使得像<code>Deployment</code>这样的控制器能够更容易地管理应用的伸缩、更新和健康状态。</li>
</ul>
</li>
</ul>
<h4 id="3-Pod-与容器的区别"><a href="#3-Pod-与容器的区别" class="headerlink" title="3. Pod 与容器的区别"></a>3. Pod 与容器的区别</h4><p>这是一个至关重要的区别，也是面试中的常见考点。</p>
<table>
<thead>
<tr>
<th align="left">特性 (Feature)</th>
<th align="left">容器 (Container)</th>
<th align="left">Pod (Kubernetes)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>基本单位 (Unit)</strong></td>
<td align="left">容器是运行时的最小执行单元（如Docker容器）。</td>
<td align="left">Pod是Kubernetes中<strong>最小的部署和管理单元</strong>。</td>
</tr>
<tr>
<td align="left"><strong>网络 (Network)</strong></td>
<td align="left">默认情况下，每个容器都有自己隔离的网络命名空间。</td>
<td align="left"><strong>一个Pod拥有一个独立的IP地址</strong>，Pod内的所有容器共享此IP。</td>
</tr>
<tr>
<td align="left"><strong>资源共享 (Sharing)</strong></td>
<td align="left">容器之间默认是隔离的。</td>
<td align="left">Pod为内部的容器提供了一个<strong>强制的资源共享环境</strong>。</td>
</tr>
<tr>
<td align="left"><strong>生命周期 (Lifecycle)</strong></td>
<td align="left">由容器运行时（如containerd, CRI-O）直接管理。</td>
<td align="left">由Kubernetes作为一个整体进行管理，生死与共。</td>
</tr>
<tr>
<td align="left"><strong>扩展单位 (Scaling)</strong></td>
<td align="left">在Kubernetes中，不直接以容器为单位进行扩展。</td>
<td align="left"><strong>是Kubernetes水平扩展的基本单位</strong>（HPA扩展的是Pod数量）。</td>
</tr>
<tr>
<td align="left"><strong>典型用途 (Use Case)</strong></td>
<td align="left">运行单个应用程序或进程。</td>
<td align="left">运行一个主应用以及其紧密耦合的辅助进程（如Sidecar模式）。</td>
</tr>
</tbody></table>
<h4 id="4-扩展知识-最佳实践"><a href="#4-扩展知识-最佳实践" class="headerlink" title="4. 扩展知识&#x2F;最佳实践"></a>4. 扩展知识&#x2F;最佳实践</h4><ul>
<li><strong>“一个Pod，一个主要进程”原则:</strong> 虽然Pod可以包含多个容器，但最佳实践是每个Pod只运行一个应用的主进程。其他容器应该是辅助性的“边车”（Sidecars），例如日志收集器、服务网格代理（如Istio Envoy）、配置加载器等。不要将多个无关的应用塞进同一个Pod。</li>
<li><strong>Pod是“易逝的” (Ephemeral):</strong> Pod被设计为可替代和临时的。当一个Pod死掉后，控制器（如Deployment）会创建一个新的Pod来替代它。因此，任何需要持久化的数据都必须使用<strong>持久化存储（PersistentVolume）</strong>，而不能依赖Pod自身的生命周期。</li>
<li><strong>通过控制器管理Pod:</strong> 在实际生产中，你几乎永远不会直接创建单个Pod。而是通过更高级的控制器（如<code>Deployment</code>, <code>StatefulSet</code>, <code>DaemonSet</code>, <code>Job</code>）来创建和管理Pod，因为这些控制器提供了自愈、扩展、滚动更新等关键能力。</li>
</ul>
<p><strong>结论：</strong> Pod是Kubernetes中最基本的构建块，它通过提供一个共享的执行环境，将一个或多个紧密协作的容器组合成一个原子管理单元，从而简化了应用的部署、调度和扩展。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/k8s%20POD/">https://huiaz.github.io/2025/09/11/k8s%20POD/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/k8s%20ReplicaSet/" title="k8s ReplicaSet"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">k8s ReplicaSet</div></div><div class="info-2"><div class="info-item-1">ReplicaSet (简称 RS) 和 ReplicationController (简称 RC) 的区别从功能上讲，ReplicaSet 和 ReplicationController 的核心目标是一致的：  确保指定数量的 Pod 副本始终在运行。 当 Pod 发生故障、删除或节点失效时，它们会自动创建新的 Pod 以维持所需数量。 当副本数量过多时，它们会终止多余的 Pod。  但它们之间存在关键的区别，主要体现在Selector (选择器) 的支持上。  1. ReplicationController (RC) 出现时间： 这是 Kubernetes 最早引入的控制器之一 (Kubernetes v1.0 之前)。 选择器 (Selector) 限制： 只支持基于等值（Equality-based）的选择器。这意味着你只能通过精确匹配标签的值来选择 Pod。 例如：selector: app=nginx，它会选择所有带有 app: nginx 标签的 Pod。 它不支持集合基（Set-based）的选择器，例如 app in (nginx, apache) 或 ver...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20Namespace/" title="k8s Namespace"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">k8s Namespace</div></div><div class="info-2"><div class="info-item-1">请描述 Kubernetes 中的 Namespace 的作用，并解释其使用场景。 🤔 分析过程：此问题考察的是对Kubernetes基本组织单元——Namespace（命名空间）的理解。一个优秀的回答需要解释其核心功能，即逻辑隔离，并能从不同维度（名称、资源、权限）阐述这种隔离。更重要的是，要能结合实际工作场景，说明为什么以及如何使用命名空间来组织集群，这直接反映了面试者的集群治理和多租户管理经验。 💡 答案生成：1. 概念或定义Namespace（命名空间）是Kubernetes中一种实现逻辑隔离的机制，它能将一个物理的Kubernetes集群划分为多个虚拟集群。每个命名空间都是一个独立的作用域，用于组织和隔离集群中的资源对象。 需要强调的是，这种隔离是逻辑上的，而非物理上的。不同命名空间中的Pod可能会运行在同一个物理节点上，但它们在API层面、策略层面和名称层面是相互隔离的。 2. Namespace 的核心作用Namespace为一组资源提供了三个维度的隔离：  1. 名称范围隔离 (Scope for Names):  作用： 这是最基本的作用。在同一个命名空间内...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/k8s_12/" title="k8s_12"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s_12</div></div><div class="info-2"><div class="info-item-1">如何在 Kubernetes 中实现服务的自动伸缩（autoscaling）？Of course. Automating the scaling of services is one of Kubernetes’ most powerful features, enabling applications to be both resilient to traffic spikes and cost-effective during quiet periods. This is achieved through a combination of several components. 🤔 分析过程：该问题旨在考察对Kubernetes核心动态管理能力的理解。一个全面的回答不能只提及一种自动伸缩方式，而应结构化地介绍Kubernetes中三个主要层次的自动伸缩器：HPA (水平), VPA (垂直), 和 CA (集群)。回答的重点在于阐明每种伸缩器的触发机制、作用范围和典型用例，并解释它们如何协同工作，共同构建一个弹性的、资源高效的系统。 💡 答案生成：1. 概念或定义Kube...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Dockerfile%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="Dockerfile 最佳实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Dockerfile 最佳实践</div></div><div class="info-2"><div class="info-item-1">Dockerfile 最佳实践Docker官方关于Dockerfile最佳实践原文链接地址：https://docs.docker.com/develop/develop-images/dockerfile_best-practices/ Docker可以通过从Dockerfile包含所有命令的文本文件中读取指令自动构建镜像，以便构建给定镜像。 Dockerfiles使用特定的格式并使用一组特定的指令。您可以在 Dockerfile Reference 页面上了解基础知识 。如果你是新手写作Dockerfile，你应该从那里开始。 本文档介绍了由 Docker，Inc. 和 Docker 社区推荐的用于构建高效镜像的最佳实践和方法。要查看更多实践和建议，请查看 Dockerfile for buildpack-deps。 一般准则和建议容器应该是短暂的通过 Dockerfile 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。我们可以查看下12 Factor(12要素)应用程序方法...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Consule%20%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" title="Consule 服务发现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Consule 服务发现</div></div><div class="info-2"><div class="info-item-1">基于 Consul 的服务发现Consul 是由 HashiCorp 开发的一个支持多数据中心的分布式服务发现和键值对存储服务的开源软件，是一个通用的服务发现和注册中心工具，被大量应用于基于微服务的软件架构当中。 接下来我们就来尝试使用 Prometheus 基于 Consul 的服务发现来监控前面的 3 个 demo 服务： 123192.168.31.46:10000192.168.31.46:10001192.168.31.46:10002  我们将 demo 服务注册到 Consul，然后配置 Prometheus 从 Consul 中发现演示服务实例，并使用 Relabeling 操作来过滤调整目标标签。关于 Consul 本身的使用可以查看官方文档 https://learn.hashicorp.com/consul 了解更多。  安装配置 Consul在页面 https://www.consul.io/downloads 下载符合自己系统的安装文件，比如我们这里是 Linux 系统，使用下面命令下载安装即可： 12345678☸ ➜ wget https://rel...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%8C%87%E6%A0%87%E7%B1%BB%E5%9E%8B/" title="指标类型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">指标类型</div></div><div class="info-2"><div class="info-item-1">指标类型从存储上来讲所有的监控指标都是相同的，但是在不同的场景下这些指标又有一些细微的差异。 例如，在 Node Exporter 返回的样本中指标 node_load1 反应的是当前系统的负载状态，随着时间的变化这个指标返回的样本数据是在不断变化的。而指标 node_cpu_seconds_total 所获取到的样本数据却不同，它是一个持续增大的值，因为其反应的是 CPU 的累计使用时间，从理论上讲只要系统不关机，这个值是会一直变大。 为了能够帮助用户理解和区分这些不同监控指标之间的差异，Prometheus 定义了 4 种不同的指标类型：Counter（计数器）、Gauge（仪表盘）、Histogram（直方图）、Summary（摘要）。 在 node-exporter（后面会详细讲解）返回的样本数据中，其注释中也包含了该样本的类型。例如： 123# HELP node_cpu_seconds_total Seconds the cpus spent in each mode.# TYPE node_cpu_seconds_total counternode_cpu_seco...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%20Kubernetes%20%E8%8A%82%E7%82%B9%20IP%20%E5%9C%B0%E5%9D%80?/" title="如何修改 Kubernetes 节点 IP 地址?"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">如何修改 Kubernetes 节点 IP 地址?</div></div><div class="info-2"><div class="info-item-1">如何修改 Kubernetes 节点 IP 地址?昨天网络环境出了点问题，本地的虚拟机搭建的 Kubernetes 环境没有固定 IP，结果节点 IP 变了，当然最简单的方式是将节点重新固定回之前的 IP 地址，但是自己头铁想去修改下集群的 IP 地址，结果一路下来踩了好多坑，压根就没那么简单~ 环境首先看下之前的环境： 1234➜  ~ cat /etc/hosts192.168.0.111 master1192.168.0.109 node1192.168.0.110 node2  新的 IP 地址： 1234➜  ~ cat /etc/hosts192.168.0.106 master1192.168.0.101 node1192.168.0.105 node2  所以我们需要修改所有节点的 IP 地址。 操作首先将所有节点的 /etc/hosts 更改为新的地址。  提示：在操作任何文件之前强烈建议先备份。  master 节点1.备份 /etc/kubernetes 目录。 1➜ cp -Rf /etc/kubernetes/ /etc/kubernetes-bak  ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Thanos%20Receiver/" title="Thanos Receiver"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Thanos Receiver</div></div><div class="info-2"><div class="info-item-1">Receiver前面我们提到 Thanos 有 Sidecar 和 Receiver 两种不同的架构模式，前面的章节我们已经学习了 Sidecar 模式的是呀，接下来我们再来了解下 Receiver 模式是如何工作的。 我们知道 Sidecar 是在每一个 Prometheus 的实例旁边添加一个 sidecar 组件来上传数据，但是数据上传并不是实时的，而是每 2h 上传一个数据块，所以远程存储的数据并不是实时的，Prometheus 需要各自持久化部分数据，这也是现在使用的 Sidecar 模式的弊端，但这并非是 Thanos 团队引入 Receiver 的决定性因素。  Receiver is only recommended for uses for whom pushing is the only viable solution, for example, analytics use cases or cases where the data ingestion must be client initiated, such as software as a servic...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%94-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">🤔 分析过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E7%AD%94%E6%A1%88%E7%94%9F%E6%88%90%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">💡 答案生成：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5%E6%88%96%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">1. 概念或定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">2. 创建方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-YAML-Manifest"><span class="toc-number">2.3.</span> <span class="toc-text">3. 示例配置文件 (YAML Manifest)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%AA%8C%E8%AF%81%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.4.</span> <span class="toc-text">4. 创建与验证步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.5.</span> <span class="toc-text">5. 扩展知识&#x2F;最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E7%AD%94%E6%A1%88%E7%94%9F%E6%88%90%EF%BC%9A-1"><span class="toc-number">3.</span> <span class="toc-text">💡 答案生成：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5%E6%88%96%E5%AE%9A%E4%B9%89-1"><span class="toc-number">3.1.</span> <span class="toc-text">1. 概念或定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%9C%E7%94%A8%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%9B%AE%E7%9A%84-Why-do-Pods-exist"><span class="toc-number">3.2.</span> <span class="toc-text">2. 作用与核心目的 (Why do Pods exist?)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Pod-%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">3. Pod 与容器的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.4.</span> <span class="toc-text">4. 扩展知识&#x2F;最佳实践</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>