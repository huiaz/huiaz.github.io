<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络模型 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Kubernetes CNI 网络模型简介K8s 的网络模型核心要求：  Pod-to-Pod 互通：每个 Pod 都有唯一 IP，Pod 之间不需要 NAT 就能通信。 Pod-to-Service 互通：通过 Service ClusterIP 或者 kube-proxy&#x2F;ipvs 实现。 跨节点通信：不同 Node 上的 Pod 必须能直接通信。  CNI（Container">
<meta property="og:type" content="article">
<meta property="og:title" content="网络模型">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="1. Kubernetes CNI 网络模型简介K8s 的网络模型核心要求：  Pod-to-Pod 互通：每个 Pod 都有唯一 IP，Pod 之间不需要 NAT 就能通信。 Pod-to-Service 互通：通过 Service ClusterIP 或者 kube-proxy&#x2F;ipvs 实现。 跨节点通信：不同 Node 上的 Pod 必须能直接通信。  CNI（Container">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:17:45.518Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "网络模型",
  "url": "https://huiaz.github.io/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:17:45.518Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络模型',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">网络模型</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">网络模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:17:45.518Z" title="更新于 2025-09-11 22:17:45">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-Kubernetes-CNI-网络模型简介"><a href="#1-Kubernetes-CNI-网络模型简介" class="headerlink" title="1. Kubernetes CNI 网络模型简介"></a>1. Kubernetes CNI 网络模型简介</h2><p>K8s 的网络模型核心要求：</p>
<ol>
<li><strong>Pod-to-Pod 互通</strong>：每个 Pod 都有唯一 IP，Pod 之间不需要 NAT 就能通信。</li>
<li><strong>Pod-to-Service 互通</strong>：通过 Service ClusterIP 或者 kube-proxy&#x2F;ipvs 实现。</li>
<li><strong>跨节点通信</strong>：不同 Node 上的 Pod 必须能直接通信。</li>
</ol>
<p>CNI（Container Network Interface）是一套标准，K8s 通过调用不同的 CNI 插件来实现具体的网络。</p>
<hr>
<h2 id="2-Flannel"><a href="#2-Flannel" class="headerlink" title="2. Flannel"></a>2. Flannel</h2><p>🔹 <strong>定位</strong>：最早、最简单的 CNI，主要实现 <strong>Pod-to-Pod 的三层网络连通性</strong>。<br> 🔹 <strong>特点</strong>：</p>
<ul>
<li>提供 Overlay 网络（VXLAN、UDP、Host-GW 等模式）。</li>
<li><strong>只管连通性</strong>，不提供 NetworkPolicy（安全策略）。</li>
<li>架构简单、易于部署，适合小规模或对网络安全需求不高的场景。</li>
</ul>
<p>✅ 优点：</p>
<ul>
<li>部署简单，稳定成熟。</li>
<li>占用资源少。</li>
</ul>
<p>❌ 缺点：</p>
<ul>
<li>功能单一，无安全策略支持。</li>
<li>性能一般（Overlay 会带来额外开销）。</li>
</ul>
<hr>
<h2 id="3-Calico"><a href="#3-Calico" class="headerlink" title="3. Calico"></a>3. Calico</h2><p>🔹 <strong>定位</strong>：功能全面的 CNI，支持 <strong>三层路由 + 安全策略</strong>。<br> 🔹 <strong>特点</strong>：</p>
<ul>
<li>默认采用 BGP（边界网关协议）做三层路由，Pod IP 可以直接在节点间路由，不一定要 overlay。</li>
<li>支持 <strong>网络策略（NetworkPolicy）</strong>，基于 iptables 或 eBPF 实现安全隔离。</li>
<li>既可以 Overlay（IP-in-IP、VXLAN），也可以纯三层（Direct Routing）。</li>
</ul>
<p>✅ 优点：</p>
<ul>
<li>高性能（BGP 直连时几乎无封装开销）。</li>
<li>完整的网络策略支持。</li>
<li>生产环境应用广泛，社区活跃。</li>
</ul>
<p>❌ 缺点：</p>
<ul>
<li>配置比 Flannel 复杂。</li>
<li>BGP 配置和大规模集群下路由收敛可能需要调优。</li>
</ul>
<hr>
<h2 id="4-Cilium"><a href="#4-Cilium" class="headerlink" title="4. Cilium"></a>4. Cilium</h2><p>🔹 <strong>定位</strong>：新一代基于 <strong>eBPF</strong> 的 CNI 插件。<br> 🔹 <strong>特点</strong>：</p>
<ul>
<li>使用 Linux eBPF 技术实现高性能数据面，替代 iptables。</li>
<li>支持 <strong>L3&#x2F;L4&#x2F;L7 网络策略</strong>（应用层可见性，甚至能基于 HTTP 方法做策略）。</li>
<li>可以与 Envoy 集成，具备 Service Mesh 能力（Cilium Service Mesh）。</li>
<li>支持 Overlay（VXLAN、Geneve）和直连路由模式。</li>
</ul>
<p>✅ 优点：</p>
<ul>
<li>高性能（eBPF 内核态转发比 iptables 更快）。</li>
<li>安全策略更细粒度（L7）。</li>
<li>可观测性强（内置 Hubble，可观察 Pod 间流量）。</li>
<li>云原生方向更先进（可替代部分 Service Mesh 功能）。</li>
</ul>
<p>❌ 缺点：</p>
<ul>
<li>对内核要求较高（Linux 内核 4.9+，推荐 5.x 以上）。</li>
<li>部署和调试复杂度比 Flannel 高。</li>
<li>对资源开销相对比 Flannel 大。</li>
</ul>
<hr>
<h2 id="5-三者对比总结"><a href="#5-三者对比总结" class="headerlink" title="5. 三者对比总结"></a>5. 三者对比总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Flannel</th>
<th>Calico</th>
<th>Cilium</th>
</tr>
</thead>
<tbody><tr>
<td>核心功能</td>
<td>Pod 网络连通</td>
<td>网络连通 + 网络策略（L3&#x2F;L4）</td>
<td>网络连通 + L3&#x2F;L4&#x2F;L7 网络策略</td>
</tr>
<tr>
<td>数据平面</td>
<td>VXLAN&#x2F;IP-in-IP</td>
<td>BGP &#x2F; VXLAN &#x2F; IP-in-IP</td>
<td>eBPF（VXLAN&#x2F;Geneve&#x2F;直连）</td>
</tr>
<tr>
<td>性能</td>
<td>中等（Overlay）</td>
<td>高（直连 BGP 模式）</td>
<td>高（eBPF 内核转发）</td>
</tr>
<tr>
<td>网络策略</td>
<td>❌ 不支持</td>
<td>✅ 支持</td>
<td>✅ 更细粒度（支持 L7）</td>
</tr>
<tr>
<td>部署复杂度</td>
<td>⭐ 最低</td>
<td>⭐⭐ 中等</td>
<td>⭐⭐⭐ 较高</td>
</tr>
<tr>
<td>适用场景</td>
<td>小规模、简单集群</td>
<td>生产环境主流、安全隔离需求强</td>
<td>对性能&#x2F;可观测性要求高的新项目</td>
</tr>
</tbody></table>
<p>好的 👍 我来给你系统讲一下 <strong>Kubernetes CNI（Container Network Interface）工作原理</strong>，包括它的流程和在 K8s 里的作用。</p>
<hr>
<h2 id="1-CNI-的背景"><a href="#1-CNI-的背景" class="headerlink" title="1. CNI 的背景"></a>1. CNI 的背景</h2><ul>
<li><strong>Kubernetes 自身不提供具体的网络实现</strong>，它只定义了网络模型要求（Pod 互通、Pod 与 Service 互通等）。</li>
<li>真正实现 Pod 网络的是 <strong>CNI 插件</strong>（例如 Flannel、Calico、Cilium）。</li>
<li><strong>CNI 是 CNCF 定义的一套标准接口</strong>，任何网络插件只要遵循这个接口，就可以和 K8s 无缝集成。</li>
</ul>
<hr>
<h2 id="2-CNI-的工作流程"><a href="#2-CNI-的工作流程" class="headerlink" title="2. CNI 的工作流程"></a>2. CNI 的工作流程</h2><p>当 Kubernetes 在某个节点上创建 Pod 时，大致流程如下：</p>
<ol>
<li><strong>Kubelet 调用 CRI（Container Runtime Interface）</strong><ul>
<li>Pod 创建时，Kubelet 通知容器运行时（如 containerd、CRI-O、Docker-shim）。</li>
</ul>
</li>
<li><strong>容器运行时调用 CNI 插件</strong><ul>
<li>容器运行时需要为容器配置网络（分配 IP、路由、DNS 等）。</li>
<li>它会根据 <code>/etc/cni/net.d/</code> 下的 CNI 配置文件，调用对应的 CNI 插件（可执行二进制）。</li>
</ul>
</li>
<li><strong>CNI 插件执行 <code>ADD</code> 操作</strong><ul>
<li>插件会创建一个 <strong>veth pair（虚拟网卡对）</strong>：一端放在 Pod 的 network namespace，另一端接到主机的 bridge 或路由设备上。</li>
<li>插件向 IPAM（IP Address Management）模块申请一个 IP 地址，分配给 Pod。</li>
<li>配置路由，使得 Pod 可以访问集群内外网络。</li>
</ul>
</li>
<li><strong>Pod 网络建立完成</strong><ul>
<li>Pod 获得 IP 地址和路由表，可以与同节点、跨节点的 Pod 通信。</li>
<li>跨节点时，CNI 插件（如 Flannel VXLAN、Calico BGP、Cilium eBPF）负责把流量正确转发到目标节点。</li>
</ul>
</li>
<li><strong>Pod 删除时调用 <code>DEL</code> 操作</strong><ul>
<li>容器运行时调用插件 <code>DEL</code>，释放 Pod 的 IP，清理网络设备。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-CNI-插件接口规范"><a href="#3-CNI-插件接口规范" class="headerlink" title="3. CNI 插件接口规范"></a>3. CNI 插件接口规范</h2><p>CNI 插件必须实现的二进制接口包括：</p>
<ul>
<li><strong>ADD</strong>：创建网络接口，分配 IP 地址。</li>
<li><strong>DEL</strong>：删除网络接口，释放 IP。</li>
<li><strong>CHECK</strong>（可选）：检查网络是否正常。</li>
<li><strong>VERSION</strong>：返回插件支持的版本信息。</li>
</ul>
<p>输入：通过标准输入传递 JSON 配置，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mynet&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isGateway&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.244.0.0/16&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出：插件返回 Pod 的 IP 信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ips&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.244.0.5/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.244.0.1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-CNI-在-Kubernetes-中的作用"><a href="#4-CNI-在-Kubernetes-中的作用" class="headerlink" title="4. CNI 在 Kubernetes 中的作用"></a>4. CNI 在 Kubernetes 中的作用</h2><ul>
<li><strong>Pod 网络接入</strong>：为每个 Pod 分配独立 IP，并与宿主机网络互通。</li>
<li><strong>跨节点通信</strong>：决定 Pod 跨节点如何转发（VXLAN、BGP、eBPF 等）。</li>
<li><strong>网络策略</strong>：部分 CNI 插件（Calico、Cilium）实现 K8s 的 <code>NetworkPolicy</code>，用于安全隔离。</li>
</ul>
<hr>
<h2 id="5-简化图示"><a href="#5-简化图示" class="headerlink" title="5. 简化图示"></a>5. 简化图示</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        Kubelet</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">    Container Runtime</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">      调用 <span class="built_in">CNI</span> 插件</span><br><span class="line">           │</span><br><span class="line">   ┌───────┴─────────┐</span><br><span class="line">   │                 │</span><br><span class="line"><span class="built_in">CNI</span> 网络插件   IPAM 插件</span><br><span class="line">   │                 │</span><br><span class="line">   └───────┬─────────┘</span><br><span class="line">           │</span><br><span class="line">   配置 Pod veth + IP</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">        Pod 获得网络</span><br></pre></td></tr></table></figure>

<p>好的，我们来深入讲解一下 <strong>Cilium 的 Native Routing with kube-proxy 模式</strong>。</p>
<hr>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>Cilium 是一个基于 <strong>eBPF</strong> 的 CNI 插件，支持多种数据路径模式，其中常见的有：</p>
<ul>
<li><strong>Overlay 模式</strong>（VXLAN&#x2F;Geneve）：流量封装后在节点之间传递。</li>
<li><strong>Native Routing 模式</strong>（直连路由）：利用节点路由表转发，不做封装，性能更高。</li>
</ul>
<p>同时，K8s 默认的 <strong>Service 转发</strong>是由 <strong>kube-proxy</strong>（基于 iptables 或 ipvs）实现的。但 Cilium 也可以完全接管 Service 转发（替代 kube-proxy），称为 <strong>kube-proxy replacement</strong> 模式。</p>
<p>你问的 <strong>Native Routing with kube-proxy 模式</strong>，意思是：<br> 👉 <strong>Cilium 使用 Native Routing 做 Pod-to-Pod 流量转发，同时 Service 还是交给 kube-proxy 处理。</strong></p>
<hr>
<h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h2><h3 id="Pod-to-Pod-通信"><a href="#Pod-to-Pod-通信" class="headerlink" title="Pod-to-Pod 通信"></a>Pod-to-Pod 通信</h3><ol>
<li>Pod 在节点上分配一个 <strong>真实的子网 IP</strong>（没有 VXLAN 封装）。</li>
<li>Cilium 配置 Linux 路由表，让不同节点之间的 Pod 网络可以直达：<ul>
<li>可以通过 <strong>BGP</strong>（Cilium + MetalLB&#x2F;FRR）动态分发路由。</li>
<li>或者通过静态路由（cluster scope routing）。</li>
</ul>
</li>
<li>数据包走主机路由转发，直接到达目标节点的 Pod（无隧道封装 → 更高性能）。</li>
</ol>
<h3 id="Pod-to-Service-通信"><a href="#Pod-to-Service-通信" class="headerlink" title="Pod-to-Service 通信"></a>Pod-to-Service 通信</h3><ul>
<li>仍由 <strong>kube-proxy</strong> 负责 Service 的虚拟 IP (ClusterIP) 转换。</li>
<li>流量到达 Service 的虚拟 IP 后，通过 iptables&#x2F;ipvs 规则 NAT 到对应 Pod。</li>
</ul>
<h3 id="简单示意："><a href="#简单示意：" class="headerlink" title="简单示意："></a>简单示意：</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[PodA]</span> <span class="built_in">--</span>(Native Routing)--&gt; <span class="selector-attr">[PodB]</span>         ✅ Cilium 直连路由</span><br><span class="line"><span class="selector-attr">[PodA]</span> <span class="built_in">--</span>(ClusterIP)--&gt; <span class="selector-attr">[kube-proxy]</span> --&gt; <span class="selector-attr">[PodB]</span>   ✅ kube-proxy NAT</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-模式特点"><a href="#3-模式特点" class="headerlink" title="3. 模式特点"></a>3. 模式特点</h2><p>✅ <strong>优点</strong>：</p>
<ul>
<li>性能好：Pod-to-Pod 无封装，减少额外开销。</li>
<li>部署简单：不用立刻替换 kube-proxy，降低接入风险。</li>
<li>兼容性强：Service 相关逻辑保持不变。</li>
</ul>
<p>❌ <strong>缺点</strong>：</p>
<ul>
<li>Service 仍然依赖 kube-proxy（iptables&#x2F;ipvs），性能和可观测性不如 Cilium eBPF Service。</li>
<li>Native Routing 需要正确配置路由（例如 BGP 或静态路由），网络环境复杂时配置量大。</li>
</ul>
<hr>
<h2 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h2><ul>
<li>集群规模中等，追求 <strong>Pod-to-Pod 高性能通信</strong>，但不想立即替换 kube-proxy。</li>
<li>已经有现成的 kube-proxy 配置，迁移成本较高。</li>
<li>对 Service 的流量性能要求不是瓶颈。</li>
</ul>
<hr>
<h2 id="5-与其他模式对比"><a href="#5-与其他模式对比" class="headerlink" title="5. 与其他模式对比"></a>5. 与其他模式对比</h2><table>
<thead>
<tr>
<th>模式</th>
<th>Pod-to-Pod</th>
<th>Pod-to-Service</th>
<th>性能</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Overlay + kube-proxy</strong></td>
<td>VXLAN&#x2F;Geneve 封装</td>
<td>kube-proxy</td>
<td>中</td>
<td>低</td>
</tr>
<tr>
<td><strong>Native Routing + kube-proxy</strong></td>
<td>直连路由</td>
<td>kube-proxy</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td><strong>Overlay + eBPF (no kube-proxy)</strong></td>
<td>VXLAN&#x2F;Geneve 封装</td>
<td>Cilium eBPF</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td><strong>Native Routing + eBPF (no kube-proxy)</strong></td>
<td>直连路由</td>
<td>Cilium eBPF</td>
<td>最高</td>
<td>高</td>
</tr>
</tbody></table>
<hr>
<p>👉 总结一句话：<br> <strong>Cilium Native Routing with kube-proxy 模式</strong>就是：</p>
<ul>
<li><strong>Pod-to-Pod</strong> 走直连路由（性能更好）。</li>
<li><strong>Service</strong> 还是走 kube-proxy（兼容性最好）。</li>
<li>适合作为从传统方案逐步迁移到 Cilium 全 eBPF 的过渡阶段。</li>
</ul>
<h2 id="Native-Routing-eBPF-hostRouting-模式工作原理"><a href="#Native-Routing-eBPF-hostRouting-模式工作原理" class="headerlink" title="Native Routing + eBPF hostRouting 模式工作原理"></a>Native Routing + eBPF hostRouting 模式工作原理</h2><p>在这个模式下：</p>
<ul>
<li><strong>Pod-to-Pod 跨节点通信</strong>：<ol>
<li>Pod 发出数据包（目的 IP &#x3D; PodB IP）。</li>
<li>Cilium 的 eBPF 程序在 veth ingress 处捕获数据包。</li>
<li>eBPF 查找路由表，判断目标 Pod 在另一个节点。</li>
<li>直接把数据包送到物理网卡，带上目标 Node 的 MAC 地址。</li>
<li>目标 Node 收到包后，Cilium eBPF 把它直接送入目标 Pod 的 veth，不再走主机协议栈。</li>
</ol>
</li>
<li><strong>Pod-to-Service</strong>：<ul>
<li>如果还保留 kube-proxy，则由 iptables&#x2F;ipvs 处理。</li>
<li>如果开启 Cilium kube-proxy replacement，则由 Cilium eBPF Service 加速。</li>
</ul>
</li>
</ul>
<h2 id="Cilium-VXLAN-模式的工作原理"><a href="#Cilium-VXLAN-模式的工作原理" class="headerlink" title="Cilium VXLAN 模式的工作原理"></a>Cilium VXLAN 模式的工作原理</h2><p>当你在 Cilium 里选择 VXLAN 模式时：</p>
<h3 id="Pod-to-Pod-流量"><a href="#Pod-to-Pod-流量" class="headerlink" title="Pod-to-Pod 流量"></a>Pod-to-Pod 流量</h3><ol>
<li><p>PodA（在 Node1）要访问 PodB（在 Node2）。</p>
</li>
<li><p>PodA 发出的数据包目的 IP &#x3D; PodB IP。</p>
</li>
<li><p>Cilium eBPF 程序拦截数据包 → 封装为 <strong>VXLAN 包</strong>：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span> IP: Node1 IP → Node2 IP</span><br><span class="line"><span class="keyword">Outer</span> UDP: dst=<span class="number">4789</span></span><br><span class="line">VXLAN <span class="keyword">Header</span></span><br><span class="line"><span class="keyword">Inner</span> Ethernet + <span class="keyword">Inner</span> IP: PodA → PodB</span><br></pre></td></tr></table></figure>
</li>
<li><p>包经过物理网络到达 Node2。</p>
</li>
<li><p>Node2 的 Cilium VXLAN 解封装，还原出 Pod-to-Pod 原始包。</p>
</li>
<li><p>交付给 PodB。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">https://huiaz.github.io/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/%E7%9B%B4%E6%96%B9%E5%9B%BE/" title="直方图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">直方图</div></div><div class="info-2"><div class="info-item-1">直方图在这一节中，我们将学习直方图指标，了解如何根据这些指标来计算分位数。Prometheus 中的直方图指标允许一个服务记录一系列数值的分布。直方图通常用于跟踪请求的延迟或响应大小等指标值，当然理论上它是可以跟踪任何根据某种分布而产生波动数值的大小。Prometheus 直方图是在客户端对数据进行的采样，它们使用的一些可配置的（例如延迟）bucket 桶对观察到的值进行计数，然后将这些 bucket 作为单独的时间序列暴露出来。 下图是一个非累积直方图的例子：  在 Prometheus 内部，直方图被实现为一组时间序列，每个序列代表指定桶的计数（例如10ms以下的请求数、25ms以下的请求数、50ms以下的请求数等）。 在 Prometheus 中每个 bucket 桶的计数器是累加的，这意味着较大值的桶也包括所有低数值的桶的计数。在作为直方图一部分的每个时间序列上，相应的桶由特殊的 le 标签表示。le 代表的是小于或等于。 与上面相同的直方图在 Prometheus 中的累积直方图如下所示：  可以看到在 Prometheus 中直方图的计数是累计的，这是很奇怪的，因为通...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E8%81%9A%E5%90%88/" title="聚合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">聚合</div></div><div class="info-2"><div class="info-item-1">聚合我们知道 Prometheus 的时间序列数据是多维数据模型，我们经常就有根据各个维度进行汇总的需求。 基于标签聚合例如我们想知道我们的 demo 服务每秒处理的请求数，那么可以将单个的速率相加就可以。 1sum(rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]))    可以得到如下所示的结果：  但是我们可以看到绘制出来的图形没有保留任何标签维度，一般来说可能我们希望保留一些维度，例如，我们可能更希望计算每个 instance 和 path 的变化率，但并不关心单个 method 或者 status 的结果，这个时候我们可以在 sum() 聚合器中添加一个 without() 的修饰符： 1sum without(method, status) (rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]))    上面的查询语句相当于用 by() 修饰符来保留...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/HPA/" title="HPA"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HPA</div></div><div class="info-2"><div class="info-item-1">HPA 控制器在前面的学习中我们使用了一个 kubectl scale 命令可以来实现 Pod 的扩缩容功能，但是这个是完全手动操作的，要应对线上的各种复杂情况，我们需要能够做到自动化去感知业务，来自动进行扩缩容。为此，Kubernetes 也为我们提供了这样的一个资源对象：Horizontal Pod Autoscaling（Pod 水平自动伸缩），简称 HPA，HPA 通过监控分析一些控制器控制的所有 Pod 的负载变化情况来确定是否需要调整 Pod 的副本数量，这是 HPA 最基本的原理：  我们可以简单的通过 kubectl autoscale 命令来创建一个 HPA 资源对象，HPA Controller 默认30s轮询一次（可通过 kube-controller-manager 的--horizontal-pod-autoscaler-sync-period 参数进行设置），查询指定的资源中的 Pod 资源使用率，并且与创建时设定的值和指标做对比，从而实现自动伸缩的功能。 Metrics Server在 HPA 的第一个版本中，我们需要 Heapster 提供 CPU...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Deployment/" title="Deployment"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Deployment</div></div><div class="info-2"><div class="info-item-1">Deployment 控制器前面我们学习了 ReplicaSet 控制器，了解到该控制器是用来维护集群中运行的 Pod 数量的，但是往往在实际操作的时候，我们反而不会去直接使用 RS，而是会使用更上层的控制器，比如我们今天要学习的主角 Deployment，Deployment 一个非常重要的功能就是实现了 Pod 的滚动更新，比如我们应用更新了，我们只需要更新我们的容器镜像，然后修改 Deployment 里面的 Pod 模板镜像，那么 Deployment 就会用滚动更新（Rolling Update）的方式来升级现在的 Pod，这个能力是非常重要的，因为对于线上的服务我们需要做到不中断服务，所以滚动更新就成了必须的一个功能。而 Deployment 这个能力的实现，依赖的就是上节课我们学习的 ReplicaSet 这个资源对象，实际上我们可以通俗的理解就是每个 Deployment 就对应集群中的一次部署，这样就更好理解了。 Deployment 概述Deployment 资源对象的格式和 ReplicaSet 几乎一致，如下资源对象就是一个常见的 Deployment 资...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Ingress/" title="Ingress"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Ingress</div></div><div class="info-2"><div class="info-item-1">Ingress前面我们学习了在 Kubernetes 集群内部使用 kube-dns 实现服务发现的功能，那么我们部署在 Kubernetes 集群中的应用如何暴露给外部的用户使用呢？我们知道可以使用 NodePort 和 LoadBlancer 类型的 Service 可以把应用暴露给外部用户使用，除此之外，Kubernetes 还为我们提供了一个非常重要的资源对象可以用来暴露服务给外部用户，那就是 Ingress。对于小规模的应用我们使用 NodePort 或许能够满足我们的需求，但是当你的应用越来越多的时候，你就会发现对于 NodePort 的管理就非常麻烦了，这个时候使用 Ingress 就非常方便了，可以避免管理大量的端口。 资源对象Ingress 资源对象是 Kubernetes 内置定义的一个对象，是从 Kuberenets 集群外部访问集群的一个入口，将外部的请求转发到集群内不同的 Service 上，其实就相当于 nginx、haproxy 等负载均衡代理服务器，可能你会觉得我们直接使用 nginx 就实现了，但是只使用 nginx 这种方式有很大缺陷，每次有新...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Service/" title="Service"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Service</div></div><div class="info-2"><div class="info-item-1">Service我们前面的课程中学习了一些常用控制器的基本用法，我们也了解到 Pod 的生命是有限的，死亡过后不会复活了。然后我们知道可以用 ReplicaSet 和 Deployment 来动态的创建和销毁 Pod，每个 Pod 都有自己的 IP 地址，但是如果 Pod 重建了的话那么他的 IP 很有可能也就变化了。这就会带来一个问题：比如我们有一些后端的 Pod 集合为集群中的其他应用提供 API 服务，如果我们在前端应用中把所有的这些后端的 Pod 的地址都写死，然后以某种方式去访问其中一个 Pod 的服务，这样看上去是可以工作的，对吧？但是如果这个 Pod 挂掉了，然后重新启动起来了，是不是 IP 地址非常有可能就变了，这个时候前端就极大可能访问不到后端的服务了。 遇到这样的问题该怎么解决呢？在没有使用 Kubernetes 之前，我相信可能很多同学都遇到过这样的问题，不一定是 IP 变化的问题，比如我们在部署一个 WEB 服务的时候，前端一般部署一个 Nginx 作为服务的入口，然后 Nginx 后面肯定就是挂载的这个服务的大量后端服务，很早以前我们可能是去手动更改 Ng...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/" title="集群模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">集群模式</div></div><div class="info-2"><div class="info-item-1">集群模式对于低于每秒一百万个数据点的摄取率，建议使用单节点版本而不是集群版本。单节点版本可根据 CPU 内核、RAM 和可用存储空间的数量进行扩展。单节点版本比集群版本更容易配置和操作，所以在使用集群版本之前要三思而后行。上面我们介绍了 VM 的单节点版本的基本使用，接下来我们来介绍下如何使用集群版。 集群版主要特点：  支持单节点版本的所有功能。 性能和容量水平扩展。 支持时间序列数据的多个独立命名空间（多租户）。 支持多副本。  组件服务前面我们了解了 VM 的基本架构，对于集群模式下主要包含以下几个服务：  vmstorage：存储原始数据并返回指定标签过滤器在给定时间范围内的查询数据，当 -storageDataPath 指向的目录包含的可用空间少于 -storage.minFreeDiskSpaceBytes 时，vmstorage 节点会自动切换到只读模式，vminsert 节点也会停止向此类节点发送数据并开始将数据重新路由到剩余的 vmstorage 节点。 vminsert：接受摄取的数据并根据指标名称及其所有标签的一致性哈希将其分散存储到 vmstorage 节...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Local%20%E5%AD%98%E5%82%A8/" title="Local 存储"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Local 存储</div></div><div class="info-2"><div class="info-item-1">Local 存储前面我们有通过 hostPath 或者 emptyDir 的方式来持久化我们的数据，但是显然我们还需要更加可靠的存储来保存应用的持久化数据，这样容器在重建后，依然可以使用之前的数据。但是存储资源和 CPU 资源以及内存资源有很大不同，为了屏蔽底层的技术实现细节，让用户更加方便的使用，Kubernetes 便引入了 PV 和 PVC 两个重要的资源对象来实现对存储的管理。 概念PV 的全称是：PersistentVolume（持久化卷），是对底层共享存储的一种抽象，PV 由管理员进行创建和配置，它和具体的底层的共享存储技术的实现方式有关，比如 Ceph、GlusterFS、NFS、hostPath 等，都是通过插件机制完成与共享存储的对接。 PVC 的全称是：PersistentVolumeClaim（持久化卷声明），PVC 是用户存储的一种声明，PVC 和 Pod 比较类似，Pod 消耗的是节点，PVC 消耗的是 PV 资源，Pod 可以请求 CPU 和内存，而 PVC 可以请求特定的存储空间和访问模式。对于真正使用存储的用户不需要关心底层的存储实现细节，只需要直...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Kubernetes-CNI-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">1. Kubernetes CNI 网络模型简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Flannel"><span class="toc-number">2.</span> <span class="toc-text">2. Flannel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Calico"><span class="toc-number">3.</span> <span class="toc-text">3. Calico</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Cilium"><span class="toc-number">4.</span> <span class="toc-text">4. Cilium</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">5. 三者对比总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-CNI-%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">6.</span> <span class="toc-text">1. CNI 的背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CNI-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">2. CNI 的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-CNI-%E6%8F%92%E4%BB%B6%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83"><span class="toc-number">8.</span> <span class="toc-text">3. CNI 插件接口规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-CNI-%E5%9C%A8-Kubernetes-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">4. CNI 在 Kubernetes 中的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%80%E5%8C%96%E5%9B%BE%E7%A4%BA"><span class="toc-number">10.</span> <span class="toc-text">5. 简化图示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%83%8C%E6%99%AF"><span class="toc-number">11.</span> <span class="toc-text">1. 背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">2. 工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod-to-Pod-%E9%80%9A%E4%BF%A1"><span class="toc-number">12.1.</span> <span class="toc-text">Pod-to-Pod 通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod-to-Service-%E9%80%9A%E4%BF%A1"><span class="toc-number">12.2.</span> <span class="toc-text">Pod-to-Service 通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E6%84%8F%EF%BC%9A"><span class="toc-number">12.3.</span> <span class="toc-text">简单示意：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A8%A1%E5%BC%8F%E7%89%B9%E7%82%B9"><span class="toc-number">13.</span> <span class="toc-text">3. 模式特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.</span> <span class="toc-text">4. 适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">15.</span> <span class="toc-text">5. 与其他模式对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native-Routing-eBPF-hostRouting-%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">Native Routing + eBPF hostRouting 模式工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cilium-VXLAN-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">17.</span> <span class="toc-text">Cilium VXLAN 模式的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod-to-Pod-%E6%B5%81%E9%87%8F"><span class="toc-number">17.1.</span> <span class="toc-text">Pod-to-Pod 流量</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>