<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络模型 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Kubernetes CNI 网络模型简介K8s 的网络模型核心要求：  Pod-to-Pod 互通：每个 Pod 都有唯一 IP，Pod 之间不需要 NAT 就能通信。 Pod-to-Service 互通：通过 Service ClusterIP 或者 kube-proxy&#x2F;ipvs 实现。 跨节点通信：不同 Node 上的 Pod 必须能直接通信。  CNI（Container">
<meta property="og:type" content="article">
<meta property="og:title" content="网络模型">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="1. Kubernetes CNI 网络模型简介K8s 的网络模型核心要求：  Pod-to-Pod 互通：每个 Pod 都有唯一 IP，Pod 之间不需要 NAT 就能通信。 Pod-to-Service 互通：通过 Service ClusterIP 或者 kube-proxy&#x2F;ipvs 实现。 跨节点通信：不同 Node 上的 Pod 必须能直接通信。  CNI（Container">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:17:45.518Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "网络模型",
  "url": "https://huiaz.github.io/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:17:45.518Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络模型',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">网络模型</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">网络模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:17:45.518Z" title="更新于 2025-09-11 22:17:45">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-Kubernetes-CNI-网络模型简介"><a href="#1-Kubernetes-CNI-网络模型简介" class="headerlink" title="1. Kubernetes CNI 网络模型简介"></a>1. Kubernetes CNI 网络模型简介</h2><p>K8s 的网络模型核心要求：</p>
<ol>
<li><strong>Pod-to-Pod 互通</strong>：每个 Pod 都有唯一 IP，Pod 之间不需要 NAT 就能通信。</li>
<li><strong>Pod-to-Service 互通</strong>：通过 Service ClusterIP 或者 kube-proxy&#x2F;ipvs 实现。</li>
<li><strong>跨节点通信</strong>：不同 Node 上的 Pod 必须能直接通信。</li>
</ol>
<p>CNI（Container Network Interface）是一套标准，K8s 通过调用不同的 CNI 插件来实现具体的网络。</p>
<hr>
<h2 id="2-Flannel"><a href="#2-Flannel" class="headerlink" title="2. Flannel"></a>2. Flannel</h2><p>🔹 <strong>定位</strong>：最早、最简单的 CNI，主要实现 <strong>Pod-to-Pod 的三层网络连通性</strong>。<br> 🔹 <strong>特点</strong>：</p>
<ul>
<li>提供 Overlay 网络（VXLAN、UDP、Host-GW 等模式）。</li>
<li><strong>只管连通性</strong>，不提供 NetworkPolicy（安全策略）。</li>
<li>架构简单、易于部署，适合小规模或对网络安全需求不高的场景。</li>
</ul>
<p>✅ 优点：</p>
<ul>
<li>部署简单，稳定成熟。</li>
<li>占用资源少。</li>
</ul>
<p>❌ 缺点：</p>
<ul>
<li>功能单一，无安全策略支持。</li>
<li>性能一般（Overlay 会带来额外开销）。</li>
</ul>
<hr>
<h2 id="3-Calico"><a href="#3-Calico" class="headerlink" title="3. Calico"></a>3. Calico</h2><p>🔹 <strong>定位</strong>：功能全面的 CNI，支持 <strong>三层路由 + 安全策略</strong>。<br> 🔹 <strong>特点</strong>：</p>
<ul>
<li>默认采用 BGP（边界网关协议）做三层路由，Pod IP 可以直接在节点间路由，不一定要 overlay。</li>
<li>支持 <strong>网络策略（NetworkPolicy）</strong>，基于 iptables 或 eBPF 实现安全隔离。</li>
<li>既可以 Overlay（IP-in-IP、VXLAN），也可以纯三层（Direct Routing）。</li>
</ul>
<p>✅ 优点：</p>
<ul>
<li>高性能（BGP 直连时几乎无封装开销）。</li>
<li>完整的网络策略支持。</li>
<li>生产环境应用广泛，社区活跃。</li>
</ul>
<p>❌ 缺点：</p>
<ul>
<li>配置比 Flannel 复杂。</li>
<li>BGP 配置和大规模集群下路由收敛可能需要调优。</li>
</ul>
<hr>
<h2 id="4-Cilium"><a href="#4-Cilium" class="headerlink" title="4. Cilium"></a>4. Cilium</h2><p>🔹 <strong>定位</strong>：新一代基于 <strong>eBPF</strong> 的 CNI 插件。<br> 🔹 <strong>特点</strong>：</p>
<ul>
<li>使用 Linux eBPF 技术实现高性能数据面，替代 iptables。</li>
<li>支持 <strong>L3&#x2F;L4&#x2F;L7 网络策略</strong>（应用层可见性，甚至能基于 HTTP 方法做策略）。</li>
<li>可以与 Envoy 集成，具备 Service Mesh 能力（Cilium Service Mesh）。</li>
<li>支持 Overlay（VXLAN、Geneve）和直连路由模式。</li>
</ul>
<p>✅ 优点：</p>
<ul>
<li>高性能（eBPF 内核态转发比 iptables 更快）。</li>
<li>安全策略更细粒度（L7）。</li>
<li>可观测性强（内置 Hubble，可观察 Pod 间流量）。</li>
<li>云原生方向更先进（可替代部分 Service Mesh 功能）。</li>
</ul>
<p>❌ 缺点：</p>
<ul>
<li>对内核要求较高（Linux 内核 4.9+，推荐 5.x 以上）。</li>
<li>部署和调试复杂度比 Flannel 高。</li>
<li>对资源开销相对比 Flannel 大。</li>
</ul>
<hr>
<h2 id="5-三者对比总结"><a href="#5-三者对比总结" class="headerlink" title="5. 三者对比总结"></a>5. 三者对比总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Flannel</th>
<th>Calico</th>
<th>Cilium</th>
</tr>
</thead>
<tbody><tr>
<td>核心功能</td>
<td>Pod 网络连通</td>
<td>网络连通 + 网络策略（L3&#x2F;L4）</td>
<td>网络连通 + L3&#x2F;L4&#x2F;L7 网络策略</td>
</tr>
<tr>
<td>数据平面</td>
<td>VXLAN&#x2F;IP-in-IP</td>
<td>BGP &#x2F; VXLAN &#x2F; IP-in-IP</td>
<td>eBPF（VXLAN&#x2F;Geneve&#x2F;直连）</td>
</tr>
<tr>
<td>性能</td>
<td>中等（Overlay）</td>
<td>高（直连 BGP 模式）</td>
<td>高（eBPF 内核转发）</td>
</tr>
<tr>
<td>网络策略</td>
<td>❌ 不支持</td>
<td>✅ 支持</td>
<td>✅ 更细粒度（支持 L7）</td>
</tr>
<tr>
<td>部署复杂度</td>
<td>⭐ 最低</td>
<td>⭐⭐ 中等</td>
<td>⭐⭐⭐ 较高</td>
</tr>
<tr>
<td>适用场景</td>
<td>小规模、简单集群</td>
<td>生产环境主流、安全隔离需求强</td>
<td>对性能&#x2F;可观测性要求高的新项目</td>
</tr>
</tbody></table>
<p>好的 👍 我来给你系统讲一下 <strong>Kubernetes CNI（Container Network Interface）工作原理</strong>，包括它的流程和在 K8s 里的作用。</p>
<hr>
<h2 id="1-CNI-的背景"><a href="#1-CNI-的背景" class="headerlink" title="1. CNI 的背景"></a>1. CNI 的背景</h2><ul>
<li><strong>Kubernetes 自身不提供具体的网络实现</strong>，它只定义了网络模型要求（Pod 互通、Pod 与 Service 互通等）。</li>
<li>真正实现 Pod 网络的是 <strong>CNI 插件</strong>（例如 Flannel、Calico、Cilium）。</li>
<li><strong>CNI 是 CNCF 定义的一套标准接口</strong>，任何网络插件只要遵循这个接口，就可以和 K8s 无缝集成。</li>
</ul>
<hr>
<h2 id="2-CNI-的工作流程"><a href="#2-CNI-的工作流程" class="headerlink" title="2. CNI 的工作流程"></a>2. CNI 的工作流程</h2><p>当 Kubernetes 在某个节点上创建 Pod 时，大致流程如下：</p>
<ol>
<li><strong>Kubelet 调用 CRI（Container Runtime Interface）</strong><ul>
<li>Pod 创建时，Kubelet 通知容器运行时（如 containerd、CRI-O、Docker-shim）。</li>
</ul>
</li>
<li><strong>容器运行时调用 CNI 插件</strong><ul>
<li>容器运行时需要为容器配置网络（分配 IP、路由、DNS 等）。</li>
<li>它会根据 <code>/etc/cni/net.d/</code> 下的 CNI 配置文件，调用对应的 CNI 插件（可执行二进制）。</li>
</ul>
</li>
<li><strong>CNI 插件执行 <code>ADD</code> 操作</strong><ul>
<li>插件会创建一个 <strong>veth pair（虚拟网卡对）</strong>：一端放在 Pod 的 network namespace，另一端接到主机的 bridge 或路由设备上。</li>
<li>插件向 IPAM（IP Address Management）模块申请一个 IP 地址，分配给 Pod。</li>
<li>配置路由，使得 Pod 可以访问集群内外网络。</li>
</ul>
</li>
<li><strong>Pod 网络建立完成</strong><ul>
<li>Pod 获得 IP 地址和路由表，可以与同节点、跨节点的 Pod 通信。</li>
<li>跨节点时，CNI 插件（如 Flannel VXLAN、Calico BGP、Cilium eBPF）负责把流量正确转发到目标节点。</li>
</ul>
</li>
<li><strong>Pod 删除时调用 <code>DEL</code> 操作</strong><ul>
<li>容器运行时调用插件 <code>DEL</code>，释放 Pod 的 IP，清理网络设备。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-CNI-插件接口规范"><a href="#3-CNI-插件接口规范" class="headerlink" title="3. CNI 插件接口规范"></a>3. CNI 插件接口规范</h2><p>CNI 插件必须实现的二进制接口包括：</p>
<ul>
<li><strong>ADD</strong>：创建网络接口，分配 IP 地址。</li>
<li><strong>DEL</strong>：删除网络接口，释放 IP。</li>
<li><strong>CHECK</strong>（可选）：检查网络是否正常。</li>
<li><strong>VERSION</strong>：返回插件支持的版本信息。</li>
</ul>
<p>输入：通过标准输入传递 JSON 配置，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mynet&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isGateway&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.244.0.0/16&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出：插件返回 Pod 的 IP 信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ips&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.244.0.5/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.244.0.1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-CNI-在-Kubernetes-中的作用"><a href="#4-CNI-在-Kubernetes-中的作用" class="headerlink" title="4. CNI 在 Kubernetes 中的作用"></a>4. CNI 在 Kubernetes 中的作用</h2><ul>
<li><strong>Pod 网络接入</strong>：为每个 Pod 分配独立 IP，并与宿主机网络互通。</li>
<li><strong>跨节点通信</strong>：决定 Pod 跨节点如何转发（VXLAN、BGP、eBPF 等）。</li>
<li><strong>网络策略</strong>：部分 CNI 插件（Calico、Cilium）实现 K8s 的 <code>NetworkPolicy</code>，用于安全隔离。</li>
</ul>
<hr>
<h2 id="5-简化图示"><a href="#5-简化图示" class="headerlink" title="5. 简化图示"></a>5. 简化图示</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        Kubelet</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">    Container Runtime</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">      调用 <span class="built_in">CNI</span> 插件</span><br><span class="line">           │</span><br><span class="line">   ┌───────┴─────────┐</span><br><span class="line">   │                 │</span><br><span class="line"><span class="built_in">CNI</span> 网络插件   IPAM 插件</span><br><span class="line">   │                 │</span><br><span class="line">   └───────┬─────────┘</span><br><span class="line">           │</span><br><span class="line">   配置 Pod veth + IP</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">        Pod 获得网络</span><br></pre></td></tr></table></figure>

<p>好的，我们来深入讲解一下 <strong>Cilium 的 Native Routing with kube-proxy 模式</strong>。</p>
<hr>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>Cilium 是一个基于 <strong>eBPF</strong> 的 CNI 插件，支持多种数据路径模式，其中常见的有：</p>
<ul>
<li><strong>Overlay 模式</strong>（VXLAN&#x2F;Geneve）：流量封装后在节点之间传递。</li>
<li><strong>Native Routing 模式</strong>（直连路由）：利用节点路由表转发，不做封装，性能更高。</li>
</ul>
<p>同时，K8s 默认的 <strong>Service 转发</strong>是由 <strong>kube-proxy</strong>（基于 iptables 或 ipvs）实现的。但 Cilium 也可以完全接管 Service 转发（替代 kube-proxy），称为 <strong>kube-proxy replacement</strong> 模式。</p>
<p>你问的 <strong>Native Routing with kube-proxy 模式</strong>，意思是：<br> 👉 <strong>Cilium 使用 Native Routing 做 Pod-to-Pod 流量转发，同时 Service 还是交给 kube-proxy 处理。</strong></p>
<hr>
<h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h2><h3 id="Pod-to-Pod-通信"><a href="#Pod-to-Pod-通信" class="headerlink" title="Pod-to-Pod 通信"></a>Pod-to-Pod 通信</h3><ol>
<li>Pod 在节点上分配一个 <strong>真实的子网 IP</strong>（没有 VXLAN 封装）。</li>
<li>Cilium 配置 Linux 路由表，让不同节点之间的 Pod 网络可以直达：<ul>
<li>可以通过 <strong>BGP</strong>（Cilium + MetalLB&#x2F;FRR）动态分发路由。</li>
<li>或者通过静态路由（cluster scope routing）。</li>
</ul>
</li>
<li>数据包走主机路由转发，直接到达目标节点的 Pod（无隧道封装 → 更高性能）。</li>
</ol>
<h3 id="Pod-to-Service-通信"><a href="#Pod-to-Service-通信" class="headerlink" title="Pod-to-Service 通信"></a>Pod-to-Service 通信</h3><ul>
<li>仍由 <strong>kube-proxy</strong> 负责 Service 的虚拟 IP (ClusterIP) 转换。</li>
<li>流量到达 Service 的虚拟 IP 后，通过 iptables&#x2F;ipvs 规则 NAT 到对应 Pod。</li>
</ul>
<h3 id="简单示意："><a href="#简单示意：" class="headerlink" title="简单示意："></a>简单示意：</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[PodA]</span> <span class="built_in">--</span>(Native Routing)--&gt; <span class="selector-attr">[PodB]</span>         ✅ Cilium 直连路由</span><br><span class="line"><span class="selector-attr">[PodA]</span> <span class="built_in">--</span>(ClusterIP)--&gt; <span class="selector-attr">[kube-proxy]</span> --&gt; <span class="selector-attr">[PodB]</span>   ✅ kube-proxy NAT</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-模式特点"><a href="#3-模式特点" class="headerlink" title="3. 模式特点"></a>3. 模式特点</h2><p>✅ <strong>优点</strong>：</p>
<ul>
<li>性能好：Pod-to-Pod 无封装，减少额外开销。</li>
<li>部署简单：不用立刻替换 kube-proxy，降低接入风险。</li>
<li>兼容性强：Service 相关逻辑保持不变。</li>
</ul>
<p>❌ <strong>缺点</strong>：</p>
<ul>
<li>Service 仍然依赖 kube-proxy（iptables&#x2F;ipvs），性能和可观测性不如 Cilium eBPF Service。</li>
<li>Native Routing 需要正确配置路由（例如 BGP 或静态路由），网络环境复杂时配置量大。</li>
</ul>
<hr>
<h2 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h2><ul>
<li>集群规模中等，追求 <strong>Pod-to-Pod 高性能通信</strong>，但不想立即替换 kube-proxy。</li>
<li>已经有现成的 kube-proxy 配置，迁移成本较高。</li>
<li>对 Service 的流量性能要求不是瓶颈。</li>
</ul>
<hr>
<h2 id="5-与其他模式对比"><a href="#5-与其他模式对比" class="headerlink" title="5. 与其他模式对比"></a>5. 与其他模式对比</h2><table>
<thead>
<tr>
<th>模式</th>
<th>Pod-to-Pod</th>
<th>Pod-to-Service</th>
<th>性能</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Overlay + kube-proxy</strong></td>
<td>VXLAN&#x2F;Geneve 封装</td>
<td>kube-proxy</td>
<td>中</td>
<td>低</td>
</tr>
<tr>
<td><strong>Native Routing + kube-proxy</strong></td>
<td>直连路由</td>
<td>kube-proxy</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td><strong>Overlay + eBPF (no kube-proxy)</strong></td>
<td>VXLAN&#x2F;Geneve 封装</td>
<td>Cilium eBPF</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td><strong>Native Routing + eBPF (no kube-proxy)</strong></td>
<td>直连路由</td>
<td>Cilium eBPF</td>
<td>最高</td>
<td>高</td>
</tr>
</tbody></table>
<hr>
<p>👉 总结一句话：<br> <strong>Cilium Native Routing with kube-proxy 模式</strong>就是：</p>
<ul>
<li><strong>Pod-to-Pod</strong> 走直连路由（性能更好）。</li>
<li><strong>Service</strong> 还是走 kube-proxy（兼容性最好）。</li>
<li>适合作为从传统方案逐步迁移到 Cilium 全 eBPF 的过渡阶段。</li>
</ul>
<h2 id="Native-Routing-eBPF-hostRouting-模式工作原理"><a href="#Native-Routing-eBPF-hostRouting-模式工作原理" class="headerlink" title="Native Routing + eBPF hostRouting 模式工作原理"></a>Native Routing + eBPF hostRouting 模式工作原理</h2><p>在这个模式下：</p>
<ul>
<li><strong>Pod-to-Pod 跨节点通信</strong>：<ol>
<li>Pod 发出数据包（目的 IP &#x3D; PodB IP）。</li>
<li>Cilium 的 eBPF 程序在 veth ingress 处捕获数据包。</li>
<li>eBPF 查找路由表，判断目标 Pod 在另一个节点。</li>
<li>直接把数据包送到物理网卡，带上目标 Node 的 MAC 地址。</li>
<li>目标 Node 收到包后，Cilium eBPF 把它直接送入目标 Pod 的 veth，不再走主机协议栈。</li>
</ol>
</li>
<li><strong>Pod-to-Service</strong>：<ul>
<li>如果还保留 kube-proxy，则由 iptables&#x2F;ipvs 处理。</li>
<li>如果开启 Cilium kube-proxy replacement，则由 Cilium eBPF Service 加速。</li>
</ul>
</li>
</ul>
<h2 id="Cilium-VXLAN-模式的工作原理"><a href="#Cilium-VXLAN-模式的工作原理" class="headerlink" title="Cilium VXLAN 模式的工作原理"></a>Cilium VXLAN 模式的工作原理</h2><p>当你在 Cilium 里选择 VXLAN 模式时：</p>
<h3 id="Pod-to-Pod-流量"><a href="#Pod-to-Pod-流量" class="headerlink" title="Pod-to-Pod 流量"></a>Pod-to-Pod 流量</h3><ol>
<li><p>PodA（在 Node1）要访问 PodB（在 Node2）。</p>
</li>
<li><p>PodA 发出的数据包目的 IP &#x3D; PodB IP。</p>
</li>
<li><p>Cilium eBPF 程序拦截数据包 → 封装为 <strong>VXLAN 包</strong>：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span> IP: Node1 IP → Node2 IP</span><br><span class="line"><span class="keyword">Outer</span> UDP: dst=<span class="number">4789</span></span><br><span class="line">VXLAN <span class="keyword">Header</span></span><br><span class="line"><span class="keyword">Inner</span> Ethernet + <span class="keyword">Inner</span> IP: PodA → PodB</span><br></pre></td></tr></table></figure>
</li>
<li><p>包经过物理网络到达 Node2。</p>
</li>
<li><p>Node2 的 Cilium VXLAN 解封装，还原出 Pod-to-Pod 原始包。</p>
</li>
<li><p>交付给 PodB。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">https://huiaz.github.io/2025/09/11/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/%E7%9B%B4%E6%96%B9%E5%9B%BE/" title="直方图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">直方图</div></div><div class="info-2"><div class="info-item-1">直方图在这一节中，我们将学习直方图指标，了解如何根据这些指标来计算分位数。Prometheus 中的直方图指标允许一个服务记录一系列数值的分布。直方图通常用于跟踪请求的延迟或响应大小等指标值，当然理论上它是可以跟踪任何根据某种分布而产生波动数值的大小。Prometheus 直方图是在客户端对数据进行的采样，它们使用的一些可配置的（例如延迟）bucket 桶对观察到的值进行计数，然后将这些 bucket 作为单独的时间序列暴露出来。 下图是一个非累积直方图的例子：  在 Prometheus 内部，直方图被实现为一组时间序列，每个序列代表指定桶的计数（例如10ms以下的请求数、25ms以下的请求数、50ms以下的请求数等）。 在 Prometheus 中每个 bucket 桶的计数器是累加的，这意味着较大值的桶也包括所有低数值的桶的计数。在作为直方图一部分的每个时间序列上，相应的桶由特殊的 le 标签表示。le 代表的是小于或等于。 与上面相同的直方图在 Prometheus 中的累积直方图如下所示：  可以看到在 Prometheus 中直方图的计数是累计的，这是很奇怪的，因为通...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E8%81%9A%E5%90%88/" title="聚合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">聚合</div></div><div class="info-2"><div class="info-item-1">聚合我们知道 Prometheus 的时间序列数据是多维数据模型，我们经常就有根据各个维度进行汇总的需求。 基于标签聚合例如我们想知道我们的 demo 服务每秒处理的请求数，那么可以将单个的速率相加就可以。 1sum(rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]))    可以得到如下所示的结果：  但是我们可以看到绘制出来的图形没有保留任何标签维度，一般来说可能我们希望保留一些维度，例如，我们可能更希望计算每个 instance 和 path 的变化率，但并不关心单个 method 或者 status 的结果，这个时候我们可以在 sum() 聚合器中添加一个 without() 的修饰符： 1sum without(method, status) (rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;&#125;[5m]))    上面的查询语句相当于用 by() 修饰符来保留...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Relabe/" title="Relabe"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Relabe</div></div><div class="info-2"><div class="info-item-1">Relabeling 重新标记Relabeling 重新标记用于配置 Prometheus 元信息的方式，它是转换和过滤 Prometheus 中 label 标签对象的核心，本章节我们将了解 Relabeling 规则的工作原理，并能够将它们应用于不同的场景中。 概述Prometheus 发现、抓取和处理不同类型的 label 标签对象，根据标签值操作或过滤这些对象非常有用，比如：  只监视具有特定服务发现注解的某些目标，通常在服务发现中使用 向目标抓取请求添加 HTTP 查询参数 仅存储从指定目标中提取样本的子集 将抓取序列的两个标签值合并为一个标签  Relabeling 是作为一系列转换步骤实现的，我们可以在 Prometheus 的配置文件中应用这些步骤来过滤或修改标记对象，我们可以对一下类型的标记对象应用 Relabeling 操作：  发现的抓取目标（relabel_configs） 抓取的单个样本（metric_relabel_configs） 发送给 Alertmanager 的报警（alert_relabel_configs） 写到远程存储的样本（write_...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Thanos%20Store/" title="Thanos Store"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Thanos Store</div></div><div class="info-2"><div class="info-item-1">Store 组件上面我们安装了 Thanos 的 Sidecar 和 Querier 组件，已经可以做到 Prometheus 的高可用，通过 Querier 提供一个统一的入口来查询监控数据，而且还可以对监控数据自动去重，但是还有一个非常重要的地方是还没有配置对象存储，如果想要查看历史监控数据就不行了，这个时候我们就需要去配置 Thanos Store 组件，将历史监控指标存储在对象存储中去。 目前 Thanos 支持的对象存储有：  要在生产环境使用最好使用 Stable 状态的，比如 S3 或者兼容 S3 的服务，比如 Ceph、Minio 等等。 对于国内用户当然最方便的还是直接使用阿里云 OSS 或者腾讯云 COS 这样的服务，但是很多时候可能我们的服务并不是跑在公有云上面的，所以这里我们用 Minio 来部署一个兼容 S3 协议的对象存储服务。 安装 MinioMinIO 是一个基于 Apache License v2.0 开源协议的高性能分布式对象存储服务，为大规模私有云基础设施而设计。它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片...</div></div></div></a><a class="pagination-related" href="/2025/09/11/StatefulSet/" title="StatefulSet"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">StatefulSet</div></div><div class="info-2"><div class="info-item-1">StatefulSet 控制器前面我们学习了 Deployment 和 ReplicaSet 两种资源对象得使用，在实际使用的过程中，Deployment 并不能编排所有类型的应用，对无状态服务编排是非常容易的，但是对于有状态服务就无能为力了。我们需要先明白一个概念：什么是有状态服务，什么是无状态服务。  无状态服务（Stateless Service）：该服务运行的实例不会在本地存储需要持久化的数据，并且多个实例对于同一个请求响应的结果是完全一致的，比如前面我们讲解的 WordPress 实例，我们是不是可以同时启动多个实例，但是我们访问任意一个实例得到的结果都是一样的吧？因为他唯一需要持久化的数据是存储在 MySQL 数据库中的，所以我们可以说 WordPress 这个应用是无状态服务，但是 MySQL 数据库就不是了，因为他需要把数据持久化到本地。 有状态服务（Stateful Service）：就和上面的概念是对立的了，该服务运行的实例需要在本地存储持久化数据，比如上面的 MySQL 数据库，你现在运行在节点 A，那么他的数据就存储在节点 A 上面的，如果这个时候你把该服...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20Rolling%20Update/" title="k8s Rolling Update"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s Rolling Update</div></div><div class="info-2"><div class="info-item-1">描述在 Kubernetes 中如何进行滚动更新和回滚操作。	 🤔 分析过程：此问题考察的是Kubernetes中最重要的功能之一：无停机更新和快速回滚。核心考察点是Deployment控制器如何通过管理ReplicaSet来实现这一过程。一个优秀的回答需要清晰地阐述”滚动更新”的内部机制（特别是maxSurge和maxUnavailable参数）、回滚是如何利用历史版本（旧的ReplicaSet）实现的，并能提供完整的命令行操作示例。 💡 答案生成：1. 概念或定义 滚动更新 (Rolling Update): 是Kubernetes中默认的部署策略，旨在实现零停机时间（Zero-Downtime）的应用升级。它通过逐个地用新版本的Pod替换旧版本的Pod，而不是一次性地销毁所有旧Pod再创建新Pod，从而保证在整个更新过程中，应用服务始终是可用的。  回滚 (Rollback): 是一个恢复操作。当新版本的应用部署后出现问题时，回滚操作可以将应用快速地恢复到之前一个稳定、可用的版本。Kubernetes通过保留历史部署版本（以ReplicaSet的形式）来实现这一功能。 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/CoreDNS/" title="CoreDNS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">CoreDNS</div></div><div class="info-2"><div class="info-item-1">服务发现上面我们讲解了 Service 的用法，我们可以通过 Service 生成的 ClusterIP(VIP) 来访问 Pod 提供的服务，但是在使用的时候还有一个问题：我们怎么知道某个应用的 VIP 呢？比如我们有两个应用，一个是 api 应用，一个是 db 应用，两个应用都是通过 Deployment 进行管理的，并且都通过 Service 暴露出了端口提供服务。api 需要连接到 db 这个应用，我们只知道 db 应用的名称和 db 对应的 Service 的名称，但是并不知道它的 VIP 地址，我们前面的 Service 课程中是不是学习到我们通过 ClusterIP 就可以访问到后面的 Pod 服务，如果我们知道了 VIP 的地址是不是就行了？ 环境变量为了解决上面的问题，在之前的版本中，Kubernetes 采用了环境变量的方法，每个 Pod 启动的时候，会通过环境变量设置所有服务的 IP 和 port 信息，这样 Pod 中的应用可以通过读取环境变量来获取依赖服务的地址信息，这种方法使用起来相对简单，但是有一个很大的问题就是依赖的服务必须在 Pod 启动之前就存...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" title="应用监控"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">应用监控</div></div><div class="info-2"><div class="info-item-1">应用监控前面我们和大家介绍了 Prometheus 的数据指标是通过一个公开的 HTTP(S) 数据接口获取到的，我们不需要单独安装监控的 agent，只需要暴露一个 metrics 接口，Prometheus 就会定期去拉取数据；对于一些普通的 HTTP 服务，我们完全可以直接重用这个服务，添加一个 /metrics 接口暴露给 Prometheus；而且获取到的指标数据格式是非常易懂的，不需要太高的学习成本。 现在很多服务从一开始就内置了一个 /metrics 接口，比如 Kubernetes 的各个组件都直接提供了数据指标接口，有一些服务即使没有原生集成该接口，也完全可以使用一些 exporter 来获取到指标数据，比如 mysqld_exporter、node_exporter，这些 exporter 就有点类似于传统监控服务中的 agent，作为服务一直存在，用来收集目标服务的指标数据然后直接暴露给 Prometheus。 普通应用对于普通应用只需要能够提供一个满足 Prometheus 格式要求的 /metrics 接口就可以让 Prometheus 来接管监控，比如...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Kubernetes-CNI-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">1. Kubernetes CNI 网络模型简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Flannel"><span class="toc-number">2.</span> <span class="toc-text">2. Flannel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Calico"><span class="toc-number">3.</span> <span class="toc-text">3. Calico</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Cilium"><span class="toc-number">4.</span> <span class="toc-text">4. Cilium</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">5. 三者对比总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-CNI-%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">6.</span> <span class="toc-text">1. CNI 的背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CNI-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">2. CNI 的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-CNI-%E6%8F%92%E4%BB%B6%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83"><span class="toc-number">8.</span> <span class="toc-text">3. CNI 插件接口规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-CNI-%E5%9C%A8-Kubernetes-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">4. CNI 在 Kubernetes 中的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%80%E5%8C%96%E5%9B%BE%E7%A4%BA"><span class="toc-number">10.</span> <span class="toc-text">5. 简化图示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%83%8C%E6%99%AF"><span class="toc-number">11.</span> <span class="toc-text">1. 背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">2. 工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod-to-Pod-%E9%80%9A%E4%BF%A1"><span class="toc-number">12.1.</span> <span class="toc-text">Pod-to-Pod 通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod-to-Service-%E9%80%9A%E4%BF%A1"><span class="toc-number">12.2.</span> <span class="toc-text">Pod-to-Service 通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E6%84%8F%EF%BC%9A"><span class="toc-number">12.3.</span> <span class="toc-text">简单示意：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A8%A1%E5%BC%8F%E7%89%B9%E7%82%B9"><span class="toc-number">13.</span> <span class="toc-text">3. 模式特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.</span> <span class="toc-text">4. 适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">15.</span> <span class="toc-text">5. 与其他模式对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native-Routing-eBPF-hostRouting-%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">Native Routing + eBPF hostRouting 模式工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cilium-VXLAN-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">17.</span> <span class="toc-text">Cilium VXLAN 模式的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod-to-Pod-%E6%B5%81%E9%87%8F"><span class="toc-number">17.1.</span> <span class="toc-text">Pod-to-Pod 流量</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>