<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>docker-overlay network | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Overlay 网络依赖于 Docker Swarm mode（或更早的 Docker UCP&#x2F;libnetwork 插件）。所以，配置 Overlay 网络的第一步是初始化或加入一个 Docker Swarm 集群。 配置 Overlay 网络模式的步骤前提条件 多台 Docker 主机： 至少需要两台机器，每台机器都安装了 Docker Engine。 端口开放： 2377&amp;#x2F">
<meta property="og:type" content="article">
<meta property="og:title" content="docker-overlay network">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/docker-overlay%20network/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="Overlay 网络依赖于 Docker Swarm mode（或更早的 Docker UCP&#x2F;libnetwork 插件）。所以，配置 Overlay 网络的第一步是初始化或加入一个 Docker Swarm 集群。 配置 Overlay 网络模式的步骤前提条件 多台 Docker 主机： 至少需要两台机器，每台机器都安装了 Docker Engine。 端口开放： 2377&amp;#x2F">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T12:40:44.814Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "docker-overlay network",
  "url": "https://huiaz.github.io/2025/09/11/docker-overlay%20network/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T12:40:44.814Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/docker-overlay%20network/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'docker-overlay network',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">docker-overlay network</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">docker-overlay network</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T12:40:44.814Z" title="更新于 2025-09-11 20:40:44">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/docker/">docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Overlay 网络依赖于 <strong>Docker Swarm mode</strong>（或更早的 Docker UCP&#x2F;libnetwork 插件）。所以，配置 Overlay 网络的第一步是<strong>初始化或加入一个 Docker Swarm 集群</strong>。</p>
<h3 id="配置-Overlay-网络模式的步骤"><a href="#配置-Overlay-网络模式的步骤" class="headerlink" title="配置 Overlay 网络模式的步骤"></a>配置 Overlay 网络模式的步骤</h3><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><ol>
<li><strong>多台 Docker 主机：</strong> 至少需要两台机器，每台机器都安装了 Docker Engine。</li>
<li><strong>端口开放：</strong><ul>
<li><strong>2377&#x2F;TCP (Swarm 管理):</strong> 管理节点之间通信。</li>
<li><strong>7946&#x2F;TCP 和 7946&#x2F;UDP (容器集群通信):</strong> Swarm 节点通信。</li>
<li><strong>4789&#x2F;UDP (Overlay 网络数据):</strong> VXLAN 隧道协议，用于容器数据传输。</li>
<li><strong>防火墙规则：</strong> 确保这些端口在主机防火墙（ufw, firewalld, iptables 等）以及任何云服务提供商的安全组中都是开放的。</li>
</ul>
</li>
</ol>
<h4 id="步骤-1：初始化-Docker-Swarm-或加入现有-Swarm"><a href="#步骤-1：初始化-Docker-Swarm-或加入现有-Swarm" class="headerlink" title="步骤 1：初始化 Docker Swarm 或加入现有 Swarm"></a>步骤 1：初始化 Docker Swarm 或加入现有 Swarm</h4><p>在其中一台主机上（作为 Swarm Manager），执行初始化命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在第一台主机（比如 host1）上执行</span></span><br><span class="line">docker swarm init --advertise-addr &lt;host1_ip&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;host1_ip&gt;</code>：是这台主机对其他 Swarm 节点可访问的 IP 地址。</li>
</ul>
<p>执行后，你会得到一个输出，其中包含一个 <code>docker swarm join</code> 命令，用于其他主机加入到这个 Swarm 集群。</p>
<p>在其他主机上（作为 Swarm Worker 或 Manager，取决于你的需求），执行加入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在其他主机（比如 host2, host3）上执行</span></span><br><span class="line">docker swarm <span class="built_in">join</span> --token &lt;token_from_init&gt; &lt;manager_ip&gt;:2377</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;token_from_init&gt;</code>：是 <code>docker swarm init</code> 命令输出中的 token。</li>
<li><code>&lt;manager_ip&gt;</code>：是 Swarm Manager 的 IP 地址。</li>
</ul>
<p><strong>验证 Swarm 节点：</strong><br>在 Manager 节点上执行 <code>docker node ls</code> 查看所有加入的节点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>你应该能看到所有主机都被列出，并且状态为 <code>Ready</code>。</p>
<h4 id="步骤-2：创建-Overlay-网络"><a href="#步骤-2：创建-Overlay-网络" class="headerlink" title="步骤 2：创建 Overlay 网络"></a>步骤 2：创建 Overlay 网络</h4><p>在<strong>任何一个 Swarm Manager 节点</strong>上，创建 Overlay 网络。此网络会自动分发到所有 Swarm 节点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver overlay --subnet 10.0.9.0/24 --attachable my-overlay-network</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--driver overlay</code>: 指定网络驱动为 overlay。</li>
<li><code>--subnet 10.0.9.0/24</code>: (可选) 指定 Overlay 网络的 IP 子网。如果不指定，Docker 会自动选择一个。</li>
<li><code>--attachable</code>: (可选，但推荐) 允许独立运行的容器（非 Swarm service 的一部分）连接到此 Overlay 网络。否则，只有 Swarm service 的任务才能使用此网络。</li>
<li><code>my-overlay-network</code>: 你为这个网络取的名字。</li>
</ul>
<p><strong>验证网络创建：</strong><br>在任何一个 Swarm 节点上，执行 <code>docker network ls</code>。你应该能看到 <code>my-overlay-network</code> 类型的网络。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>输出中你应该看到类似：</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID     NAME                  DRIVER    SCOPE</span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">&lt;NETWORK_ID&gt;   my-overlay-network    overlay   swarm</span><br><span class="line"><span class="meta prompt_">...</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>SCOPE</code> 为 <code>swarm</code> 表示这是一个 Overlay 网络，并且已经在整个 Swarm 集群中可用。</p>
<h4 id="步骤-3：在容器中使用-Overlay-网络"><a href="#步骤-3：在容器中使用-Overlay-网络" class="headerlink" title="步骤 3：在容器中使用 Overlay 网络"></a>步骤 3：在容器中使用 Overlay 网络</h4><p>现在你可以通过两种方式在容器中使用这个 Overlay 网络：</p>
<p><strong>A. 用于 Docker Swarm Services (推荐方式)</strong></p>
<p>这是 Overlay 网络最常见的用途。当你创建一个 Swarm Service，并将其连接到 Overlay 网络时，Swarm 会在不同的节点上调度 Service 的任务（容器），并确保它们可以通过 Overlay 网络互相通信。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Swarm manager 节点上执行</span></span><br><span class="line">docker service create \</span><br><span class="line">  --name my-web-app \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  --network my-overlay-network \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--network my-overlay-network</code>: 指定 Service 的任务连接到 <code>my-overlay-network</code>。</li>
</ul>
<p>现在 <code>my-web-app</code> 的所有 3 个副本，无论它们运行在哪个节点上，都可以通过容器名 <code>my-web-app</code> 或其内部 IP 互相通信。</p>
<p><strong>B. 用于独立容器 (配合 <code>--attachable</code> 选项)</strong></p>
<p>如果你在创建 Overlay 网络时使用了 <code>--attachable</code> 选项，那么你也可以将非 Swarm Service 的独立容器连接到这个网络。</p>
<p>例如，在 <code>host1</code> 上启动一个容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 host1 上执行</span></span><br><span class="line">docker run -itd --name container1 --network my-overlay-network alpine/git sh</span><br></pre></td></tr></table></figure>

<p>在 <code>host2</code> 上启动另一个容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 host2 上执行</span></span><br><span class="line">docker run -itd --name container2 --network my-overlay-network alpine/git sh</span><br></pre></td></tr></table></figure>

<p>现在，<code>container1</code> 和 <code>container2</code> 尽管运行在不同的物理主机上，但它们可以通过其容器名互相 ping 通：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设在 container1 内部执行</span></span><br><span class="line">docker <span class="built_in">exec</span> container1 ping container2</span><br></pre></td></tr></table></figure>
<p>你应该能看到 <code>container2</code> 的响应。</p>
<h3 id="Overlay-网络的工作原理简述"><a href="#Overlay-网络的工作原理简述" class="headerlink" title="Overlay 网络的工作原理简述"></a>Overlay 网络的工作原理简述</h3><ol>
<li><strong>VXLAN (Virtual eXtensible Local Area Network):</strong> Overlay 网络的核心是 VXLAN。Docker Daemon 在每个 Swarm 节点上创建 VXLAN 隧道，将容器数据包封装在 UDP 数据包中，并通过底层物理网络传输。</li>
<li><strong>KV 存储 (Consul&#x2F;Etcd&#x2F;Zookeeper 或 Raft):</strong> Docker Engine 使用内置的 Raft 共识算法（作为 Swarm mode 的一部分），或配置外部 KV 存储（旧版本），来同步网络配置和容器 IP 地址信息，确保所有节点对网络拓扑有相同的视图。</li>
<li><strong>Ingress 路由网格 (Service):</strong> 对于 Swarm Services，Docker 提供了一个内置的 DNS 服务和 Ingress 路由网格。当你访问一个 Service 的端口时，请求会被路由到该 Service 的任何一个健康副本，无论它运行在哪个节点上。这也是为什么服务发现如此简单。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>防火墙：</strong> 再次强调，确保必要的端口（尤其是 4789&#x2F;UDP）在所有主机之间开放，这是 Overlay 网络工作的基石。</li>
<li><strong>MTU (Maximum Transmission Unit):</strong> VXLAN 封装会增加数据包大小。如果你的底层网络 MTU 较小，可能会导致性能问题。通常，Docker 会自动调整容器的 MTU，但如果遇到网络问题，这可能是一个排查点。</li>
<li><strong>复杂性：</strong> 虽然配置简单，但底层原理涉及网络虚拟化，排查问题时可能需要更深入的网络知识。</li>
</ul>
<p>通过以上步骤，你就可以成功配置和使用 Docker Overlay 网络模式，实现容器的跨主机通信。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/docker-overlay%20network/">https://huiaz.github.io/2025/09/11/docker-overlay%20network/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/docker-volume/" title="docker-volume"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">docker-volume</div></div><div class="info-2"><div class="info-item-1">———— | :———————————– | :———————————– || 管理方       | Docker 引擎                          | 用户&#x2F;宿主机                          || 宿主机位置   | Docker 管理的特定目录                | 用户指定的任意路径                   || 可移植性     | 高，不依赖宿主机路径             | 低，依赖宿主机特定路径           || 安全性       | 高，与宿主机文件系统隔离         | 较低，容器可修改宿主机文件       || 推荐使用场景 | 生产环境、数据库、应用数据持久化 | 开发环境、共享配置文件、代码同步 | 作为运维工程师，我的核心建议是：  **首选命名数据卷 (Named Volumes)**：为所有生产数据的持久化使用命名数据卷，因为它们清晰、易于管理且安全。 谨慎使用绑定挂载：仅在开发、调试或需要明确操作宿主机文件的受控场景下使用。在生产环境中要严格审查...</div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-network/" title="Docker Network"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Docker Network</div></div><div class="info-2"><div class="info-item-1">|————— | :——- | :——- | :——- | :——————————— || Bridge (自定义) | 高   | 好   | 低   | 绝大多数应用，特别是多容器应用 || Host            | 无       | 最佳 | 极低 | 追求极致性能，端口不冲突的场景     || Overlay         | 高       | 中等     | 中等     | 多主机&#x2F;Docker Swarm 集群通信   || Macvlan         | 高       | 好       | 中等     | 需要容器作为物理网络独立设备的场景 || None            | 完全 | N&#x2F;A      | 极低     | 无网络需求的任务                   | 作为运维工程师，我的首选建议是：为你的多容器应用创建一个自定义的 bridge 网络。这提供了最好的平衡点——良好的隔离性、服务发现能力、可接受的性能和简单的管理。仅在有特殊需求时，才考虑其他网络模式。 </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/TCP%20%E7%9A%84%20SACK/" title="TCP 的 SACK"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 的 SACK</div></div><div class="info-2"><div class="info-item-1">TCP 的 SACK（Selective Acknowledgement，选择性确认）机制是为了解决快速重传机制的一个不足之处，尤其是在出现多个数据包丢失的情况下，SACK 能显著提高 TCP 的效率和吞吐量。 快速重传的局限性回顾：我们知道，快速重传在单个或少量数据包丢失时非常有效。它通过检测到三个重复 ACK 来推断丢失的报文段并立即重传。 然而，它的局限性在于：  只能推断一个丢失的报文段： 当发送方收到三个重复 ACK 时，它只能知道确认号所指向的那个（通常是被期望接收的）报文段丢失了。 “笨拙”的重传序列： 如果多个不连续的报文段丢失，或者重传的报文段本身又丢失了，快速重传机制就显得力不从心。发送方只能一个接一个地重传，每重传一个丢失的包，都需要等待新的重复 ACK 来触发下一个重传，或者最终退化回超时重传。 例如：发送了 1, 2, 3, 4, 5, 6。 假设 2 和 4 都丢失了。 接收方收到 1，ACK for 2。 接收方收到 3，重复 ACK for 2。 接收方收到 5，重复 ACK for 2。 接收方收到 6，重复 ACK for 2。 发送方收到 3...</div></div></div></a><a class="pagination-related" href="/2025/09/11/shell-notify/" title="shell-notify"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">shell-notify</div></div><div class="info-2"><div class="info-item-1">文件监控在 Shell 中，实现文件监控主要有两种策略：  轮询检查（Polling）：定时检查文件的元数据（如修改时间、大小、校验和），适用于对实时性要求不高的场景。 事件驱动（Event-Driven）：利用系统工具（如 inotifywait）实时捕捉文件系统的事件，效率高，响应快，是生产环境中的首选方案。  下面我将分别介绍这两种方法，并重点推荐使用 inotifywait 的专业方案。  方法一：轮询检查（基于 stat 和 md5sum）这种方法简单直接，不依赖任何额外工具，但效率较低，且有延迟。 核心思路 在一个无限循环 while true; do ... done 中执行。 记录文件当前的 MD5 校验和或修改时间。 sleep 一段时间。 再次获取文件的校验和或修改时间，与之前记录的值进行比较。 如果发生变化，则执行相应操作（如发送警报、记录日志）。  示例脚本：监控 /etc/hosts 文件的内容变化1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin...</div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-volume/" title="docker-volume"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">docker-volume</div></div><div class="info-2"><div class="info-item-1">———— | :———————————– | :———————————– || 管理方       | Docker 引擎                          | 用户&#x2F;宿主机                          || 宿主机位置   | Docker 管理的特定目录                | 用户指定的任意路径                   || 可移植性     | 高，不依赖宿主机路径             | 低，依赖宿主机特定路径           || 安全性       | 高，与宿主机文件系统隔离         | 较低，容器可修改宿主机文件       || 推荐使用场景 | 生产环境、数据库、应用数据持久化 | 开发环境、共享配置文件、代码同步 | 作为运维工程师，我的核心建议是：  **首选命名数据卷 (Named Volumes)**：为所有生产数据的持久化使用命名数据卷，因为它们清晰、易于管理且安全。 谨慎使用绑定挂载：仅在开发、调试或需要明确操作宿主机文件的受控场景下使用。在生产环境中要严格审查...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Pod%20%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/" title="Pod 使用进阶"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Pod 使用进阶</div></div><div class="info-2"><div class="info-item-1">Pod 使用进阶-深入理解 Pod 对象Pod 资源配置实际上上面几个步骤就是影响一个 Pod 生命周期的大的部分，但是还有一些细节也会在 Pod 的启动过程进行设置，比如在容器启动之前还会为当前的容器设置分配的 CPU、内存等资源，我们知道我们可以通过 CGroup 来对容器的资源进行限制，同样的，在 Pod 中我们也可以直接配置某个容器的使用的 CPU 或者内存的上限。那么 Pod 是如何来使用和控制这些资源的分配的呢？ 首先对于 CPU，我们知道计算机里 CPU 的资源是按“时间片”的方式来进行分配的，系统里的每一个操作都需要 CPU 的处理，所以，哪个任务要是申请的 CPU 时间片越多，那么它得到的 CPU 资源就越多，这个很容器理解。 然后还需要了解下 CGroup 里面对于 CPU 资源的单位换算： 121 CPU =  1000 millicpu（1 Core = 1000m）0.5 CPU = 500 millicpu （0.5 Core = 500m）  这里的 m 就是毫、毫核的意思，Kubernetes 集群中的每一个节点可以通过操作系统的命令来确认本节点的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-swarm/" title="docker-swarm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">docker-swarm</div></div><div class="info-2"><div class="info-item-1">————– | :———————————————– || 集群管理       | 将多台机器整合成单一资源池，简化管理。           || 声明式服务     | 从命令式操作转变为期望状态管理，更可靠、自动化。 || 伸缩与负载均衡 | 轻松应对流量变化，实现服务高可用。               || 服务发现       | 解耦服务间的依赖，容器间通信无需硬编码 IP。      || 自我修复       | 自动处理节点或容器故障，提升系统韧性。           || 滚动更新       | 实现平滑、零停机的应用升级。                     | 总而言之，Docker Swarm 是一个轻量级但功能完备的容器编排器。对于中小型集群或希望快速上手容器编排的团队来说，它是一个非常优秀的选择，能够极大地提升部署效率和系统的可靠性。 </div></div></div></a><a class="pagination-related" href="/2025/09/11/Secret/" title="Secret"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Secret</div></div><div class="info-2"><div class="info-item-1">Secret前文我们学习 ConfigMap 的时候，我们说 ConfigMap 这个资源对象是 Kubernetes 当中非常重要的一个资源对象，一般情况下 ConfigMap 是用来存储一些非安全的配置信息，如果涉及到一些安全相关的数据的话用 ConfigMap 就非常不妥了，因为 ConfigMap 是明文存储的，这个时候我们就需要用到另外一个资源对象了：Secret，Secret用来保存敏感信息，例如密码、OAuth 令牌和 ssh key 等等，将这些信息放在 Secret 中比放在 Pod 的定义中或者 Docker 镜像中要更加安全和灵活。 Secret 主要使用的有以下三种类型：  Opaque：base64 编码格式的 Secret，用来存储密码、密钥等；但数据也可以通过 base64 –decode 解码得到原始数据，所有加密性很弱。 kubernetes.io/dockercfg: ~/.dockercfg 文件的序列化形式 kubernetes.io/dockerconfigjson：用来存储私有docker registry的认证信息，~/.docker...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-Overlay-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.</span> <span class="toc-text">配置 Overlay 网络模式的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">前提条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96-Docker-Swarm-%E6%88%96%E5%8A%A0%E5%85%A5%E7%8E%B0%E6%9C%89-Swarm"><span class="toc-number">1.2.</span> <span class="toc-text">步骤 1：初始化 Docker Swarm 或加入现有 Swarm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E5%88%9B%E5%BB%BA-Overlay-%E7%BD%91%E7%BB%9C"><span class="toc-number">1.3.</span> <span class="toc-text">步骤 2：创建 Overlay 网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-Overlay-%E7%BD%91%E7%BB%9C"><span class="toc-number">1.4.</span> <span class="toc-text">步骤 3：在容器中使用 Overlay 网络</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Overlay-%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">Overlay 网络的工作原理简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.</span> <span class="toc-text">注意事项</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>