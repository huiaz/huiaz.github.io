<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>docker 安全 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="好的，这是一个非常核心且关键的问题。保证在 Docker 沙箱中执行程序的安全性，绝不是一个“开箱即用”的功能，而是一个需要我们运维工程师进行多层防御、纵深加固的系统工程。 简单地说，Docker 自身提供了基础的隔离机制，但默认配置是为了“易用性”而非“最高安全性”。我们的工作就是层层加固这个沙箱，堵住所有可能的安全漏洞。 以下是我在项目中确保 Docker 沙箱安全性的完整策略，从内到外分为四">
<meta property="og:type" content="article">
<meta property="og:title" content="docker 安全">
<meta property="og:url" content="http://example.com/2025/09/11/docker%20%E5%AE%89%E5%85%A8/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="好的，这是一个非常核心且关键的问题。保证在 Docker 沙箱中执行程序的安全性，绝不是一个“开箱即用”的功能，而是一个需要我们运维工程师进行多层防御、纵深加固的系统工程。 简单地说，Docker 自身提供了基础的隔离机制，但默认配置是为了“易用性”而非“最高安全性”。我们的工作就是层层加固这个沙箱，堵住所有可能的安全漏洞。 以下是我在项目中确保 Docker 沙箱安全性的完整策略，从内到外分为四">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:28:44.789Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "docker 安全",
  "url": "http://example.com/2025/09/11/docker%20%E5%AE%89%E5%85%A8/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:28:44.789Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/11/docker%20%E5%AE%89%E5%85%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'docker 安全',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">docker 安全</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">docker 安全</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:28:44.789Z" title="更新于 2025-09-11 22:28:44">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/docker/">docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>好的，这是一个非常核心且关键的问题。保证在 Docker 沙箱中执行程序的安全性，绝不是一个“开箱即用”的功能，而是一个需要我们运维工程师进行<strong>多层防御、纵深加固</strong>的系统工程。</p>
<p>简单地说，Docker 自身提供了基础的隔离机制，但默认配置是为了“易用性”而非“最高安全性”。我们的工作就是层层加固这个沙箱，堵住所有可能的安全漏洞。</p>
<p>以下是我在项目中确保 Docker 沙箱安全性的完整策略，从内到外分为四个层面：</p>
<h3 id="层面一：强化容器自身的隔离性（加固沙箱的墙壁）"><a href="#层面一：强化容器自身的隔离性（加固沙箱的墙壁）" class="headerlink" title="层面一：强化容器自身的隔离性（加固沙箱的墙壁）"></a>层面一：强化容器自身的隔离性（加固沙箱的墙壁）</h3><p>这是最基础也是最核心的一步，目标是让容器内的进程即使被攻破，也无法对宿主机或其他容器造成影响。</p>
<ol>
<li><p><strong>坚持最小权限原则：绝不使用 root 用户运行应用</strong></p>
<ul>
<li><strong>做什么</strong>：在 <code>Dockerfile</code> 中，创建专用的低权限用户和用户组，并使用 <code>USER</code> 指令切换过去。</li>
<li><strong>为什么</strong>：如果容器内的应用以 <code>root</code> 用户运行，一旦应用被攻破，攻击者就立即获得了容器内的最高权限。如果此时再发生容器逃逸，其破坏力将是毁灭性的。以非 <code>root</code> 用户运行，攻击者即使得手，也只是一个受限的普通用户。</li>
<li><strong>示例 <code>Dockerfile</code></strong>:<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建一个非 root 用户 &#x27;appuser&#x27;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r appuser &amp;&amp; useradd -r -g appuser appuser</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=appuser:appuser . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 切换到这个非 root 用户</span></span><br><span class="line"><span class="keyword">USER</span> appuser</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>移除不必要的能力（Capabilities）</strong></p>
<ul>
<li><strong>做什么</strong>：Docker 默认会给容器分配一些 Linux Capabilities（内核权限的子集）。我们应该遵循“默认禁止，按需授权”的原则，丢弃所有不必要的能力。</li>
<li><strong>为什么</strong>：例如，<code>NET_RAW</code> 能力允许创建原始套接字（可用于网络嗅探和欺骗）。如果你的应用只是一个 Web 服务，它根本不需要这个权限。</li>
<li><strong>示例 <code>docker run</code></strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 丢弃所有能力，然后只添加应用必需的能力 (例如绑定低位端口)</span></span><br><span class="line">docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE ... my-app</span><br></pre></td></tr></table></figure>
在 Kubernetes 中，这通过 <code>securityContext</code> 的 <code>capabilities</code> 字段来配置。</li>
</ul>
</li>
<li><p><strong>启用 Seccomp、AppArmor 或 SELinux</strong></p>
<ul>
<li><strong>做什么</strong>：应用更强的强制访问控制策略。</li>
<li>**Seccomp (Secure Computing Mode)**：限制容器能向内核发起的系统调用（syscall）。Docker 默认有一个白名单，但我们可以自定义一个更严格的配置文件，只允许应用绝对必需的几十个系统调用。</li>
<li><strong>AppArmor &#x2F; SELinux</strong>：更细粒度的安全模块，可以限制进程对文件、网络端口、以及其他内核资源的访问。</li>
<li><strong>为什么</strong>：这是在内核层面设置的最后一道防线。即使攻击者在容器内找到了一个可利用的漏洞，Seccomp 或 AppArmor 也可能直接阻止其恶意行为所需的系统调用，使其攻击失效。</li>
</ul>
</li>
<li><p><strong>设置只读文件系统</strong></p>
<ul>
<li><strong>做什么</strong>：以只读模式运行容器的文件系统，只将需要写入的目录挂载为 <code>tmpfs</code> 或数据卷。</li>
<li><strong>为什么</strong>：这能有效防止攻击者在攻入容器后修改应用文件、植入后门或写入恶意脚本。</li>
<li><strong>示例 <code>docker run</code></strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --read-only --tmpfs /run --tmpfs /tmp -v my-data:/app/data ... my-app</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="层面二：最小化镜像的攻击面（减少沙箱内的武器）"><a href="#层面二：最小化镜像的攻击面（减少沙箱内的武器）" class="headerlink" title="层面二：最小化镜像的攻击面（减少沙箱内的武器）"></a>层面二：最小化镜像的攻击面（减少沙箱内的武器）</h3><p>一个“干净”的容器本身就不容易被利用。</p>
<ol>
<li><p><strong>使用最小化的基础镜像</strong></p>
<ul>
<li><strong>做什么</strong>：不使用 <code>ubuntu</code>、<code>centos</code> 等庞大的通用镜像，而是选择 <code>alpine</code>、<code>scratch</code> 或 Google 的 <code>distroless</code> 镜像。</li>
<li><strong>为什么</strong>：镜像中包含的软件包和库越少，潜在的、可被利用的 CVE 漏洞就越少。<code>distroless</code> 镜像甚至不包含 shell 和包管理器，攻击者即使进入容器也几乎“寸步难行”。</li>
</ul>
</li>
<li><p><strong>采用多阶段构建（Multi-stage Builds）</strong></p>
<ul>
<li><strong>做什么</strong>：在 <code>Dockerfile</code> 中，使用一个阶段（如 <code>maven</code> 或 <code>golang</code>）来编译代码和构建依赖，然后在下一个阶段，将编译好的产物（如 <code>*.jar</code> 或二进制文件）复制到一个干净的、不含任何构建工具的基础镜像中。</li>
<li><strong>为什么</strong>：这确保了最终的生产镜像中只包含运行应用所必需的文件，不包含任何编译器、构建工具、源代码等敏感信息和潜在攻击点。</li>
</ul>
</li>
<li><p><strong>定期进行镜像漏洞扫描</strong></p>
<ul>
<li><strong>做什么</strong>：在 CI&#x2F;CD 流水线中集成 Clair, Trivy, Snyk 等开源扫描工具。在镜像构建完成后、推送到仓库前，自动对其进行安全扫描。</li>
<li><strong>为什么</strong>：主动发现并修复已知漏洞，而不是等被攻击后才亡羊补牢。对于扫描出的高危漏洞，应阻止镜像的部署。</li>
</ul>
</li>
</ol>
<h3 id="层面三：加固宿主机和-Docker-Daemon（保护沙箱外的世界）"><a href="#层面三：加固宿主机和-Docker-Daemon（保护沙箱外的世界）" class="headerlink" title="层面三：加固宿主机和 Docker Daemon（保护沙箱外的世界）"></a>层面三：加固宿主机和 Docker Daemon（保护沙箱外的世界）</h3><p>容器的安全依赖于宿主机的安全。</p>
<ol>
<li><p><strong>保护 Docker Socket</strong></p>
<ul>
<li><strong>做什么</strong>：永远不要将宿主机的 Docker Socket (<code>/var/run/docker.sock</code>) 直接挂载到容器内部，除非你完全信任该容器。</li>
<li><strong>为什么</strong>：获得了 Docker Socket 的访问权限，就等同于获得了宿主机的 <code>root</code> 权限。容器内的进程可以通过它来控制宿主机上的所有容器，甚至创建新的特权容器来逃逸。</li>
</ul>
</li>
<li><p><strong>保持宿主机内核和 Docker 引擎为最新版本</strong></p>
<ul>
<li><strong>做什么</strong>：定期更新宿主机的内核和 Docker 引擎。</li>
<li><strong>为什么</strong>：容器逃逸的漏洞大多发生在内核层面。及时打补丁是防御此类“核弹级”漏洞的最有效手段。</li>
</ul>
</li>
<li><p><strong>启用用户命名空间（User Namespaces）</strong></p>
<ul>
<li><strong>做什么</strong>：配置 Docker Daemon 启用 <code>userns-remap</code>。</li>
<li><strong>为什么</strong>：这会将容器内的 <code>root</code> 用户映射到宿主机上的一个非 <code>root</code> 高位 UID。这样一来，即使容器内的进程以 <code>root</code> 身份逃逸出来，它在宿主机上也只是一个没有特权的普通用户，极大地降低了威胁。</li>
</ul>
</li>
</ol>
<h3 id="层面四：实施运行时安全监控（安装监控摄像头）"><a href="#层面四：实施运行时安全监控（安装监控摄像头）" class="headerlink" title="层面四：实施运行时安全监控（安装监控摄像头）"></a>层面四：实施运行时安全监控（安装监控摄像头）</h3><p>假设防御可能被绕过，我们需要有能力检测和响应正在发生的攻击。</p>
<ol>
<li><strong>使用容器运行时安全工具</strong><ul>
<li><strong>做什么</strong>：部署 Falco、Sysdig Secure、Aqua Security 等运行时安全工具。</li>
<li><strong>为什么</strong>：这些工具通过监控内核系统调用和容器活动，能够基于规则集实时检测异常行为，例如：<ul>
<li>容器内启动了一个 shell (<code>bash</code>, <code>sh</code>)。</li>
<li>修改了 <code>/etc</code> 或 <code>/bin</code> 目录下的文件。</li>
<li>建立了非预期的出站网络连接。</li>
<li>读取了敏感文件（如 <code>/etc/shadow</code>）。<br>一旦检测到这些行为，系统会立即发出告警，为我们应急响应争取宝贵的时间。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结来说，保障 Docker 沙箱安全是一个纵深防御体系：</strong></p>
<ul>
<li><strong>首先，让沙箱本身足够坚固</strong>（非 root、去能力、只读文件系统）。</li>
<li><strong>其次，减少沙箱内的攻击目标</strong>（最小镜像、多阶段构建、漏洞扫描）。</li>
<li><strong>然后，保护好沙箱外部的环境</strong>（宿主机、Docker Daemon）。</li>
<li><strong>最后，对沙箱进行实时监控，及时发现异常</strong>（运行时安全）。</li>
</ul>
<p>通过综合运用这些策略，我们可以将 Docker 容器的安全级别提升到足以在生产环境中自信地运行不受信任代码的程度。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/docker%20%E5%AE%89%E5%85%A8/">http://example.com/2025/09/11/docker%20%E5%AE%89%E5%85%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/docker-dockerfile/" title="Dockerfile"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Dockerfile</div></div><div class="info-2"><div class="info-item-1">一、Dockerfile 的作用Dockerfile 是一个文本文件，其核心作用是定义了构建一个 Docker 镜像所需的所有步骤和指令。它就像一份自动化的“安装说明书”或“烹饪菜谱”，Docker 根据这份说明书，就能一步不差地构建出一个标准、一致的镜像。 它的主要作用体现在：  **自动化构建 (Automation)**：将手动配置环境的繁琐步骤（安装依赖、复制文件、设置环境变量等）代码化，实现了构建过程的全自动。 **可重复性 (Reproducibility)**：只要 Dockerfile 不变，无论在谁的机器上、在什么时间执行构建，最终得到的镜像内容都是完全一致的，这从根本上保证了环境的一致性。 **版本控制 (Versioning)**：Dockerfile 可以像代码一样存放在 Git 等版本控制系统中进行管理。每一次对环境的变更，都可以通过修改 Dockerfile 并提交记录来追溯，使得环境演进有迹可循。 **透明性与审查 (Transparency &amp; Auditing)**：任何团队成员都可以通过阅读 Dockerfile，清晰地了解到一个镜像是...</div></div></div></a><a class="pagination-related" href="/2025/09/11/categraf/" title="categraf"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">categraf</div></div><div class="info-2"><div class="info-item-1">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115[global]# whether print configsprint_configs = false# add label(agent_hostname) to series# &quot;&quot; -&gt; auto detect hostname# &quot;xx&quot; -&gt; use specified string xx# &quot;$hostname&quot; -&gt; auto detect hostname# &quot;$ip&quot; -&gt; auto detec...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86/" title="Linux 系统中的内核模块管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 系统中的内核模块管理</div></div><div class="info-2"><div class="info-item-1">Linux 内核模块的管理 一、Linux 内核模块的工作原理Linux 内核采用模块化的设计思想，其核心功能是模块化实现的。  模块化设计： 内核自身只包含最核心的功能，而将许多非核心但必要的功能（如：网卡驱动、显卡驱动、文件系统驱动、USB 支持、加密算法等）设计成可以随时加载和卸载的模块。 动态加载&#x2F;卸载： 当系统需要某个功能时（例如，插入了一个USB设备，或是需要访问某种特定的文件系统），对应的内核模块会被动态加载到内核空间中运行；当该功能不再需要时，模块可以被卸载，从而释放内存资源。 优点： 减小内核镜像大小： 核心内核保持精简，只需要加载必需的模块。 提高灵活性： 无需重新编译整个内核就能添加或更新驱动、文件系统等功能。 节省内存： 不使用的模块可以卸载，释放内存。 方便调试： 可以在运行时加载新的或修改过的模块进行测试。   模块文件： 内核模块通常以 .ko（kernel object）为扩展名，存储在 /lib/modules/&lt;kernel-version&gt;/ 目录下，按照类别（如 kernel/drivers、kernel/fs、ker...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E9%94%99%E8%AF%AF%E4%BF%AE%E6%8A%A4/" title="Linux 系统文件错误修护"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 系统文件错误修护</div></div><div class="info-2"><div class="info-item-1">修复 Linux 文件系统错误 一、文件系统错误的危害文件系统错误可能导致以下问题：  数据丢失或损坏： 文件内容错乱，甚至文件消失。 系统无法启动： 根文件系统损坏可能导致系统无法挂载核心目录。 应用程序崩溃： 读取到损坏文件或元数据引发应用程序错误。 性能下降： 文件系统需要花费额外时间处理错误，导致读写变慢。 挂载失败： 损坏的文件系统可能无法被正确挂载。   二、检查文件系统错误的工具：fsckLinux 中用于检查和修复文件系统错误的主要工具是 fsck （file system check）。它实际上是一个前端程序，会根据文件系统的类型（如 ext4, xfs, fat32 等）自动调用相应的特定工具，例如 fsck.ext4, fsck.xfs 等。 重要原则：绝对不要在已挂载（mounted）的文件系统上运行 fsck，特别是读写状态下挂载的文件系统。 这可能导致数据进一步损坏或丢失。唯一的例外是根文件系统 /，在某些情况下需要在运行时以只读方式进行检查，但通常更推荐在系统启动时或进入恢复模式进行检查。 1. 检查和修复未被挂载的文件系统这是最安全和推荐的方式。 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-network/" title="Docker Network"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Docker Network</div></div><div class="info-2"><div class="info-item-1">|————— | :——- | :——- | :——- | :——————————— || Bridge (自定义) | 高   | 好   | 低   | 绝大多数应用，特别是多容器应用 || Host            | 无       | 最佳 | 极低 | 追求极致性能，端口不冲突的场景     || Overlay         | 高       | 中等     | 中等     | 多主机&#x2F;Docker Swarm 集群通信   || Macvlan         | 高       | 好       | 中等     | 需要容器作为物理网络独立设备的场景 || None            | 完全 | N&#x2F;A      | 极低     | 无网络需求的任务                   | 作为运维工程师，我的首选建议是：为你的多容器应用创建一个自定义的 bridge 网络。这提供了最好的平衡点——良好的隔离性、服务发现能力、可接受的性能和简单的管理。仅在有特殊需求时，才考虑其他网络模式。 </div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%B1%82%E6%AC%A1/" title="Linux的文件系统目录层次"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux的文件系统目录层次</div></div><div class="info-2"><div class="info-item-1">Linux 文件系统层次结构 一、Linux 文件系统层次结构 (FHS) 概述Linux 的文件系统是一个单一的、统一的目录树，所有文件和目录都从根目录 / 开始。这与 Windows 系统中每个分区（如 C:, D:）都有自己的目录树不同。即使系统有多个硬盘或分区，它们也会被“挂载”到这个统一的目录树的某个点上，成为其中的一部分。 FHS 的主要目标是：  标准化： 确保不同 Linux 发行版的文件和目录位置保持一致，方便用户和开发人员。 可移植性： 简化软件在不同 Linux 系统间的移植。 层次性： 清晰地划分系统文件、程序、用户数据、可变数据等，方便管理和备份。 清晰性： 目录名称大多具有描述性，使其用途一目了然。  二、重要目录及其用途示例下面我们将详细介绍 Linux 系统中一些重要的目录及其常见用途。 1. / (根目录) 用途： 整个文件系统的最顶层，所有其他目录和文件都位于其下。系统启动所需的核心文件位于此目录，或者通过其下的子目录链接。 示例内容： 常见子目录如 /bin, /etc, /home, /usr, /var 等。  2. /bin (二进制可...</div></div></div></a><a class="pagination-related" href="/2025/09/11/CGroups%20%E4%B8%8E%20Namespaces/" title="CGroups 与 Namespaces"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">CGroups 与 Namespaces</div></div><div class="info-2"><div class="info-item-1">CGroups 与 Namespaces本节我们来一起了解下容器背后的两个核心技术：CGroups 和 Namespace。 CGroups 概述CGroups 全称为 Linux Control Group，其作用是限制一组进程使用的资源（CPU、内存等）上限，CGroups 也是 Containerd 容器技术的核心实现原理之一，首先我们需要先了解几个 CGroups 的基本概念：  Task: 在 cgroup 中，task 可以理解为一个进程，但这里的进程和一般意义上的操作系统进程不太一样，实际上是进程 ID 和线程 ID 列表。 CGroup: 即控制组，一个控制组就是一组按照某种标准划分的 Tasks，可以理解为资源限制是以进程组为单位实现的，一个进程加入到某个控制组后，就会受到相应配置的资源限制。 Hierarchy: cgroup 的层级组织关系，cgroup 以树形层级组织，每个 cgroup 子节点默认继承其父 cgroup 节点的配置属性，这样每个 Hierarchy 在初始化会有 root cgroup。 Subsystem: 即子系统，子系统表示具体的资...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4/" title="Linux 排查命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 排查命令</div></div><div class="info-2"><div class="info-item-1">(1) 如何在 Linux 中查看系统资源使用情况？比如内存、CPU、网络端口。  一、 CPU 使用情况1. top 命令 (实时交互式)top 命令是最常用的 CPU 监控工具，它提供了一个实时更新的进程列表，并显示 CPU 使用率、内存使用率、进程 ID (PID)、用户、运行时间等信息。 1top  关键信息解读：  第一行（top line）： load average 显示了过去 1、5、15 分钟的系统平均负载。这是衡量系统忙碌程度的重要指标，数值大于 CPU 核心数时通常表示系统存在瓶颈。 第二行（Tasks）： 显示进程总数，以及运行、睡眠、停止和僵尸进程的数量。 第三行（Cpu(s)）： 显示 CPU 的使用率，各项指标含义如下： us (user): 用户空间程序的 CPU 使用率。 sy (system): 内核空间程序的 CPU 使用率。 ni (nice): 改变过优先级的用户进程的 CPU 使用率。 id (idle): 空闲 CPU 百分比。 wa (iowait): CPU 等待 I&#x2F;O 操作完成的百分比。 hi (hardware i...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E9%9D%A2%E4%B8%80%EF%BC%9A%E5%BC%BA%E5%8C%96%E5%AE%B9%E5%99%A8%E8%87%AA%E8%BA%AB%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88%E5%8A%A0%E5%9B%BA%E6%B2%99%E7%AE%B1%E7%9A%84%E5%A2%99%E5%A3%81%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">层面一：强化容器自身的隔离性（加固沙箱的墙壁）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E9%9D%A2%E4%BA%8C%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%96%E9%95%9C%E5%83%8F%E7%9A%84%E6%94%BB%E5%87%BB%E9%9D%A2%EF%BC%88%E5%87%8F%E5%B0%91%E6%B2%99%E7%AE%B1%E5%86%85%E7%9A%84%E6%AD%A6%E5%99%A8%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">层面二：最小化镜像的攻击面（减少沙箱内的武器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E9%9D%A2%E4%B8%89%EF%BC%9A%E5%8A%A0%E5%9B%BA%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%92%8C-Docker-Daemon%EF%BC%88%E4%BF%9D%E6%8A%A4%E6%B2%99%E7%AE%B1%E5%A4%96%E7%9A%84%E4%B8%96%E7%95%8C%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">层面三：加固宿主机和 Docker Daemon（保护沙箱外的世界）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E9%9D%A2%E5%9B%9B%EF%BC%9A%E5%AE%9E%E6%96%BD%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%89%E5%85%A8%E7%9B%91%E6%8E%A7%EF%BC%88%E5%AE%89%E8%A3%85%E7%9B%91%E6%8E%A7%E6%91%84%E5%83%8F%E5%A4%B4%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">层面四：实施运行时安全监控（安装监控摄像头）</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>