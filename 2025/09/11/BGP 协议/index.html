<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BGP 协议 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是 BGP (Border Gateway Protocol)？BGP (Border Gateway Protocol)，即边界网关协议，是互联网上路由选择的核心协议，也被称为“互联网的胶水”或“互联网的骨干”。它是一种外部网关协议 (EGP)，用于在自治系统 (Autonomous System, AS) 之间交换路由信息，从而实现全球互联网的互联互通。 核心概念：  自治系统 (AS)：">
<meta property="og:type" content="article">
<meta property="og:title" content="BGP 协议">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/BGP%20%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="什么是 BGP (Border Gateway Protocol)？BGP (Border Gateway Protocol)，即边界网关协议，是互联网上路由选择的核心协议，也被称为“互联网的胶水”或“互联网的骨干”。它是一种外部网关协议 (EGP)，用于在自治系统 (Autonomous System, AS) 之间交换路由信息，从而实现全球互联网的互联互通。 核心概念：  自治系统 (AS)：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:24:40.040Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="BGP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "BGP 协议",
  "url": "https://huiaz.github.io/2025/09/11/BGP%20%E5%8D%8F%E8%AE%AE/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:24:40.040Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/BGP%20%E5%8D%8F%E8%AE%AE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BGP 协议',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">BGP 协议</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">BGP 协议</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:24:40.040Z" title="更新于 2025-09-11 22:24:40">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="什么是-BGP-Border-Gateway-Protocol-？"><a href="#什么是-BGP-Border-Gateway-Protocol-？" class="headerlink" title="什么是 BGP (Border Gateway Protocol)？"></a>什么是 BGP (Border Gateway Protocol)？</h3><p>BGP (Border Gateway Protocol)，即<strong>边界网关协议</strong>，是互联网上<strong>路由选择的核心协议</strong>，也被称为“互联网的胶水”或“互联网的骨干”。它是一种<strong>外部网关协议 (EGP)<strong>，用于在</strong>自治系统 (Autonomous System, AS)</strong> 之间交换路由信息，从而实现全球互联网的互联互通。</p>
<p><strong>核心概念：</strong></p>
<ul>
<li><strong>自治系统 (AS)：</strong> 互联网上一个由单一行政实体或组织控制的、拥有统一路由策略的 IP 网络集合。每个 AS 都被分配一个唯一的 16 位或 32 位的数字，称为 **AS 号 (ASN)**。例如，大型的互联网服务提供商 (ISP)、大学网络、大型企业网络等都可能是一个 AS。</li>
<li><strong>路由：</strong> 数据包从源头到达目的地的路径选择过程。</li>
<li><strong>外部网关协议 (EGP)：</strong> 指在不同自治系统之间交换路由信息的协议。</li>
<li><strong>内部网关协议 (IGP)：</strong> 指在同一个自治系统内部交换路由信息的协议，例如 OSPF、EIGRP、RIP 等。</li>
</ul>
<p>BGP 的主要目标是确保数据包能够从全球任何一个 AS 发送到另一个 AS，并找到最佳的（或符合策略的）路径。</p>
<h3 id="BGP-的工作原理概述："><a href="#BGP-的工作原理概述：" class="headerlink" title="BGP 的工作原理概述："></a>BGP 的工作原理概述：</h3><p>BGP 是一种<strong>路径矢量路由协议 (Path-Vector Routing Protocol)<strong>。与距离矢量协议（如 RIP）或链路状态协议（如 OSPF）不同，BGP 在路由更新中不仅包含到达目的地的距离信息，还包含了</strong>到达目的地的完整 AS 路径信息</strong>。</p>
<ol>
<li><p><strong>BGP Peerings (对等体关系)：</strong> BGP 路由器之间需要建立 TCP 连接（端口 179）来交换路由信息。这些相互连接的 BGP 路由器被称为 BGP 对等体 (peers) 或 BGP 发言人 (speakers)。</p>
<ul>
<li><strong>eBGP (external BGP)：</strong> 不同 AS 之间的 BGP 对等体关系。这是 BGP 的主要应用场景，用于在互联网服务提供商之间和客户网络之间交换路由信息。</li>
<li><strong>iBGP (internal BGP)：</strong> 同一 AS 内部的 BGP 对等体关系。用于在 AS 内部的所有路由器之间同步从外部学到的路由信息，确保 AS 内部对外部路由的一致视图。</li>
</ul>
</li>
<li><p><strong>路由信息交换：</strong></p>
<ul>
<li>BGP 路由器会周期性地交换完整的路由表（或在路由发生变化时发送增量更新）。</li>
<li>每个 BGP 更新消息都包含：<ul>
<li><strong>网络前缀：</strong> 目的地网络的 IP 地址范围。</li>
<li><strong>Next-Hop：</strong> 到达该网络前缀的下一跳 IP 地址。</li>
<li><strong>AS Path (AS 路径)：</strong> 这是一个有序的 AS 号列表，表示数据包将经过哪些 AS 才能到达目的地。例如，<code>AS65000 AS64512 AS100</code> 表示数据包将从 AS65000 经过 AS64512 再到达 AS100。</li>
<li><strong>BGP Attributes (BGP 属性)：</strong> 一系列额外的属性，用于影响路由选择过程和策略。例如：<ul>
<li><code>Local Preference</code> (本地优先级)：在 AS 内部选择离开本 AS 的最佳路径。</li>
<li><code>MED (Multi-Exit Discriminator)</code>：向邻居 AS 建议选择进入本 AS 的最佳入口点。</li>
<li><code>Origin</code> (起源)：说明路由信息是如何起源的（IGP、EGP 或不确定）。</li>
<li><code>Community</code> (共同体)：自定义标签，用于共享和应用策略。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>路由选择：</strong> 当 BGP 路由器有多个到达同一个目的地的路径时，它会根据一套复杂的<strong>路由选择算法</strong>（也称为 BGP 决策过程）来选择最佳路径。这个算法考虑了大量的 BGP 属性，包括：</p>
<ul>
<li><code>Next-Hop</code> 可达性（必须可达）</li>
<li><code>Local Preference</code> (越高越好)</li>
<li><code>AS Path</code> 长度（越短越好，经过的 AS 越少）</li>
<li><code>Origin</code> 类型</li>
<li><code>MED</code> (越低越好)</li>
<li>BGP Peerings 类型 (iBGP vs eBGP)</li>
<li>其他更细致的属性和规则。</li>
<li><strong>策略路由：</strong> BGP 的独特之处在于它高度依赖并支持<strong>策略路由</strong>。AS 可以根据自身的商业协议、成本、带宽等因素，而非仅仅基于最短路径，来控制流量的进出。例如，ISP 可能更倾向于将流量发送给其付费客户，而不是免费对等方。</li>
</ul>
</li>
</ol>
<h3 id="BGP-在互联网中的作用："><a href="#BGP-在互联网中的作用：" class="headerlink" title="BGP 在互联网中的作用："></a>BGP 在互联网中的作用：</h3><p>BGP 在互联网中扮演着不可或缺的角色，其作用主要体现在以下几个方面：</p>
<ol>
<li><p><strong>互联网的全球互联互通：</strong> BGP 是互联网得以成为“网络之网络”的基础。它允许全球数万个独立的自治系统相互交换路由信息，确保数据包能够跨越不同的网络边界，从地球的一端到达另一端。没有 BGP，互联网将只是一堆孤立的网络。</p>
</li>
<li><p><strong>实现路由的可靠性和冗余：</strong></p>
<ul>
<li>BGP 允许 AS 拥有多个连接到其他 AS 的路径。当一条路径失效时，BGP 能够快速学习到新的可用路径，从而实现路由的<strong>冗余和故障转移</strong>。</li>
<li>通过 BGP，不同的 ISP 可以互联，即使某个 ISP 的骨干网络出现故障，流量也可以通过其他 ISP 的路径继续传输到目的地。</li>
</ul>
</li>
<li><p><strong>支持大规模路由表：</strong> 互联网的路由表非常庞大（目前包含数十万条路由前缀）。BGP 经过优化，能够高效地处理和维护这种规模的路由信息，避免路由黑洞或环路。</p>
</li>
<li><p><strong>实现路由策略和商业需求：</strong></p>
<ul>
<li>这是 BGP 最核心也是最复杂的功能。BGP 允许 AS 根据其**商业关系 (客户、提供商、对等方)**、成本、带宽、地理位置等因素，对流量的进出进行细粒度的控制。</li>
<li><strong>流量工程：</strong> AS 可以通过操纵 BGP 属性（如 AS Path Prepending, Local Preference, MED），引导流量按照期望的路径通过或离开其网络。例如，一个 ISP 可以选择优先从其“提供商”那里接收免费流量，而不是从“对等方”那里接收同样的数据。</li>
<li><strong>多宿主 (Multihoming)：</strong> 企业或组织可以通过连接到多个 ISP，使用 BGP 实现多宿主。这不仅提供了互联网连接的冗余，还可以根据 BGP 策略选择更优的出口&#x2F;入口（例如，选择延迟更低的 ISP，或根据负载均衡）。</li>
</ul>
</li>
<li><p><strong>防止路由环路：</strong> AS Path 属性是 BGP 防止环路的关键机制。当一个 BGP 路由器收到一个路由更新时，如果 AS Path 中包含了自己的 AS 号，它就会丢弃这条路由，从而有效避免数据包在 AS 之间无限循环。</p>
</li>
</ol>
<p><strong>简而言之，BGP 不仅仅是指导数据包如何从 A 到 B，更是互联网世界中各个“国家”（自治系统）之间进行“外交”和“交通”的桥梁和规则集。它以一种高度可配置和策略驱动的方式，确保了互联网的全球连通性、弹性和商业运作。</strong></p>
<h3 id="BGP-的挑战："><a href="#BGP-的挑战：" class="headerlink" title="BGP 的挑战："></a>BGP 的挑战：</h3><p>尽管 BGP 至关重要，但它也面临一些挑战：</p>
<ul>
<li><strong>配置复杂性：</strong> BGP 的配置非常复杂，需要专业的网络工程师进行管理，错误的配置可能导致严重的网络中断。</li>
<li><strong>路由劫持 (Route Hijacking)：</strong> 错误的或恶意的 BGP 路由通告可能导致特定 IP 地址段的流量被重定向到错误的网络，造成服务中断或数据窃取。这是互联网安全领域的一个重要威胁。</li>
<li><strong>路由膨胀：</strong> 全球路由表持续增长，对路由器内存和处理能力构成挑战。</li>
<li><strong>收敛时间：</strong> 在大规模网络事件发生时，BGP 收敛（即所有路由器都更新到最新的路由信息）可能需要一定时间，期间可能导致流量中断。</li>
</ul>
<p>为了应对这些挑战，社区一直在努力开发和部署 BGP 安全扩展 (如 BGPsec、ROA 等)，以增强 BGP 的信任和安全。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/BGP%20%E5%8D%8F%E8%AE%AE/">https://huiaz.github.io/2025/09/11/BGP%20%E5%8D%8F%E8%AE%AE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/BGP/">BGP</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/CGroups%20%E4%B8%8E%20Namespaces/" title="CGroups 与 Namespaces"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CGroups 与 Namespaces</div></div><div class="info-2"><div class="info-item-1">CGroups 与 Namespaces本节我们来一起了解下容器背后的两个核心技术：CGroups 和 Namespace。 CGroups 概述CGroups 全称为 Linux Control Group，其作用是限制一组进程使用的资源（CPU、内存等）上限，CGroups 也是 Containerd 容器技术的核心实现原理之一，首先我们需要先了解几个 CGroups 的基本概念：  Task: 在 cgroup 中，task 可以理解为一个进程，但这里的进程和一般意义上的操作系统进程不太一样，实际上是进程 ID 和线程 ID 列表。 CGroup: 即控制组，一个控制组就是一组按照某种标准划分的 Tasks，可以理解为资源限制是以进程组为单位实现的，一个进程加入到某个控制组后，就会受到相应配置的资源限制。 Hierarchy: cgroup 的层级组织关系，cgroup 以树形层级组织，每个 cgroup 子节点默认继承其父 cgroup 节点的配置属性，这样每个 Hierarchy 在初始化会有 root cgroup。 Subsystem: 即子系统，子系统表示具体的资...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Admission%20webhooks/" title="Admission webhooks"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Admission webhooks</div></div><div class="info-2"><div class="info-item-1">准入控制器Kubernetes 提供了需要扩展其内置功能的方法，最常用的可能是自定义资源类型和自定义控制器了，除此之外，Kubernetes 还有一些其他非常有趣的功能，比如 admission webhooks 就可以用于扩展 API，用于修改某些 Kubernetes 资源的基本行为。 准入控制器是在对象持久化之前用于对 Kubernetes API Server 的请求进行拦截的代码段，在请求经过身份验证和授权之后放行通过。准入控制器可能正在 validating、mutating 或者都在执行，Mutating 控制器可以修改他们处理的资源对象，Validating 控制器不会，如果任何一个阶段中的任何控制器拒绝了请求，则会立即拒绝整个请求，并将错误返回给最终的用户。 这意味着有一些特殊的控制器可以拦截 Kubernetes API 请求，并根据自定义的逻辑修改或者拒绝它们。Kubernetes 有自己实现的一个控制器列表：https://kubernetes.io/docs/reference/access-authn-authz/admission-controlle...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%20dmesg%20%E5%91%BD%E4%BB%A4/" title="Linux 系统 dmesg 命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 系统 dmesg 命令</div></div><div class="info-2"><div class="info-item-1">dmesg 是在 Linux 系统中排查各种底层问题（尤其是与硬件、驱动、系统启动、内存、I&#x2F;O 错误等相关的）时常用的诊断工具。它允许查看内核环形缓冲区（kernel ring buffer）中的消息，这些消息是内核在运行过程中记录的重要事件和错误信息，对于理解系统内部工作状态和定位故障至关重要。  一、dmesg 简介 全称： diagnostic message 功能： 显示内核的启动信息以及运行时内核模块和硬件设备的日志信息。这些信息存储在内核的环形缓冲区中。 特性： 持久性： 即使系统崩溃，只要重新启动，dmesg 中的最近日志通常还在（取决于是否被新日志覆盖）。 实时性： 持续记录内核事件，包括硬件初始化、设备驱动加载、系统错误、USB 设备插拔、网络事件、OOM (Out Of Memory) 杀手活动等。 独立性： 不依赖于用户空间的日志服务（如 syslogd 或 rsyslogd），因此在这些服务未启动或有问题时也能查看内核日志。     二、dmesg 的基本使用方法直接运行 dmesg 命令，默认会打印出内核环形缓冲区中的所有消息到标准输出。 1...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6/" title="存储插件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">存储插件</div></div><div class="info-2"><div class="info-item-1">存储插件前面的章节中我们介绍了在 Kubernetes 中的持久化存储的使用，了解了 PV、PVC 以及 StorageClass 的使用方法，从本地存储到 NFS 共享存储都有学习，到这里我们其实已经可以完成应用各种场景的数据持久化了，但是难免在实际的使用过程中会遇到各种各样的问题，要解决这些问题最好的方式就是来了解下 Kubernetes 中存储的实现原理。 Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 kubectl explain pod.spec.volumes 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存储服务接入到 Kubernetes 系统中来，在 Kubernetes 中就对应 In-Tree 和 Out-Of-Tree 两种方式，In-Tree 就是在 Kubernetes 源码内部实现的，和 Kubernetes 一起发布、管理的，但是更新迭代慢、灵活性比较差，Out-Of-Tree 是独立于 Kubernetes 的，目前主要有 CSI 和 FlexVolume 两种机制，开发者可以根据自己的存储类型实现...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20Selinux%20/" title="Linux Selinux"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux Selinux</div></div><div class="info-2"><div class="info-item-1">SELinux (Security-Enhanced Linux)SELinux 是 Linux 系统中一个非常强大的安全模块，它提供了强制访问控制（Mandatory Access Control, MAC）机制，极大地增强了系统的安全性。理解 SELinux 的工作原理和作用，对于构建健壮安全的 Linux 环境至关重要。  一、什么是 SELinux？SELinux 是美国国家安全局（NSA）和 Red Hat 公司合作开发的一个 Linux 内核安全模块。它在 Linux 标准的自主访问控制（Discretionary Access Control, DAC）权限模型之上，添加了一层更细粒度、更严格的访问控制机制。 DAC vs. MAC (SELinux):  自主访问控制 (DAC)： 这是传统的 Linux 权限模型。文件的所有者可以决定谁可以访问他们的文件（读、写、执行）。例如，一个用户不能删除另一个用户的文件，除非对方赋予了删除权限。DAC 的弱点在于，如果一个应用程序被攻破，攻击者就可以以该应用程序的权限为所欲为，因为 DAC 只关心用户和进程的身份，不关心它...</div></div></div></a><a class="pagination-related" href="/2025/09/11/WebSocket%20%E5%92%8C%20HTTP/" title="WebSocket 和 HTTP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">WebSocket 和 HTTP</div></div><div class="info-2"><div class="info-item-1">WebSocket 和 HTTP 都是应用层协议，用于在客户端和服务器之间传输数据。然而，它们在通信模式、连接方式、数据流向和使用场景上存在根本性的区别。理解这些区别对于选择适合你应用的通信协议至关重要。  主要区别概览   特性 HTTP (通常指 HTTP&#x2F;1.1) WebSocket    通信模式 请求-响应 (Request-Response) 模型 全双工 (Full-duplex) 持久连接   连接方式 短连接 (默认)。每次请求-响应后连接通常关闭或保持短暂的 Keep-Alive 长连接。一次握手后连接持续开放，直到一方关闭   数据流向 单向。客户端发起请求，服务器响应，然后循环。 双向。客户端和服务器可以随时互相发送消息，无需等待请求。   开销 每次请求都包含完整的头部信息，开销较大。 初始握手开销较大，一旦建立，后续数据帧只有很小的头部开销。   传输效率 对于实时、高频数据交换效率低。 对于实时、高频数据交换效率高。   协议类型 无状态 (Stateless)。每次请求都是独立的。 有状态 (Stateful)。连接建立后，双方都知道彼此...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Job%20%E4%B8%8E%20CronJob/" title="Job 与 CronJob"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Job 与 CronJob</div></div><div class="info-2"><div class="info-item-1">Job 与 CronJob接下来给大家介绍另外一类资源对象：Job，我们在日常的工作中经常都会遇到一些需要进行批量数据处理和分析的需求，当然也会有按时间来进行调度的工作，在我们的 Kubernetes 集群中为我们提供了 Job 和 CronJob 两种资源对象来应对我们的这种需求。 Job 负责处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束。而CronJob 则就是在 Job 上加上了时间调度。 Job我们用 Job 这个资源对象来创建一个任务，我们定义一个 Job 来执行一个倒计时的任务，对应的资源清单如下所示： 12345678910111213141516# job-demo.yamlapiVersion: batch/v1kind: Jobmetadata:  name: job-demospec:  template:    spec:      restartPolicy: Never      containers:      - name: counter        image: busybox        command: ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Service/" title="Service"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Service</div></div><div class="info-2"><div class="info-item-1">Service我们前面的课程中学习了一些常用控制器的基本用法，我们也了解到 Pod 的生命是有限的，死亡过后不会复活了。然后我们知道可以用 ReplicaSet 和 Deployment 来动态的创建和销毁 Pod，每个 Pod 都有自己的 IP 地址，但是如果 Pod 重建了的话那么他的 IP 很有可能也就变化了。这就会带来一个问题：比如我们有一些后端的 Pod 集合为集群中的其他应用提供 API 服务，如果我们在前端应用中把所有的这些后端的 Pod 的地址都写死，然后以某种方式去访问其中一个 Pod 的服务，这样看上去是可以工作的，对吧？但是如果这个 Pod 挂掉了，然后重新启动起来了，是不是 IP 地址非常有可能就变了，这个时候前端就极大可能访问不到后端的服务了。 遇到这样的问题该怎么解决呢？在没有使用 Kubernetes 之前，我相信可能很多同学都遇到过这样的问题，不一定是 IP 变化的问题，比如我们在部署一个 WEB 服务的时候，前端一般部署一个 Nginx 作为服务的入口，然后 Nginx 后面肯定就是挂载的这个服务的大量后端服务，很早以前我们可能是去手动更改 Ng...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-BGP-Border-Gateway-Protocol-%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是 BGP (Border Gateway Protocol)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BGP-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">BGP 的工作原理概述：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BGP-%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">BGP 在互联网中的作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BGP-%E7%9A%84%E6%8C%91%E6%88%98%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">BGP 的挑战：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>