<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 系统 lsof 命令 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="lsof（list open files）命令是排查Linux系统中各种“文件占用”问题的利器。在Linux中，“一切皆文件”，这意味着进程不仅打开普通文件（如文本文件、二进制文件），还可能打开目录、网络套接字（sockets）、管道（pipes）、设备文件（如磁盘、终端）、以及共享库等。当我们需要定位某个文件为什么不能被删除、某个端口为何被占用、或者某个进程占用了大量资源时，lsof 都能提供至">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 系统 lsof 命令">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%20lsof%20%E5%91%BD%E4%BB%A4/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="lsof（list open files）命令是排查Linux系统中各种“文件占用”问题的利器。在Linux中，“一切皆文件”，这意味着进程不仅打开普通文件（如文本文件、二进制文件），还可能打开目录、网络套接字（sockets）、管道（pipes）、设备文件（如磁盘、终端）、以及共享库等。当我们需要定位某个文件为什么不能被删除、某个端口为何被占用、或者某个进程占用了大量资源时，lsof 都能提供至">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:47:21.808Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 系统 lsof 命令",
  "url": "https://huiaz.github.io/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%20lsof%20%E5%91%BD%E4%BB%A4/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:47:21.808Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%20lsof%20%E5%91%BD%E4%BB%A4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 系统 lsof 命令',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 系统 lsof 命令</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux 系统 lsof 命令</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:47:21.808Z" title="更新于 2025-09-11 21:47:21">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/Command/">Command</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><code>lsof</code>（list open files）命令是排查Linux系统中各种“文件占用”问题的利器。在Linux中，“一切皆文件”，这意味着进程不仅打开普通文件（如文本文件、二进制文件），还可能打开目录、网络套接字（sockets）、管道（pipes）、设备文件（如磁盘、终端）、以及共享库等。当我们需要定位某个文件为什么不能被删除、某个端口为何被占用、或者某个进程占用了大量资源时，<code>lsof</code> 都能提供至关重要的信息。</p>
<hr>
<h3 id="一、lsof-简介"><a href="#一、lsof-简介" class="headerlink" title="一、lsof 简介"></a>一、<code>lsof</code> 简介</h3><ul>
<li><strong>功能：</strong> 列出当前系统打开文件的进程信息。</li>
<li><strong>原理：</strong> <code>lsof</code> 通过读取内核信息来确定哪些进程正在持有哪些文件描述符。</li>
<li><strong>应用场景：</strong><ul>
<li><strong>文件无法删除&#x2F;卸载：</strong> 某个文件或目录被进程占用，无法删除或卸载其所在文件系统。</li>
<li><strong>端口占用：</strong> 某个端口被未知进程监听或占用，导致新服务无法启动。</li>
<li><strong>磁盘空间报警：</strong> 某个被删除的文件仍然占用磁盘空间（因为其句柄仍被进程持有）。</li>
<li><strong>进程资源分析：</strong> 查看特定进程打开了哪些文件，评估其资源使用情况。</li>
<li><strong>网络连接故障：</strong> 检查哪些进程在进行网络通信。</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong> 运行 <code>lsof</code> 通常需要 <code>root</code> 权限才能查看所有进程打开的文件。</p>
<hr>
<h3 id="二、lsof-的基本使用方法"><a href="#二、lsof-的基本使用方法" class="headerlink" title="二、lsof 的基本使用方法"></a>二、<code>lsof</code> 的基本使用方法</h3><p>直接运行 <code>lsof</code> 会列出当前系统所有进程打开的所有文件，输出量巨大，通常不直接使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure>

<p><strong>默认输出格式解释：</strong></p>
<p>每行显示一个打开的文件信息，包括：</p>
<ul>
<li><strong><code>COMMAND</code></strong>: 打开文件的进程名。</li>
<li><strong><code>PID</code></strong>: 进程ID。</li>
<li><strong><code>USER</code></strong>: 进程所有者。</li>
<li><strong><code>FD</code></strong>: 文件描述符。这是一个数字，表示进程用于访问文件的句柄。常见的类型有：<ul>
<li><code>cwd</code>: 当前工作目录</li>
<li><code>txt</code>: 程序的可执行文本（例如，一个执行中的二进制文件）。</li>
<li><code>mem</code>: 内存映射文件。</li>
<li><code>mmap</code>: 内存映射文件。</li>
<li><code>rtd</code>: 根目录。</li>
<li><code>DEL</code>: 已被删除但仍被进程占用的文件。</li>
<li><code>数字</code>: 表示普通文件描述符（例如 <code>0</code> 是标准输入，<code>1</code> 是标准输出，<code>2</code> 是标准错误）。</li>
<li><code>数字u</code>: 读写模式的文件。</li>
<li><code>数字r</code>: 只读模式的文件。</li>
<li><code>数字w</code>: 只写模式的文件。</li>
</ul>
</li>
<li><strong><code>TYPE</code></strong>: 文件类型。常见的有：<ul>
<li><code>REG</code>: 普通文件。</li>
<li><code>DIR</code>: 目录。</li>
<li><code>CHR</code>: 字符特殊文件（例如终端设备）。</li>
<li><code>BLK</code>: 块特殊文件（例如磁盘设备）。</li>
<li><code>FIFO</code>: 命名管道。</li>
<li><code>PIPE</code>: 匿名管道。</li>
<li><code>LNK</code>: 符号链接。</li>
<li><code>UNIX</code>: UNIX 域套接字。</li>
<li><code>IPv4</code>, <code>IPv6</code>: IPV4&#x2F;IPV6 套接字。</li>
</ul>
</li>
<li><strong><code>DEVICE</code></strong>: 设备号（主设备号,次设备号）。对于网络文件，它通常显示为 <code>node</code>。</li>
<li><strong><code>SIZE/OFF</code></strong>: 文件大小或文件偏移量。对于套接字，有时显示为 <code>inode</code> 号。</li>
<li><strong><code>NODE</code></strong>: 文件的 inode 号（对于网络文件通常是 TCP&#x2F;UDP 的 inode 号）。</li>
<li><strong><code>NAME</code></strong>: 文件的路径或网络连接的详细信息。</li>
</ul>
<hr>
<h3 id="三、lsof-的常用选项和排查技巧"><a href="#三、lsof-的常用选项和排查技巧" class="headerlink" title="三、lsof 的常用选项和排查技巧"></a>三、<code>lsof</code> 的常用选项和排查技巧</h3><h4 id="1-根据文件-目录查找占用进程"><a href="#1-根据文件-目录查找占用进程" class="headerlink" title="1. 根据文件&#x2F;目录查找占用进程"></a>1. 根据文件&#x2F;目录查找占用进程</h4><p>这是最常见的用途之一，当你发现无法删除或卸载某个文件&#x2F;目录时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsof /path/to/file          <span class="comment"># 查找占用指定文件的进程</span></span><br><span class="line">lsof /path/to/directory     <span class="comment"># 查找占用指定目录下任何文件的进程</span></span><br><span class="line">lsof +D /path/to/directory  <span class="comment"># 查找占用指定目录及其子目录下任何文件的进程 (递归)</span></span><br><span class="line">lsof +L1                    <span class="comment"># 显示被删除但仍被占用的文件 (文件系统空间未释放)</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<ul>
<li>检查 <code>/mnt/mydata</code> 目录是否被占用，导致无法 <code>umount</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /mnt/mydata</span><br></pre></td></tr></table></figure></li>
<li>检查哪个进程正在使用 <code>/var/log/nginx/access.log</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /var/log/nginx/access.log</span><br></pre></td></tr></table></figure></li>
<li>查找所有已删除但仍被进程持有的文件 (其磁盘空间不会被立即释放)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof | grep <span class="string">&quot;deleted&quot;</span></span><br><span class="line"><span class="comment"># 或者更精确地：</span></span><br><span class="line">lsof +L1</span><br></pre></td></tr></table></figure>
当看到 <code>(deleted)</code> 标记时，说明文件已经被删除，但因为有进程还在打开它，所以实际的磁盘空间（inode和数据块）还未被回收。你需要找到并终止这些进程，或者重启这些进程，空间才能真正释放。</li>
</ul>
<h4 id="2-根据进程-ID-PID-查找打开的文件"><a href="#2-根据进程-ID-PID-查找打开的文件" class="headerlink" title="2. 根据进程 ID (PID) 查找打开的文件"></a>2. 根据进程 ID (PID) 查找打开的文件</h4><p>当你已经知道某个进程的 PID，想了解它打开了哪些文件时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p &lt;PID&gt;               <span class="comment"># 查找指定 PID 进程打开的所有文件</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<ul>
<li>查找 PID 为 1234 的进程打开了哪些文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p 1234</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-根据用户查找打开的文件"><a href="#3-根据用户查找打开的文件" class="headerlink" title="3. 根据用户查找打开的文件"></a>3. 根据用户查找打开的文件</h4><p>查找特定用户拥有或运行的进程打开的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -u &lt;username&gt;          <span class="comment"># 查找指定用户所有进程打开的文件</span></span><br><span class="line">lsof -u root                <span class="comment"># 查找 root 用户打开的文件</span></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<ul>
<li>查看 <code>nginx</code> 用户打开了哪些文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -u nginx</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-根据命令名查找打开的文件"><a href="#4-根据命令名查找打开的文件" class="headerlink" title="4. 根据命令名查找打开的文件"></a>4. 根据命令名查找打开的文件</h4><p>查找特定命令名（或进程名）的进程打开的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -c &lt;command_name&gt;      <span class="comment"># 查找指定命令名进程打开的文件</span></span><br><span class="line">lsof -c apache2             <span class="comment"># 查找所有 apache2 进程打开的文件</span></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<ul>
<li>查看 <code>mysqld</code> 进程打开了哪些文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -c mysqld</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-查找网络连接和端口占用"><a href="#5-查找网络连接和端口占用" class="headerlink" title="5. 查找网络连接和端口占用"></a>5. 查找网络连接和端口占用</h4><p>这是 <code>lsof</code> 的另一个强大功能，尤其在排查端口冲突时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lsof -i                   <span class="comment"># 列出所有打开的 IPv4 和 IPv6 网络文件 (sockets)</span></span><br><span class="line">lsof -i :&lt;port_number&gt;    <span class="comment"># 查找占用指定端口的进程 (TCP/UDP)</span></span><br><span class="line">lsof -i tcp:&lt;port_number&gt; <span class="comment"># 查找占用指定 TCP 端口的进程</span></span><br><span class="line">lsof -i udp:&lt;port_number&gt; <span class="comment"># 查找占用指定 UDP 端口的进程</span></span><br><span class="line">lsof -i @&lt;host&gt;           <span class="comment"># 查找与指定主机有网络连接的进程</span></span><br><span class="line">lsof -i tcp@&lt;host&gt;:&lt;port&gt; <span class="comment"># 查找与指定主机和端口有 TCP 连接的进程</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<ul>
<li><p>哪个进程占用了 80 端口 (HTTP)？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof -i :80</span><br><span class="line"><span class="comment"># 通常会看到 nginx, apache, 或者其他 web 服务器进程</span></span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">COMMAND</span>    PID     USER   FD   TYPE DEVICE SIZE/<span class="literal">OFF</span> NODE NAME</span><br><span class="line"><span class="attribute">nginx</span>      <span class="number">1234</span>    root    <span class="number">6</span>u  IPv4  <span class="number">67890</span>      <span class="number">0</span>t0  TCP *:http (LISTEN)</span><br><span class="line"><span class="attribute">nginx</span>      <span class="number">1235</span>    www     <span class="number">6</span>u  IPv4  <span class="number">67890</span>      <span class="number">0</span>t0  TCP *:http (LISTEN)</span><br></pre></td></tr></table></figure>
<p>从输出中可以看到 <code>nginx</code> 进程，PID 为 1234 和 1235，正在监听 <code>*:http</code> (即 80 端口)。</p>
</li>
<li><p>哪个进程连接到数据库服务器的 3306 端口？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof -i :3306</span><br><span class="line"><span class="comment"># 或者更具体，如果知道数据库服务器 IP：</span></span><br><span class="line"><span class="comment"># sudo lsof -i tcp@192.168.1.10:3306</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有处于 <code>LISTEN</code> 状态的 TCP 端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof -i -s TCP:LISTEN -P -n</span><br><span class="line"><span class="comment"># -P: 不将端口号转换为服务名</span></span><br><span class="line"><span class="comment"># -n: 不将 IP 地址转换为主机名</span></span><br><span class="line"><span class="comment"># -s TCP:LISTEN: 只显示 TCP 监听状态的 socket</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-组合选项"><a href="#6-组合选项" class="headerlink" title="6. 组合选项"></a>6. 组合选项</h4><p><code>lsof</code> 的这些选项可以组合使用，以实现更精确的过滤。</p>
<p><strong>示例：</strong></p>
<ul>
<li>查找 <code>root</code> 用户运行的，占用 22 端口 (SSH) 的进程：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof -i :22 -u root</span><br><span class="line"><span class="comment"># 通常会看到 sshd 进程</span></span><br></pre></td></tr></table></figure></li>
<li>查找当前目录下，被已删除但仍被进程占用的文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof +L1 $(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="四、文件占用问题排查与解决流程"><a href="#四、文件占用问题排查与解决流程" class="headerlink" title="四、文件占用问题排查与解决流程"></a>四、文件占用问题排查与解决流程</h3><p>当遇到文件或端口占用问题时，可以使用以下步骤进行排查和解决：</p>
<ol>
<li><p><strong>确定问题现象：</strong></p>
<ul>
<li>文件无法删除：<code>rm: cannot remove &#39;filename&#39;: Device or resource busy</code></li>
<li>文件系统无法卸载：<code>umount: /mnt/data: target is busy</code></li>
<li>服务启动失败，端口被占用：<code>Address already in use</code></li>
</ul>
</li>
<li><p><strong>使用 <code>lsof</code> 定位：</strong><br>根据问题类型选择合适的 <code>lsof</code> 命令。</p>
<ul>
<li><p><strong>文件&#x2F;目录占用：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof /path/to/problem</span><br><span class="line"><span class="comment"># 如果是目录，且怀疑子目录或文件被占用：</span></span><br><span class="line"><span class="built_in">sudo</span> lsof +D /path/to/problem</span><br></pre></td></tr></table></figure>
<p>查看输出中的 <code>COMMAND</code> 和 <code>PID</code> 列， identify the responsible process.</p>
</li>
<li><p><strong>端口占用：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof -i :&lt;port_number&gt;</span><br></pre></td></tr></table></figure>
<p>同样，从输出中获取 <code>COMMAND</code> 和 <code>PID</code>。</p>
</li>
<li><p><strong>已删除文件仍占用空间：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof +L1</span><br></pre></td></tr></table></figure>
<p>重点关注带有 <code>(deleted)</code> 标记的行，找出对应的 <code>PID</code>。</p>
</li>
</ul>
</li>
<li><p><strong>分析 <code>lsof</code> 输出：</strong></p>
<ul>
<li><strong><code>COMMAND</code> 和 <code>PID</code>：</strong> 哪个进程导致的问题？</li>
<li><strong><code>USER</code>：</strong> 谁拥有这个进程？这有助于确定权限和责任。</li>
<li><strong><code>FD</code>：</strong> 文件描述符的类型（<code>cwd</code>, <code>txt</code>, <code>DEL</code>, <code>u</code>, <code>r</code>, <code>w</code>）告诉你进程是以什么方式打开文件的。特别是 <code>DEL</code>，表明文件已被删除但仍在内存中。</li>
<li><strong><code>NAME</code>：</strong> 确认是否是你正在寻找的文件或连接。</li>
</ul>
</li>
<li><p><strong>采取解决措施：</strong></p>
<ul>
<li><p><strong>正常关闭&#x2F;重启服务：</strong> 如果问题是由一个已知的应用程序或服务（如Nginx、MySQL）引起的，尝试优雅地关闭或重启该服务。这通常是最好的方法，因为它能确保数据的完整性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop &lt;service_name&gt;</span><br><span class="line"><span class="comment"># 再次检查 lsof 是否已经释放</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start &lt;service_name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>强制终止进程：</strong> 如果无法正常关闭或重启，或者进程是恶意的&#x2F;僵尸进程，可以强制终止。<br><strong>警告：慎用！强制终止进程可能导致数据损坏或丢失！</strong> 尤其当文件是正在被写入的关键数据文件时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">kill</span> &lt;PID&gt;                <span class="comment"># SIGTERM，尝试优雅终止</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">kill</span> -9 &lt;PID&gt;             <span class="comment"># SIGKILL，强制终止，不给进程清理机会</span></span><br><span class="line"><span class="comment"># 再次检查 lsof 是否已经释放</span></span><br></pre></td></tr></table></figure>
<p>终止进程后，磁盘空间应立即释放，如果问题是文件无法删除，现在应该可以删除了。</p>
</li>
<li><p><strong>检查共享库占用：</strong> 如果是可执行文件或共享库被占用 (TYPE 为 <code>TXT</code> 或 <code>REG</code> 并且 <code>NAME</code> 是 <code>.so</code> 文件)，通常需要停止（或重启）所有使用该库的进程。</p>
</li>
</ul>
</li>
</ol>
<p><strong>示例场景：磁盘空间满，<code>df -h</code> 却没有找到大文件</strong></p>
<ol>
<li><strong>现象：</strong> <code>df -h</code> 显示 <code>/var</code> 分区 100% 使用，但 <code>du -sh /var</code> 看到实际占用空间远小于 100%。</li>
<li><strong>怀疑：</strong> 有文件被删除，但其文件句柄仍被进程持有，导致空间未释放。</li>
<li><strong><code>lsof</code> 定位：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof +L1 | grep <span class="string">&quot;/var&quot;</span></span><br></pre></td></tr></table></figure>
假设发现：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">COMMAND</span> PID   USER   FD   TYPE DEVICE SIZE/<span class="literal">OFF</span>    NODE NAME</span><br><span class="line"><span class="attribute">nginx</span>   <span class="number">1234</span>  root   <span class="number">10</span>w  REG  <span class="number">253</span>,<span class="number">0</span>  <span class="number">123456789</span> <span class="number">1234567</span> /var/log/nginx/access.log (deleted)</span><br></pre></td></tr></table></figure>
这表明 <code>/var/log/nginx/access.log</code> 这个文件已经被删除，但 PID 1234 的 <code>nginx</code> 进程还在写入它，所以空间没有释放。</li>
<li><strong>解决：</strong> 最安全的方法是重启 <code>nginx</code> 服务。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart nginx</span><br></pre></td></tr></table></figure>
重启后，<code>nginx</code> 会重新打开新的日志文件，旧的被删除文件的句柄会被释放，磁盘空间也会被回收。</li>
</ol>
<hr>
<h3 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h3><ul>
<li><strong>权限：</strong> 为了获得最完整的输出，请使用 <code>sudo lsof</code>。</li>
<li><strong>输出量：</strong> 直接运行 <code>lsof</code> 输出巨大，务必配合管道和过滤条件。</li>
<li><strong>误杀进程：</strong> 在 <code>kill</code> 进程之前，务必确认进程的身份和影响，避免误杀关键服务。</li>
<li><strong>复杂场景：</strong> 对于复杂的网络连接问题，<code>netstat -tulnp</code> 或 <code>ss -tulnp</code> 也是非常有用的补充工具，它们更专注于网络套接字信息。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%20lsof%20%E5%91%BD%E4%BB%A4/">https://huiaz.github.io/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%20lsof%20%E5%91%BD%E4%BB%A4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/" title="Linux 文件权限"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux 文件权限</div></div><div class="info-2"><div class="info-item-1">Linux 系统权限管理 一、Linux 权限管理的核心理念：用户、组与权限Linux 系统中的权限管理围绕着三个核心概念展开：用户（User）、组（Group） 和 其他（Others），以及针对这些实体设定的读（Read）、写（Write）、执行（Execute） 三种基本权限。 1. 用户 (User)：每个用户都有一个唯一的用户 ID (UID)。系统通过 UID 来识别用户。  root 用户： UID 为 0，拥有系统最高权限，可以执行任何操作。 系统用户： UID 1-999 (具体范围依发行版可能不同)，用于运行系统服务，通常不能登录。 普通用户： UID 1000 及以上，是日常操作的用户。  2. 组 (Group)：每个组都有一个唯一的组 ID (GID)。用户可以属于一个或多个组。  Primary Group (主组)： 用户创建时自动归属的组。 Secondary Groups (附加组)： 用户除了主组外，还可以加入多个附加组。 目的： 简化权限管理。可以将文件权限赋给一个组，所有属于该组的用户都将获得相应的权限，而无需单独为每个用户设置。  3. ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%20dmesg%20%E5%91%BD%E4%BB%A4/" title="Linux 系统 dmesg 命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux 系统 dmesg 命令</div></div><div class="info-2"><div class="info-item-1">dmesg 是在 Linux 系统中排查各种底层问题（尤其是与硬件、驱动、系统启动、内存、I&#x2F;O 错误等相关的）时常用的诊断工具。它允许查看内核环形缓冲区（kernel ring buffer）中的消息，这些消息是内核在运行过程中记录的重要事件和错误信息，对于理解系统内部工作状态和定位故障至关重要。  一、dmesg 简介 全称： diagnostic message 功能： 显示内核的启动信息以及运行时内核模块和硬件设备的日志信息。这些信息存储在内核的环形缓冲区中。 特性： 持久性： 即使系统崩溃，只要重新启动，dmesg 中的最近日志通常还在（取决于是否被新日志覆盖）。 实时性： 持续记录内核事件，包括硬件初始化、设备驱动加载、系统错误、USB 设备插拔、网络事件、OOM (Out Of Memory) 杀手活动等。 独立性： 不依赖于用户空间的日志服务（如 syslogd 或 rsyslogd），因此在这些服务未启动或有问题时也能查看内核日志。     二、dmesg 的基本使用方法直接运行 dmesg 命令，默认会打印出内核环形缓冲区中的所有消息到标准输出。 1...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/" title="Linux 文件权限"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 文件权限</div></div><div class="info-2"><div class="info-item-1">Linux 系统权限管理 一、Linux 权限管理的核心理念：用户、组与权限Linux 系统中的权限管理围绕着三个核心概念展开：用户（User）、组（Group） 和 其他（Others），以及针对这些实体设定的读（Read）、写（Write）、执行（Execute） 三种基本权限。 1. 用户 (User)：每个用户都有一个唯一的用户 ID (UID)。系统通过 UID 来识别用户。  root 用户： UID 为 0，拥有系统最高权限，可以执行任何操作。 系统用户： UID 1-999 (具体范围依发行版可能不同)，用于运行系统服务，通常不能登录。 普通用户： UID 1000 及以上，是日常操作的用户。  2. 组 (Group)：每个组都有一个唯一的组 ID (GID)。用户可以属于一个或多个组。  Primary Group (主组)： 用户创建时自动归属的组。 Secondary Groups (附加组)： 用户除了主组外，还可以加入多个附加组。 目的： 简化权限管理。可以将文件权限赋给一个组，所有属于该组的用户都将获得相应的权限，而无需单独为每个用户设置。  3. ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20iostat/" title="Linux iostat"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux iostat</div></div><div class="info-2"><div class="info-item-1">iostat 是 Linux sysstat 工具集中的一个命令，主要用于 CPU 使用情况 和 磁盘 I&#x2F;O 统计。 它通常用来排查 磁盘性能瓶颈 或 CPU 负载问题。  一、基本语法1iostat [选项] [间隔] [次数]   间隔：两次采样之间的秒数 次数：采样次数 如果不加参数，只显示一次从系统启动以来的平均统计   二、常用选项 **-c**：只显示 CPU 统计信息 **-d**：只显示磁盘设备统计信息 **-x**：显示扩展统计信息（更详细的磁盘指标） **-p [设备]**：显示指定设备的分区统计 **-k &#x2F; -m**：以 KB&#x2F;s 或 MB&#x2F;s 显示数据传输速率 **-N**：显示 LVM 的统计信息 **-t**：显示时间戳   三、示例 查看所有 CPU 和磁盘的 I&#x2F;O 统计  1iostat   每隔 2 秒更新一次 CPU 和磁盘统计，显示 5 次  1iostat 2 5   只看 CPU 使用率  1iostat -c 1 3   只看磁盘 I&#x2F;O  1iostat -d 1 3 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-dockerfile/" title="Dockerfile"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Dockerfile</div></div><div class="info-2"><div class="info-item-1">一、Dockerfile 的作用Dockerfile 是一个文本文件，其核心作用是定义了构建一个 Docker 镜像所需的所有步骤和指令。它就像一份自动化的“安装说明书”或“烹饪菜谱”，Docker 根据这份说明书，就能一步不差地构建出一个标准、一致的镜像。 它的主要作用体现在：  **自动化构建 (Automation)**：将手动配置环境的繁琐步骤（安装依赖、复制文件、设置环境变量等）代码化，实现了构建过程的全自动。 **可重复性 (Reproducibility)**：只要 Dockerfile 不变，无论在谁的机器上、在什么时间执行构建，最终得到的镜像内容都是完全一致的，这从根本上保证了环境的一致性。 **版本控制 (Versioning)**：Dockerfile 可以像代码一样存放在 Git 等版本控制系统中进行管理。每一次对环境的变更，都可以通过修改 Dockerfile 并提交记录来追溯，使得环境演进有迹可循。 **透明性与审查 (Transparency &amp; Auditing)**：任何团队成员都可以通过阅读 Dockerfile，清晰地了解到一个镜像是...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4/" title="Linux 排查命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 排查命令</div></div><div class="info-2"><div class="info-item-1">(1) 如何在 Linux 中查看系统资源使用情况？比如内存、CPU、网络端口。  一、 CPU 使用情况1. top 命令 (实时交互式)top 命令是最常用的 CPU 监控工具，它提供了一个实时更新的进程列表，并显示 CPU 使用率、内存使用率、进程 ID (PID)、用户、运行时间等信息。 1top  关键信息解读：  第一行（top line）： load average 显示了过去 1、5、15 分钟的系统平均负载。这是衡量系统忙碌程度的重要指标，数值大于 CPU 核心数时通常表示系统存在瓶颈。 第二行（Tasks）： 显示进程总数，以及运行、睡眠、停止和僵尸进程的数量。 第三行（Cpu(s)）： 显示 CPU 的使用率，各项指标含义如下： us (user): 用户空间程序的 CPU 使用率。 sy (system): 内核空间程序的 CPU 使用率。 ni (nice): 改变过优先级的用户进程的 CPU 使用率。 id (idle): 空闲 CPU 百分比。 wa (iowait): CPU 等待 I&#x2F;O 操作完成的百分比。 hi (hardware i...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/" title="Linux 故障诊断工具"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 故障诊断工具</div></div><div class="info-2"><div class="info-item-1">Linux 故障诊断工具（Markdown 整理） 背景 如果一款应用在 Linux 上运行缓慢，可能的瓶颈包括：CPU、磁盘 I&#x2F;O、网络、内存或数据库。以下工具可协助定位问题。建议不要只依赖某一个时刻的快照，而是多次采样观测趋势。 (Syed Ali)  1. vmstat 显示多个系统统计信息。 注意观察 r（运行队列长度）列，如果值偏高，说明 CPU 资源紧张。 cs 表示上下文切换次数，如果偏高，可能系统正在频繁切换任务（网络、磁盘、CPU 等），可考虑减少系统运行的应用数量。 (Syed Ali)  2. free 与缓存逻辑说明Linux 会使用内存来缓存 inode 信息和文件内容以加速磁盘访问。因此 free 命令输出可能显示“free”值较少，但大部分内存被 buffers 和 cache 占用，如下例所示： 123456789$ free -mtotal used free shared buff/cache availableMem: 386445 16613 8443 4110 361388 364610Swap: 8191 317 7874$...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E4%B8%AD%E7%9A%84%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/" title="Linux 中的硬链接和软连接"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 中的硬链接和软连接</div></div><div class="info-2"><div class="info-item-1">1. 硬链接 (Hard Link)定义：硬链接是文件系统中的一种特殊引用，它指向文件系统中的同一个文件 inode（索引节点）。简单来说，一个硬链接就是原始文件的一个别名，它们共享同一个 inode。 inode 包含了文件的所有元数据，如文件类型、权限、所有者、组、大小以及数据的物理位置等信息。 创建方式：使用 ln 命令创建硬链接： 1ln [原始文件] [硬链接文件]  特点：  共享 inode： 原始文件和硬链接文件共享同一个 inode 号。你可以通过 ls -i 命令来查看。 同等地位： 对于操作系统来说，硬链接和原始文件是完全平等的。它们只是同一个文件内容的两个不同入口。 不能跨文件系统： 硬链接只能在同一个文件系统内部创建，因为 inode 号在不同的文件系统上是独立的。 不能链接目录： 出于文件系统结构完整性和避免循环引用等复杂性，不允许创建指向目录的硬链接。 删除特性： 删除硬链接文件不会影响原始文件，也不会影响其他硬链接文件，只要还有至少一个硬链接指向该 inode，文件内容就不会被删除。 只有当所有指向该 inode 的硬链接都被删除后，操作系统才会释...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81lsof-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、lsof 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81lsof-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">二、lsof 的基本使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81lsof-%E7%9A%84%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9%E5%92%8C%E6%8E%92%E6%9F%A5%E6%8A%80%E5%B7%A7"><span class="toc-number">3.</span> <span class="toc-text">三、lsof 的常用选项和排查技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E6%9F%A5%E6%89%BE%E5%8D%A0%E7%94%A8%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1. 根据文件&#x2F;目录查找占用进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%B9%E6%8D%AE%E8%BF%9B%E7%A8%8B-ID-PID-%E6%9F%A5%E6%89%BE%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">2. 根据进程 ID (PID) 查找打开的文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E6%9F%A5%E6%89%BE%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">3. 根据用户查找打开的文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%A0%B9%E6%8D%AE%E5%91%BD%E4%BB%A4%E5%90%8D%E6%9F%A5%E6%89%BE%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text">4. 根据命令名查找打开的文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9F%A5%E6%89%BE%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text">5. 查找网络连接和端口占用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%BB%84%E5%90%88%E9%80%89%E9%A1%B9"><span class="toc-number">3.6.</span> <span class="toc-text">6. 组合选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">四、文件占用问题排查与解决流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.</span> <span class="toc-text">五、注意事项</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>