<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>APISIX | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="APISIXApache APISIX 是一个基于 OpenResty 和 Etcd 实现的动态、实时、高性能的 API 网关，目前已经是 Apache 顶级项目。提供了丰富的流量管理功能，如负载均衡、动态路由、动态 upstream、A&#x2F;B 测试、金丝雀发布、限速、熔断、防御恶意攻击、认证、监控指标、服务可观测性、服务治理等。可以使用 APISIX 来处理传统的南北流量以及服务之间的东">
<meta property="og:type" content="article">
<meta property="og:title" content="APISIX">
<meta property="og:url" content="http://example.com/2025/09/11/APISIX/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="APISIXApache APISIX 是一个基于 OpenResty 和 Etcd 实现的动态、实时、高性能的 API 网关，目前已经是 Apache 顶级项目。提供了丰富的流量管理功能，如负载均衡、动态路由、动态 upstream、A&#x2F;B 测试、金丝雀发布、限速、熔断、防御恶意攻击、认证、监控指标、服务可观测性、服务治理等。可以使用 APISIX 来处理传统的南北流量以及服务之间的东">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T12:42:57.209Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "APISIX",
  "url": "http://example.com/2025/09/11/APISIX/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T12:42:57.209Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/11/APISIX/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'APISIX',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">APISIX</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">APISIX</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T12:42:57.209Z" title="更新于 2025-09-11 20:42:57">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E7%BD%91%E7%BB%9C/">网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="APISIX"><a href="#APISIX" class="headerlink" title="APISIX"></a>APISIX</h1><p><a target="_blank" rel="noopener" href="https://apisix.apache.org/">Apache APISIX</a> 是一个基于 <code>OpenResty</code> 和 Etcd 实现的动态、实时、高性能的 API 网关，目前已经是 Apache 顶级项目。提供了丰富的流量管理功能，如负载均衡、动态路由、动态 upstream、A&#x2F;B 测试、金丝雀发布、限速、熔断、防御恶意攻击、认证、监控指标、服务可观测性、服务治理等。可以使用 APISIX 来处理传统的南北流量以及服务之间的东西向流量。</p>
<p>APISIX 基于 Nginx 和 etcd，与传统 API 网关相比，APISIX 具有动态路由和热加载插件功能，避免了配置之后的 reload 操作，同时 APISIX 支持 HTTP(S)、HTTP2、Dubbo、QUIC、MQTT、TCP&#x2F;UDP 等更多的协议。而且还内置了 Dashboard，提供强大而灵活的界面。同样也提供了丰富的插件支持功能，而且还可以让用户自定义插件。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/t2audk.png" alt="APISIX 架构图"></p>
<p>上图是 APISIX 的架构图，整体上分成数据面和控制面两个部分，控制面用来管理路由，主要通过 etcd 来实现配置中心，数据面用来处理客户端请求，通过 APISIX 自身来实现，会不断去 watch etcd 中的 route、upstream 等数据。</p>
<h2 id="APISIX-Ingress"><a href="#APISIX-Ingress" class="headerlink" title="APISIX Ingress"></a>APISIX Ingress</h2><p>同样作为一个 API 网关，APISIX 也支持作为 Kubernetes 的一个 Ingress 控制器进行使用。APISIX Ingress 在架构上分成了两部分，一部分是 APISIX Ingress Controller，作为控制面它将完成配置管理与分发。另一部分 APISIX(代理) 负责承载业务流量。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/4918f9.png" alt="apisix-ingress-controller"></p>
<p>当 Client 发起请求，到达 Apache APISIX 后，会直接把相应的业务流量传输到后端（如 Service Pod），从而完成转发过程。此过程不需要经过 Ingress Controller，这样做可以保证一旦有问题出现，或者是进行变更、扩缩容或者迁移处理等，都不会影响到用户和业务流量。</p>
<p>同时在配置端，用户通过 <code>kubectl apply</code> 创建资源，可将自定义 CRD 配置应用到 K8s 集群，Ingress Controller 会持续 watch 这些资源变更，来将相应配置应用到 Apache APISIX（通过 admin api）。</p>
<p>从上图可以看出 APISIX Ingress 采用了数据面与控制面的分离架构，所以用户可以选择将数据面部署在 K8s 集群内部或外部。但 Ingress Nginx 是将控制面和数据面放在了同一个 Pod 中，如果 Pod 或控制面出现一点闪失，整个 Pod 就会挂掉，进而影响到业务流量。这种架构分离，给用户提供了比较方便的部署选择，同时在业务架构调整场景下，也方便进行相关数据的迁移与使用。</p>
<p>APISIX Ingress 控制器目前支持的核心特性包括：</p>
<ul>
<li>全动态，支持高级路由匹配规则，可与 Apache APISIX 官方 50 多个插件 &amp; 客户自定义插件进行扩展使用</li>
<li>支持 CRD，更容易理解声明式配置</li>
<li>兼容原生 Ingress 资源对象</li>
<li>支持流量切分</li>
<li>服务自动注册发现，无惧扩缩容</li>
<li>更灵活的负载均衡策略，自带健康检查功能</li>
<li>支持 gRPC plaintext 与 TCP 4 层代理</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们这里在 Kubernetes 集群中来使用 APISIX，可以通过 Helm Chart 来进行安装，首先添加官方提供的 Helm Chart 仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ helm repo add apisix https://charts.apiseven.com</span><br><span class="line">➜ helm repo update</span><br></pre></td></tr></table></figure>



<p>由于 APISIX 的 Chart 包中包含 dashboard 和 ingress 控制器的依赖，我们只需要在 values 中启用即可安装 ingress 控制器了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ helm fetch apisix/apisix</span><br><span class="line">➜ tar -xvf apisix-0.7.2.tgz</span><br><span class="line">➜ mkdir -p apisix/ci</span><br></pre></td></tr></table></figure>



<p>在 <code>apisix/ci</code> 目录中新建一个用于安装的 values 文件，内容如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ci/prod.yaml</span></span><br><span class="line"><span class="attr">apisix:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="comment"># 固定在node2节点上</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="string">node2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Cluster</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">9080</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 启用 tls</span></span><br><span class="line">    <span class="attr">servicePort:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">9443</span></span><br><span class="line"></span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 会自动创建3个节点的etcd集群</span></span><br><span class="line">  <span class="attr">replicaCount:</span> <span class="number">1</span> <span class="comment"># 多副本需要修改下模板，这里暂时运行一个etcd pod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dashboard:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingress-controller:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">apisix:</span></span><br><span class="line">      <span class="attr">serviceName:</span> <span class="string">apisix-admin</span></span><br><span class="line">      <span class="attr">serviceNamespace:</span> <span class="string">apisix</span> <span class="comment"># 指定命名空间，如果不是 ingress-apisix 需要重新指定</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>经测试官方的 Helm Chart 包对 etcd 多节点集群支持不是很好，我测试跑 3 个节点会出问题，另外对外部的 etcd tls 集群兼容度也不好，比如 dashboard 的 Chart 需要自己修改模板去支持 tls，所以这里我们测试先改成 1 个副本的 etcd 集群。</p>
</blockquote>
<p>APISIX 需要依赖 etcd，默认情况下 Helm Chart 会自动安装一个 3 副本的 etcd 集群，需要提供一个默认的 StorageClass（存储章节会详细讲解），如果你已经有默认的存储类则可以忽略下面的步骤，这里我们安装一个 nfs 的 provisioner，用下面的命令可以安装一个默认的 StorageClass：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/</span><br><span class="line">➜ helm upgrade --install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \</span><br><span class="line">--set nfs.server=192.168.31.31 \</span><br><span class="line">--set nfs.path=/var/lib/k8s/data \</span><br><span class="line">--set image.repository=cnych/nfs-subdir-external-provisioner \</span><br><span class="line">--set storageClass.defaultClass=true -n kube-system</span><br></pre></td></tr></table></figure>



<p>安装完成后会自动创建一个 StorageClass：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get sc</span><br><span class="line">NAME                   PROVISIONER                                     RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE</span><br><span class="line">nfs-client (default)   cluster.local/nfs-subdir-external-provisioner   Delete          Immediate              true                   35s</span><br></pre></td></tr></table></figure>



<p>然后直接执行下面的命令进行一键安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜ helm upgrade --install apisix ./apisix -f ./apisix/ci/prod.yaml -n apisix</span><br><span class="line">Release &quot;apisix&quot; does not exist. Installing it now.</span><br><span class="line">NAME: apisix</span><br><span class="line">LAST DEPLOYED: Thu Dec 30 16:28:38 2021</span><br><span class="line">NAMESPACE: apisix</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">NOTES:</span><br><span class="line">1. Get the application URL by running these commands:</span><br><span class="line">  export NODE_PORT=$(kubectl get --namespace apisix -o jsonpath=&quot;&#123;.spec.ports[0].nodePort&#125;&quot; services apisix-gateway)</span><br><span class="line">  export NODE_IP=$(kubectl get nodes --namespace apisix -o jsonpath=&quot;&#123;.items[0].status.addresses[0].address&#125;&quot;)</span><br><span class="line">  echo http://$NODE_IP:$NODE_PORT</span><br></pre></td></tr></table></figure>



<p>正常就可以成功部署 apisix 了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods -n apisix</span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">apisix-dashboard-b69d5c768-r6tqk             1/1     Running   0          85m</span><br><span class="line">apisix-etcd-0                                1/1     Running   0          90m</span><br><span class="line">apisix-fb8cdb569-wz9gq                       1/1     Running   0          87m</span><br><span class="line">apisix-ingress-controller-7d5bbf5dd5-r6khq   1/1     Running   0          85m</span><br><span class="line">➜ kubectl get svc -n apisix</span><br><span class="line">NAME                        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">apisix-admin                ClusterIP   10.97.108.252    &lt;none&gt;        9180/TCP                     24h</span><br><span class="line">apisix-dashboard            ClusterIP   10.108.202.136   &lt;none&gt;        80/TCP                       24h</span><br><span class="line">apisix-etcd                 ClusterIP   10.107.150.100   &lt;none&gt;        2379/TCP,2380/TCP            24h</span><br><span class="line">apisix-etcd-headless        ClusterIP   None             &lt;none&gt;        2379/TCP,2380/TCP            24h</span><br><span class="line">apisix-gateway              NodePort    10.97.214.188    &lt;none&gt;        80:32200/TCP,443:31417/TCP   24h</span><br><span class="line">apisix-ingress-controller   ClusterIP   10.103.176.26    &lt;none&gt;        80/TCP                       24h</span><br></pre></td></tr></table></figure>



<h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><p>现在我们可以为 Dashboard 创建一个路由规则，新建一个如下所示的 <code>ApisixRoute</code> 资源对象即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">apisix</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">apisix.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/*&#x27;</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">apisix-dashboard</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<p>创建后 <code>apisix-ingress-controller</code> 会将上面的资源对象通过 admin api 映射成 APISIX 中的配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get apisixroute -n apisixNAME        HOSTS                    URIS     AGE</span><br><span class="line">dashboard   [&quot;apisix.qikqiak.com&quot;]   [&quot;/*&quot;]   75m</span><br></pre></td></tr></table></figure>



<p>所以其实我们的访问入口是 APISIX，而 <code>apisix-ingress-controller</code> 只是一个用于监听 crds，然后将 crds 翻译成 APISIX 的配置的工具而已，现在就可以通过 <code>apisix-gateway</code> 的 NodePort 端口去访问我们的 dashboard 了：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/ernkst.png" alt="dashboard"></p>
<p>当然如果不想在访问的时候域名后面带上端口，在云端环境可以直接将 <code>apisix-gateway</code> 这个 Service 设置成 LoadBalancer 模式，在本地测试的时候可以使用 <code>kubectl port-forward</code> 将服务暴露在节点的 80 端口上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node2 节点暴露 apisix-gateway 服务</span></span><br><span class="line">➜ kubectl port-forward --address 0.0.0.0 svc/apisix-gateway 80:80 443:443 -n apisix</span><br></pre></td></tr></table></figure>



<p>默认登录用户名和密码都是 admin，登录后在<code>路由</code>菜单下正常可以看到上面我们创建的这个 dashboard 的路由信息：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/wiec1f.png" alt="dashboard route"></p>
<p>点击<code>更多</code>下面的<code>查看</code>就可以看到在 APISIX 下面真正的路由配置信息：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/3ynwm1.png" alt="apisix config"></p>
<p>所以我们要使用 APISIX，也一定要理解其中的路由 Route 这个概念，路由（Route）是请求的入口点，它定义了客户端请求与服务之间的匹配规则，路由可以与服务（Service）、上游（Upstream）关联，一个服务可对应一组路由，一个路由可以对应一个上游对象（一组后端服务节点），因此，每个匹配到路由的请求将被网关代理到路由绑定的上游服务中。</p>
<p>理解了路由后自然就知道了我们还需要一个上游 Upstream 进行关联，这个概念和 Nginx 中的 Upstream 基本是一致的，在<code>上游</code>菜单下可以看到我们上面创建的 dashboard 对应的上游服务：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/836sgi.png" alt="Upstream"></p>
<p>其实就是将 Kubernetes 中的 Endpoints 映射成 APISIX 中的 Upstream，然后我们可以自己在 APISIX 这边进行负载。</p>
<p>APISIX 提供的 Dashboard 功能还是非常全面的，我们甚至都可以直接在页面上进行所有的配置，包括插件这些，非常方便。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/8v1lj2.png" alt="插件"></p>
<p>当然还有很多其他高级的功能，比如流量切分、请求认证等等，这些高级功能在 crds 中去使用则更加方便了，当然也是支持原生的 Ingress 资源对象的，关于 APISIX 的更多用法，后续再进行说明。</p>
<h2 id="URL-Rewrite"><a href="#URL-Rewrite" class="headerlink" title="URL Rewrite"></a>URL Rewrite</h2><p>同样我们来介绍下如何使用 APISIX 来实现 URL Rewrite 操作，同样还是以前面测试用过的 Nexus 应用为例进行说明，通过 <code>ApisixRoute</code> 对象来配置服务路由，对应的资源清单如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nexus.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nexus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nexus</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">cnych/nexus:3.20.1</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8081</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nexusport</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nexus</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/*&#x27;</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>直接创建上面的资源对象即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl apply -f nexus.yaml</span><br><span class="line">➜ kubectl get apisixroute</span><br><span class="line">NAME    HOSTS                   URIS     AGE</span><br><span class="line">nexus   [&quot;ops.qikqiak.com&quot;]   [&quot;/*&quot;]   39s</span><br><span class="line">➜ kubectl get pods -l app=nexus</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nexus-6f78b79d4c-b79r4   1/1     Running   0          48s</span><br><span class="line">➜ kubectl get svc -l app=nexus</span><br><span class="line">NAME    TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">nexus   ClusterIP   10.102.53.243   &lt;none&gt;        8081/TCP   58s</span><br></pre></td></tr></table></figure>



<p>部署完成后，我们根据 <code>ApisixRoute</code> 对象中的配置，只需要将域名 <code>ops.qikqiak.com</code> 解析到 node2 节点（上面通过 port-forward 暴露了 80 端口）即可访问：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/v6w782.png" alt="nexus"></p>
<p>同样如果现在需要通过一个子路径来访问 Nexus 应用的话又应该怎么来实现呢？比如通过 <code>http://ops.qikqiak.com/nexus</code> 来访问我们的应用，首先我们肯定需要修改 <code>ApisixRoute</code> 对象中匹配的 paths 路径，将其修改为 <code>/nexus</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>更新后我们可以通过 <code>http://ops.qikqiak.com/nexus</code> 访问应用：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/v3hn0k.png" alt="nexus 404"></p>
<p>仔细分析发现很多静态资源 404 了，这是因为现在我们只匹配了 <code>/nexus</code> 的请求，而我们的静态资源是 <code>/static</code> 路径开头的，当然就匹配不到了，所以就出现了 404，所以我们只需要加上这个 <code>/static</code> 路径的匹配就可以了，同样更新 ApisixRoute 对象，新增 <code>/static/*</code> 路径支持：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>更新后发现虽然静态资源可以正常访问了，但是当我们访问 <code>http://ops.qikqiak.com/nexus</code> 的时候依然会出现 404 错误。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/j0doah.png" alt="nexus 404"></p>
<p>这是因为我们这里是将 <code>/nexus</code> 路径的请求直接路由到后端服务去了，而后端服务没有对该路径做任何处理，所以也就是 404 的响应了，在之前 ingress-nginx 或者 traefik 中我们是通过 url 重写来实现的，而在 APISIX 中同样可以实现这个处理，相当于在请求在真正到达上游服务之前将请求的 url 重写到根目录就可以了，这里我们需要用到 <a target="_blank" rel="noopener" href="https://apisix.apache.org/zh/docs/apisix/plugins/proxy-rewrite">proxy-rewrite</a> 这个插件（需要确保在安装的时候已经包含了该插件），<code>proxy-rewrite</code> 是上游代理信息重写插件，支持对 scheme、uri、host 等信息的重写，该插件可配置的属性如下表所示：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/vk8n41.png" alt="proxy-rewrite 属性"></p>
<p>我们现在的需求是希望将所有 <code>/nexus</code> 下面的请求都重写到根路径 <code>/</code> 下面去，所以我们应该使用 <code>regex_uri</code> 属性，转发到上游的新 uri 地址, 使用正则表达式匹配来自客户端的 uri，当匹配成功后使用模板替换转发到上游的 uri, 未匹配成功时将客户端请求的 uri 转发至上游，重新修改后的 <code>ApisixRoute</code> 对象如下所示，新增 <code>plugins</code> 属性来配置插件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-rewrite</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^/nexus(/|$)(.*)&#x27;</span>, <span class="string">&#x27;/$2&#x27;</span>]</span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>这里我们启用一个 <code>proxy-rewrite</code> 插件，并且将所有 <code>/nexus</code> 路径的请求都重写到了 <code>/</code> 跟路径下，重新更新后再次访问 <code>http://ops.qikqiak.com/nexus</code> 应该就可以正常访问了：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/9fwt92.png" alt="nexus"></p>
<p>只有最后一个小问题了，从浏览器网络请求中可以看出我们没有去匹配 <code>/service</code> 这个路径的请求，只需要配置上该路径即可，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/service/*&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-rewrite</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^/nexus(/|$)(.*)&#x27;</span>, <span class="string">&#x27;/$2&#x27;</span>]</span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>现在重新访问子路径就完成正常了：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/et3x9n.png" alt="子路径"></p>
<h2 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h2><p>现在当我们访问 <code>http://ops.qikqiak.com/nexus</code> 或者 <code>http://ops.qikqiak.com/nexus/</code> 的时候都可以得到正常的结果，一般来说我们可能希望能够统一访问路径，比如访问 <code>/nexus</code> 子路径的时候可以自动跳转到 <code>/nexus/</code> 以 Splash 结尾的路径上去。同样要实现该需求我们只需要使用一个名为 <code>redirect</code> 的插件即可，该插件是 URI 重定向插件，可配置的属性如下所示：</p>
<p><img src="https://picdn.youdianzhishi.com/images/20220107174345.png" alt="redirect 插件"></p>
<p>要实现我们的需求直接使用 <code>regex_uri</code> 这个属性即可，只需要去匹配 <code>/nexus</code> 的请求，然后进行跳转即可，更新 <code>ApisixRoute</code> 对象：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/service/*&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-rewrite</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^/nexus(/|$)(.*)&#x27;</span>, <span class="string">&#x27;/$2&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^(/nexus)$&#x27;</span>, <span class="string">&#x27;$1/&#x27;</span>]</span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>我们新启用了一个 <code>redirect</code> 插件，并配置 <code>regex_uri: [&quot;^(/nexus)$&quot;, &quot;$1/&quot;]</code>，这样当访问 <code>/nexus</code> 的时候会自动跳转到 <code>/nexus/</code> 路径下面去。</p>
<p>同样如果我们想要重定向到 https，只需要在该插件下面设置 <code>config.http_to_https=true</code> 即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ... 其他部分省略</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">http_to_https:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h2 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h2><p>通过使用上面的 <code>redirect</code> 插件配置 <code>http_to_https</code> 可以将请求重定向到 https 上去，但是我们现在并没有对我们的 <code>ops.qikqiak.com</code> 配置 https 证书，这里我们就需要使用 <code>ApisixTls</code> 对象来进行证书管理。</p>
<p>我们先使用 <code>openssl</code> 创建一个自签名的证书，当然你有正规 CA 机构购买的证书的话直接将证书下载下来使用即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj &quot;/CN=ops.qikqiak.com&quot;</span><br></pre></td></tr></table></figure>



<p>然后通过 Secret 对象来引用上面创建的证书文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要注意证书文件名称必须是 tls.crt 和 tls.key</span></span><br><span class="line">➜ kubectl create secret tls ops-tls --cert=tls.crt --key=tls.key</span><br></pre></td></tr></table></figure>



<p>然后就可以创建一个 <code>ApisixTls</code> 资源对象，引用上面的 Secret 即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixTls</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ops-tls</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">  <span class="attr">secret:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ops-tls</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>



<p>同时 APISIX TLS 还可以配置 <code>spec.client</code>，用于进行 mTLS 双向认证的配置。上面的资源对象创建完成后，即可访问 https 服务了（chrome 浏览器默认会限制不安全的证书，只需要在页面上输入 <code>thisisunsafe</code> 即可访问了）：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/tgrf70.png" alt="https"></p>
<p>而且当访问 http 的时候也会自动跳转到 https 上面去，此外我们还可以结合 cert-manager 来实现自动化的 https。</p>
<h2 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h2><p>身份认证在日常生活当中是非常常见的一项功能，大家平时基本都会接触到。比如用支付宝消费时的人脸识别确认、公司上班下班时的指纹&#x2F;面部打卡以及网站上进行账号密码登录操作等，其实都是身份认证的场景体现。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/nrmvoy.png" alt="auth"></p>
<p>如上图，Jack 通过账号密码请求服务端应用，服务端应用中需要有一个专门用做身份认证的模块来处理这部分的逻辑。请求处理完毕子后，如果使用 JWT Token 认证方式，服务器会反馈一个 Token 去标识这个用户为 Jack。如果登录过程中账号密码输入错误，就会导致身份认证失败。</p>
<p>但是每个应用服务模块去开发一个单独的身份认证模块，用来支持身份认证的一套流程处理，当服务量多了之后，就会发现这些模块的开发工作量都是非常巨大且重复的。这个时候，我们可以通过把这部分的开发逻辑放置到 Apache APISIX 的网关层来实现统一，减少开发量。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/xtuxsn.png" alt="apisix auth"></p>
<p>如上图所示，用户或应用方直接去请求 Apache APISIX，然后 Apache APISIX 通过识别并认证通过后，会将鉴别的身份信息传递到上游应用服务，之后上游应用服务就可以从请求头中读到这部分信息，然后进行后续的逻辑处理。</p>
<p>Apache APISIX 作为一个 API 网关，目前已开启与各种插件功能的适配合作，插件库也比较丰富。目前已经可与大量身份认证相关的插件进行搭配处理，如下图所示。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/rdea2v.png" alt="API 网关认证插件"></p>
<p>基础认证插件比如 <code>Key-Auth</code>、<code>Basic-Auth</code>，他们是通过账号密码的方式进行认证。复杂一些的认证插件如 <code>Hmac-Auth</code>、<code>JWT-Auth</code>，如 <code>Hmac-Auth</code> 通过对请求信息做一些加密，生成一个签名，当 API 调用方将这个签名携带到 Apache APISIX，Apache APISIX 会以相同的算法计算签名，只有当签名方和应用调用方认证相同时才予以通过。其他则是一些通用认证协议和联合第三方组件进行合作的认证协议，例如 <code>OpenID-Connect</code> 身份认证机制，以及 <code>LDAP</code> 认证等。</p>
<p>Apache APISIX 还可以针对每一个 Consumer （即调用方应用）去做不同级别的插件配置。如下图所示，我们创建了两个消费者 Consumer A、Consumer B，我们将 Consumer A 应用到应用 1，则后续应用 1 的访问将会开启 Consumer A 的这部分插件，例如 IP 黑白名单，限制并发数量等。将 Consumer B 应用到应用 2 ，由于开启了 http-log 插件，则应用 2 的访问日志将会通过 HTTP 的方式发送到日志系统进行收集。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/vy9bkn.png" alt="配置灵活"></p>
<p>总体说来 APISIX 的认证系统功能非常强大，我们非常有必要掌握。</p>
<h3 id="basic-auth"><a href="#basic-auth" class="headerlink" title="basic-auth"></a>basic-auth</h3><p>首先我们来了解下最简单的基本认证在 APISIX 中是如何使用的。<code>basic-auth</code> 是一个认证插件，它需要与 Consumer 一起配合才能工作。添加 Basic Auth 到一个 Service 或 Route，然后 Consumer 将其用户名和密码添加到请求头中以验证其请求。</p>
<p>首先我们需要在 APISIX Consumer 消费者中增加 basic auth 认证配置，为其指定用户名和密码，我们这里在 APISIX Ingress 中，可以通过 <code>ApisixConsumer</code> 资源对象进行配置，比如这里我们为前面的 nexus 实例应用添加一个基本认证，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nexus-basic-auth.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixConsumer</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexusBauth</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">authParameter:</span></span><br><span class="line">    <span class="attr">basicAuth:</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">admin321</span></span><br></pre></td></tr></table></figure>



<p><code>ApisixConsumer</code> 资源对象中只需要配置 <code>authParameter</code> 认证参数即可，目前只支持 <code>BasicAuth</code> 与 <code>KeyAuth</code> 两种认证类型，在 basicAuth 下面可以通过 value 可直接去配置相关的 username 和 password，也可以直接使用 Secret 资源对象进行配置，比起明文配置会更安全一些。</p>
<p>然后在 <code>ApisixRoute</code> 中添加 authentication，将其开启并指定认证类型即可，就可以实现使用 Consumer 去完成相关配置认证，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/service/*&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-rewrite</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^/nexus(/|$)(.*)&#x27;</span>, <span class="string">&#x27;/$2&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^(/nexus)$&#x27;</span>, <span class="string">&#x27;$1/&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">http_to_https:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br><span class="line">      <span class="attr">authentication:</span> <span class="comment"># 开启 basic auth 认证</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">basicAuth</span></span><br></pre></td></tr></table></figure>



<p>直接更新上面的资源即可开启 basic auth 认证了，在 Dashboard 上也可以看到创建了一个 Consumer：</p>
<p><img src="https://picdn.youdianzhishi.com/images/20220111160306.png" alt="consumer"></p>
<p>然后我们可以进行如下的测试来进行验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缺少 Authorization header</span></span><br><span class="line">➜ curl -i http://ops.qikqiak.com/nexus/</span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">Date: Tue, 11 Jan 2022 07:44:49 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">WWW-Authenticate: Basic realm=&#x27;.&#x27;</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line">&#123;&quot;message&quot;:&quot;Missing authorization in request&quot;&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户名不存在</span></span><br><span class="line">➜ curl -i -ubar:bar http://ops.qikqiak.com/nexus/</span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">Date: Tue, 11 Jan 2022 07:45:07 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line">&#123;&quot;message&quot;:&quot;Invalid user key in authorization&quot;&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">成功请求</span></span><br><span class="line">➜ curl -uadmin:admin321 http://ops.qikqiak.com/nexus/</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h3 id="consumer-restriction"><a href="#consumer-restriction" class="headerlink" title="consumer-restriction"></a>consumer-restriction</h3><p>不过这里大家可能会有一个疑问，在 Route 上面我们并没有去指定具体的一个 Consumer，然后就可以进行 Basic Auth 认证了，那如果我们有多个 Consumer 都定义了 Basic Auth 岂不是都会生效的？确实是这样的，这就是 APISIX 的实现方式，所有的 Consumer 对启用对应插件的 Route 都会生效的，如果我们只想 Consumer A 应用在 Route A、Consumer B 应用在 Route B 上面的话呢？要实现这个功能就需要用到另外一个插件：<a target="_blank" rel="noopener" href="https://apisix.apache.org/zh/docs/apisix/plugins/consumer-restriction/">consumer-restriction</a>。</p>
<p><code>consumer-restriction</code> 插件可以根据选择的不同对象做相应的访问限制，该插件可配置的属性如下表所示：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/9jz6xt.png" alt="consumer restriction"></p>
<p>其中的 type 字段是个枚举类型，它可以是 <code>consumer_name</code> 或 <code>service_id</code>，分别代表以下含义：</p>
<ul>
<li><code>consumer_name</code>：把 consumer 的 username 列入白名单或黑名单（支持单个或多个 consumer）来限制对服务或路由的访问。</li>
<li><code>service_id</code>：把 service 的 id 列入白名单或黑名单（支持一个或多个 service）来限制 service 的访问，需要结合授权插件一起使用。</li>
</ul>
<p>比如现在我们有两个 Consumer：jack1 和 jack2，这两个 Consumer 都配置了 Basic Auth 认证，配置如下所示：</p>
<p>Conumer <code>jack1</code> 的认证配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ curl http://192.168.31.46/apisix/admin/consumers -H &#x27;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#x27; -X PUT -i -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;: &quot;jack1&quot;,</span><br><span class="line">    &quot;plugins&quot;: &#123;</span><br><span class="line">        &quot;basic-auth&quot;: &#123;</span><br><span class="line">            &quot;username&quot;:&quot;jack2019&quot;,</span><br><span class="line">            &quot;password&quot;: &quot;123456&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>Conumer <code>jack2</code> 的认证配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ curl http://192.168.31.46/apisix/admin/consumers -H &#x27;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#x27; -X PUT -i -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;: &quot;jack2&quot;,</span><br><span class="line">    &quot;plugins&quot;: &#123;</span><br><span class="line">        &quot;basic-auth&quot;: &#123;</span><br><span class="line">            &quot;username&quot;:&quot;jack2020&quot;,</span><br><span class="line">            &quot;password&quot;: &quot;123456&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>现在我们只想给一个 Route 路由对象启用 jack1 这个 Consumer 的认证配置，则除了启用 <code>basic-auth</code> 插件之外，还需要在 <code>consumer-restriction</code> 插件中配置一个 <code>whitelist</code> 白名单（当然配置黑名单也是可以的），如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜ curl http://192.168.31.46/apisix/admin/routes/1 -H &#x27;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#x27; -X PUT -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;uri&quot;: &quot;/index.html&quot;,</span><br><span class="line">    &quot;upstream&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;roundrobin&quot;,</span><br><span class="line">        &quot;nodes&quot;: &#123;</span><br><span class="line">            &quot;127.0.0.1:1980&quot;: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;plugins&quot;: &#123;</span><br><span class="line">        &quot;basic-auth&quot;: &#123;&#125;,</span><br><span class="line">        &quot;consumer-restriction&quot;: &#123;</span><br><span class="line">            &quot;whitelist&quot;: [</span><br><span class="line">                &quot;jack1&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>然后我们使用 jack1 去访问我们的路由进行验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -u jack2019:123456 http://127.0.0.1:9080/index.html -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>正常使用 jack2 访问就会认证失败了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -u jack2020:123456 http://127.0.0.1:9080/index.html -i</span><br><span class="line">HTTP/1.1 403 Forbidden</span><br><span class="line">...</span><br><span class="line">&#123;&quot;message&quot;:&quot;The consumer_name is forbidden.&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>所以当你只想让一个 Route 对象关联指定的 Consumer 的时候，记得使用 <code>consumer-restriction</code> 插件。</p>
<h3 id="jwt-auth"><a href="#jwt-auth" class="headerlink" title="jwt-auth"></a>jwt-auth</h3><p>在平时的应用中可能使用 jwt 认证的场景是最多的，同样在 APISIX 中也有提供 <code>jwt-auth</code> 的插件，它同样需要与 Consumer 一起配合才能工作，我们只需要添加 JWT Auth 到一个 Service 或 Route，然后 Consumer 将其密钥添加到查询字符串参数、请求头或 cookie 中以验证其请求即可。</p>
<p>由于目前 <code>ApisixConsumer</code> 还不支持 <code>jwt-auth</code> 配置，所以需要我们去 APISIX 手动创建一个 Consumer，可以通过 APISIX 的 API 进行创建，当然也可以直接通过 Dashboard 页面操作。在 Dashboard 消费者页面点击创建消费者：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/9z7ow8.png" alt="创建消费者"></p>
<p>点击<strong>下一步</strong>进入插件配置页面，这里我们需要启用 <code>jwt-auth</code> 这个插件：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/d2aie8.png" alt="启用jwt-auth"></p>
<p>在插件配置页面配置 <code>jwt-auth</code> 相关属性，可参考插件文档 <a target="_blank" rel="noopener" href="https://apisix.apache.org/zh/docs/apisix/plugins/jwt-auth/">https://apisix.apache.org/zh/docs/apisix/plugins/jwt-auth/</a>:</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/2p2o90.png" alt="配置jwt-auth"></p>
<p>可配置的属性如下表所示：</p>
<p><img src="https://picdn.youdianzhishi.com/images/20220111184501.png" alt="jwt 属性"></p>
<p>然后提交即可创建完成 Consumer，然后我们只需要在需要的 Service 或者 Route 上开启 <code>jwt-auth</code> 即可，比如同样还是针对上面的 nexus 应用，我们只需要在 <code>ApisixRoute</code> 对象中启用一个 <code>jwt-auth</code> 插件即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/nexus*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/static/*&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/service/*&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jwt-auth</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">http_to_https:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redirect</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^(/nexus)$&#x27;</span>, <span class="string">&#x27;$1/&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-rewrite</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">regex_uri:</span> [<span class="string">&#x27;^/nexus(/|$)(.*)&#x27;</span>, <span class="string">&#x27;/$2&#x27;</span>]</span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>需要注意的是 <code>authentication</code> 属性也不支持 <code>jwt-auth</code>，所以这里我们通过 <code>plugins</code> 进行启用，重新更新上面的对象后我们同样来测试验证下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://ops.qikqiak.com/nexus/</span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">Date: Tue, 11 Jan 2022 08:54:30 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line">&#123;&quot;message&quot;:&quot;Missing JWT token in request&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>要正常访问我们的服务就需要先进行登录获取 <code>jwt-auth</code> 的 token，通过 APISIX 的 <code>apisix/plugin/jwt/sign</code> 可以获取：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://192.168.31.46/apisix/plugin/jwt/sign\?key\=user-key</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 11 Jan 2022 09:01:29 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJ1c2VyLWtleSIsImV4cCI6MTY0MTk3ODA4OX0.rdzMxM4QAKI444c3SC3u3ZqfW9rKnsqrdorLHCGqrQg</span><br></pre></td></tr></table></figure>



<p>要注意上面我们在获取 token 的时候需要传递创建消费者的标识 key，因为可能有多个不同的 Consumer 消费者，然后我们将上面获得的 token 放入到 Header 头中进行访问：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://ops.qikqiak.com/nexus/ -H &#x27;Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJ1c2VyLWtleSIsImV4cCI6MTY0MTk3ODA4OX0.rdzMxM4QAKI444c3SC3u3ZqfW9rKnsqrdorLHCGqrQg&#x27;</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 8802</span><br><span class="line">Connection: keep-alive</span><br><span class="line">......</span><br><span class="line">Expires: 0</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>可以看到可以正常访问。同样也可以放到请求参数中验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://ops.qikqiak.com/nexus/?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJ1c2VyLWtleSIsImV4cCI6MTY0MTk3ODA4OX0.rdzMxM4QAKI444c3SC3u3ZqfW9rKnsqrdorLHCGqrQg</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>此外还可以放到 cookie 中进行验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://ops.qikqiak.com/nexus/ --cookie jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJ1c2VyLWtleSIsImV4cCI6MTY0MTk3ODA4OX0.rdzMxM4QAKI444c3SC3u3ZqfW9rKnsqrdorLHCGqrQg</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h2 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h2><p>除了 APISIX 官方内置的插件之外，我们也可以根据自己的需求去自定义插件，要自定义插件需要使用到 APISIX 提供的 Runner，目前已经支持 Java、Go 和 Python 语言的 Runner，这个 Runner 相当于是 APISIX 和自定义插件之间的桥梁，比如 <code>apache-apisix-python-runner</code> 这个项目通过 Python Runner 可以把 Python 直接应用到 APISIX 的插件开发中，整体架构如下所示：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/sr199a.png" alt="Apache APISIX work flow"></p>
<p>左边是 APISIX 的工作流程，右边的 <code>Plugin Runner</code> 是各语言的插件运行器，当在 APISIX 中配置一个 Plugin Runner 时，APISIX 会启动一个子进程运行 Plugin Runner，该子进程与 APISIX 进程属于同一个用户，当我们重启或重新加载 APISIX 时，Plugin Runner 也将被重启。</p>
<p>如果你为一个给定的路由配置了 <code>ext-plugin-*</code> 插件，请求命中该路由时将触发 APISIX 通过 <code>Unix Socket</code> 向 Plugin Runner 发起 RPC 调用。调用分为两个阶段：</p>
<ul>
<li><code>ext-plugin-pre-req</code>：在执行 APISIX 内置插件之前</li>
<li><code>ext-plugin-post-req</code>：在执行 APISIX 内置插件之后</li>
</ul>
<p>接下来我们就以 Python 为例来说明如何自定义插件，首先获取 <code>apache-apisix-python-runner</code> 项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ git clone https://github.com/apache/apisix-python-plugin-runner.git</span><br><span class="line">➜ cd apisix-python-plugin-runner</span><br><span class="line">➜ git checkout 0.1.0  # 切换刀0.1.0版本</span><br></pre></td></tr></table></figure>



<p>如果是开发模式，则我们可以直接使用下面的命令启动 Python Runner：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ APISIX_LISTEN_ADDRESS=unix:/tmp/runner.sock python3 apisix/main.py start</span><br></pre></td></tr></table></figure>



<p>启动后需要在 APISIX 配置文件中新增外部插件配置，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ vim /path/to/apisix/conf/config.yaml</span><br><span class="line">apisix:</span><br><span class="line">  admin_key:</span><br><span class="line">    - name: &quot;admin&quot;</span><br><span class="line">      key: edd1c9f034335f136f87ad84b625c8f1</span><br><span class="line">      role: admin</span><br><span class="line"></span><br><span class="line">ext-plugin:</span><br><span class="line">  path_for_test: /tmp/runner.sock</span><br></pre></td></tr></table></figure>



<p>通过 <code>ext-plugin.path_for_test</code> 指定 Python Runner 的 unix socket 文件路径即可，如果是生产环境则可以通过 <code>ext-plugin.cmd</code> 来指定 Runner 的启动命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ext-plugin:</span><br><span class="line">  cmd: [ &quot;python3&quot;, &quot;/path/to/apisix-python-plugin-runner/apisix/main.py&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure>



<p>我们这里的 APISIX 是运行 Kubernetes 集群中的，所以要在 APISIX 的 Pod 中去执行 Python Runner 的代码，我们自然需要将我们的 Python 代码放到 APISIX 的容器中去，然后安装自定义插件的相关依赖，直接在 APISIX 配置文件中添加上面的配置即可，所以我们这里基于 APISIX 的镜像来重新定制包含插件的镜像，在 <code>apisix-python-plugin-runner</code> 项目根目录下新增如下所示的 Dockerfile 文件：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> apache/apisix:<span class="number">2.10</span>.<span class="number">0</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /apisix-python-plugin-runner</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --update python3 py3-pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cd</span> /apisix-python-plugin-runner &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 -m pip install --upgrade pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 -m pip install -r requirements.txt --ignore-installed &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 setup.py install --force</span></span><br></pre></td></tr></table></figure>



<p>基于上面 Dockerfile 构建一个新的镜像，推送到 Docker Hub：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ docker build -t cnych/apisix:py3-plugin-2.10.0-alpine .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送到DockerHub</span></span><br><span class="line">➜ docker push cnych/apisix:py3-plugin-2.10.0-alpine</span><br></pre></td></tr></table></figure>



<p>接下来我们需要使用上面构建的镜像来安装 APISIX，我们这里使用的是 Helm Chart 进行安装的，所以需要通过 Values 文件进行覆盖，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ci/prod.yaml</span></span><br><span class="line"><span class="attr">apisix:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">cnych/apisix</span></span><br><span class="line">    <span class="attr">tag:</span> <span class="string">py3-plugin-2.10.0-alpine</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>



<p>由于官方的 Helm Chart 没有提供对 <code>ext-plugin</code> 配置的支持，所以需要我们手动修改模板文件 <code>templates/configmap.yaml</code>，在 <code>apisix</code> 属性同级目录下面新增 <code>ext-plugin</code> 相关配置，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.extPlugins.enabled</span> &#125;&#125;</span><br><span class="line"><span class="attr">ext-plugin:</span></span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.extPlugins.pathForTest</span> &#125;&#125;</span><br><span class="line">  <span class="attr">path_for_test:</span> &#123;&#123; <span class="string">.Values.extPlugins.pathForTest</span> &#125;&#125;</span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.extPlugins.cmds</span> &#125;&#125;</span><br><span class="line">  <span class="attr">cmd:</span></span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">range</span> <span class="string">$cmd</span> <span class="string">:=</span> <span class="string">.Values.extPlugins.cmds</span> &#125;&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;&#123; <span class="string">$cmd</span> &#125;&#125;</span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">  &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">nginx_config:</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">root</span>  <span class="comment"># fix 执行 python runner没权限的问题</span></span><br></pre></td></tr></table></figure>



<p>然后在定制的 Values 文件中添加如下所示的配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ci/prod.yaml</span></span><br><span class="line"><span class="attr">extPlugins:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cmds:</span> [<span class="string">&#x27;python3&#x27;</span>, <span class="string">&#x27;/apisix-python-plugin-runner/apisix/main.py&#x27;</span>, <span class="string">&#x27;start&#x27;</span>]</span><br></pre></td></tr></table></figure>



<p>接着就可以重新部署 APISIX 了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ helm upgrade --install apisix ./apisix -f ./apisix/ci/prod.yaml -n apisix</span><br></pre></td></tr></table></figure>



<p>部署完成后在 APISIX 的 Pod 中可以看到会启动一个 Python Runner 的子进程：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/tg916o.png" alt="apisix top"></p>
<p>在插件目录 <code>/apisix-python-plugin-runner/apisix/plugins</code> 中的 <code>.py</code> 文件都会被自动加载，上面示例中有两个插件 <code>stop.py</code> 和 <code>rewrite.py</code>，我们以 <code>stop.py</code> 为例进行说明，该插件代码如下所示：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apisix.runner.plugin.base <span class="keyword">import</span> Base</span><br><span class="line"><span class="keyword">from</span> apisix.runner.http.request <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> apisix.runner.http.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stop</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Stop, <span class="variable language_">self</span>).__init__(<span class="variable language_">self</span>.__class__.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">self, request: Request, response: Response</span>):</span><br><span class="line">        <span class="comment"># 可以通过 `self.config` 获取配置信息，如果插件配置为JSON将自动转换为字典结构</span></span><br><span class="line">        <span class="comment"># print(self.config)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置响应 Header 头</span></span><br><span class="line">        response.headers[<span class="string">&quot;X-Resp-A6-Runner&quot;</span>] = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        <span class="comment"># 设置响应body</span></span><br><span class="line">        response.body = <span class="string">&quot;Hello, Python Runner of APISIX&quot;</span></span><br><span class="line">        <span class="comment"># 设置响应状态码</span></span><br><span class="line">        response.status_code = <span class="number">201</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过调用 `self.stop()` 中断请求流程，此时将立即响应请求给客户端</span></span><br><span class="line">        <span class="comment"># 如果未显示调用 `self.stop()` 或 显示调用 `self.rewrite()`将继续将请求</span></span><br><span class="line">        <span class="comment"># 默认为 `self.rewrite()`</span></span><br><span class="line">        <span class="variable language_">self</span>.stop()</span><br></pre></td></tr></table></figure>



<p>实现插件首先必须要继承 <code>Base</code> 类，必须实现 <code>filter</code> 函数，插件执行核心业务逻辑就是在 <code>filter</code> 函数中，该函数只包含 <code>Request</code> 和 <code>Response</code> 类对象作为参数，<code>Request</code> 对象参数可以获取请求信息，<code>Response</code> 对象参数可以设置响应信息 ，<code>self.config</code> 可以获取插件配置信息，在 <code>filter</code> 函数中调用 <code>self.stop()</code> 时将马上中断请求，响应数据，调用 <code>self.rewrite()</code> 时，将会继续请求。</p>
<p>然后我们在前面的 Nexus 应用中新增一个路由来测试我们上面的 <code>stop</code> 插件，在 <code>ApisixRoute</code> 对象中新增一个路由规则，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apisix.apache.org/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ApisixRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nexus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ext</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">hosts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ops.qikqiak.com</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;/extPlugin&#x27;</span></span><br><span class="line">      <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ext-plugin-pre-req</span> <span class="comment"># 启用ext-plugin-pre-req插件</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">conf:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;stop&#x27;</span> <span class="comment"># 使用 stop 这个自定义插件</span></span><br><span class="line">                <span class="attr">value:</span> <span class="string">&#x27;&#123;&quot;body&quot;:&quot;hello&quot;&#125;&#x27;</span></span><br><span class="line">      <span class="attr">backends:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">serviceName:</span> <span class="string">nexus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>



<p>直接创建上面的路由即可，核心配置是启用 <code>ext-plugin-pre-req</code> 插件（前提是在配置文件中已经启用该插件，在 Helm Chart 的 Values 中添加上），然后在 <code>config</code> 下面使用 <code>conf</code> 属性进行配置，<code>conf</code> 为数组格式可以同时设置多个插件，插件配置对象中 <code>name</code> 为插件名称，该名称需要与插件代码文件和对象名称一致，<code>value</code> 为插件配置，可以为 JSON 字符串。</p>
<p>创建后同样在 Dashboard 中也可以看到 APISIX 中的路由配置格式：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/z8tq8g.png" alt="apisix ext plugin"></p>
<p>接着我们可以来访问 <code>http://ops.qikqiak.com/extPlugin</code> 这个路径来验证我们的自定义插件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -i http://ops.qikqiak.com/extPlugin</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Thu, 13 Jan 2022 07:04:50 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">accept: */*</span><br><span class="line">user-agent: curl/7.64.1</span><br><span class="line">host: ops.qikqiak.com</span><br><span class="line">X-Resp-A6-Runner: Python</span><br><span class="line">Server: APISIX/2.10.0</span><br><span class="line"></span><br><span class="line">Hello, Python Runner of APISIX</span><br></pre></td></tr></table></figure>



<p>访问请求结果中有一个 <code>X-Resp-A6-Runner: Python</code> 头信息，返回的 body 数据为 <code>Hello, Python Runner of APISIX</code>，和我们在插件中的定义是符合的。到这里就完成了使用 Python 进行 APISIX 自定义插件，我们有任何的业务逻辑需要处理直接去定义一个对应的插件即可。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/APISIX/">http://example.com/2025/09/11/APISIX/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/ARP%E5%8D%8F%E8%AE%AE/" title="ARP协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ARP协议</div></div><div class="info-2"><div class="info-item-1">好的，我们来详细了解一下 ARP 和 RARP。  1. ARP (Address Resolution Protocol) - 地址解析协议作用： 将网络层（IP 地址） 地址解析为数据链路层（MAC 地址） 的协议。 应用场景：当一个主机想与同一局域网内的另一个主机进行通信时，它知道目标主机的 IP 地址，但数据链路层（如以太网）需要目标主机的 MAC 地址来封装帧。此时就需要 ARP 来完成 IP 到 MAC 的映射。 工作原理（简化流程）：  ARP 请求： 主机 A（已知主机 B 的 IP 地址）希望获取主机 B 的 MAC 地址，它会构建一个 ARP 请求报文，其中包含自己的 IP 地址和 MAC 地址，以及目标主机 B 的 IP 地址。 广播： 主机 A 将这个 ARP 请求报文封装在一个以太网帧中，并将目的 MAC 地址设置为广播地址（FFFF.FFFF.FFFF），然后发送到局域网中。 接收与响应： 局域网中的所有主机都会收到这个广播帧。 每个主机都会检查 ARP 请求报文中的目标 IP 地址是否是自己的 IP 地址。 只有目标主机 B 会识别出这个 IP 地址...</div></div></div></a><a class="pagination-related" href="/2025/09/11/AMQP%E5%8D%8F%E8%AE%AE/" title="AMQP协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">AMQP协议</div></div><div class="info-2"><div class="info-item-1">好的，当然。AMQP（Advanced Message Queuing Protocol），即高级消息队列协议，是一个网络协议，用于在应用程序或系统之间传递消息。你可以把它理解为消息中间件领域的 “HTTP” 或 “SMTP”。它不是一个具体的软件（像 RabbitMQ），而是一个开放标准，定义了消息应该如何产生、传输、路由和消费。 作为一名运维工程师，我们经常接触到 RabbitMQ，而 RabbitMQ 就是 AMQP 协议最著名、最完整的实现者。理解 AMQP 能帮助我们更好地配置、监控和排查与消息队列相关的问题。 AMQP 的核心思想：解耦和异步AMQP 的主要目标是解决两个核心问题：  解耦 (Decoupling): 消息的发送方（生产者）和接收方（消费者）不需要知道对方的存在，它们只需要与中间的消息代理（Broker）通信。这使得系统组件可以独立开发、部署和扩展。 异步 (Asynchronicity): 生产者发送消息后，不需要等待消费者处理完毕。消息会暂存在 Broker 中，消费者可以在自己方便的时候去获取和处理。这大大提高了系统的响应速度和吞吐量。  AMQ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/" title="局部变量"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">局部变量</div></div><div class="info-2"><div class="info-item-1">您好！这是一个非常核心且有深度的 Go 语言问题。作为后端开发专家，我来为您详细解析。 简短的答案是：Go 语言中的局部变量分配在哪里（栈或堆），不是由开发者决定的，而是由 Go 编译器在编译时通过“逃逸分析”（Escape Analysis）来决定的。 开发者编写代码时，可以认为所有局部变量都优先分配在栈（Stack）上。只有在编译器证明一个变量的生命周期需要在其声明的函数返回后依然有效时，这个变量才会“逃逸”（escape）到堆（Heap）上。  1. 为什么优先分配在栈上？栈是为函数调用而设计的一种内存区域，具有以下显著优势：  极高的分配和回收效率： 栈内存的分配和回收仅仅是移动栈指针（SP），这是一个非常快速的 CPU 指令。当函数调用时，栈帧（stack frame）被压入栈；函数返回时，栈帧被弹出。整个过程无需复杂的内存管理和垃圾回收（GC）介入。 低 GC 压力： 因为栈上的内存在函数返回时自动回收，所以垃圾回收器不需要扫描栈上的对象，这大大减轻了 GC 的负担，提升了程序性能。 更好的缓存局部性： 栈内存通常是连续的，更容易被 CPU 缓存命中，从而提高访问速度...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Go%20struct%20%E5%8F%AF%E4%BB%A5%E6%AF%94%E8%BE%83%E5%90%97/" title="Go struct 可以比较吗"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Go struct 可以比较吗</div></div><div class="info-2"><div class="info-item-1">这是一个非常重要的 Go 语言基础问题。答案是：并非所有 struct 都可以比较。  Go 语言中 Struct 的可比较性规则✅ 可比较 (Comparable) 的 Struct一个 struct 只有在它的所有字段都是可比较类型时，它本身才是可比较的。 可比较的类型包括：  布尔值 数值类型（int, float32, complex64 等） 字符串 指针 通道 (channel) 接口类型 结构体（当其所有字段都可比较时） 数组（当其元素类型可比较时）  示例 1：可比较的 Struct 123456789101112type Person struct &#123;    Name string    Age  int&#125;func main() &#123;    p1 := Person&#123;Name: &quot;Alice&quot;, Age: 30&#125;    p2 := Person&#123;Name: &quot;Alice&quot;, Age: 30&#125;      // 可以直接比较    fmt.Println(p1...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%A4%9A%E5%80%BC%E8%BF%94%E5%9B%9E/" title="多值返回"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">多值返回</div></div><div class="info-2"><div class="info-item-1">多值返回 (Multiple Return Values) 是其最独特且强大的特性之一，它深刻影响了 Go 程序的风格、错误处理机制和 API 设计。它的“意义”在于解决了传统编程语言中一些常见的痛点，并带来了诸多便利。 作为一名后端开发专家，我将为您详细阐述 Go 语言多值返回的用途和其背后的设计哲学。 1. 核心理念：显式的错误处理这是 Go 语言多值返回最常见、也最重要的用途。 在许多其他语言中，错误处理通常依赖于异常（Exceptions）：当发生错误时，函数会抛出异常，中止当前执行流程，并将控制权转移到最近的 try-catch 块。虽然这在某些情况下很方便，但也可能导致：  隐藏的控制流： 调用者可能不知道某个函数会抛出异常，或者忘记捕获。 性能开销： 异常处理机制通常伴随着性能开销。 不明确的 API： 函数签名无法直接体现它可能抛出的所有异常。  Go 语言拒绝了异常机制，转而采用显式的、基于返回值的错误处理。一个函数通常会返回两个值：  结果值 (Result Value): 如果操作成功，这是您期望得到的值。 错误值 (Error Value): 如果操作失败...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%A9%BAstruct%7B%7D/" title="Go 语言中空struct{}"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Go 语言中空struct{}</div></div><div class="info-2"><div class="info-item-1">您好，这是一个非常深刻的问题，对 struct&#123;&#125; 的理解直接反映了对 Go 语言内存模型和设计哲学的掌握程度。 核心答案：struct&#123;&#125; 是一个不包含任何字段的结构体类型，它的关键特性是其实例（value）不占用任何内存空间（大小为零）。 正因为这个特性，它在 Go 中被广泛用作一个“信号”或“占位符”，我们只关心它的存在，而完全不关心它的值。 我们可以通过 unsafe.Sizeof 来验证它的大小： 1234567891011package mainimport (	&quot;fmt&quot;	&quot;unsafe&quot;)func main() &#123;	var emptyStruct struct&#123;&#125;	fmt.Printf(&quot;空 struct&#123;&#125; 的大小是: %d 字节\n&quot;, unsafe.Sizeof(emptyStruct)) // 输出: 空 struct&#123;&#125; 的大小是: 0 字节&#125;  这 0 字节的特性，使其在以下...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Dockerfile%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="Dockerfile 最佳实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Dockerfile 最佳实践</div></div><div class="info-2"><div class="info-item-1">Dockerfile 最佳实践Docker官方关于Dockerfile最佳实践原文链接地址：https://docs.docker.com/develop/develop-images/dockerfile_best-practices/ Docker可以通过从Dockerfile包含所有命令的文本文件中读取指令自动构建镜像，以便构建给定镜像。 Dockerfiles使用特定的格式并使用一组特定的指令。您可以在 Dockerfile Reference 页面上了解基础知识 。如果你是新手写作Dockerfile，你应该从那里开始。 本文档介绍了由 Docker，Inc. 和 Docker 社区推荐的用于构建高效镜像的最佳实践和方法。要查看更多实践和建议，请查看 Dockerfile for buildpack-deps。 一般准则和建议容器应该是短暂的通过 Dockerfile 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。我们可以查看下12 Factor(12要素)应用程序方法...</div></div></div></a><a class="pagination-related" href="/2025/09/11/categraf/" title="categraf"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">categraf</div></div><div class="info-2"><div class="info-item-1">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115[global]# whether print configsprint_configs = false# add label(agent_hostname) to series# &quot;&quot; -&gt; auto detect hostname# &quot;xx&quot; -&gt; use specified string xx# &quot;$hostname&quot; -&gt; auto detect hostname# &quot;$ip&quot; -&gt; auto detec...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#APISIX"><span class="toc-number">1.</span> <span class="toc-text">APISIX</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#APISIX-Ingress"><span class="toc-number">1.1.</span> <span class="toc-text">APISIX Ingress</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dashboard"><span class="toc-number">1.3.</span> <span class="toc-text">Dashboard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL-Rewrite"><span class="toc-number">1.4.</span> <span class="toc-text">URL Rewrite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redirect"><span class="toc-number">1.5.</span> <span class="toc-text">redirect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tls"><span class="toc-number">1.6.</span> <span class="toc-text">tls</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auth"><span class="toc-number">1.7.</span> <span class="toc-text">auth</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basic-auth"><span class="toc-number">1.7.1.</span> <span class="toc-text">basic-auth</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consumer-restriction"><span class="toc-number">1.7.2.</span> <span class="toc-text">consumer-restriction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jwt-auth"><span class="toc-number">1.7.3.</span> <span class="toc-text">jwt-auth</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6"><span class="toc-number">1.8.</span> <span class="toc-text">自定义插件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>