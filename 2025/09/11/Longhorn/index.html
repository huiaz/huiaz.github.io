<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Longhorn | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Longhorn前面我们学习了本地存储、NFS 共享存储，除了这些存储类型之外，还有一个块存储，同样为 Kubernetes 提供块存储的方案有很多，比如 Ceph RBD，今天我们为大家介绍的是 Rancher 开源的一款 Kubernetes 的云原生分布式块存储方案 - Longhorn。 使用 Longhorn，可以：  使用 Longhorn 卷作为 Kubernetes 集群中分布式有">
<meta property="og:type" content="article">
<meta property="og:title" content="Longhorn">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/Longhorn/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="Longhorn前面我们学习了本地存储、NFS 共享存储，除了这些存储类型之外，还有一个块存储，同样为 Kubernetes 提供块存储的方案有很多，比如 Ceph RBD，今天我们为大家介绍的是 Rancher 开源的一款 Kubernetes 的云原生分布式块存储方案 - Longhorn。 使用 Longhorn，可以：  使用 Longhorn 卷作为 Kubernetes 集群中分布式有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:48:54.237Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Longhorn",
  "url": "https://huiaz.github.io/2025/09/11/Longhorn/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:48:54.237Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/Longhorn/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Longhorn',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Longhorn</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Longhorn</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:48:54.237Z" title="更新于 2025-09-11 21:48:54">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E5%AD%98%E5%82%A8/">存储</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Longhorn"><a href="#Longhorn" class="headerlink" title="Longhorn"></a>Longhorn</h1><p>前面我们学习了本地存储、NFS 共享存储，除了这些存储类型之外，还有一个块存储，同样为 Kubernetes 提供块存储的方案有很多，比如 Ceph RBD，今天我们为大家介绍的是 Rancher 开源的一款 Kubernetes 的云原生分布式块存储方案 - Longhorn。</p>
<p>使用 Longhorn，可以：</p>
<ul>
<li>使用 Longhorn 卷作为 Kubernetes 集群中分布式有状态应用程序的持久存储</li>
<li>将你的块存储分区为 Longhorn 卷，以便你可以在有或没有云提供商的情况下使用 Kubernetes 卷</li>
<li>跨多个节点和数据中心复制块存储以提高可用性</li>
<li>将备份数据存储在 NFS 或 AWS S3 等外部存储中</li>
<li>创建跨集群灾难恢复卷，以便可以从第二个 Kubernetes 集群中的备份中快速恢复主 Kubernetes 集群中的数据</li>
<li>调度一个卷的快照，并将备份调度到 NFS 或 S3 兼容的二级存储</li>
<li>从备份还原卷</li>
<li>不中断持久卷的情况下升级 Longhorn</li>
</ul>
<p>Longhorn 还带有独立的 UI，可以使用 Helm、kubectl 或 Rancher 应用程序目录进行安装。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Longhorn 为每个卷创建一个专用的存储控制器，并在多个节点上存储的多个副本之间同步复制该卷。Longhorn 在整体上分为两层：<strong>数据平面和控制平面</strong>，Longhorn Engine 是存储控制器，对应数据平面，Longhorn Manager 对应控制平面。</p>
<p>Longhorn Manager 会以 DaemonSet 的形式在 Longhorn 集群中的每个节点上运行，它负责在 Kubernetes 集群中创建和管理卷，并处理来自 UI 或 Kubernetes 卷插件的 API 调用，它是遵循 Kubernetes 控制器模式。</p>
<p>Longhorn Manager 通过与 Kubernetes APIServer 通信来创建新的 Longhorn volume CRD，然后 Longhorn Manager 会一直 Watch APIServer 的响应，当它看到发现创建了一个新的 Longhorn volume CRD 时，Longhorn Manager 就会去创建一个新的对应卷。当 Longhorn Manager 被要求创建一个卷时，它会在卷所连接的节点上创建一个 Longhorn Engine 实例，并在每个将放置副本的节点上创建一个副本，副本应放置在不同的主机上以确保最大可用性。副本的多条数据路径确保了 Longhorn 卷的高可用性，即使某个副本或引擎出现问题，也不会影响所有副本或 Pod 对卷的访问。</p>
<p>Longhorn Engine 始终与使用 Longhorn 卷的 Pod 在同一节点中运行，它在存储在多个节点上的多个副本之间同步复制卷。</p>
<p>如下图所示，描述了 Longhorn 卷、Longhorn Engine、副本实例和磁盘之间的读&#x2F;写数据流:</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/recuan.png" alt="卷、Longhorn Engine、副本实例和磁盘之间的读/写数据流"></p>
<ul>
<li>上图中有 3 个 Longhorn 卷实例</li>
<li>每个卷都有一个专用控制器，称为 Longhorn Engine，并作为 Linux 进程运行</li>
<li>每个 Longhorn 卷有两个副本，每个副本也是一个 Linux 进程</li>
<li>图中的箭头表示卷、控制器实例、副本实例和磁盘之间的读&#x2F;写数据流</li>
<li>通过为每个卷创建单独的 Longhorn Engine，如果一个控制器发生故障，其他卷的功能不会受到影响</li>
</ul>
<blockquote>
<p>注意: 图中的 Engine 并非是单独的一个 Pod，而是每一个 Volume 会对应一个 golang exec 出来的 Linux 进程</p>
</blockquote>
<p>在 Longhorn 中，每个 Engine 只需要服务一个卷，简化了存储控制器的设计，由于控制器软件的故障域与单个卷隔离，因此控制器崩溃只会影响一个卷。由于 Longhorn Engine 足够简单和轻便，因此我们可以创建多达 100000 个独立的 Engine，Kubernetes 去调度这些独立的 Engine，从一组共享的磁盘中提取资源，并与 Longhorn 合作形成一个弹性的分布式块存储系统。</p>
<p>因为每个卷都有自己的控制器，所以每个卷的控制器和副本实例也可以升级，而不会导致 IO 操作明显中断。Longhorn 可以创建一个长时间运行的 job 任务来协调所有卷的升级，而不会中断系统的运行。</p>
<p>Longhorn 是通过 CSI 驱动在 Kubernetes 中管理的，CSI 驱动通过调用 Longhorn 来创建卷，为 Kubernetes 工作负载创建持久性数据，CSI 插件可以让我们创建、删除、附加、分离、挂载卷，并对卷进行快照操作，Kubernetes 集群内部使用 CSI 接口与 Longhorn CSI 驱动进行通信，而 Longhorn CSI 驱动是通过使用 Longhorn API 与 Longhorn Manager 进行通信。</p>
<p>此外 Longhorn 还提供一个 UI 界面程序，通过 Longhorn API 与 Longhorn Manager 进行交互，通过 Longhorn UI 可以管理快照、备份、节点和磁盘等，此外，集群工作节点的空间使用情况还可以通过 Longhorn UI 查看。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要在 Kubernetes 集群上安装 Longhorn，需要集群的每个节点都必须满足以下要求：</p>
<ul>
<li>与 Kubernetes 兼容的容器运行时（Docker v1.13+、containerd v1.3.7+ 等）</li>
<li>Kubernetes v1.18+</li>
<li>安装 <code>open-iscsi</code>，并且 <code>iscsid</code> 守护程序在所有节点上运行，这是必要的，因为 Longhorn 依赖主机上的 <code>iscsiadm</code> 为 Kubernetes 提供持久卷</li>
<li>RWX 支持需要每个节点上都安装 NFSv4 客户端</li>
<li>宿主机文件系统支持 <code>file extents</code> 功能来存储数据，目前我们支持：ext4 与 XFS</li>
<li>bash、curl、findmnt、grep、awk、blkid、lsblk 等工具必须安装</li>
<li><code>Mount propagation</code> 必须启用，它允许将一个容器挂载的卷与同一 pod 中的其他容器共享，甚至可以与同一节点上的其他 pod 共享</li>
</ul>
<p>Longhorn workloads 必须能够以 root 身份运行才能正确部署和操作 Longhorn。</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>为了验证这些环境要求，Longhorn 官方提供了一个脚本来帮助我们进行检查，执行该脚本需要在本地安装 <code>jq</code> 工具，执行下面的命令即可运行脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -sSfL https://raw.githubusercontent.com/longhorn/longhorn/v1.2.3/scripts/environment_check.sh | bash</span><br><span class="line">daemonset.apps/longhorn-environment-check created</span><br><span class="line">waiting for pods to become ready (0/2)</span><br><span class="line">waiting for pods to become ready (0/2)</span><br><span class="line">all pods ready (2/2)</span><br><span class="line"></span><br><span class="line">  MountPropagation is enabled!</span><br><span class="line"></span><br><span class="line">cleaning up...</span><br><span class="line">daemonset.apps &quot;longhorn-environment-check&quot; deleted</span><br><span class="line">clean up complete</span><br></pre></td></tr></table></figure>



<p>如果没有检查通过会给出相关的提示信息。</p>
<p>要安装 <code>open-iscsi</code>，可以直接使用下面的命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt-get install open-iscsi  <span class="comment"># Debian 和 Ubuntu 系统命令</span></span></span><br><span class="line">➜ yum install -y iscsi-initiator-utils</span><br></pre></td></tr></table></figure>



<p>Longhorn 官方还为我们还提供了一个 iscsi 安装程序，可以更轻松地自动安装 <code>open-iscsi</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/v1.2.3/deploy/prerequisite/longhorn-iscsi-installation.yaml</span><br></pre></td></tr></table></figure>



<p>部署完成后，运行以下命令来检查安装程序的 pod 状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pod | grep longhorn-iscsi-installation</span><br><span class="line">longhorn-iscsi-installation-49hd7   1/1     Running   0          21m</span><br><span class="line">longhorn-iscsi-installation-pzb7r   1/1     Running   0          39m</span><br></pre></td></tr></table></figure>



<p>也可以通过以下命令查看日志，查看安装结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl logs longhorn-iscsi-installation-pzb7r -c iscsi-installation</span><br><span class="line">...</span><br><span class="line">Installed:</span><br><span class="line">  iscsi-initiator-utils.x86_64 0:6.2.0.874-7.amzn2</span><br><span class="line"></span><br><span class="line">Dependency Installed:</span><br><span class="line">  iscsi-initiator-utils-iscsiuio.x86_64 0:6.2.0.874-7.amzn2</span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/iscsid.service to /usr/lib/systemd/system/iscsid.service.</span><br><span class="line">iscsi install successfully</span><br></pre></td></tr></table></figure>



<p>同样要安装 NFSv4 客户端，可以直接使用下面的命令一键安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt-get install nfs-common  <span class="comment">#  Debian 和 Ubuntu 系统命令</span></span></span><br><span class="line">➜ yum install nfs-utils</span><br></pre></td></tr></table></figure>



<p>同样 Longhorn 官方也提供了一个 nfs 客户端安装程序，可以更轻松地自动安装 nfs-client：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/v1.2.3/deploy/prerequisite/longhorn-nfs-installation.yaml</span><br></pre></td></tr></table></figure>



<p>部署完成后，运行以下命令来检查安装程序的 pod 状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pod | grep longhorn-nfs-installation</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">longhorn-nfs-installation-t2v9v   1/1     Running   0          143m</span><br><span class="line">longhorn-nfs-installation-7nphm   1/1     Running   0          143m</span><br></pre></td></tr></table></figure>



<p>也可以通过以下命令查看日志，查看安装结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl logs longhorn-nfs-installation-t2v9v -c nfs-installation</span><br><span class="line">...</span><br><span class="line">nfs install successfully</span><br></pre></td></tr></table></figure>



<p>相关依赖环境准备好过后就可以开始安装 Longhorn 了。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>官方支持使用 Rancher Catalog 应用、kubectl 与 helm 三种方式来进行安装，同样这里我们选择使用 helm 进行安装。</p>
<p>首先添加 longhorn 的 chart 仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ helm repo add longhorn https://charts.longhorn.io</span><br><span class="line">➜ helm repo update</span><br></pre></td></tr></table></figure>



<p>然后可以根据自己的实际场景定制 values 文件，可以通过下面的命令获取默认的 values 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -Lo values.yaml https://raw.githubusercontent.com/longhorn/charts/master/charts/longhorn/values.yaml</span><br></pre></td></tr></table></figure>



<p>然后可以修改 values 文件中的配置，longhorn 推荐单独挂盘作为存储使用，这里作为测试直接使用默认的 <code>/var/lib/longhorn</code> 目录。</p>
<p>如下所示默认配置的示例片段：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">defaultSettings:</span></span><br><span class="line">  <span class="attr">backupTarget:</span> <span class="string">s3://backupbucket@us-east-1/backupstore</span></span><br><span class="line">  <span class="attr">backupTargetCredentialSecret:</span> <span class="string">minio-secret</span></span><br><span class="line">  <span class="attr">createDefaultDiskLabeledNodes:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">defaultDataPath:</span> <span class="string">/var/lib/longhorn-example/</span></span><br><span class="line">  <span class="attr">replicaSoftAntiAffinity:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">storageOverProvisioningPercentage:</span> <span class="number">600</span></span><br><span class="line">  <span class="attr">storageMinimalAvailablePercentage:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">upgradeChecker:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">defaultReplicaCount:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">defaultDataLocality:</span> <span class="string">disabled</span></span><br><span class="line">  <span class="attr">guaranteedEngineCPU:</span></span><br><span class="line">  <span class="attr">defaultLonghornStaticStorageClass:</span> <span class="string">longhorn-static-example</span></span><br><span class="line">  <span class="attr">backupstorePollInterval:</span> <span class="number">500</span></span><br><span class="line">  <span class="attr">taintToleration:</span> <span class="string">key1=value1:NoSchedule;</span> <span class="string">key2:NoExecute</span></span><br><span class="line">  <span class="attr">systemManagedComponentsNodeSelector:</span> <span class="string">&#x27;label-key1:label-value1&#x27;</span></span><br><span class="line">  <span class="attr">priority-class:</span> <span class="string">high-priority</span></span><br><span class="line">  <span class="attr">autoSalvage:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">disableSchedulingOnCordonedNode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">replicaZoneSoftAntiAffinity:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">volumeAttachmentRecoveryPolicy:</span> <span class="string">never</span></span><br><span class="line">  <span class="attr">nodeDownPodDeletionPolicy:</span> <span class="string">do-nothing</span></span><br><span class="line">  <span class="attr">mkfsExt4Parameters:</span> <span class="string">-O</span> <span class="string">^64bit,^metadata_csum</span></span><br><span class="line">  <span class="attr">guaranteed-engine-manager-cpu:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">guaranteed-replica-manager-cpu:</span> <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingress:</span> <span class="comment"># 开启ingress</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span> <span class="comment"># 配置 ingressclass</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">longhorn.k8s.local</span></span><br><span class="line">  <span class="attr">annotations:</span> <span class="comment"># 添加annotations</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/proxy-body-size:</span> <span class="string">10000m</span></span><br><span class="line"><span class="attr">enablePSP:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">persistence:</span></span><br><span class="line">  <span class="attr">defaultClass:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">defaultFsType:</span> <span class="string">ext4</span></span><br><span class="line">  <span class="attr">defaultClassReplicaCount:</span> <span class="number">2</span> <span class="comment"># 配置成节点数</span></span><br></pre></td></tr></table></figure>



<p>然后执行下面的命令一键安装 Longhorn：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ helm upgrade --install longhorn longhorn/longhorn --namespace longhorn-system --create-namespace -f values.yaml</span><br><span class="line">NAME: longhorn</span><br><span class="line">LAST DEPLOYED: Sun Feb 20 16:14:05 2022</span><br><span class="line">NAMESPACE: longhorn-system</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Longhorn is now installed on the cluster!</span><br><span class="line"></span><br><span class="line">Please wait a few minutes for other Longhorn components such as CSI deployments, Engine Images, and Instance Managers to be initialized.</span><br><span class="line"></span><br><span class="line">Visit our documentation at https://longhorn.io/docs/</span><br></pre></td></tr></table></figure>



<p>部署后可以查看 Pod 的运行状态来确保安装正确：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods -n longhorn-system</span><br><span class="line">NAME                                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">csi-attacher-5f46994f7-fqntq                1/1     Running   0          33s</span><br><span class="line">csi-attacher-5f46994f7-ltxg8                1/1     Running   0          36m</span><br><span class="line">csi-attacher-5f46994f7-vw75d                1/1     Running   0          36m</span><br><span class="line">csi-provisioner-6ccbfbf86f-bvc99            1/1     Running   0          33s</span><br><span class="line">csi-provisioner-6ccbfbf86f-k46hn            1/1     Running   0          36m</span><br><span class="line">csi-provisioner-6ccbfbf86f-lxm8h            1/1     Running   0          36m</span><br><span class="line">csi-resizer-6dd8bd4c97-52gmm                1/1     Running   0          35m</span><br><span class="line">csi-resizer-6dd8bd4c97-9btj6                1/1     Running   0          3s</span><br><span class="line">csi-resizer-6dd8bd4c97-fdjmp                1/1     Running   0          35m</span><br><span class="line">csi-snapshotter-86f65d8bc-5mjk2             1/1     Running   0          33s</span><br><span class="line">csi-snapshotter-86f65d8bc-5rrfs             1/1     Running   0          35m</span><br><span class="line">csi-snapshotter-86f65d8bc-bg6nv             1/1     Running   0          35m</span><br><span class="line">engine-image-ei-fa2dfbf0-jrb2d              1/1     Running   0          36m</span><br><span class="line">engine-image-ei-fa2dfbf0-m5799              1/1     Running   0          36m</span><br><span class="line">instance-manager-e-051171e6                 1/1     Running   0          36m</span><br><span class="line">instance-manager-e-db94b4b7                 1/1     Running   0          24m</span><br><span class="line">instance-manager-r-dd84ad5c                 1/1     Running   0          36m</span><br><span class="line">instance-manager-r-f5eefb8a                 1/1     Running   0          24m</span><br><span class="line">longhorn-csi-plugin-mljt2                   2/2     Running   0          35m</span><br><span class="line">longhorn-csi-plugin-rfzcj                   2/2     Running   0          24m</span><br><span class="line">longhorn-driver-deployer-6db849975f-dh4p4   1/1     Running   0          58m</span><br><span class="line">longhorn-manager-bxks6                      1/1     Running   0          24m</span><br><span class="line">longhorn-manager-tj58k                      1/1     Running   0          2m50s</span><br><span class="line">longhorn-ui-6f547c964-k56xr                 1/1     Running   0          58m</span><br></pre></td></tr></table></figure>



<p>上面是部署完成后运行的 Pod，这里可以对这些工作负载做一个简单的说明：</p>
<ul>
<li><code>csi-attacher-xxx</code>、<code>csi-provisioner-xxx</code>、<code>csi-resizer-xxx</code>、<code>csi-snapshotter-xxx</code> 是 csi 原生的组件</li>
<li><code>longhorn-manager-xxx</code> 是运行在每个节点上的 Longhorn Manager，是一个控制器，也为 Longhorn UI 或者 CSI 插件提供 API，主要功能是通过修改 Kubernetes CRD 来触发控制循环，比如 volume attach&#x2F;detach 操作</li>
<li><code>longhorn-ui-xxx</code> 提供 Longhorn UI 服务，提供一个可视化的控制页面</li>
<li>Longhorn Engine 数据平面，提供两种工作模式：Engine Mode（<code>instance-manager-e-xxx</code> 的 Pod）、Replica Mode（<code>instance-manager-r-xxx</code> 的 Pod），Replica 负责实际数据的写入，每个副本包含数据的完整副本，Engine 连接到副本实现 volume 的数据平面，任何写操作都会同步到所有副本，读操作从任意一个副本读取数据</li>
</ul>
<p>由于上面安装的时候我们添加了 Ingress 支持，所以可以通过配置的域名去访问 Longhorn UI：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get ingress  -n longhorn-system</span><br><span class="line">NAME               CLASS   HOSTS                ADDRESS         PORTS   AGE</span><br><span class="line">longhorn-ingress   nginx   longhorn.k8s.local   192.168.31.31   80      4m11s</span><br></pre></td></tr></table></figure>



<p>这里我们使用的 ingress-nginx 这个控制器，安装完成后在浏览器中直接访问 <code>http://longhorn.k8s.local</code> 即可，Longhorn UI 界面中展示了当前存储系统的状态。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/uozcf3.png" alt="Longhorn UI"></p>
<p>关于存储的几种状态：</p>
<ul>
<li><code>Schedulable</code>: 可用于 Longhorn 卷调度的实际空间(actual space)</li>
<li><code>Reserved</code>: 为其他应用程序和系统保留的空间(space reserved)</li>
<li><code>Used</code>: Longhorn、系统和其他应用程序已使用的实际空间(space reserved)</li>
<li><code>Disabled</code>: 不允许调度 Longhorn 卷的磁盘&#x2F;节点的总空间</li>
</ul>
<p>在 Node 页面，Longhorn 会显示每个节点的空间分配、调度和使用信息：</p>
<p><img src="https://picdn.youdianzhishi.com/images/20220222150810.png" alt="Node 页面"></p>
<ul>
<li>Size 列：Longhorn 卷可以使用的最大实际可用空间，它等于节点的总磁盘空间减去保留空间。</li>
<li>Allocated 列：左边的数字是**卷调度(volume scheduling)**已使用的大小，并不代表该空间已被用于 Longhorn 卷数据存储。正确的数字是卷调度的 max 大小，它是 Size 乘以 Storage Over Provisioning Percentage 的结果，因此，这两个数字之间的差异（我们称之为可分配空间 allocable space）决定了卷副本是否可以调度到这个节点。</li>
<li>Used 列：左边部分表示该节点当前使用的空间，整个条形表示节点的总空间。</li>
</ul>
<p>此外还会创建一个默认的 StorageClass 对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get sc longhorn</span><br><span class="line">NAME                 PROVISIONER          RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class="line">longhorn (default)   driver.longhorn.io   Delete          Immediate           true                   91m</span><br><span class="line">➜ kubectl get sc longhorn -o yaml</span><br><span class="line">allowVolumeExpansion: true</span><br><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    ......</span><br><span class="line">    storageclass.kubernetes.io/is-default-class: &quot;true&quot;</span><br><span class="line">  creationTimestamp: &quot;2022-02-20T09:32:51Z&quot;</span><br><span class="line">  ......</span><br><span class="line">  name: longhorn</span><br><span class="line">  resourceVersion: &quot;4524911&quot;</span><br><span class="line">  uid: 6066e858-e7ab-4dab-95db-7ff829e6e01b</span><br><span class="line">parameters:</span><br><span class="line">  fromBackup: &quot;&quot;</span><br><span class="line">  fsType: ext4</span><br><span class="line">  numberOfReplicas: &quot;3&quot;</span><br><span class="line">  staleReplicaTimeout: &quot;30&quot;</span><br><span class="line">provisioner: driver.longhorn.io</span><br><span class="line">reclaimPolicy: Delete</span><br><span class="line">volumeBindingMode: Immediate</span><br></pre></td></tr></table></figure>



<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>下面我们来测试使用 longhorn 提供一个存储卷，由于提供了默认的 StorageClass，所以直接创建 PVC 即可，创建一个如下所示的 PVC：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">longhorn</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>



<p>然后部署一个 mysql 应用来使用上面的 PVC 进行数据持久化：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">mysql:5.6</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">password</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">mysql-pvc</span></span><br></pre></td></tr></table></figure>



<p>直接创建上面的资源对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pvc mysql-pvc</span><br><span class="line">NAME        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">mysql-pvc   Bound    pvc-ec17a7e4-7bb4-4456-9380-353db3ed4307   1Gi        RWO            longhorn       8s</span><br><span class="line">➜ kubectl get pods</span><br><span class="line">NAME                     READY   STATUS    RESTARTS      AGE</span><br><span class="line">mysql-6879698bd4-r8cxz   1/1     Running   0             3m10s</span><br><span class="line">➜ kubectl exec -it mysql-6879698bd4-r8cxz -- mysql -uroot -ppassword</span><br><span class="line">Warning: Using a password on the command line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 1</span><br><span class="line">Server version: 5.6.51 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create database longhorn;</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt;</span></span><br></pre></td></tr></table></figure>



<p>应用启动成功后我们可以去节点上查看数据来验证是否成功：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ ls /var/lib/longhorn/</span><br><span class="line">engine-binaries  longhorn-disk.cfg  replicas</span><br><span class="line">➜ ls /var/lib/longhorn/replicas/</span><br><span class="line">pvc-ec17a7e4-7bb4-4456-9380-353db3ed4307-c40376c5</span><br><span class="line">➜ ls /var/lib/longhorn/replicas/pvc-ec17a7e4-7bb4-4456-9380-353db3ed4307-c40376c5</span><br><span class="line">revision.counter  volume-head-000.img  volume-head-000.img.meta  volume.meta</span><br></pre></td></tr></table></figure>



<p>需要注意的是 longhorn 是分布式块存储，与分布式文件系统不同，不能超过 pv 设置的存储大小（上例中为 1G）。我们在数据库中创建了一个名为 <code>longhorn</code> 的数据库，然后我们重建 Pod 再次查看数据是否依然存在：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods</span><br><span class="line">NAME                     READY   STATUS    RESTARTS      AGE</span><br><span class="line">mysql-6879698bd4-s8tfv   1/1     Running   0             6s</span><br><span class="line">➜ kubectl exec -it mysql-6879698bd4-s8tfv -- mysql -uroot -ppassword</span><br><span class="line">Warning: Using a password on the command line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 1</span><br><span class="line">Server version: 5.6.51 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show databases;</span></span><br><span class="line">+---------------------+</span><br><span class="line">| Database            |</span><br><span class="line">+---------------------+</span><br><span class="line">| information_schema  |</span><br><span class="line">| longhorn            |</span><br><span class="line">| #mysql50#lost+found |</span><br><span class="line">| mysql               |</span><br><span class="line">| performance_schema  |</span><br><span class="line">+---------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt;</span></span><br></pre></td></tr></table></figure>



<p>可以看到前面创建的数据库依然存在，证明我们的数据持久化成功了。在 Longhorn UI 界面中也可以看到数据卷的信息：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/vffmth.png" alt="volume"></p>
<h2 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h2><p>Longhorn 提供了备份恢复功能，要使用这个功能我们需要给卷创建一个 <code>snapshot</code> 快照，快照是 Kubernetes Volume 在任何指定时间点的状态。</p>
<p>在 Longhorn UI 的 Volume 页面中点击要创建快照的卷，进入卷的详细信息页面，点击下方的 <code>Take Snapshot</code> 按钮即可创建快照了，创建快照后，将在卷头(Volume Head)之前的快照列表中可以看到它，比如这里我们会前面测试使用的 <code>mysql</code> 卷创建一个快照：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/w0805c.png" alt="创建快照"></p>
<p>同样在节点的数据目录下面也可以看到创建的快照数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜ tree /var/lib/longhorn/replicas/pvc-ec17a7e4-7bb4-4456-9380-353db3ed4307-fbf72396/</span><br><span class="line">/var/lib/longhorn/replicas/pvc-ec17a7e4-7bb4-4456-9380-353db3ed4307-fbf72396/</span><br><span class="line">├── revision.counter</span><br><span class="line">├── volume-head-002.img</span><br><span class="line">├── volume-head-002.img.meta</span><br><span class="line">├── volume.meta</span><br><span class="line">├── volume-snap-3b1f877b-24ba-44ec-808e-ab8d4b15f8dd.img</span><br><span class="line">├── volume-snap-3b1f877b-24ba-44ec-808e-ab8d4b15f8dd.img.meta</span><br><span class="line">├── volume-snap-5d403e8e-65e8-46d1-aa54-70aa3280dac4.img</span><br><span class="line">└── volume-snap-5d403e8e-65e8-46d1-aa54-70aa3280dac4.img.meta</span><br><span class="line"></span><br><span class="line">0 directories, 8 files</span><br></pre></td></tr></table></figure>



<p>其中的 <code>volume-snap-xxx</code> 后面的数据和页面上的快照名称是一致的，比如页面中我们刚刚创建的快照名称为 <code>3b1f877b-24ba-44ec-808e-ab8d4b15f8dd</code>，其中的 <code>img</code> 文件是镜像文件，而 <code>img.meta</code> 是保存当前快照的元信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ cat volume-snap-3b1f877b-24ba-44ec-808e-ab8d4b15f8dd.img.meta</span><br><span class="line">&#123;&quot;Name&quot;:&quot;volume-head-001.img&quot;,&quot;Parent&quot;:&quot;volume-snap-5d403e8e-65e8-46d1-aa54-70aa3280dac4.img&quot;,&quot;Removed&quot;:false,&quot;UserCreated&quot;:true,&quot;Created&quot;:&quot;2022-02-22T07:36:48Z&quot;,&quot;Labels&quot;:null&#125;</span><br></pre></td></tr></table></figure>



<p>元信息里面包含父级的文件镜像，这其实表明快照是增量的快照。</p>
<p>此外除了手动创建快照之外，从 Longhorn UI 上还可以进行周期性快照和备份，同样在卷的详细页面可以进行配置，在 <code>Recurring Jobs Schedule</code> 区域点击 <code>Add</code> 按钮即可创建一个定时的快照。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/dmvziu.png" alt="定时快照"></p>
<p>创建任务的时候可以选择任务类型是备份(backup)或快照(snapshot)，任务的时间以 CRON 表达式的形式进行配置，还可以配置要保留的备份或快照数量以及标签。</p>
<p>为了避免当卷长时间没有新数据时，<code>recurring jobs</code> 可能会用相同的备份和空快照覆盖旧的备份&#x2F;快照的问题，Longhorn 执行以下操作：</p>
<ul>
<li><code>Recurring backup job</code> 仅在自上次备份以来卷有新数据时才进行新备份</li>
<li><code>Recurring snapshot job</code> 仅在卷头(volume head)中有新数据时才拍摄新快照</li>
</ul>
<p>此外我们还可以通过使用 Kubernetes 的 StorageClass 来配置定时快照，可以通过 StorageClass 的 <code>recurringJobs</code> 参数配置定时备份和快照，<code>recurringJobs</code> 字段应遵循以下 JSON 格式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">longhorn</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">driver.longhorn.io</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">numberOfReplicas:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">  <span class="attr">staleReplicaTimeout:</span> <span class="string">&quot;30&quot;</span></span><br><span class="line">  <span class="attr">fromBackup:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">recurringJobs:</span> <span class="string">&#x27;[</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;name&quot;:&quot;snap&quot;,</span></span><br><span class="line"><span class="string">      &quot;task&quot;:&quot;snapshot&quot;,</span></span><br><span class="line"><span class="string">      &quot;cron&quot;:&quot;*/1 * * * *&quot;,</span></span><br><span class="line"><span class="string">      &quot;retain&quot;:1</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;name&quot;:&quot;backup&quot;,</span></span><br><span class="line"><span class="string">      &quot;task&quot;:&quot;backup&quot;,</span></span><br><span class="line"><span class="string">      &quot;cron&quot;:&quot;*/2 * * * *&quot;,</span></span><br><span class="line"><span class="string">      &quot;retain&quot;:1</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]&#x27;</span></span><br></pre></td></tr></table></figure>



<p>应为每个 recurring job 指定以下参数：</p>
<ul>
<li>name：认为的名称，不要在一个 <code>recurringJobs</code> 中使用重复的名称，并且 name 的长度不能超过 8 个字符</li>
<li>task：任务的类型，它仅支持 snapshot 或 backup</li>
<li>cron：Cron 表达式，指定任务的执行时间</li>
<li>retain：Longhorn 将为一项任务保留多少快照&#x2F;备份，不少于 1</li>
</ul>
<p>使用这个 StorageClass 创建的任何卷都将自动配置上这些 <code>recurring jobs</code>。</p>
<p>要备份卷就需要在 Longhorn 中配置一个备份目标，可以是一个 NFS 服务或者 S3 兼容的对象存储服务，用于存储 Longhorn 卷的备份数据，备份目标可以在 <code>Settings/General/BackupTarget</code> 中配置，我们这里使用 Helm Chart 安装的，最好的方式是去定制 values 文件中的 <code>defaultSettings.backupTarget</code>，当然也可以直接去通过 Longhorn UI 进行配置，比如这里我们先配置备份目标为 nfs 服务，<code>Backup Target</code> 值设置为 <code>nfs://192.168.31.31:/var/lib/k8s/data</code>（要确保目录存在），<code>Backup Target Credential Secret</code> 留空即可，然后拉到最下面点击 <code>Save</code>：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/tckkaa.png" alt="backup 配置"></p>
<p>备份目标配置后，就可以开始备份了，同样导航到 Longhorn UI 的 Volume 页面，选择要备份的卷，点击 <code>Create Backup</code>，然后添加合适的标签点击 OK 即可。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/xydv6j.png" alt="创建备份"></p>
<p>备份完成后导航到 Backup 页面就可以看到对应的备份数据了：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/myguu3.png" alt="备份数据"></p>
<p>这些备份的数据也会对应一个 <code>backupvolumes</code> crd 对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get backupvolumes -n longhorn-system</span><br><span class="line">NAME                                       CREATEDAT              LASTBACKUPNAME            LASTBACKUPAT           LASTSYNCEDAT</span><br><span class="line">pvc-ec17a7e4-7bb4-4456-9380-353db3ed4307   2022-02-22T09:23:24Z   backup-8ae4af9c49534859   2022-02-22T09:23:24Z   2022-02-22T09:41:09Z</span><br></pre></td></tr></table></figure>



<p>然后我们去到 NFS 服务器上查看会在挂载目录下面创建一个 <code>backupstore</code> 目录，下面会保留我们备份的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜ tree /var/lib/k8s/data/backupstore</span><br><span class="line">/var/lib/k8s/data/backupstore</span><br><span class="line">└── volumes</span><br><span class="line">    └── 5e</span><br><span class="line">        └── b6</span><br><span class="line">            └── pvc-ec17a7e4-7bb4-4456-9380-353db3ed4307</span><br><span class="line">                ├── backups</span><br><span class="line">                │   └── backup_backup-8ae4af9c49534859.cfg</span><br><span class="line">                ├── blocks</span><br><span class="line">                │   ├── 02</span><br><span class="line">                │   │   └── 2e</span><br><span class="line">                │   │       └── 022eefc6526cd3d8fc3a9f9a4ba253a910c61a1c430a807403f60a2f233fa210.blk</span><br><span class="line">                ......</span><br><span class="line">                │   └── f7</span><br><span class="line">                │       └── e3</span><br><span class="line">                │           └── f7e3ae1f83e10da4ece5142abac1fafc0d0917370f7418874c151a66a18bfa15.blk</span><br><span class="line">                └── volume.cfg</span><br><span class="line"></span><br><span class="line">51 directories, 25 files</span><br></pre></td></tr></table></figure>



<p>同样这个时候我们也可以去快照列表选择要备份的快照：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/lezyhw.png" alt="备份快照"></p>
<p>有了备份数据后要想要恢复数据，只需要选择对应的备份数据，点击 <code>Restore Latest Backup</code> 恢复数据即可：</p>
<p><img src="https://picdn.youdianzhishi.com/images/20220222173315.png" alt="恢复数据"></p>
<h2 id="ReadWriteMany"><a href="#ReadWriteMany" class="headerlink" title="ReadWriteMany"></a>ReadWriteMany</h2><p>Longhorn 可以通过 <code>NFSv4</code> 服务器暴露 Longhorn 卷，原生支持 RWX 工作负载，使用的 RWX 卷 会在 longhorn-system 命名空间下面创建一个 <code>share-manager-&lt;volume-name&gt;</code> 的 Pod，该 Pod 负责通过在 Pod 内运行的 NFSv4 服务器暴露 Longhorn 卷。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/h74y3g.png" alt="RWX"></p>
<p>要能够使用 RWX 卷，每个客户端节点都需要安装 <code>NFSv4</code> 客户端，对于 Ubuntu，可以通过以下方式安装 NFSv4 客户端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ apt install nfs-common</span><br></pre></td></tr></table></figure>



<p>对于基于 RPM 的发行版，可以通过以下方式安装 NFSv4 客户端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ yum install nfs-utils</span><br></pre></td></tr></table></figure>



<p>现在我们来创建一个如下所示的 PVC 对象，访问模式配置为 <code>ReadWriteMany</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html-vol.yaml</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">longhorn</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>



<p>直接创建上面的资源对象就会动态创建一个 PV 与之绑定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pvc html</span><br><span class="line">NAME   STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">html   Bound    pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15   1Gi        RWX            longhorn       15s</span><br><span class="line">➜ kubectl get pv pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15</span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM          STORAGECLASS   REASON   AGE</span><br><span class="line">pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15   1Gi        RWX            Delete           Bound    default/html   longhorn                63s</span><br></pre></td></tr></table></figure>



<p>然后创建一个如下所示的名为 writer 的 Deployment 资源对象，使用上面创建的 PVC 来持久化数据：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html-writer.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">writer</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">writer</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">writer</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">content</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">alpine:latest</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/html</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span></span><br><span class="line">              <span class="string">date</span> <span class="string">&gt;&gt;</span> <span class="string">/html/index.html;</span></span><br><span class="line">              <span class="string">sleep</span> <span class="number">5</span><span class="string">;</span></span><br><span class="line">              <span class="string">done</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>



<p>部署后上面创建的 Longhorn 的卷就变成 <code>Attached</code> 状态了：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/dgetd6.png" alt="Attached"></p>
<p>并且这个时候会自动启动一个 <code>share-manager</code> 的 Pod，通过该 Pod 内运行的 NFSv4 服务器来暴露 Longhorn 卷：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods -n longhorn-system -l longhorn.io/component=share-manager</span><br><span class="line">NAME                                                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">share-manager-pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15   1/1     Running   0          2m16s</span><br><span class="line">➜ kubectl logs -f share-manager-pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15 -n longhorn-system</span><br><span class="line">time=&quot;2022-02-22T10:07:42Z&quot; level=info msg=&quot;starting RLIMIT_NOFILE rlimit.Cur 1048576, rlimit.Max 1048576&quot;</span><br><span class="line">time=&quot;2022-02-22T10:07:42Z&quot; level=info msg=&quot;ending RLIMIT_NOFILE rlimit.Cur 1048576, rlimit.Max 1048576&quot;</span><br><span class="line">time=&quot;2022-02-22T10:07:42Z&quot; level=debug msg=&quot;volume pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15 device /dev/longhorn/pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15 contains filesystem of format &quot; encrypted=false volume=pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15</span><br><span class="line">I0222 10:07:42.432630       1 mount_linux.go:425] Disk &quot;/dev/longhorn/pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15&quot; appears to be unformatted, attempting to format as type: &quot;ext4&quot; with options: [-F -m0 /dev/longhorn/pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15]</span><br><span class="line">I0222 10:07:42.981928       1 mount_linux.go:435] Disk successfully formatted (mkfs): ext4 - /dev/longhorn/pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15 /export/pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15</span><br><span class="line">time=&quot;2022-02-22T10:07:43Z&quot; level=info msg=&quot;starting nfs server, volume is ready for export&quot; encrypted=false volume=pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15</span><br><span class="line">time=&quot;2022-02-22T10:07:43Z&quot; level=info msg=&quot;Running NFS server!&quot;</span><br><span class="line">time=&quot;2022-02-22T10:07:43Z&quot; level=info msg=&quot;starting health check for volume&quot; encrypted=false volume=pvc-a03c5f7d-d4ca-43e9-aa4a-fb3b5eb5cf15</span><br></pre></td></tr></table></figure>



<p>然后我们再创建一个如下所示的 Deployment：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html-reader.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reader</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">reader</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">reader</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:stable-alpine</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">html</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reader</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">reader</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<p>上面的 reader Pods 可以引用 writer Pod 相同的 PVC，是因为上面我们创建的 PV 和 PVC 是 <code>ReadWriteMany</code> 访问模式，直接创建上面的资源对象，我们可以通过 NodePort 来访问应用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods -l app=reader</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">reader-b54c4749d-4bjxf   1/1     Running   0          11s</span><br><span class="line">reader-b54c4749d-5thwz   1/1     Running   0          4m11s</span><br><span class="line">reader-b54c4749d-drcfk   1/1     Running   0          5m35s</span><br><span class="line">➜ kubectl get svc reader</span><br><span class="line">NAME     TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">reader   NodePort   10.101.54.19   &lt;none&gt;        80:31800/TCP   84s</span><br><span class="line">➜ curl http://192.168.31.31:31800</span><br><span class="line">......</span><br><span class="line">Tue Feb 22 10:18:39 UTC 2022</span><br><span class="line">Tue Feb 22 10:18:44 UTC 2022</span><br><span class="line">Tue Feb 22 10:18:49 UTC 2022</span><br><span class="line">Tue Feb 22 10:18:54 UTC 2022</span><br><span class="line">Tue Feb 22 10:18:59 UTC 2022</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>现在我们尝试从一个 reader Pod 中去产生一些数据，然后再去访问应用验证数据是否正确：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl exec reader-b54c4749d-4bjxf-- /bin/sh -c &quot;echo longhorn rwx access mode &gt;&gt; /usr/share/nginx/html/index.html&quot;</span><br><span class="line">➜ curl http://192.168.31.31:31800</span><br><span class="line">......</span><br><span class="line">Tue Feb 22 10:23:49 UTC 2022</span><br><span class="line">longhorn rwx access mode</span><br></pre></td></tr></table></figure>



<p>这里我们就验证了在 Longhorn 中使用 <code>ReadWriteMany</code> 访问模式的 Volume 卷。</p>
<h2 id="CSI-卷管理"><a href="#CSI-卷管理" class="headerlink" title="CSI 卷管理"></a>CSI 卷管理</h2><p>上面我们提到了通过 Longhorn UI 可以对卷进行快照、备份恢复等功能，此外我们还可以通过 Kubernetes 来实现对卷的管理，比如可以在集群上启用 CSI 快照和克隆支持。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/npw3k8.png" alt="卷管理"></p>
<h3 id="CSI-卷快照"><a href="#CSI-卷快照" class="headerlink" title="CSI 卷快照"></a>CSI 卷快照</h3><p>Kubernetes 从 1.12 版本开始引入了存储卷快照功能，在 1.17 版本进入 Beta 版本，和 PV、PVC 两个资源对象类似，Kubernetes 提供了 <code>VolumeSnapshotContent</code>、<code>VolumeSnapshot</code>、<code>VolumeSnapshotClass</code> 三个资源对象用于卷快照管理。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>VolumeSnapshotContent</code> 是基于某个 PV 创建的快照，类似于 PV 的资源概念；<code>VolumeSnapshot</code> 是用户对卷快照的请求，类似于持久化声明 PVC 的概念；<code>VolumeSnapshotClass</code> 对象可以来设置快照的特性，屏蔽 <code>VolumeSnapshotContent</code> 的细节，为 <code>VolumeSnapshot</code> 绑定提供动态管理，就像 <code>StorageClass</code> 的“类”概念。</p>
<p>卷快照能力为 Kubernetes 用户提供了一种标准的方式来在指定时间点复制卷的内容，并且不需要创建全新的卷，比如数据库管理员可以在执行编辑或删除之类的修改之前对数据库执行备份。</p>
<p>但是在使用该功能时，需要注意以下几点：</p>
<ul>
<li><code>VolumeSnapshot</code>、<code>VolumeSnapshotContent</code> 和 <code>VolumeSnapshotClass</code> 资源对象是 CRDs， 不属于核心 API。</li>
<li><code>VolumeSnapshot</code> 支持仅可用于 CSI 驱动。</li>
<li>作为 <code>VolumeSnapshot</code> 部署过程的一部分，Kubernetes 团队提供了一个部署于控制平面的快照控制器，并且提供了一个叫做 <code>csi-snapshotter</code> 的 Sidecar 容器，和 CSI 驱动程序一起部署，快照控制器会去监听 <code>VolumeSnapshot</code> 和 <code>VolumeSnapshotContent</code> 对象，并且负责创建和删除 <code>VolumeSnapshotContent</code> 对象。 <code>csi-snapshotter</code> 监听 <code>VolumeSnapshotContent</code> 对象，并且触发针对 CSI 端点的 <code>CreateSnapshot</code> 和 <code>DeleteSnapshot</code> 的操作，完成快照的创建或删除。</li>
<li>CSI 驱动可能实现，也可能没有实现卷快照功能，CSI 驱动可能会使用 <code>csi-snapshotter</code> 来提供对卷快照的支持，详见 <a target="_blank" rel="noopener" href="https://kubernetes-csi.github.io/docs/external-snapshotter.html">CSI 驱动程序文档</a>。</li>
</ul>
<p><code>VolumeSnapshotContents</code> 和 <code>VolumeSnapshots</code> 的生命周期包括资源供应、资源绑定、对使用 PVC 的保护机制和资源删除等各个阶段，这两个对象会遵循这些生命周期。</p>
<p><strong>资源供应</strong>：与 PV 的资源供应类似，<code>VolumeSnapshotContent</code> 也可以以静态或动态两种方式供应资源。</p>
<ul>
<li>静态供应：集群管理员会预先创建好一组 <code>VolumeSnapshotContent</code> 资源，类似于手动创建 PV</li>
<li>动态供应：基于 <code>VolumeSnapshotClass</code> 资源，当用户创建 <code>VolumeSnapshot</code> 申请时自动创建 <code>VolumeSnapshotContent</code>，类似于 <code>StorageClass</code> 动态创建 PV</li>
</ul>
<p><strong>资源绑定</strong>：快照控制器负责将 <code>VolumeSnapshot</code> 与一个合适的 <code>VolumeSnapshotContent</code> 进行绑定，包括静态和动态供应两种情况，<code>VolumeSnapshot</code> 和 <code>VolumeSnapshotContent</code> 之间也是一对一进行绑定的，不会存在一对多的情况。</p>
<p><strong>对使用中的 PVC 的保护机制</strong>：当存储快照 <code>VolumeSnapshot</code> 正在被创建且还未完成时，相关的 PVC 将会被标记为<code>正被使用中</code>，如果用户对 PVC 进行删除操作，系统不会立即删除 PVC，以避免快照还未做完造成数据丢失，删除操作会延迟到 <code>VolumeSnapshot</code> 创建完成（<code>readyToUse</code> 状态）或被终止（<code>aborted</code> 状态）的情况下完成。</p>
<p><strong>资源删除</strong>：对 <code>VolumeSnapshot</code> 发起删除操作时，对与其绑定的后端 <code>VolumeSnapshotContent</code> 的删除操作将基于删除策略 <code>DeletionPolicy</code> 的设置来决定，可以配置的删除策略有：</p>
<ul>
<li><code>Delete</code>：自动删除 <code>VolumeSnapshotContent</code> 资源对象和快照的内容。</li>
<li><code>Retain</code>：<code>VolumeSnapshotContent</code> 资源对象和快照的内容都将保留，需要手动清理。</li>
</ul>
<p>我们这里的 Longhorn 系统在部署完成后创建了 3 个 <code>csi-snapshotter</code> 的 Pod：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods -n longhorn-system</span><br><span class="line">NAME                                                     READY   STATUS      RESTARTS       AGE</span><br><span class="line">csi-snapshotter-86f65d8bc-9t7dd                          1/1     Running     5 (126m ago)   2d17h</span><br><span class="line">csi-snapshotter-86f65d8bc-d6xbj                          1/1     Running     5 (126m ago)   2d17h</span><br><span class="line">csi-snapshotter-86f65d8bc-dncwv                          1/1     Running     5 (126m ago)   2d17h</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>这其实是启动的 3 个副本，同一时间只有一个 Pod 提供服务，通过 <code>leader-election</code> 来实现的选主高可用，比如当前这里提供服务的是 <code>csi-snapshotter-86f65d8bc-dncwv</code>，我们可以查看对应的日志信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl logs -f csi-snapshotter-86f65d8bc-dncwv -n longhorn-system</span><br><span class="line">......</span><br><span class="line">E0223 04:36:33.570567       1 reflector.go:127] github.com/kubernetes-csi/external-snapshotter/client/v3/informers/externalversions/factory.go:117: Failed to watch *v1beta1.VolumeSnapshotClass: failed to list *v1beta1.VolumeSnapshotClass: the server could not find the requested resource (get volumesnapshotclasses.snapshot.storage.k8s.io)</span><br><span class="line">E0223 04:37:03.773447       1 reflector.go:127] github.com/kubernetes-csi/external-snapshotter/client/v3/informers/externalversions/factory.go:117: Failed to watch *v1beta1.VolumeSnapshotContent: failed to list *v1beta1.VolumeSnapshotContent: the server could not find the requested resource (get volumesnapshotcontents.snapshot.storage.k8s.io)</span><br></pre></td></tr></table></figure>



<p>可以看到提示没有 <code>VolumeSnapshotClass</code> 和 <code>VolumeSnapshotContent</code> 资源，这是因为这两个资源都是 CRDs，并不是 Kubernetes 内置的资源对象，而我们在安装 Longhorn 的时候也没有安装这两个 CRDs，所以找不到，要通过 CSI 来实现卷快照功能自然就需要先安装 CRDs，我们可以从 <a target="_blank" rel="noopener" href="https://github.com/kubernetes-csi/external-snapshotter">external-snapshotter</a> 项目中来获取：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ git clone https://github.com/kubernetes-csi/external-snapshotter</span><br><span class="line">➜ cd external-snapshotter &amp;&amp; git checkout v5.0.1</span><br><span class="line">➜ kubectl kustomize client/config/crd | kubectl create -f -</span><br></pre></td></tr></table></figure>



<p>上面的命令会安装上面提到的 3 个 Snapshot CRDs:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get crd |grep snapshot</span><br><span class="line">volumesnapshotclasses.snapshot.storage.k8s.io    2022-02-23T05:31:34Z</span><br><span class="line">volumesnapshotcontents.snapshot.storage.k8s.io   2022-02-23T05:31:34Z</span><br><span class="line">volumesnapshots.snapshot.storage.k8s.io          2022-02-23T05:31:34Z</span><br></pre></td></tr></table></figure>



<p>安装完成后再去查看上面的 <code>csi-snapshotter</code> 相关的 Pod 日志就正常了。CRDs 安装完成后还不够，我们还需要一个快照控制器来监听 <code>VolumeSnapshot</code> 和 <code>VolumeSnapshotContent</code> 对象，同样 <code>external-snapshotter</code> 项目中也提供了一个 <code>Common Snapshot Controller</code>，执行下面的命令一键安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 deploy/kubernetes/snapshot-controller/setup-snapshot-controller.yaml 镜像地址为 cnych/csi-snapshot-controller:v5.0.0，默认为 gcr 镜像</span></span><br><span class="line">➜ kubectl -n kube-system kustomize deploy/kubernetes/snapshot-controller | kubectl create -f -</span><br></pre></td></tr></table></figure>



<p>这里我们将快照控制器安装到了 <code>kube-system</code> 命名空间下，启动两个副本，同样同一时间只有一个 Pod 提供服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods -n kube-system -l app=snapshot-controller</span><br><span class="line">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">snapshot-controller-677b65dc6c-288w9   1/1     Running   0          3m22s</span><br><span class="line">snapshot-controller-677b65dc6c-zgdcm   1/1     Running   0          39s</span><br></pre></td></tr></table></figure>



<p>到这里就将使用 CSI 来配置快照的环境准备好了。</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>下面我们仍然以前面的 <code>mysql-pvc</code> 这个卷为例来说明下如何使用卷快照功能：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pvc mysql-pvc</span><br><span class="line">NAME        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">mysql-pvc   Bound    pvc-ec17a7e4-7bb4-4456-9380-353db3ed4307   1Gi        RWO            longhorn       2d18h</span><br></pre></td></tr></table></figure>



<p>要创建 <code>mysql-pvc</code> 的快照申请，首先需要创建一个 <code>VolumeSnapshot</code> 对象：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapshot-mysql.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">snapshot.storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VolumeSnapshot</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-snapshot-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumeSnapshotClassName:</span> <span class="string">longhorn</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">persistentVolumeClaimName:</span> <span class="string">mysql-pvc</span></span><br><span class="line">    <span class="comment"># volumeSnapshotContentName: test-content</span></span><br></pre></td></tr></table></figure>



<p>其中就两个主要配置参数：</p>
<ul>
<li><code>volumeSnapshotClassName</code>：指定 <code>VolumeSnapshotClass</code> 的名称，这样就可以动态创建一个对应的 <code>VolumeSnapshotContent</code> 与之绑定，如果没有指定该参数，则属于静态方式，需要手动创建 <code>VolumeSnapshotContent</code>。</li>
<li><code>persistentVolumeClaimName</code>：指定数据来源的 PVC 名称。</li>
<li><code>volumeSnapshotContentName</code>：如果是申请静态存储快照，则需要通过该参数来指定一个 <code>VolumeSnapshotContent</code>。</li>
</ul>
<p>上面我们指定了一个存储快照类 longhorn，当然需要创建这个对象：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapshotclass.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">snapshot.storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VolumeSnapshotClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">longhorn</span></span><br><span class="line">  <span class="comment"># annotations:  # 如果要指定成默认的快照类</span></span><br><span class="line">  <span class="comment">#   snapshot.storage.kubernetes.io/is-default-class: &quot;true&quot;</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">driver.longhorn.io</span></span><br><span class="line"><span class="attr">deletionPolicy:</span> <span class="string">Delete</span></span><br></pre></td></tr></table></figure>



<p>每个 <code>VolumeSnapshotClass</code> 都包含 driver、deletionPolicy 和 parameters 字段，在需要动态配置属于该类的 <code>VolumeSnapshot</code> 时使用。</p>
<ul>
<li><code>driver</code>：表示 CSI 存储插件驱动的名称，这里我们使用的是 Longhorn 插件，名为 <code>driver.longhorn.io</code></li>
<li><code>deletionPolicy</code>：删除策略，可以设置为 Delete 或 Retain，如果删除策略是 Delete，那么底层的存储快照会和 <code>VolumeSnapshotContent</code> 对象一起删除，如果删除策略是 Retain，那么底层快照和 <code>VolumeSnapshotContent</code> 对象都会被保留。</li>
<li><code>parameters</code>：存储插件需要配置的参数，有 CSI 驱动提供具体的配置参数。</li>
</ul>
<p>如果想将当前快照类设置成默认的则需要添加 <code>snapshot.storage.kubernetes.io/is-default-class: &quot;true&quot;</code> 这样的 annotations。</p>
<p>现在我们直接创建上面的两个资源对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl apply -f snapshotclass.yaml</span><br><span class="line">volumesnapshotclass.snapshot.storage.k8s.io/longhorn created</span><br><span class="line">➜ kubectl apply -f snapshot-mysql.yaml</span><br><span class="line">volumesnapshot.snapshot.storage.k8s.io/mysql-snapshot-demo created</span><br><span class="line">➜ kubectl get volumesnapshotclass</span><br><span class="line">NAME       DRIVER               DELETIONPOLICY   AGE</span><br><span class="line">longhorn   driver.longhorn.io   Delete           43s</span><br><span class="line">➜ kubectl get volumesnapshot</span><br><span class="line">NAME                  READYTOUSE   SOURCEPVC   SOURCESNAPSHOTCONTENT   RESTORESIZE   SNAPSHOTCLASS   SNAPSHOTCONTENT                                    CREATIONTIME   AGE</span><br><span class="line">mysql-snapshot-demo   true         mysql-pvc                           1Gi           longhorn        snapcontent-1119649a-d4f2-447f-a21a-e527f202e43e   43s            43s</span><br></pre></td></tr></table></figure>



<p>这个时候会动态为我们创建一个 <code>VolumeSnapshotContent</code> 对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get volumesnapshotcontent</span><br><span class="line">NAME                                               READYTOUSE   RESTORESIZE   DELETIONPOLICY   DRIVER               VOLUMESNAPSHOTCLASS   VOLUMESNAPSHOT        VOLUMESNAPSHOTNAMESPACE   AGE</span><br><span class="line">snapcontent-1119649a-d4f2-447f-a21a-e527f202e43e   true         1073741824    Delete           driver.longhorn.io   longhorn              mysql-snapshot-demo   default                   97s</span><br></pre></td></tr></table></figure>



<p>自动创建的 <code>VolumeSnapshotContent</code> 对象内容如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">snapshot.storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VolumeSnapshotContent</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">snapcontent-1119649a-d4f2-447f-a21a-e527f202e43e</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">deletionPolicy:</span> <span class="string">Delete</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">driver.longhorn.io</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">volumeHandle:</span> <span class="string">pvc-ec17a7e4-7bb4-4456-9380-353db3ed4307</span></span><br><span class="line">  <span class="attr">volumeSnapshotClassName:</span> <span class="string">longhorn</span></span><br><span class="line">  <span class="attr">volumeSnapshotRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">snapshot.storage.k8s.io/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">VolumeSnapshot</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mysql-snapshot-demo</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">resourceVersion:</span> <span class="string">&#x27;4967456&#x27;</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">1119649a-d4f2-447f-a21a-e527f202e43e</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">creationTime:</span> <span class="number">1645597546000000000</span></span><br><span class="line">  <span class="attr">readyToUse:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">restoreSize:</span> <span class="number">1073741824</span></span><br><span class="line">  <span class="attr">snapshotHandle:</span> <span class="string">bs://pvc-ec17a7e4-7bb4-4456-9380-353db3ed4307/backup-f5f28fd624a148ed</span></span><br></pre></td></tr></table></figure>



<p>其中的 <code>source.volumeHandle</code> 字段的值是在后端存储上创建并由 CSI 驱动在创建存储卷期间返回的 Volume 的唯一标识符，在动态供应模式下需要该字段，指定的是快照的来源 Volume 信息，<code>volumeSnapshotRef</code> 下面就是和关联的 <code>VolumeSnapshot</code> 对象的相关信息。当然这个时候我们在 Longhorn UI 界面上也可以看到上面我们创建的这个快照了，快照名称为 <code>snapshot-1119649a-d4f2-447f-a21a-e527f202e43e</code>，后面的 ID 与上面的 <code>VolumeSnapshotContent</code> 名称保持一致：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/ylhyeq.png" alt="快照"></p>
<p>并且也会进行一次对应的 Backup 操作，备份的信息通过 <code>snapshotHandle</code> 进行指定的，格式为 <code>bs://backup-&lt;volume&gt;/backup-&lt;name&gt;</code>：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/hzrj02.png" alt="备份"></p>
<p>这样我们就完成了通过 CSI 实现卷的快照管理功能。</p>
<h3 id="基于快照创建新的-PVC（恢复）"><a href="#基于快照创建新的-PVC（恢复）" class="headerlink" title="基于快照创建新的 PVC（恢复）"></a>基于快照创建新的 PVC（恢复）</h3><p>Kubernetes 对基于快照创建存储卷在 1.17 版本更新到了 Beta 版本，要启用该特性，就需要在 kube-apiserver、kube-controller-manager 和 kubelet 的 Feature Gate 中启用 <code>--feature-gates=...,VolumeSnapshotDataSource</code>（我们这里是 1.22 版本默认已经启用了），然后就可以基于某个快照创建一个新的 PVC 存储卷了，比如现在我们来基于上面创建的 <code>mysql-snapshot-demo</code> 这个对象来创建一个新的 PVC：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># restore-mysql.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-restore-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">longhorn</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">dataSource:</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">snapshot.storage.k8s.io</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">VolumeSnapshot</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mysql-snapshot-demo</span></span><br></pre></td></tr></table></figure>



<p>上面的 PVC 对象和我们平时声明的方式基本一致，唯一不同的是通过一个 <code>dataSource</code> 字段配置了基于名为 <code>mysql-snapshot-demo</code> 的存储快照进行创建，创建上面的资源对象后同样会自动创建一个 PV 与之绑定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pvc mysql-restore-pvc</span><br><span class="line">NAME                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">mysql-restore-pvc   Bound    pvc-e4ddd985-31a8-4570-b393-dcedec3b0d95   1Gi        RWO            longhorn       17s</span><br></pre></td></tr></table></figure>



<p>在 Longhorn UI 中去查看该卷，可以看到该卷的实际大小并不为 0，这是因为我们是从快照中创建过来的，相当于从上面的快照中恢复的数据：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/2r6car.png" alt="恢复卷"></p>
<h3 id="卷克隆"><a href="#卷克隆" class="headerlink" title="卷克隆"></a>卷克隆</h3><p>除了基于快照创建新的 PVC 对象之外，CSI 类型的存储还支持存储的克隆功能，可以基于已经存在的 PVC 克隆一个新的 PVC，实现方式也是通过在 <code>dataSource</code> 字段中来设置源 PVC 来实现。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/ujmfb8.png" alt="clone"></p>
<p>克隆一个 PVC 其实就是对已存在的存储卷创建一个副本，唯一的区别是，系统在为克隆 PVC 提供后端存储资源时，不是新建一个空的 PV，而是复制一个与原 PVC 绑定 PV 完全一样的 PV。</p>
<p>从 Kubernetes API 的角度看，克隆的实现只是在创建新的 PVC 时， 增加了指定一个现有 PVC 作为数据源的能力，源 PVC 必须是 bound 状态且可用的。</p>
<p>用户在使用该功能时，需要注意以下事项：</p>
<ul>
<li>克隆仅适用于 CSI 驱动</li>
<li>克隆仅适用于动态供应</li>
<li>克隆功能取决于具体的 CSI 驱动是否实现该功能</li>
<li>要求目标 PVC 和源 PVC 必须处于同一个命名空间</li>
<li>只支持在相同的 StorageClass 中（可以使用默认的）</li>
<li>两个存储卷的存储模式（VolumeMode）要一致</li>
</ul>
<p>同样我们来对前面的 <code>mysql-pvc</code> 这个存储卷进行克隆操作，对应的 PVC 声明如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-clone-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">longhorn</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span> <span class="comment"># 必须大于或等于源的值</span></span><br><span class="line">  <span class="attr">dataSource:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mysql-pvc</span></span><br></pre></td></tr></table></figure>



<p>该 PVC 和源 PVC 声明一样的配置，唯一不同的是通过 <code>dataSource</code> 指定了源 PVC 的名称，直接创建这个资源对象，结果是 <code>mysql-clone-pvc</code> 这个新的 PVC 与源 <code>mysql-pvc</code> 拥有相同的数据。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pvc mysql-clone-pvc</span><br><span class="line">NAME              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">mysql-clone-pvc   Bound    pvc-58eab5f0-a386-435c-91f4-0c26f7935695   1Gi        RWO            longhorn       31s</span><br></pre></td></tr></table></figure>



<p>在 Longhorn UI 页面中也可以看到对应的卷：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/zhlgqn.png" alt="克隆"></p>
<p>一旦新的 PVC 可用，被克隆的 PVC 就可以像其他 PVC 一样被使用了，也可以对其进行克隆、快照、删除等操作。</p>
<h3 id="卷动态扩容"><a href="#卷动态扩容" class="headerlink" title="卷动态扩容"></a>卷动态扩容</h3><p>我们知道对于存储来说扩容是一个非常终于的需求，对于 Kubernetes 中的卷动态扩容同样也是需要的基本功能，PV 要做扩容操作是需要底层存储支持该操作才能实现，Longhorn 底层是支持卷扩容操作的，但是要求扩展的卷必须处于 <code>detached</code> 状态才能操作，有两种方法可以扩容 Longhorn 卷：修改 PVC 和使用 Longhorn UI。</p>
<p>通过 Longhorn UI 操作比较简单，直接在页面中选择要扩容的卷，在操作中选择 <code>Expand Volume</code> 进行操作即可：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/i1a8be.png" alt="扩容"></p>
<p>要通过 PVC 来进行扩容首先需要 PVC 由 Longhorn StorageClass 进行动态供应，并且在 StorageClass 中 <code>allowVolumeExpansion</code> 属性设置为 true，建议使用这种方法，因为 PVC 和 PV 会自动更新，并且在扩容后都会保持一致。比如上面使用的 mysql-clone-pvc 这个卷（处于 <code>detached</code> 状态）使用的 longhorn 这个 StorageClass 中就已经配置了 <code>allowVolumeExpansion: true</code>，然后直接修改 mysql-pvc 这个卷下面的 <code>spec.resources.requests.storage</code> 值即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pvc mysql-clone-pvc</span><br><span class="line">NAME              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">mysql-clone-pvc   Bound    pvc-58eab5f0-a386-435c-91f4-0c26f7935695   1Gi        RWO            longhorn       40m</span><br><span class="line">➜ kubectl patch pvc mysql-clone-pvc -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;resources&quot;:&#123;&quot;requests&quot;:&#123;&quot;storage&quot;:&quot;2Gi&quot;&#125;&#125;&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>修改后可以查看该 PVC 的 events 信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl describe pvc mysql-clone-pvc</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason                  Age                From                                                                                      Message</span><br><span class="line">  ----     ------                  ----               ----                                                                                      -------</span><br><span class="line">  ......</span><br><span class="line">  Normal   Resizing                14s                external-resizer driver.longhorn.io                                                       External resizer is resizing volume pvc-58eab5f0-a386-435c-91f4-0c26f7935695</span><br><span class="line">  Warning  ExternalExpanding       14s                volume_expand                                                                             Ignoring the PVC: didn&#x27;t find a plugin capable of expanding the volume; waiting for an external controller to process this PVC.</span><br><span class="line">  Normal   VolumeResizeSuccessful  2s                 external-resizer driver.longhorn.io                                                       Resize volume succeeded</span><br></pre></td></tr></table></figure>



<p>可以看到通过 <code>external-resizer</code> 组件实现了 Resize 操作，查看 PVC 和 PV 的大小验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pvc mysql-clone-pvc</span><br><span class="line">NAME              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">mysql-clone-pvc   Bound    pvc-58eab5f0-a386-435c-91f4-0c26f7935695   2Gi        RWO            longhorn       43m</span><br><span class="line">➜ kubectl get pv pvc-58eab5f0-a386-435c-91f4-0c26f7935695</span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                     STORAGECLASS   REASON   AGE</span><br><span class="line">pvc-58eab5f0-a386-435c-91f4-0c26f7935695   2Gi        RWO            Delete           Bound    default/mysql-clone-pvc   longhorn                43m</span><br></pre></td></tr></table></figure>



<p>可以看到 PVC 和 PV 中的容量都变成了 2Gi，证明扩容成功了，通过 Longhorn UI 也可以查看到卷扩容成功了：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/3p9bma.png" alt="扩容"></p>
<p><a target="_blank" rel="noopener" href="https://docs.youdianzhishi.com/k8s/storage/plugin/">
</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/Longhorn/">https://huiaz.github.io/2025/09/11/Longhorn/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/NAT/" title="NAT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">NAT</div></div><div class="info-2"><div class="info-item-1">什么是网络地址转换（NAT）？NAT (Network Address Translation)，即网络地址转换，是一种在 IP 网络中改变数据包的 IP 地址信息的技术。它的主要目的是解决 IPv4 地址枯竭的问题，同时也能提供一定程度的网络安全隔离。 简单来说，NAT 允许一个拥有私有 IP 地址的网络（如家庭网络或企业内部网络）连接到使用公共 IP 地址的外部网络（如互联网），而无需为内部的每台设备都分配一个唯一的公共 IP 地址。 核心概念：  私有 IP 地址： 在私有网络内部使用的 IP 地址，它们不能直接在公共互联网上路由。RFC 1918 定义了以下私有 IP 地址范围： 10.0.0.0 到 10.255.255.255 (10&#x2F;8) 172.16.0.0 到 172.31.255.255 (172.16&#x2F;12) 192.168.0.0 到 192.168.255.255 (192.168&#x2F;16)   公共 IP 地址： 在公共互联网上可寻址的全球唯一的 IP 地址。 NAT 设备： 通常是路由器或防火墙，负责执行 IP 地址的转换...</div></div></div></a><a class="pagination-related" href="/2025/09/11/LocalDNS/" title="LocalDNS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">LocalDNS</div></div><div class="info-2"><div class="info-item-1">DNS 优化前面我们讲解了在 Kubernetes 中我们可以使用 CoreDNS 来进行集群的域名解析，但是如果在集群规模较大并发较高的情况下我们仍然需要对 DNS 进行优化，典型的就是大家比较熟悉的 CoreDNS 会出现超时 5s 的情况。 超时原因在 iptables 模式下（默认情况下），每个服务的 kube-proxy 在主机网络名称空间的 nat 表中创建一些 iptables 规则。 比如在集群中具有两个 DNS 服务器实例的 kube-dns 服务，其相关规则大致如下所示： 12345678910(1) -A PREROUTING -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES&lt;...&gt;(2) -A KUBE-SERVICES -d 10.96.0.10/32 -p udp -m comment --comment &quot;kube-system/kube-dns:dns cluster IP&quot; -m udp --dport 53 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Ingress/" title="Ingress"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Ingress</div></div><div class="info-2"><div class="info-item-1">Ingress前面我们学习了在 Kubernetes 集群内部使用 kube-dns 实现服务发现的功能，那么我们部署在 Kubernetes 集群中的应用如何暴露给外部的用户使用呢？我们知道可以使用 NodePort 和 LoadBlancer 类型的 Service 可以把应用暴露给外部用户使用，除此之外，Kubernetes 还为我们提供了一个非常重要的资源对象可以用来暴露服务给外部用户，那就是 Ingress。对于小规模的应用我们使用 NodePort 或许能够满足我们的需求，但是当你的应用越来越多的时候，你就会发现对于 NodePort 的管理就非常麻烦了，这个时候使用 Ingress 就非常方便了，可以避免管理大量的端口。 资源对象Ingress 资源对象是 Kubernetes 内置定义的一个对象，是从 Kuberenets 集群外部访问集群的一个入口，将外部的请求转发到集群内不同的 Service 上，其实就相当于 nginx、haproxy 等负载均衡代理服务器，可能你会觉得我们直接使用 nginx 就实现了，但是只使用 nginx 这种方式有很大缺陷，每次有新...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Relabe/" title="Relabe"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Relabe</div></div><div class="info-2"><div class="info-item-1">Relabeling 重新标记Relabeling 重新标记用于配置 Prometheus 元信息的方式，它是转换和过滤 Prometheus 中 label 标签对象的核心，本章节我们将了解 Relabeling 规则的工作原理，并能够将它们应用于不同的场景中。 概述Prometheus 发现、抓取和处理不同类型的 label 标签对象，根据标签值操作或过滤这些对象非常有用，比如：  只监视具有特定服务发现注解的某些目标，通常在服务发现中使用 向目标抓取请求添加 HTTP 查询参数 仅存储从指定目标中提取样本的子集 将抓取序列的两个标签值合并为一个标签  Relabeling 是作为一系列转换步骤实现的，我们可以在 Prometheus 的配置文件中应用这些步骤来过滤或修改标记对象，我们可以对一下类型的标记对象应用 Relabeling 操作：  发现的抓取目标（relabel_configs） 抓取的单个样本（metric_relabel_configs） 发送给 Alertmanager 的报警（alert_relabel_configs） 写到远程存储的样本（write_...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s_12/" title="k8s_12"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s_12</div></div><div class="info-2"><div class="info-item-1">如何在 Kubernetes 中实现服务的自动伸缩（autoscaling）？Of course. Automating the scaling of services is one of Kubernetes’ most powerful features, enabling applications to be both resilient to traffic spikes and cost-effective during quiet periods. This is achieved through a combination of several components. 🤔 分析过程：该问题旨在考察对Kubernetes核心动态管理能力的理解。一个全面的回答不能只提及一种自动伸缩方式，而应结构化地介绍Kubernetes中三个主要层次的自动伸缩器：HPA (水平), VPA (垂直), 和 CA (集群)。回答的重点在于阐明每种伸缩器的触发机制、作用范围和典型用例，并解释它们如何协同工作，共同构建一个弹性的、资源高效的系统。 💡 答案生成：1. 概念或定义Kube...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ingress-nginx/" title="ingress-nginx"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ingress-nginx</div></div><div class="info-2"><div class="info-item-1">ingress-nginx我们已经了解了 Ingress 资源对象只是一个路由请求描述配置文件，要让其真正生效还需要对应的 Ingress 控制器才行，Ingress 控制器有很多，这里我们先介绍使用最多的 ingress-nginx，它是基于 Nginx 的 Ingress 控制器。 运行原理ingress-nginx 控制器主要是用来组装一个 nginx.conf 的配置文件，当配置文件发生任何变动的时候就需要重新加载 Nginx 来生效，但是并不会只在影响 upstream 配置的变更后就重新加载 Nginx，控制器内部会使用一个 lua-nginx-module 来实现该功能。 我们知道 Kubernetes 控制器使用控制循环模式来检查控制器中所需的状态是否已更新或是否需要变更，所以 ingress-nginx 需要使用集群中的不同对象来构建模型，比如 Ingress、Service、Endpoints、Secret、ConfigMap 等可以生成反映集群状态的配置文件的对象，控制器需要一直 Watch 这些资源对象的变化，但是并没有办法知道特定的更改是否会影响到最终生...</div></div></div></a><a class="pagination-related" href="/2025/09/11/CRD/" title="CRD"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">CRD</div></div><div class="info-2"><div class="info-item-1">CRDCustom Resource Define 简称 CRD，是 Kubernetes（v1.7+）为提高可扩展性，让开发者去自定义资源的一种方式。CRD 资源可以动态注册到集群中，注册完毕后，用户可以通过 kubectl 来创建访问这个自定义的资源对象，类似于操作 Pod 一样。不过需要注意的是 CRD 仅仅是资源的定义而已，需要一个 Controller 去监听 CRD 的各种事件来添加自定义的业务逻辑。 定义如果说只是对 CRD 资源本身进行 CRUD 操作的话，不需要 Controller 也是可以实现的，相当于就是只有数据存入了 etcd 中，而没有对这个数据的相关操作而已。比如我们可以定义一个如下所示的 CRD 资源清单文件： 12345678910111213141516171819202122232425262728293031323334353637383940# crd-demo.yamlapiVersion: apiextensions.k8s.io/v1kind: CustomResourceDefinitionmetadata:  # name 必须...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%20KubeBlocks/" title="数据管理平台 KubeBlocks"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">数据管理平台 KubeBlocks</div></div><div class="info-2"><div class="info-item-1">云原生数据管理平台 KubeBlocksKubeBlocks 是基于 Kubernetes 的云原生数据基础设施，将顶级云服务提供商的大规模生产经验与增强的可用性和稳定性改进相结合，帮助用户轻松构建容器化、声明式的关系型、NoSQL、流计算和向量型数据库服务。  为什么需要 KubeBlocks？Kubernetes 已经成为容器编排的事实标准。它利用 ReplicaSet 提供的可扩展性和可用性以及 Deployment 提供的发布和回滚功能来管理日益增加的无状态工作负载。然而，管理有状态工作负载给 Kubernetes 带来了巨大的挑战，尽管 StatefulSet 提供了稳定的持久存储和唯一的网络标识符，但这些功能对于复杂的有状态工作负载来说远远不够。 为了应对这些挑战，并解决复杂性问题，KubeBlocks 引入了 ReplicationSet 和 ConsensusSet，具备以下能力：  基于角色的更新顺序可减少因升级版本、缩放和重新启动而导致的停机时间。 维护数据复制的状态，并自动修复复制错误或延迟。  KubeBlocks 具有以下特点：  支持多云，与 AWS、...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Longhorn"><span class="toc-number">1.</span> <span class="toc-text">Longhorn</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96"><span class="toc-number">1.2.1.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2"><span class="toc-number">1.2.2.</span> <span class="toc-text">部署</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D"><span class="toc-number">1.4.</span> <span class="toc-text">备份恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReadWriteMany"><span class="toc-number">1.5.</span> <span class="toc-text">ReadWriteMany</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSI-%E5%8D%B7%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">CSI 卷管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSI-%E5%8D%B7%E5%BF%AB%E7%85%A7"><span class="toc-number">1.6.1.</span> <span class="toc-text">CSI 卷快照</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%BF%AB%E7%85%A7%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84-PVC%EF%BC%88%E6%81%A2%E5%A4%8D%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">基于快照创建新的 PVC（恢复）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E5%85%8B%E9%9A%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">卷克隆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9"><span class="toc-number">1.6.4.</span> <span class="toc-text">卷动态扩容</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>