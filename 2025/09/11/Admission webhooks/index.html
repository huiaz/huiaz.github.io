<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Admission webhooks | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="准入控制器Kubernetes 提供了需要扩展其内置功能的方法，最常用的可能是自定义资源类型和自定义控制器了，除此之外，Kubernetes 还有一些其他非常有趣的功能，比如 admission webhooks 就可以用于扩展 API，用于修改某些 Kubernetes 资源的基本行为。 准入控制器是在对象持久化之前用于对 Kubernetes API Server 的请求进行拦截的代码段，在请">
<meta property="og:type" content="article">
<meta property="og:title" content="Admission webhooks">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/Admission%20webhooks/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="准入控制器Kubernetes 提供了需要扩展其内置功能的方法，最常用的可能是自定义资源类型和自定义控制器了，除此之外，Kubernetes 还有一些其他非常有趣的功能，比如 admission webhooks 就可以用于扩展 API，用于修改某些 Kubernetes 资源的基本行为。 准入控制器是在对象持久化之前用于对 Kubernetes API Server 的请求进行拦截的代码段，在请">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:21:26.083Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Admission webhooks",
  "url": "https://huiaz.github.io/2025/09/11/Admission%20webhooks/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:21:26.083Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/Admission%20webhooks/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Admission webhooks',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Admission webhooks</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Admission webhooks</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:21:26.083Z" title="更新于 2025-09-11 22:21:26">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E6%8E%A7%E5%88%B6%E5%99%A8/">控制器</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="准入控制器"><a href="#准入控制器" class="headerlink" title="准入控制器"></a>准入控制器</h1><p>Kubernetes 提供了需要扩展其内置功能的方法，最常用的可能是自定义资源类型和自定义控制器了，除此之外，Kubernetes 还有一些其他非常有趣的功能，比如 <code>admission webhooks</code> 就可以用于扩展 API，用于修改某些 Kubernetes 资源的基本行为。</p>
<p>准入控制器是在<strong>对象持久化之前</strong>用于对 Kubernetes API Server 的请求进行拦截的代码段，在请求经过<strong>身份验证</strong>和<strong>授权之后</strong>放行通过。准入控制器可能正在 <code>validating</code>、<code>mutating</code> 或者都在执行，<code>Mutating</code> 控制器可以修改他们处理的资源对象，<code>Validating</code> 控制器不会，如果任何一个阶段中的任何控制器拒绝了请求，则会立即拒绝整个请求，并将错误返回给最终的用户。</p>
<p>这意味着有一些特殊的控制器可以拦截 Kubernetes API 请求，并根据自定义的逻辑修改或者拒绝它们。Kubernetes 有自己实现的一个控制器列表：<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do%EF%BC%8C%E5%BD%93%E7%84%B6%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%8C%E8%99%BD%E7%84%B6%E8%BF%99%E4%BA%9B%E6%8E%A7%E5%88%B6%E5%99%A8%E5%90%AC%E8%B5%B7%E6%9D%A5%E5%8A%9F%E8%83%BD%E6%AF%94%E8%BE%83%E5%BC%BA%E5%A4%A7%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E4%BA%9B%E6%8E%A7%E5%88%B6%E5%99%A8%E9%9C%80%E8%A6%81%E8%A2%AB%E7%BC%96%E8%AF%91%E8%BF%9B">https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do，当然你也可以编写自己的控制器，虽然这些控制器听起来功能比较强大，但是这些控制器需要被编译进</a> kube-apiserver，并且只能在 apiserver 启动时启动。</p>
<p>也可以直接使用 kube-apiserver 启动参数查看内置支持的控制器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kube-apiserver --help |grep enable-admission-plugins</span><br></pre></td></tr></table></figure>



<p>由于上面的控制器的限制，我们就需要用到<strong>动态</strong>的概念了，而不是和 apiserver 耦合在一起，<code>Admission webhooks</code> 就通过一种动态配置方法解决了这个限制问题。</p>
<h2 id="admission-webhook-是什么"><a href="#admission-webhook-是什么" class="headerlink" title="admission webhook 是什么?"></a>admission webhook 是什么?</h2><p>在 Kubernetes apiserver 中包含两个特殊的准入控制器：<code>MutatingAdmissionWebhook</code> 和<code>ValidatingAdmissionWebhook</code>，这两个控制器将发送准入请求到外部的 HTTP 回调服务并接收一个准入响应。如果启用了这两个准入控制器，Kubernetes 管理员可以在集群中创建和配置一个 admission webhook。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/t38f8v.png" alt="k8s api request lifecycle"></p>
<p>整体的步骤如下所示：</p>
<ul>
<li><ol>
<li>检查集群中是否启用了 admission webhook 控制器，并根据需要进行配置。</li>
</ol>
</li>
<li><ol>
<li>编写处理准入请求的 HTTP 回调，回调可以是一个部署在集群中的简单 HTTP 服务，甚至也可以是一个 <code>serverless</code> 函数。</li>
</ol>
</li>
<li><ol>
<li>通过 <code>MutatingWebhookConfiguration</code> 和 <code>ValidatingWebhookConfiguration</code> 资源配置 admission webhook。</li>
</ol>
</li>
</ul>
<p>这两种类型的 admission webhook 之间的区别是非常明显的：<code>validating webhooks</code> 可以拒绝请求，但是它们却不能修改准入请求中获取的对象，而 <code>mutating webhooks</code> 可以在返回准入响应之前通过创建补丁来修改对象，如果 webhook 拒绝了一个请求，则会向最终用户返回错误。</p>
<p>现在非常火热的 Service Mesh 应用 <code>istio</code> 就是通过 mutating webhooks 来自动将 <code>Envoy</code> 这个 sidecar 容器注入到 Pod 中去的：<a target="_blank" rel="noopener" href="https://istio.io/docs/setup/kubernetes/sidecar-injection/%E3%80%82">https://istio.io/docs/setup/kubernetes/sidecar-injection/。</a></p>
<h2 id="创建配置一个-Admission-Webhook"><a href="#创建配置一个-Admission-Webhook" class="headerlink" title="创建配置一个 Admission Webhook"></a>创建配置一个 Admission Webhook</h2><p>上面我们介绍了 Admission Webhook 的理论知识，接下来我们在一个真实的 Kubernetes 集群中来实际测试使用下，我们将创建一个 webhook 的 webserver，将其部署到集群中，然后创建 webhook 配置查看是否生效。</p>
<p>首先确保在 apiserver 中启用了 <code>MutatingAdmissionWebhook</code> 和 <code>ValidatingAdmissionWebhook</code> 这两个控制器，通过参数 <code>--enable-admission-plugins</code> 进行配置，当前 v1.22 版本已经内置默认开启了，如果没有开启则需要添加上这两个参数，然后重启 apiserver。</p>
<p>然后通过运行下面的命令检查集群中是否启用了准入注册 API：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl api-versions |grep admission</span><br><span class="line">admissionregistration.k8s.io/v1</span><br></pre></td></tr></table></figure>



<h3 id="编写-webhook"><a href="#编写-webhook" class="headerlink" title="编写 webhook"></a>编写 webhook</h3><p>满足了前面的先决条件后，接下来我们就来实现一个 webhook 示例，通过监听两个不同的 HTTP 端点（validate 和 mutate）来进行 <code>validating</code> 和 <code>mutating webhook</code> 验证。</p>
<p>这个 webhook 的完整代码可以在 Github 上获取：<a target="_blank" rel="noopener" href="https://github.com/cnych/admission-webhook-example%EF%BC%8C%E8%AF%A5%E4%BB%93%E5%BA%93">https://github.com/cnych/admission-webhook-example，该仓库</a> Fork 自项目 <a target="_blank" rel="noopener" href="https://github.com/banzaicloud/admission-webhook-example%E3%80%82%E8%BF%99%E4%B8%AA">https://github.com/banzaicloud/admission-webhook-example。这个</a> webhook 是一个简单的带 TLS 认证的 HTTP 服务，用 Deployment 方式部署在我们的集群中。</p>
<p>代码中主要的逻辑在两个文件中：<code>main.go</code> 和 <code>webhook.go</code>，main.go 文件包含创建 HTTP 服务的代码，而 webhook.go 包含 validates 和 mutates 两个 webhook 的逻辑，大部分代码都比较简单，首先查看 main.go 文件，查看如何使用标准 golang 包来启动 HTTP 服务，以及如何从命令行标志中读取 TLS 配置的证书：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag.StringVar(&amp;parameters.certFile, <span class="string">&quot;tlsCertFile&quot;</span>, <span class="string">&quot;/etc/webhook/certs/cert.pem&quot;</span>, <span class="string">&quot;File containing the x509 Certificate for HTTPS.&quot;</span>)</span><br><span class="line">flag.StringVar(&amp;parameters.keyFile, <span class="string">&quot;tlsKeyFile&quot;</span>, <span class="string">&quot;/etc/webhook/certs/key.pem&quot;</span>, <span class="string">&quot;File containing the x509 private key to --tlsCertFile.&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>然后一个比较重要的是 serve 函数，用来处理传入的 mutate 和 validating 函数 的 HTTP 请求。该函数从请求中反序列化 <code>AdmissionReview</code> 对象，执行一些基本的内容校验，根据 URL 路径调用相应的 mutate 和 validate 函数，然后序列化 AdmissionReview 对象：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(whsvr *WebhookServer)</span></span> serve(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">var</span> body []<span class="type">byte</span></span><br><span class="line">    <span class="keyword">if</span> r.Body != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> data, err := ioutil.ReadAll(r.Body); err == <span class="literal">nil</span> &#123;</span><br><span class="line">            body = data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(body) == <span class="number">0</span> &#123;</span><br><span class="line">        glog.Error(<span class="string">&quot;empty body&quot;</span>)</span><br><span class="line">        http.Error(w, <span class="string">&quot;empty body&quot;</span>, http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验 Content-Type</span></span><br><span class="line">    contentType := r.Header.Get(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> contentType != <span class="string">&quot;application/json&quot;</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;Content-Type=%s, expect application/json&quot;</span>, contentType)</span><br><span class="line">        http.Error(w, <span class="string">&quot;invalid Content-Type, expect `application/json`&quot;</span>, http.StatusUnsupportedMediaType)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> admissionResponse *v1beta1.AdmissionResponse</span><br><span class="line">    ar := v1beta1.AdmissionReview&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> _, _, err := deserializer.Decode(body, <span class="literal">nil</span>, &amp;ar); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;Can&#x27;t decode body: %v&quot;</span>, err)</span><br><span class="line">        admissionResponse = &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">            Result: &amp;metav1.Status&#123;</span><br><span class="line">                Message: err.Error(),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.URL.Path == <span class="string">&quot;/mutate&quot;</span> &#123;</span><br><span class="line">            admissionResponse = whsvr.mutate(&amp;ar)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> r.URL.Path == <span class="string">&quot;/validate&quot;</span> &#123;</span><br><span class="line">            admissionResponse = whsvr.validate(&amp;ar)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    admissionReview := v1beta1.AdmissionReview&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> admissionResponse != <span class="literal">nil</span> &#123;</span><br><span class="line">        admissionReview.Response = admissionResponse</span><br><span class="line">        <span class="keyword">if</span> ar.Request != <span class="literal">nil</span> &#123;</span><br><span class="line">            admissionReview.Response.UID = ar.Request.UID</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resp, err := json.Marshal(admissionReview)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;Can&#x27;t encode response: %v&quot;</span>, err)</span><br><span class="line">        http.Error(w, fmt.Sprintf(<span class="string">&quot;could not encode response: %v&quot;</span>, err), http.StatusInternalServerError)</span><br><span class="line">    &#125;</span><br><span class="line">    glog.Infof(<span class="string">&quot;Ready to write reponse ...&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> _, err := w.Write(resp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;Can&#x27;t write response: %v&quot;</span>, err)</span><br><span class="line">        http.Error(w, fmt.Sprintf(<span class="string">&quot;could not write response: %v&quot;</span>, err), http.StatusInternalServerError)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>主要的准入逻辑是 validate 和 mutate 两个函数。validate 函数检查资源对象是否需要校验：不验证 kube-system 和 kube-public 两个命名空间中的资源，如果想要显示的声明不验证某个资源，可以通过在资源对象中添加一个 <code>admission-webhook-example.qikqiak.com/validate=false</code> 的 annotation 进行声明。如果需要验证，则根据资源类型的 kind，和标签与其对应项进行比较，将 service 或者 deployment 资源从请求中反序列化出来。如果缺少某些 label 标签，则响应中的 Allowed 会被设置为 false。如果验证失败，则会在响应中写入失败原因，最终用户在尝试创建资源时会收到失败的信息。validate 函数实现如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// validate deployments and services</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(whsvr *WebhookServer)</span></span> validate(ar *v1beta1.AdmissionReview) *v1beta1.AdmissionResponse &#123;</span><br><span class="line">    req := ar.Request</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        availableLabels                 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">        objectMeta                      *metav1.ObjectMeta</span><br><span class="line">        resourceNamespace, resourceName <span class="type">string</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    glog.Infof(<span class="string">&quot;AdmissionReview for Kind=%v, Namespace=%v Name=%v (%v) UID=%v patchOperation=%v UserInfo=%v&quot;</span>,</span><br><span class="line">        req.Kind, req.Namespace, req.Name, resourceName, req.UID, req.Operation, req.UserInfo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> req.Kind.Kind &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Deployment&quot;</span>:</span><br><span class="line">        <span class="keyword">var</span> deployment appsv1.Deployment</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(req.Object.Raw, &amp;deployment); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">&quot;Could not unmarshal raw object: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">                Result: &amp;metav1.Status&#123;</span><br><span class="line">                    Message: err.Error(),</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resourceName, resourceNamespace, objectMeta = deployment.Name, deployment.Namespace, &amp;deployment.ObjectMeta</span><br><span class="line">        availableLabels = deployment.Labels</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Service&quot;</span>:</span><br><span class="line">        <span class="keyword">var</span> service corev1.Service</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(req.Object.Raw, &amp;service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">&quot;Could not unmarshal raw object: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">                Result: &amp;metav1.Status&#123;</span><br><span class="line">                    Message: err.Error(),</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resourceName, resourceNamespace, objectMeta = service.Name, service.Namespace, &amp;service.ObjectMeta</span><br><span class="line">        availableLabels = service.Labels</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !validationRequired(ignoredNamespaces, objectMeta) &#123;</span><br><span class="line">        glog.Infof(<span class="string">&quot;Skipping validation for %s/%s due to policy check&quot;</span>, resourceNamespace, resourceName)</span><br><span class="line">        <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">            Allowed: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allowed := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> result *metav1.Status</span><br><span class="line">    glog.Info(<span class="string">&quot;available labels:&quot;</span>, availableLabels)</span><br><span class="line">    glog.Info(<span class="string">&quot;required labels&quot;</span>, requiredLabels)</span><br><span class="line">    <span class="keyword">for</span> _, rl := <span class="keyword">range</span> requiredLabels &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := availableLabels[rl]; !ok &#123;</span><br><span class="line">            allowed = <span class="literal">false</span></span><br><span class="line">            result = &amp;metav1.Status&#123;</span><br><span class="line">                Reason: <span class="string">&quot;required labels are not set&quot;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">        Allowed: allowed,</span><br><span class="line">        Result:  result,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>判断是否需要进行校验的方法如下，可以通过 namespace 进行忽略，也可以通过 annotations 设置进行配置：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validationRequired</span><span class="params">(ignoredList []<span class="type">string</span>, metadata *metav1.ObjectMeta)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    required := admissionRequired(ignoredList, admissionWebhookAnnotationValidateKey, metadata)</span><br><span class="line">    glog.Infof(<span class="string">&quot;Validation policy for %v/%v: required:%v&quot;</span>, metadata.Namespace, metadata.Name, required)</span><br><span class="line">    <span class="keyword">return</span> required</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">admissionRequired</span><span class="params">(ignoredList []<span class="type">string</span>, admissionAnnotationKey <span class="type">string</span>, metadata *metav1.ObjectMeta)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// skip special kubernetes system namespaces</span></span><br><span class="line">    <span class="keyword">for</span> _, namespace := <span class="keyword">range</span> ignoredList &#123;</span><br><span class="line">        <span class="keyword">if</span> metadata.Namespace == namespace &#123;</span><br><span class="line">            glog.Infof(<span class="string">&quot;Skip validation for %v for it&#x27;s in special namespace:%v&quot;</span>, metadata.Name, metadata.Namespace)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    annotations := metadata.GetAnnotations()</span><br><span class="line">    <span class="keyword">if</span> annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">        annotations = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> required <span class="type">bool</span></span><br><span class="line">    <span class="keyword">switch</span> strings.ToLower(annotations[admissionAnnotationKey]) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        required = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;n&quot;</span>, <span class="string">&quot;no&quot;</span>, <span class="string">&quot;false&quot;</span>, <span class="string">&quot;off&quot;</span>:</span><br><span class="line">        required = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> required</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>mutate 函数的代码是非常类似的，但不是仅仅比较标签并在响应中设置 Allowed，而是创建一个补丁，将缺失的标签添加到资源中，并将 not_available 设置为标签的值。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main mutation process</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(whsvr *WebhookServer)</span></span> mutate(ar *v1beta1.AdmissionReview) *v1beta1.AdmissionResponse &#123;</span><br><span class="line">    req := ar.Request</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        availableLabels, availableAnnotations <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">        objectMeta                            *metav1.ObjectMeta</span><br><span class="line">        resourceNamespace, resourceName       <span class="type">string</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    glog.Infof(<span class="string">&quot;AdmissionReview for Kind=%v, Namespace=%v Name=%v (%v) UID=%v patchOperation=%v UserInfo=%v&quot;</span>,</span><br><span class="line">        req.Kind, req.Namespace, req.Name, resourceName, req.UID, req.Operation, req.UserInfo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> req.Kind.Kind &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Deployment&quot;</span>:</span><br><span class="line">        <span class="keyword">var</span> deployment appsv1.Deployment</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(req.Object.Raw, &amp;deployment); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">&quot;Could not unmarshal raw object: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">                Result: &amp;metav1.Status&#123;</span><br><span class="line">                    Message: err.Error(),</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resourceName, resourceNamespace, objectMeta = deployment.Name, deployment.Namespace, &amp;deployment.ObjectMeta</span><br><span class="line">        availableLabels = deployment.Labels</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Service&quot;</span>:</span><br><span class="line">        <span class="keyword">var</span> service corev1.Service</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(req.Object.Raw, &amp;service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">&quot;Could not unmarshal raw object: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">                Result: &amp;metav1.Status&#123;</span><br><span class="line">                    Message: err.Error(),</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resourceName, resourceNamespace, objectMeta = service.Name, service.Namespace, &amp;service.ObjectMeta</span><br><span class="line">        availableLabels = service.Labels</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !mutationRequired(ignoredNamespaces, objectMeta) &#123;</span><br><span class="line">        glog.Infof(<span class="string">&quot;Skipping validation for %s/%s due to policy check&quot;</span>, resourceNamespace, resourceName)</span><br><span class="line">        <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">            Allowed: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    annotations := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;admissionWebhookAnnotationStatusKey: <span class="string">&quot;mutated&quot;</span>&#125;</span><br><span class="line">    patchBytes, err := createPatch(availableAnnotations, annotations, availableLabels, addLabels)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">            Result: &amp;metav1.Status&#123;</span><br><span class="line">                Message: err.Error(),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glog.Infof(<span class="string">&quot;AdmissionResponse: patch=%v\n&quot;</span>, <span class="type">string</span>(patchBytes))</span><br><span class="line">    <span class="keyword">return</span> &amp;v1beta1.AdmissionResponse&#123;</span><br><span class="line">        Allowed: <span class="literal">true</span>,</span><br><span class="line">        Patch:   patchBytes,</span><br><span class="line">        PatchType: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> *v1beta1.PatchType &#123;</span><br><span class="line">            pt := v1beta1.PatchTypeJSONPatch</span><br><span class="line">            <span class="keyword">return</span> &amp;pt</span><br><span class="line">        &#125;(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>其实我们已经将代码打包成一个 docker 镜像了，你可以直接使用，镜像仓库地址为：<code>cnych/admission-webhook-example:v1</code>。当然如果你希望更改部分代码，那就需要重新构建项目了，由于这个项目采用 go 语言开发，包管理工具更改为了 <code>go mod</code>，所以我们需要确保构建环境提前安装好 go 环境，当然 docker 也是必不可少的，因为我们需要的是打包成一个 docker 镜像。</p>
<p>获取项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir admission-webhook &amp;&amp; cd admission-webhook</span><br><span class="line">git clone https://github.com/cnych/admission-webhook-example.git</span><br></pre></td></tr></table></figure>



<p>我们可以看到代码根目录下面有一个 build 的脚本，只需要提供我们自己的 docker 镜像用户名然后直接构建即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_USER=cnych</span><br><span class="line">./build</span><br></pre></td></tr></table></figure>



<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>为了部署 webhook server，我们需要在我们的 Kubernetes 集群中创建一个 service 和 deployment 资源对象，部署是非常简单的，只是需要配置服务的 TLS 配置。我们可以在代码根目录下面的 deployment 文件夹下面查看 <code>deployment.yaml</code> 文件中关于证书的配置声明，会发现从命令行参数中读取的证书和私钥文件是通过一个 secret 对象挂载进来的：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-tlsCertFile=/etc/webhook/certs/cert.pem</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-tlsKeyFile=/etc/webhook/certs/key.pem</span></span><br><span class="line">[<span class="string">...</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">webhook-certs</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/etc/webhook/certs</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">webhook-certs</span></span><br><span class="line">  <span class="attr">secret:</span></span><br><span class="line">  <span class="attr">secretName:</span> <span class="string">admission-webhook-example-certs</span></span><br></pre></td></tr></table></figure>



<p>在生产环境中，对于 TLS 证书（特别是私钥）的处理是非常重要的，我们可以使用类似于 <code>cert-manager</code> 之类的工具来自动处理 TLS 证书，或者将私钥密钥存储在 Vault 中，而不是直接存在 secret 资源对象中。</p>
<p>我们可以使用任何类型的证书，但是需要注意的是我们这里设置的 CA 证书是需要让 apiserver 能够验证的，我们这里可以重用 Istio 项目中的生成的证书签名请求脚本。通过发送请求到 apiserver，获取认证信息，然后使用获得的结果来创建需要的 secret 对象。</p>
<p>首先，<a target="_blank" rel="noopener" href="https://github.com/cnych/admission-webhook-example/blob/master/deployment/webhook-create-signed-cert.sh">运行该脚本</a>检查 secret 对象中是否有证书和私钥信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ./deployment/webhook-create-signed-cert.sh</span><br><span class="line">creating certs in tmpdir /var/folders/x3/wjy_1z155pdf8jg_jgpmf6kc0000gn/T/tmp.IboFfX97</span><br><span class="line">Generating RSA private key, 2048 bit long modulus (2 primes)</span><br><span class="line">..................+++++</span><br><span class="line">........+++++</span><br><span class="line">e is 65537 (0x010001)</span><br><span class="line">certificatesigningrequest.certificates.k8s.io/admission-webhook-example-svc.default created</span><br><span class="line">NAME                                    AGE   REQUESTOR          CONDITION</span><br><span class="line">admission-webhook-example-svc.default   1s    kubernetes-admin   Pending</span><br><span class="line">certificatesigningrequest.certificates.k8s.io/admission-webhook-example-svc.default approved</span><br><span class="line">secret/admission-webhook-example-certs created</span><br><span class="line"></span><br><span class="line">➜  ~ kubectl get secret admission-webhook-example-certs</span><br><span class="line">NAME                              TYPE     DATA   AGE</span><br><span class="line">admission-webhook-example-certs   Opaque   2      28s</span><br></pre></td></tr></table></figure>



<p>一旦 secret 对象创建成功，我们就可以直接创建 deployment 和 service 对象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/rbac.yaml</span><br><span class="line">➜  ~ kubectl apply -f deployment/deployment.yaml</span><br><span class="line">deployment.apps &quot;admission-webhook-example-deployment&quot; created</span><br><span class="line"></span><br><span class="line">➜  ~ kubectl apply -f deployment/service.yaml</span><br><span class="line">service &quot;admission-webhook-example-svc&quot; created</span><br></pre></td></tr></table></figure>



<h3 id="配置-webhook"><a href="#配置-webhook" class="headerlink" title="配置 webhook"></a>配置 webhook</h3><p>现在我们的 webhook 服务运行起来了，它可以接收来自 apiserver 的请求。但是我们还需要在 kubernetes 上创建一些配置资源。首先来配置 validating 这个 webhook，查看 webhook 配置，我们会注意到它里面包含一个 <code>CA_BUNDLE</code> 的占位符：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clientConfig:</span><br><span class="line">  service:</span><br><span class="line">        name: admission-webhook-example-svc</span><br><span class="line">        namespace: default</span><br><span class="line">        path: &quot;/validate&quot;</span><br><span class="line">    caBundle: $&#123;CA_BUNDLE&#125;</span><br></pre></td></tr></table></figure>



<p>CA 证书应提供给 admission webhook 配置，这样 apiserver 才可以信任 webhook server 提供的 TLS 证书。因为我们上面已经使用 Kubernetes API 签署了证书，所以我们可以使用我们的 kubeconfig 中的 CA 证书来简化操作。代码仓库中也提供了一个小脚本用来替换 CA_BUNDLE 这个占位符，创建 <code>validating webhook</code> 之前运行该命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ./deployment/validatingwebhook.yaml | ./deployment/webhook-patch-ca-bundle.sh &gt; ./deployment/validatingwebhook-ca-bundle.yaml</span><br></pre></td></tr></table></figure>



<p>执行完成后可以查看 <code>validatingwebhook-ca-bundle.yaml</code> 文件中的 <code>CA_BUNDLE</code> 占位符的值是否已经被替换掉了。需要注意的是 <code>clientConfig</code> 里面的 path 路径是 <code>/validate</code>，因为我们代码在是将 validate 和 mutate 集成在一个服务中的。</p>
<p>然后就是需要配置一些 RBAC 规则，我们想在 deployment 或 service 创建时拦截 API 请求，所以 apiGroups 和 apiVersions 对应的值分别为 <code>apps/v1</code> 对应 deployment，v1 对应 service。</p>
<p>webhook 的最后一部分是配置一个 <code>namespaceSelector</code>，我们可以为 webhook 工作的命名空间定义一个 selector，这个配置不是必须的，比如我们这里添加了下面的配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespaceSelector:</span><br><span class="line">  matchLabels:</span><br><span class="line">      admission-webhook-example: enabled</span><br></pre></td></tr></table></figure>



<p>则我们的 webhook 会只适用于设置了 <code>admission-webhook-example=enabled</code> 标签的 namespaces。</p>
<p>所以，首先需要在 default 这个 namespace 中添加该标签：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl label namespace default admission-webhook-example=enabled</span><br><span class="line">namespace &quot;default&quot; labeled</span><br></pre></td></tr></table></figure>



<p>最后，创建这个 validating webhook 配置对象，这会动态地将 webhook 添加到 webhook 链上，所以一旦创建资源，就会拦截请求然后调用我们的 webhook 服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/validatingwebhook-ca-bundle.yaml</span><br><span class="line">validatingwebhookconfiguration.admissionregistration.k8s.io &quot;validation-webhook-example-cfg&quot; created</span><br></pre></td></tr></table></figure>



<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>现在让我们创建一个 deployment 资源来验证下是否有效，代码仓库下有一个 <code>sleep.yaml</code> 的资源清单文件，直接创建即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/sleep.yaml</span><br><span class="line">Error from server (required labels are not set): error when creating &quot;deployment/sleep.yaml&quot;: admission webhook &quot;required-labels.qikqiak.com&quot; denied the request: required labels are not set</span><br></pre></td></tr></table></figure>



<p>正常情况下创建的时候会出现上面的错误信息，然后部署另外一个 <code>sleep-with-labels.yaml</code> 的资源清单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/sleep-with-labels.yaml</span><br><span class="line">deployment.apps &quot;sleep&quot; created</span><br></pre></td></tr></table></figure>



<p>可以看到可以正常部署，然后我们将上面的 deployment 删除，然后部署另外一个 <code>sleep-no-validation.yaml</code> 资源清单，该清单中不存在所需的标签，但是配置了 <code>admission-webhook-example.qikqiak.com/validate=false</code> 这样的 annotation，所以正常也是可以正常创建的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl delete deployment sleep</span><br><span class="line">➜  ~ kubectl apply -f deployment/sleep-no-validation.yaml</span><br><span class="line">deployment.apps &quot;sleep&quot; created</span><br></pre></td></tr></table></figure>



<h3 id="部署-mutating-webhook"><a href="#部署-mutating-webhook" class="headerlink" title="部署 mutating webhook"></a>部署 mutating webhook</h3><p>首先，我们将上面的 <code>validating webhook</code> 删除，防止对 mutating 产生干扰，然后部署新的配置。 <code>mutating webhook</code> 与 <code>validating webhook</code> 配置基本相同，但是 webook server 的路径是 <code>/mutate</code>，同样的我们也需要先填充上 <code>CA_BUNDLE</code> 这个占位符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl delete validatingwebhookconfiguration validation-webhook-example-cfg</span><br><span class="line">validatingwebhookconfiguration.admissionregistration.k8s.io &quot;validation-webhook-example-cfg&quot; deleted</span><br><span class="line"></span><br><span class="line">➜  ~ cat ./deployment/mutatingwebhook.yaml | ./deployment/webhook-patch-ca-bundle.sh &gt; ./deployment/mutatingwebhook-ca-bundle.yaml</span><br><span class="line"></span><br><span class="line">➜  ~ kubectl apply -f deployment/mutatingwebhook-ca-bundle.yaml</span><br><span class="line">mutatingwebhookconfiguration.admissionregistration.k8s.io &quot;mutating-webhook-example-cfg&quot; created</span><br></pre></td></tr></table></figure>



<p>现在我们可以再次部署上面的 sleep 应用程序，然后查看是否正确添加 label 标签：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/sleep.yaml</span><br><span class="line">deployment.apps &quot;sleep&quot; created</span><br><span class="line"></span><br><span class="line">➜  ~ kubectl get deploy sleep -o yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    admission-webhook-example.qikqiak.com/status: mutated</span><br><span class="line">    deployment.kubernetes.io/revision: &quot;1&quot;</span><br><span class="line">  creationTimestamp: &quot;2020-06-01T08:10:04Z&quot;</span><br><span class="line">  generation: 1</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/component: not_available</span><br><span class="line">    app.kubernetes.io/instance: not_available</span><br><span class="line">    app.kubernetes.io/managed-by: not_available</span><br><span class="line">    app.kubernetes.io/name: not_available</span><br><span class="line">    app.kubernetes.io/part-of: not_available</span><br><span class="line">    app.kubernetes.io/version: not_available</span><br><span class="line">  name: sleep</span><br><span class="line">  namespace: default</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>最后，我们重新创建 <code>validating webhook</code>，来一起测试。现在，尝试再次创建 sleep 应用。正常是可以创建成功的，我们可以查看下 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-are-they">admission-controllers 的文档</a>。</p>
<p>准入控制分两个阶段进行，第一阶段，运行 <code>mutating admission</code> 控制器，第二阶段运行 <code>validating admission</code> 控制器。</p>
<p>所以 <code>mutating webhook</code> 在第一阶段添加上缺失的 labels 标签，然后 <code>validating webhook</code> 在第二阶段就不会拒绝这个 deployment 了，因为标签已经存在了，用 <code>not_available</code> 设置他们的值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kubectl apply -f deployment/validatingwebhook-ca-bundle.yaml</span><br><span class="line">validatingwebhookconfiguration.admissionregistration.k8s.io &quot;validation-webhook-example-cfg&quot; created</span><br><span class="line"></span><br><span class="line">➜  ~ kubectl apply -f deployment/sleep.yaml</span><br><span class="line">deployment.apps &quot;sleep&quot; created</span><br></pre></td></tr></table></figure>



<p>但是如果我们有这样的相关需求就单独去开发一个准入控制器的 webhook 是不是就显得非常麻烦，不够灵活了，为了解决这个问题我们可以使用 Kubernetes 提供的一些策略管理引擎，在不需要编写代码的情况也可以来实现我们的这些需求，比如 <code>Kyverno</code>、<code>Gatekeeper</code> 等等，后续我们再进行详细讲解。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/Admission%20webhooks/">https://huiaz.github.io/2025/09/11/Admission%20webhooks/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/BGP%20%E5%8D%8F%E8%AE%AE/" title="BGP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">BGP 协议</div></div><div class="info-2"><div class="info-item-1">什么是 BGP (Border Gateway Protocol)？BGP (Border Gateway Protocol)，即边界网关协议，是互联网上路由选择的核心协议，也被称为“互联网的胶水”或“互联网的骨干”。它是一种外部网关协议 (EGP)，用于在自治系统 (Autonomous System, AS) 之间交换路由信息，从而实现全球互联网的互联互通。 核心概念：  自治系统 (AS)： 互联网上一个由单一行政实体或组织控制的、拥有统一路由策略的 IP 网络集合。每个 AS 都被分配一个唯一的 16 位或 32 位的数字，称为 **AS 号 (ASN)**。例如，大型的互联网服务提供商 (ISP)、大学网络、大型企业网络等都可能是一个 AS。 路由： 数据包从源头到达目的地的路径选择过程。 外部网关协议 (EGP)： 指在不同自治系统之间交换路由信息的协议。 内部网关协议 (IGP)： 指在同一个自治系统内部交换路由信息的协议，例如 OSPF、EIGRP、RIP 等。  BGP 的主要目标是确保数据包能够从全球任何一个 AS 发送到另一个 AS，并找到最佳的（或符合策略...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ARP%E5%8D%8F%E8%AE%AE/" title="ARP协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ARP协议</div></div><div class="info-2"><div class="info-item-1">好的，我们来详细了解一下 ARP 和 RARP。  1. ARP (Address Resolution Protocol) - 地址解析协议作用： 将网络层（IP 地址） 地址解析为数据链路层（MAC 地址） 的协议。 应用场景：当一个主机想与同一局域网内的另一个主机进行通信时，它知道目标主机的 IP 地址，但数据链路层（如以太网）需要目标主机的 MAC 地址来封装帧。此时就需要 ARP 来完成 IP 到 MAC 的映射。 工作原理（简化流程）：  ARP 请求： 主机 A（已知主机 B 的 IP 地址）希望获取主机 B 的 MAC 地址，它会构建一个 ARP 请求报文，其中包含自己的 IP 地址和 MAC 地址，以及目标主机 B 的 IP 地址。 广播： 主机 A 将这个 ARP 请求报文封装在一个以太网帧中，并将目的 MAC 地址设置为广播地址（FFFF.FFFF.FFFF），然后发送到局域网中。 接收与响应： 局域网中的所有主机都会收到这个广播帧。 每个主机都会检查 ARP 请求报文中的目标 IP 地址是否是自己的 IP 地址。 只有目标主机 B 会识别出这个 IP 地址...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/PromQL%20%E5%9F%BA%E7%A1%80/" title="PromQL 基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">PromQL 基础</div></div><div class="info-2"><div class="info-item-1">PromQL 基础在继续深入学习 PromQL 查询细节之前，我们先来看看 PromQL 查询的一些理论基础。 嵌套结构与 SQL 查询语言（SELECT * FROM …）不同，PromQL 是一种嵌套的函数式语言，就是我们要把需要查找的数据描述成一组嵌套的表达式，每个表达式都会评估为一个中间值，每个中间值都会被用作它上层表达式中的参数，而查询的最外层表达式表示你可以在表格、图形中看到的最终返回值。比如下面的查询语句： 1234567891011histogram_quantile(  # 查询的根，最终结果表示一个近似分位数。  0.9,  # histogram_quantile() 的第一个参数，分位数的目标值  # histogram_quantile() 的第二个参数，聚合的直方图  sum by(le, method, path) (    # sum() 的参数，直方图过去5分钟每秒增量。    rate(      # rate() 的参数，过去5分钟的原始直方图序列      demo_api_request_duration_seconds_bucket&#...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%9C%A8%20Kubernetes%20%E4%B8%8A%E9%83%A8%E7%BD%B2%20LLM%20%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/" title="在 Kubernetes 上部署 LLM 大语言模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">在 Kubernetes 上部署 LLM 大语言模型</div></div><div class="info-2"><div class="info-item-1">在 Kubernetes 上部署 LLM 大语言模型从今年开始，人们对大型语言模型 (LLM) 及其在 GPU 基础设施上的部署的兴趣显着增加。这种不断增长的热情是由人工智能和机器学习的进步推动的，这需要 GPU 能够有效提供大量的计算能力。GPU 领先制造商 Nvidia 的股价也因这一趋势而飙升。同样诞生了大量的大模型，对于这些模型的部署和管理也变得越来越重要，在这方面 Ollama 和 OpenUI 是一个不错的选择。 Ollama 是一个开源的机器学习模型部署工具，它可以帮助您将模型部署到生产环境中，简化大型语言模型 (LLM) 的管理和交互。Ollama 拥有各种一流的开源模型，例如 Llama 3、Phi 3、Mistral 等等，我们可以将 Ollama 看成是 Docker，但是专注于机器学习模型。  使用 Ollama 部署模型非常简单，就类似于使用 Docker 部署应用程序一样。但是，如果你对 CLI 不熟悉，那么使用 Ollama 会有点痛苦。为了解决这个问题，我们可以使用一个 open-webui 的项目，它提供了一个漂亮的界面，可以让您更轻松地部署模型...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Kubernetes%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" title="Kubernetes 集群部署"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Kubernetes 集群部署</div></div><div class="info-2"><div class="info-item-1">Kubernetes 集群部署现在我们使用 kubeadm 从头搭建一个使用 containerd 作为容器运行时的 Kubernetes 集群，这里我们安装最新的 v1.22.2 版本。 环境准备3 个节点，都是 Centos 7.6 系统，内核版本：3.10.0-1062.4.1.el7.x86_64，在每个节点上添加 hosts 信息： 1234➜  ~ cat /etc/hosts192.168.31.31 master1192.168.31.108 node1192.168.31.46 node2  hostname 节点的 hostname 必须使用标准的 DNS 命名，另外千万不用什么默认的localhost 的 hostname，会导致各种错误出现的。在 Kubernetes 项目里，机器的名字以及一切存储在 Etcd 中的 API 对象，都必须使用标准的 DNS 命名（RFC 1123）。可以使用命令 hostnamectl set-hostname node1 来修改 hostname。 禁用防火墙： 12➜  ~ systemctl stop firewal...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Pod%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="Pod 生命周期"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Pod 生命周期</div></div><div class="info-2"><div class="info-item-1">Pod 生命周期 前面我们已经了解了 Pod 的设计原理，接下来我们来了解下 Pod 的生命周期。下图展示了一个 Pod 的完整生命周期过程，其中包含 Init Container、Pod Hook、健康检查 三个主要部分，接下来我们就来分别介绍影响 Pod 生命周期的部分： 首先在介绍 Pod 的生命周期之前，我们先了解下 Pod 的状态，因为 Pod 状态可以反应出当前我们的 Pod 的具体状态信息，也是我们分析排错的一个必备的方式。 Pod 状态首先先了解下 Pod 的状态值，我们可以通过 kubectl explain pod.status 命令来了解关于 Pod 状态的一些信息，Pod 的状态定义在 PodStatus 对象中，其中有一个 phase 字段，下面是 phase 的可能取值：  挂起（Pending）：Pod 信息已经提交给了集群，但是还没有被调度器调度到合适的节点或者 Pod 里的镜像正在下载 运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态 成功（Succee...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Pod%20%E8%B0%83%E5%BA%A6/" title="Pod 调度"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Pod 调度</div></div><div class="info-2"><div class="info-item-1">调度一般情况下我们部署的 Pod 是通过集群的自动调度策略来选择节点的，默认情况下调度器考虑的是资源足够，并且负载尽量平均，但是有的时候我们需要能够更加细粒度的去控制 Pod 的调度，比如我们希望一些机器学习的应用只跑在有 GPU 的节点上；但是有的时候我们的服务之间交流比较频繁，又希望能够将这服务的 Pod 都调度到同一个的节点上。这就需要使用一些调度方式来控制 Pod 的调度了，主要有两个概念：亲和性和反亲和性，亲和性又分成节点亲和性(nodeAffinity)和 Pod 亲和性(podAffinity)。 nodeSelector在了解亲和性之前，我们先来了解一个非常常用的调度方式：nodeSelector。我们知道 label 标签是 kubernetes 中一个非常重要的概念，用户可以非常灵活的利用 label 来管理集群中的资源，比如最常见的 Service 对象通过 label 去匹配 Pod 资源，而 Pod 的调度也可以根据节点的 label 来进行调度。 我们可以通过下面的命令查看我们的 node 的 label： 12345➜ kubectl get nod...</div></div></div></a><a class="pagination-related" href="/2025/09/11/kube-state-metrics/" title="kube-state-metrics"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">kube-state-metrics</div></div><div class="info-2"><div class="info-item-1">kube-state-metrics上面我们配置了自动发现 Endpoints 的监控，但是这些监控数据都是应用内部的监控，需要应用本身提供一个 /metrics 接口，或者对应的 exporter 来暴露对应的指标数据，但是在 Kubernetes 集群上 Pod、DaemonSet、Deployment、Job、CronJob 等各种资源对象的状态也需要监控，这也反映了使用这些资源部署的应用的状态。比如：  我调度了多少个副本？现在可用的有几个？ 多少个 Pod 是 running/stopped/terminated 状态？ Pod 重启了多少次？ 我有多少 job 在运行中等等  通过查看前面从集群中拉取的指标(这些指标主要来自 apiserver 和 kubelet 中集成的 cAdvisor)，并没有具体的各种资源对象的状态指标。对于 Prometheus 来说，当然是需要引入新的 exporter 来暴露这些指标，Kubernetes 提供了一个kube-state-metrics 就是我们需要的。kube-state-metrics 关注于获取 Kubernete...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">准入控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#admission-webhook-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">admission webhook 是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA-Admission-Webhook"><span class="toc-number">1.2.</span> <span class="toc-text">创建配置一个 Admission Webhook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99-webhook"><span class="toc-number">1.2.1.</span> <span class="toc-text">编写 webhook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA"><span class="toc-number">1.2.2.</span> <span class="toc-text">构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2"><span class="toc-number">1.2.3.</span> <span class="toc-text">部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-webhook"><span class="toc-number">1.2.4.</span> <span class="toc-text">配置 webhook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.2.5.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2-mutating-webhook"><span class="toc-number">1.2.6.</span> <span class="toc-text">部署 mutating webhook</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>