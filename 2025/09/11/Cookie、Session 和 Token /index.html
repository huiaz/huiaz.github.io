<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Cookie、Session 和 Token | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Cookie、Session 和 Token 都是在 Web 开发中用于管理用户状态、实现身份认证和授权的关键机制，但它们在存储位置、工作原理、安全性、无状态性等方面存在显著差异。 1. Cookie 定义： Cookie 是存储在用户浏览器（客户端） 的一小段文本信息。 作用： 会话管理： 记录用户的登录状态、购物车内容等。 个性化设置： 记住用户的偏好（如语言、主题）。 追踪： 记录用户行为，">
<meta property="og:type" content="article">
<meta property="og:title" content="Cookie、Session 和 Token">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/Cookie%E3%80%81Session%20%E5%92%8C%20Token%20/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="Cookie、Session 和 Token 都是在 Web 开发中用于管理用户状态、实现身份认证和授权的关键机制，但它们在存储位置、工作原理、安全性、无状态性等方面存在显著差异。 1. Cookie 定义： Cookie 是存储在用户浏览器（客户端） 的一小段文本信息。 作用： 会话管理： 记录用户的登录状态、购物车内容等。 个性化设置： 记住用户的偏好（如语言、主题）。 追踪： 记录用户行为，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:26:20.237Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Cookie、Session 和 Token",
  "url": "https://huiaz.github.io/2025/09/11/Cookie%E3%80%81Session%20%E5%92%8C%20Token%20/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:26:20.237Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/Cookie%E3%80%81Session%20%E5%92%8C%20Token%20/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Cookie、Session 和 Token',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Cookie、Session 和 Token</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Cookie、Session 和 Token</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:26:20.237Z" title="更新于 2025-09-11 22:26:20">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Cookie、Session 和 Token 都是在 Web 开发中用于<strong>管理用户状态、实现身份认证和授权</strong>的关键机制，但它们在存储位置、工作原理、安全性、无状态性等方面存在显著差异。</p>
<h3 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h3><ul>
<li><strong>定义：</strong> Cookie 是<strong>存储在用户浏览器（客户端）</strong> 的一小段文本信息。</li>
<li><strong>作用：</strong><ul>
<li><strong>会话管理：</strong> 记录用户的登录状态、购物车内容等。</li>
<li><strong>个性化设置：</strong> 记住用户的偏好（如语言、主题）。</li>
<li><strong>追踪：</strong> 记录用户行为，用于数据分析和广告推送。</li>
</ul>
</li>
<li><strong>工作原理：</strong><ol>
<li>当用户第一次访问服务器时，服务器在响应头中包含 <code>Set-Cookie</code> 字段，将 Cookie 发送给浏览器。</li>
<li>浏览器接收到 Cookie 后，将其存储起来。</li>
<li>之后，浏览器每次向同一个域发送请求时，都会在请求头中自动带上该域相关的所有 Cookie。</li>
<li>服务器接收到请求后，从 Cookie 中读取信息。</li>
</ol>
</li>
<li><strong>特点：</strong><ul>
<li><strong>存储位置：</strong> 客户端（浏览器）。</li>
<li><strong>由谁管理：</strong> 浏览器自动发送，服务器设置。</li>
<li><strong>安全性：</strong><ul>
<li><strong>易受 CSRF 攻击：</strong> 因为浏览器会自动发送 Cookie，攻击者可能利用这一点伪造请求。</li>
<li><strong>易受 XSS 攻击：</strong> 如果未设置 <code>HttpOnly</code> 标志，JS 可以访问 Cookie，攻击者可利用 XSS 窃取 Cookie。</li>
<li><strong>明文传输风险：</strong> 如果不使用 HTTPS，Cookie 内容可能被截获。</li>
</ul>
</li>
<li><strong>大小限制：</strong> 通常每个 Cookie 大小限制在 4KB 左右，且每个域的 Cookie 数量也有限制。</li>
<li><strong>跨域：</strong> 通常不支持跨域共享（除非进行特殊配置如 <code>domain</code> 属性）。</li>
</ul>
</li>
</ul>
<h3 id="2-Session-基于-Cookie-或-URL-重写"><a href="#2-Session-基于-Cookie-或-URL-重写" class="headerlink" title="2. Session (基于 Cookie 或 URL 重写)"></a>2. Session (基于 Cookie 或 URL 重写)</h3><ul>
<li><strong>定义：</strong> Session 是一种<strong>服务器端</strong>的用户会话管理机制。服务器为每个用户创建一个唯一的会话（Session），并将用户的状态信息存储在服务器上。</li>
<li><strong>作用：</strong> 维护用户的会话状态，跟踪用户在一系列请求中的操作。</li>
<li><strong>工作原理：</strong><ol>
<li>当用户第一次访问服务器时，服务器会生成一个唯一的 Session ID。</li>
<li>服务器将这个 Session ID 以 Cookie（最常见的方式，称为 Session Cookie）的形式发送给浏览器。</li>
<li>浏览器接收到 Session ID Cookie 后存储起来。</li>
<li>之后，浏览器每次请求时，都会将这个 Session ID Cookie 发送给服务器。</li>
<li>服务器根据 Session ID 找到对应的 Session 数据，从而识别用户和其会话状态。</li>
<li>（另一种较少用的方式是 URL 重写，将 Session ID 放在 URL 参数中，但安全性、美观性差）</li>
</ol>
</li>
<li><strong>特点：</strong><ul>
<li><strong>存储位置：</strong> 服务器端。客户端只存储 Session ID。</li>
<li><strong>由谁管理：</strong> 服务器生成和管理会话；Cookie（Session ID）由浏览器自动发送。</li>
<li><strong>安全性：</strong> 相对于直接将数据存放在 Cookie 中更安全，因为实际数据在服务器端，攻击者无法直接篡改。但仍依赖于 Cookie 的安全性（CSRF、XSS）。</li>
<li><strong>扩展性（Scalability）：</strong> 存在挑战。在分布式系统中（多台服务器），需要共享 Session 数据（如使用 Redis、Memcached 等集中式存储），否则用户请求可能被路由到不识别其 Session 的服务器。</li>
<li><strong>占用服务器资源：</strong> 每个会话都会占用服务器内存或其他存储资源。</li>
</ul>
</li>
</ul>
<h3 id="3-Token-通常指-JWT-JSON-Web-Token"><a href="#3-Token-通常指-JWT-JSON-Web-Token" class="headerlink" title="3. Token (通常指 JWT - JSON Web Token)"></a>3. Token (通常指 JWT - JSON Web Token)</h3><ul>
<li><strong>定义：</strong> Token 是一种<strong>无状态</strong>的认证机制。与 Session 不同，用户的所有认证信息和授权信息都<strong>编码在 Token 本身</strong>中，并通过签名确保其不可篡改。</li>
<li><strong>作用：</strong> 用户身份认证和授权。它允许服务器在不存储用户状态的情况下，验证用户的身份和权限。</li>
<li><strong>工作原理（JWT 为例）：</strong><ol>
<li>用户通过用户名和密码向服务器认证。</li>
<li>服务器验证凭据，然后生成一个包含用户信息的 Token（如用户ID、角色、过期时间）。</li>
<li>服务器将 Token 返回给客户端。</li>
<li>客户端（通常是浏览器或移动应用）将 Token 存储起来（如在 localStorage、sessionStorage 或 Cookie 中）。</li>
<li>之后，客户端每次向服务器发送请求时，都会在请求头（通常是 <code>Authorization</code> 字段，如 <code>Bearer &lt;token&gt;</code>）中带上这个 Token。</li>
<li>服务器接收到请求后，解析并验证 Token 的签名。如果签名有效且未过期，服务器就认为用户是合法的，并从 Token 中提取用户信息，进行授权操作。</li>
</ol>
</li>
<li><strong>特点：</strong><ul>
<li><strong>存储位置：</strong> 客户端（通常是 localStorage、sessionStorage）。</li>
<li><strong>由谁管理：</strong> Token 由服务器生成和签名，客户端存储和发送，服务器验证。</li>
<li><strong>安全性：</strong><ul>
<li><strong>无状态：</strong> 服务器无需存储会话信息，减轻服务器压力，易于扩展。</li>
<li><strong>减少 CSRF 风险：</strong> 因为 Token 不会自动由浏览器发送，攻击者难以利用。</li>
<li><strong>易受 XSS 攻击：</strong> 如果 Token 存储在 localStorage，仍可能被 XSS 攻击窃取。解决方案是结合 Cookie 和 HttpOnly 使用。</li>
<li><strong>明文传输风险：</strong> Token 内容（Payload）是 Base64 编码的，不是加密的。敏感信息不应直接放入 Token 中。认证必须通过 HTTPS。</li>
<li><strong>无法主动失效：</strong> 一旦 Token 被签发，除非过期，否则服务器无法强制其失效（除非使用黑名单机制）。</li>
</ul>
</li>
<li><strong>扩展性（Scalability）：</strong> 极其适合分布式系统和微服务架构，因为每个服务器都可以独立验证 Token，无需共享会话数据。</li>
<li><strong>大小：</strong> 通常比 Session ID 大，但比完整 Session 数据小。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="对比总结："><a href="#对比总结：" class="headerlink" title="对比总结："></a>对比总结：</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Cookie</th>
<th align="left">Session</th>
<th align="left">Token (JWT)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工作模式</strong></td>
<td align="left">客户端存储少量数据</td>
<td align="left">服务器端存储会话数据，客户端存 ID</td>
<td align="left">客户端存储包含认证授权信息的数据</td>
</tr>
<tr>
<td align="left"><strong>状态</strong></td>
<td align="left">有状态（服务器依赖 Cookie 内容进行决策）</td>
<td align="left">有状态（服务器需要存储会话数据）</td>
<td align="left"><strong>无状态</strong>（服务器无需存储会话信息）</td>
</tr>
<tr>
<td align="left"><strong>存储位置</strong></td>
<td align="left"><strong>客户端（浏览器）</strong></td>
<td align="left"><strong>服务器端</strong>（实际数据）；客户端存 Session ID（通常在 Cookie 中）</td>
<td align="left"><strong>客户端</strong>（通常是 localStorage&#x2F;sessionStorage）</td>
</tr>
<tr>
<td align="left"><strong>发送方式</strong></td>
<td align="left">浏览器自动每次请求都带上</td>
<td align="left">浏览器自动带上 Session ID Cookie</td>
<td align="left">客户端手动添加到请求头（如 <code>Authorization: Bearer &lt;token&gt;</code>）</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">CSRF, XSS (无 HttpOnly) 风险高</td>
<td align="left">对实际数据更安全，但仍依赖 Session ID Cookie 的安全</td>
<td align="left">XSS (localStorage) 风险；无法强制失效；无 CSRF 风险（但需避免 Cookie 传输）</td>
</tr>
<tr>
<td align="left"><strong>可扩展性</strong></td>
<td align="left">中等（依赖于每个请求都带上）</td>
<td align="left">差（分布式需共享 Session）</td>
<td align="left"><strong>好</strong>（无状态，易于分布式部署）</td>
</tr>
<tr>
<td align="left"><strong>资源消耗</strong></td>
<td align="left">客户端资源</td>
<td align="left"><strong>服务器资源</strong>（内存&#x2F;DB 存储会话）</td>
<td align="left">客户端资源（存储 Token）；服务器资源（验证签名）</td>
</tr>
<tr>
<td align="left"><strong>应用场景</strong></td>
<td align="left">少量信息存储，用户偏好，追踪</td>
<td align="left">传统 Web 应用的登录状态管理</td>
<td align="left">RESTful API 认证，移动应用，SSO (单点登录)</td>
</tr>
</tbody></table>
<h3 id="如何选择："><a href="#如何选择：" class="headerlink" title="如何选择："></a>如何选择：</h3><ul>
<li><strong>Session + Cookie：</strong> 适用于传统的<strong>单体应用</strong>，需要维护用户会话状态，且不追求极致的扩展性。优点是实现相对简单，安全性在于服务器端数据。</li>
<li><strong>Token (JWT)：</strong> 适用于<strong>前后端分离</strong>、<strong>微服务架构</strong>、<strong>移动应用</strong>、<strong>跨域认证</strong>以及<strong>单点登录 (SSO)</strong> 场景。优点是无状态、易于扩展、安全性相对较高（尤其是在防范 CSRF 方面）。需要注意 JWT 的过期和刷新机制。</li>
<li><strong>纯 Cookie：</strong> 比较少用于身份认证，更多用于少量非敏感数据的存储和用户行为追踪。因为直接在 Cookie 中存储敏感信息安全性较低。</li>
</ul>
<p>在现代 Web 开发中，由于前后端分离和微服务的流行，<strong>Token (JWT)</strong> 已成为越来越主流的认证授权方式。但很多框架也会结合使用 Cookie 来存储 Token，并利用 HttpOnly 和 Secure 标志来增强安全性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/Cookie%E3%80%81Session%20%E5%92%8C%20Token%20/">https://huiaz.github.io/2025/09/11/Cookie%E3%80%81Session%20%E5%92%8C%20Token%20/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/CoreDNS/" title="CoreDNS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CoreDNS</div></div><div class="info-2"><div class="info-item-1">服务发现上面我们讲解了 Service 的用法，我们可以通过 Service 生成的 ClusterIP(VIP) 来访问 Pod 提供的服务，但是在使用的时候还有一个问题：我们怎么知道某个应用的 VIP 呢？比如我们有两个应用，一个是 api 应用，一个是 db 应用，两个应用都是通过 Deployment 进行管理的，并且都通过 Service 暴露出了端口提供服务。api 需要连接到 db 这个应用，我们只知道 db 应用的名称和 db 对应的 Service 的名称，但是并不知道它的 VIP 地址，我们前面的 Service 课程中是不是学习到我们通过 ClusterIP 就可以访问到后面的 Pod 服务，如果我们知道了 VIP 的地址是不是就行了？ 环境变量为了解决上面的问题，在之前的版本中，Kubernetes 采用了环境变量的方法，每个 Pod 启动的时候，会通过环境变量设置所有服务的 IP 和 port 信息，这样 Pod 中的应用可以通过读取环境变量来获取依赖服务的地址信息，这种方法使用起来相对简单，但是有一个很大的问题就是依赖的服务必须在 Pod 启动之前就存...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Containerd/" title="Containerd"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Containerd</div></div><div class="info-2"><div class="info-item-1">Containerd 使用我们知道很早之前的 Docker Engine 中就有了 containerd，只不过现在是将 containerd 从 Docker Engine 里分离出来，作为一个独立的开源项目，目标是提供一个更加开放、稳定的容器运行基础设施。分离出来的 containerd 将具有更多的功能，涵盖整个容器运行时管理的所有需求，提供更强大的支持。 containerd 是一个工业级标准的容器运行时，它强调简单性、健壮性和可移植性，containerd 可以负责干下面这些事情：  管理容器的生命周期（从创建容器到销毁容器） 拉取&#x2F;推送容器镜像 存储管理（管理镜像及容器数据的存储） 调用 runc 运行容器（与 runc 等容器运行时交互） 管理容器网络接口及网络  架构containerd 可用作 Linux 和 Windows 的守护程序，它管理其主机系统完整的容器生命周期，从镜像传输和存储到容器执行和监测，再到底层存储到网络附件等等。  上图是 containerd 官方提供的架构图，可以看出 containerd 采用的也是 C&#x2F;S 架构，...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="代理模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">代理模式</div></div><div class="info-2"><div class="info-item-1">什么是正向代理？正向代理（Forward Proxy），通常我们所说的“代理服务器”指的就是正向代理。它是一个位于客户端和目标服务器之间的服务器。  工作原理： 客户端明确知道自己要访问的目标服务器，但它不直接与目标服务器通信，而是将请求发送给正向代理服务器，由代理服务器去访问目标服务器，然后将目标服务器的响应返回给客户端。 隐藏谁？ 隐藏的是真实的客户端。对于目标服务器来说，它只知道请求来自代理服务器，而不知道是哪个客户端发起的。 应用场景： 规避防火墙或网络限制： 例如，在某些地区或公司网络中，访问特定网站被限制，可以通过境外或未受限地区的正向代理服务器进行访问。 访问内部资源： 例如，公司内部网络通过一个统一的正向代理出口访问互联网资源。 提高访问速度： 代理服务器可以缓存内容，当多个用户访问同一资源时，可以直接从代理缓存中获取，加快速度。 匿名访问： 隐藏真实 IP 地址，保护用户隐私。 网络安全审计： 记录所有经过代理的请求，进行内容过滤和安全检查。    简单理解： 客户端请求一个它想访问的网站A，告诉代理服务器，代理服务器代替客户端去访问网站A，然后把网站A的内容返...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/" title="TCP 滑动窗口的作用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 滑动窗口的作用</div></div><div class="info-2"><div class="info-item-1">TCP 滑动窗口（Sliding Window）是 TCP 协议中一个核心且关键的机制，它主要实现了以下几个重要的作用：  实现流量控制 (Flow Control):  问题： 发送方发送数据的速度如果远超接收方的处理速度，接收方的缓冲区最终会被填满，导致数据溢出丢失。 解决方案： 接收方会通过 TCP 报文段中的窗口大小字段（Window size）告诉发送方，其当前还有多少接收缓冲区是可用的。发送方收到的窗口大小就是它当前可以发送的最大数据量，它绝对不能发送超过这个窗口大小的数据。 动态调整： 随着接收方处理数据的速度和可用缓冲区空间的变化，窗口大小会动态调整。如果接收方处理得慢，窗口就会变小；如果处理得快，窗口就会变大。这确保了发送方的发送速率能与接收方的处理速率相匹配，避免接收方缓冲区溢出。   实现可靠传输 (Reliable Transmission):  问题： 网络传输可能导致数据包丢失、乱序或错误。TCP 需要确保所有数据在发送方和接收方之间都能完整、按序地到达。 解决方案： 滑动窗口机制与确认（ACK）和重传机制紧密结合。 发送窗口： 发送窗口维护着一系列允...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E4%B8%AD%E7%9A%84%20%60RST%60%EF%BC%88Reset%EF%BC%89%E6%8A%A5%E6%96%87/" title="TCP 中的 &#96;RST&#96;（Reset）报文"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 中的 &#96;RST&#96;（Reset）报文</div></div><div class="info-2"><div class="info-item-1">TCP 中的 RST（Reset）报文是一种特殊的控制报文，它表示连接的异常终止或拒绝。与正常关闭连接的 FIN 报文不同，RST 是一种“硬”关闭，它强制终止连接，不进行正常的四次挥手过程，也不保证任何未发送或未确认的数据被可靠传递。 以下是 TCP 中出现 RST 报文的几种常见情况： 1. 端口未开放（连接被拒绝）当客户端向一个服务器的某个端口发起 TCP 连接（发送 SYN 报文），但该端口并没有任何进程在监听（即端口未开放或服务器不接受该连接），或者服务器明确拒绝接收该连接时，服务器会立即返回一个 RST 报文作为对 SYN 报文的响应。  场景： 你尝试 telnet 192.168.1.100 80，但服务器上没有 web 服务运行在 80 端口。 表现： 客户端收到 RST 后，会报告“Connection refused”之类的错误。  2. 半开连接或无效连接当一方的 TCP 连接意外关闭（例如，进程崩溃、拔掉网线、操作系统重启等），而另一方没有意识到连接已经中断，仍然尝试向此已关闭的连接发送数据时，已关闭的一方（或其操作系统）会发送一个 RST 报文，告知对...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81/" title="HTTP 状态码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 状态码</div></div><div class="info-2"><div class="info-item-1">HTTP 状态码HTTP 状态码是服务器对请求的响应。它们是三位数字，分为五个类别，指示请求是否已成功处理，或者是否存在错误。理解这些状态码对于调试网络问题和理解Web应用程序的行为至关重要。 以下是常见的 HTTP 状态码及其简要说明：  1xx - 信息响应 (Informational Responses)指示请求已被接收，继续处理。这些是临时响应，不带任何内容。  100 Continue: 客户端应继续其请求。通常用于客户端发送一个大型请求体到服务器之前，先发送头部，服务器如果允许，则返回 100 Continue，然后客户端再发送请求体。   2xx - 成功响应 (Successful Responses)指示请求已被成功接收、理解和接受。  200 OK: 请求已成功。这是最常见的状态码，表示请求的一切正常，服务器已返回所请求的数据。 201 Created: 请求已成功，并因此创建了一个新的资源。这通常是 PUT 或 POST 请求的响应。响应体中通常包含新创建资源的URI。 202 Accepted: 请求已被接受进行处理，但处理尚未完成。请求可能最终被执行，...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%20%E8%AF%B7%E6%B1%82%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9/" title="HTTP 请求包含哪些内容"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 请求包含哪些内容</div></div><div class="info-2"><div class="info-item-1">HTTP 请求包含哪些内容，请求头和请求体有哪些类型？一个 HTTP 请求通常包含三个主要部分：请求行 (Request Line)、请求头 (Request Headers) 和 **请求体 (Request Body)**。 HTTP 请求的组成部分 请求行 (Request Line)这是请求的第一行，它定义了请求的基本信息。它包含三部分：  **方法 (Method)**：指示对资源所执行的操作类型（例如 GET、POST、PUT 等）。 **URI (Uniform Resource Identifier)**：要访问的资源的路径。 **HTTP 版本 (HTTP Version)**：客户端使用的 HTTP 协议版本（例如 HTTP&#x2F;1.1、HTTP&#x2F;2.0）。  示例：GET /index.html HTTP/1.1  请求头 (Request Headers)请求头提供了关于请求的附加信息、客户端的信息以及响应的期望行为。每个请求头都是一个键值对，以冒号分隔，然后是回车换行符。 示例： 1234567Host: www.example.comU...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%201.0%20%E5%92%8C%202.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" title="HTTP 1.0 和 2.0 有什么区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 1.0 和 2.0 有什么区别</div></div><div class="info-2"><div class="info-item-1">HTTP 1.0 和 2.0 有什么区别？HTTP 1.0 和 2.0 在性能、效率和功能方面存在显著差异。以下是它们的关键区别： HTTP 1.0 (最初的成功)  核心概念：每次请求&#x2F;响应一个连接。 这是它最主要的特点。 短连接 (Short-lived connections): 每个请求和响应都需要建立一个新的TCP连接，在完成传输后立即关闭。这导致了大量的连接建立和关闭开销（三次握手和四次挥手）。   串行请求 (Serial requests): 浏览器一次只能发送一个请求，必须等待当前请求的响应，才能发送下一个请求。这导致了“队头阻塞 (Head-of-Line Blocking)”问题，即一个慢的响应会阻碍后续所有请求。 无头部压缩 (No header compression): 每个请求和响应的头部信息都是原始的，可能包含大量重复信息。 无服务器推送 (No server push): 服务器无法主动向客户端发送资源，只能响应客户端的请求。 无二进制分帧 (No binary framing): 数据以文本形式传输，效率较低。 Cookie (部分支...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Cookie"><span class="toc-number">1.</span> <span class="toc-text">1. Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Session-%E5%9F%BA%E4%BA%8E-Cookie-%E6%88%96-URL-%E9%87%8D%E5%86%99"><span class="toc-number">2.</span> <span class="toc-text">2. Session (基于 Cookie 或 URL 重写)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Token-%E9%80%9A%E5%B8%B8%E6%8C%87-JWT-JSON-Web-Token"><span class="toc-number">3.</span> <span class="toc-text">3. Token (通常指 JWT - JSON Web Token)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">对比总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">如何选择：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>