<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP 的粘包和拆包 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="好的，我们来深入讨论 TCP 的“粘包”和“拆包”问题。这两个概念是 TCP 编程中非常基础但又极其重要的，理解它们是正确处理 TCP 数据流的关键。  1. 为什么会出现粘包和拆包？根本原因在于 TCP 是一个“面向字节流”（Byte Stream）的协议，而不是“面向消息&#x2F;数据报”（Message&#x2F;Datagram Oriented）的协议。  TCP 的特性：  缓冲区：">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP 的粘包和拆包">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="好的，我们来深入讨论 TCP 的“粘包”和“拆包”问题。这两个概念是 TCP 编程中非常基础但又极其重要的，理解它们是正确处理 TCP 数据流的关键。  1. 为什么会出现粘包和拆包？根本原因在于 TCP 是一个“面向字节流”（Byte Stream）的协议，而不是“面向消息&#x2F;数据报”（Message&#x2F;Datagram Oriented）的协议。  TCP 的特性：  缓冲区：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:07:05.379Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP 的粘包和拆包",
  "url": "https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:07:05.379Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP 的粘包和拆包',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP 的粘包和拆包</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP 的粘包和拆包</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:07:05.379Z" title="更新于 2025-09-11 22:07:05">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>好的，我们来深入讨论 TCP 的“粘包”和“拆包”问题。这两个概念是 TCP 编程中非常基础但又极其重要的，理解它们是正确处理 TCP 数据流的关键。</p>
<hr>
<h3 id="1-为什么会出现粘包和拆包？"><a href="#1-为什么会出现粘包和拆包？" class="headerlink" title="1. 为什么会出现粘包和拆包？"></a>1. 为什么会出现粘包和拆包？</h3><p><strong>根本原因在于 TCP 是一个“面向字节流”（Byte Stream）的协议，而不是“面向消息&#x2F;数据报”（Message&#x2F;Datagram Oriented）的协议。</strong></p>
<ul>
<li><p><strong>TCP 的特性：</strong></p>
<ul>
<li><strong>缓冲区：</strong> TCP 有自己的发送缓冲区和接收缓冲区。</li>
<li><strong>全双工：</strong> 数据可以双向独立传输。</li>
<li><strong>可靠的、按序的、无界限的字节流：</strong> TCP 传输的只是字节序列，它不关心你在应用层发送了多少次数据，每次发送了多少字节，或者每次发送的内容之间有什么逻辑边界。</li>
</ul>
</li>
<li><p><strong>发送方：</strong> 当应用程序调用 <code>send()</code> 或 <code>write()</code> 发送数据时，数据首先被复制到 TCP 的发送缓冲区。TCP 协议栈会根据自身的拥塞控制、流量控制以及发送缓冲区的大小，<strong>决定何时、发送多少数据到网络上</strong>。它可能会：</p>
<ul>
<li>将多次小的发送请求合并成一个大的 TCP 段发送（<strong>粘包</strong>）。</li>
<li>将一次大的发送请求拆分成多个小的 TCP 段发送（<strong>拆包</strong>）。</li>
<li>将不同应用程序的发送请求（如果它们使用同一个 TCP 连接）合并发送（<strong>粘包</strong>）。</li>
</ul>
</li>
<li><p><strong>接收方：</strong> 当 TCP 接收到数据时，它会将其放入接收缓冲区，并按照序列号重新排序，然后将其交付给应用程序。应用程序调用 <code>recv()</code> 或 <code>read()</code> 从这个缓冲区读取数据。一次 <code>recv()</code> 调用可能：</p>
<ul>
<li>读取到单个完整的数据包。</li>
<li>读取到多个粘连在一起的数据包（<strong>粘包</strong>）。</li>
<li>只读取到单个数据包的一部分内容（<strong>拆包</strong>）。</li>
<li>读取到单个数据包的开头一部分和前一个数据包的末尾一部分（<strong>粘包</strong>）。</li>
</ul>
</li>
</ul>
<p><strong>核心问题：TCP 不保留消息边界。</strong> 应用程序发送的“消息”概念在 TCP 层被抹平了，只剩下一串无结构的字节。</p>
<hr>
<h3 id="2-什么是粘包？"><a href="#2-什么是粘包？" class="headerlink" title="2. 什么是粘包？"></a>2. 什么是粘包？</h3><p><strong>粘包 (Nagle’s Algorithm and Delayed ACKs):</strong><br>当发送方发送的多个数据包很小，或者发送方和接收方的发送&#x2F;接收速度不匹配时，TCP 可能会将多个小的数据包封装成一个大的 TCP 段（Segment）进行发送。</p>
<p><strong>图示示例（发送方行为）：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用程序发送： <span class="selector-attr">[Msg A]</span> <span class="selector-attr">[Msg B]</span> <span class="selector-attr">[Msg C]</span></span><br><span class="line"></span><br><span class="line">TCP 发送缓冲区：</span><br><span class="line"><span class="selector-attr">[Msg A]</span> <span class="selector-attr">[Msg B]</span> <span class="selector-attr">[Msg C]</span></span><br><span class="line"></span><br><span class="line">TCP 实际发送（可能合并）：</span><br><span class="line"><span class="selector-attr">[            Msg A Msg B Msg C             ]</span>  -&gt; 一个TCP段</span><br></pre></td></tr></table></figure>

<p><strong>图示示例（接收方行为）：</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TCP 接收缓冲区：</span><br><span class="line"><span class="selector-attr">[Msg A_part1 Msg A_part2 Msg B_part1 Msg B_part2 Msg C]</span></span><br><span class="line"></span><br><span class="line">应用程序一次 <span class="built_in">recv</span>() 读取：</span><br><span class="line"><span class="selector-attr">[Msg A_part1 Msg A_part2]</span> -&gt; 第一次 <span class="built_in">recv</span>() (拆包)</span><br><span class="line"><span class="selector-attr">[Msg B_part1 Msg B_part2 Msg C]</span> -&gt; 第二次 <span class="built_in">recv</span>() (粘包 + 剩余部分)</span><br></pre></td></tr></table></figure>

<p><strong>触发粘包的常见情况：</strong></p>
<ol>
<li><strong>Nagle算法：</strong> TCP 默认会启用 Nagle 算法（通常用于优化网络利用率）。该算法会延迟发送小数据包，直到确认收到前一个数据包，或者缓冲器达到最大段大小（MSS），或者达到一定的延迟时间。这会导致多个小数据包被“粘”在一起发送。</li>
<li><strong>发送&#x2F;接收缓冲区：</strong> 如果发送端数据很小，而发送缓冲区还有空间，TCP 可能不会立即发送，而是等待更多数据“填满”缓冲区或达到一定条件再发送。同样，接收方可能一次性从缓冲区读取多个完整的逻辑消息。</li>
<li><strong>MSS（最大段大小）：</strong> TCP 会将大于 MSS 的数据拆分，但小于 MSS 的数据可能会被整合。</li>
</ol>
<hr>
<h3 id="3-什么是拆包？"><a href="#3-什么是拆包？" class="headerlink" title="3. 什么是拆包？"></a>3. 什么是拆包？</h3><p><strong>拆包 (Fragmentation):</strong><br>当发送的数据包比较大，或者一次发送的数据量超过了 TCP 的最大段大小（MSS），或者网络条件不佳时，TCP 可能会将一个大的数据包拆分成多个小的 TCP 段进行发送。</p>
<p><strong>图示示例（发送方行为）：</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">应用程序发送： [                  Big Msg A                         ]</span><br><span class="line"></span><br><span class="line">TCP 发送缓冲区：</span><br><span class="line">[                  Big Msg A                         ]</span><br><span class="line"></span><br><span class="line">TCP 实际发送（拆分）：</span><br><span class="line">[       B<span class="function"><span class="title">ig</span> Msg A part 1       ] -&gt;</span> 第<span class="number">1</span>个TCP段</span><br><span class="line">[       B<span class="function"><span class="title">ig</span> Msg A part 2       ] -&gt;</span> 第<span class="number">2</span>个TCP段</span><br><span class="line">[       B<span class="function"><span class="title">ig</span> Msg A part 3       ] -&gt;</span> 第<span class="number">3</span>个TCP段</span><br></pre></td></tr></table></figure>

<p><strong>图示示例（接收方行为）：</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCP 接收缓冲区：</span><br><span class="line"><span class="selector-attr">[Big Msg A part 1 Big Msg A part 2 Big Msg A part 3]</span></span><br><span class="line"></span><br><span class="line">应用程序一次 <span class="built_in">recv</span>() 读取：</span><br><span class="line"><span class="selector-attr">[Big Msg A part 1]</span> -&gt; 第一次 <span class="built_in">recv</span>()</span><br><span class="line"><span class="selector-attr">[Big Msg A part 2]</span> -&gt; 第二次 <span class="built_in">recv</span>()</span><br><span class="line"><span class="selector-attr">[Big Msg A part 3]</span> -&gt; 第三次 <span class="built_in">recv</span>()</span><br></pre></td></tr></table></figure>

<p><strong>触发拆包的常见情况：</strong></p>
<ol>
<li><strong>MSS（最大段大小）：</strong> 这是最常见的原因。TCP 会将大于 MSS 的数据拆分成 MSS 大小的数据段进行传输。</li>
<li><strong>发送缓冲区不足（极端情况）：</strong> 虽然不常见，但如果应用程序写入的数据量非常大，超出了发送缓冲区当前可用的空间，发送操作可能会被阻塞或部分写入，后续再写入剩下的部分，导致数据被动拆分。</li>
<li><strong>网络拥塞或拥塞窗口限制：</strong> TCP 的拥塞控制机制可能会限制一次能发送的数据量，导致即使发送缓冲区有足够数据，也只能分批发送。</li>
</ol>
<hr>
<h3 id="4-如何处理粘包和拆包问题？"><a href="#4-如何处理粘包和拆包问题？" class="headerlink" title="4. 如何处理粘包和拆包问题？"></a>4. 如何处理粘包和拆包问题？</h3><p>由于 TCP 不提供消息边界，应用程序必须自己定义和处理消息边界。这是 TCP 编程中最关键的一步。</p>
<p>主要的处理策略是在应用层为数据添加“消息边界”信息：</p>
<h4 id="4-1-1-定长消息法-Fixed-Length-Message"><a href="#4-1-1-定长消息法-Fixed-Length-Message" class="headerlink" title="4.1. 1. 定长消息法 (Fixed Length Message)"></a>4.1. 1. 定长消息法 (Fixed Length Message)</h4><ul>
<li><strong>原理：</strong> 约定每个逻辑消息的长度都是固定的。</li>
<li><strong>发送方：</strong> 即使数据不足固定长度，也要填充到固定长度再发送。</li>
<li><strong>接收方：</strong> 每次从缓冲区中读取固定长度字节的数据，认为是一个完整的消息。如果读取到的不足固定长度，则等待直到足够数据。</li>
<li><strong>优点：</strong> 实现简单。</li>
<li><strong>缺点：</strong><ul>
<li>灵活性差：所有消息必须是固定长度。</li>
<li>效率低：如果实际消息很小，会浪费带宽用于填充。</li>
<li>不适合：消息长度经常变化或数据量很大的场景。</li>
</ul>
</li>
</ul>
<h4 id="4-2-2-特殊字符-分隔符法-Delimiter-Based-Message"><a href="#4-2-2-特殊字符-分隔符法-Delimiter-Based-Message" class="headerlink" title="4.2. 2. 特殊字符&#x2F;分隔符法 (Delimiter Based Message)"></a>4.2. 2. 特殊字符&#x2F;分隔符法 (Delimiter Based Message)</h4><ul>
<li><strong>原理：</strong> 在每个消息的末尾添加一个特殊的字符或字符串作为消息的结束标志。</li>
<li><strong>发送方：</strong> 在每个消息后面添加分隔符。</li>
<li><strong>接收方：</strong> 持续从缓冲区读取数据，直到检测到分隔符。</li>
<li><strong>优点：</strong> 实现相对简单，无需固定长度。</li>
<li><strong>缺点：</strong><ul>
<li><strong>数据中不能包含分隔符：</strong> 这是最大的缺陷，如果消息内容中也包含了分隔符，就会导致错误解析。</li>
<li>效率相对较低：需要逐字节处理查找分隔符。</li>
<li>如果分隔符丢失或损坏，数据会无法正确解析。</li>
</ul>
</li>
</ul>
<h4 id="4-3-3-消息头-消息体法-Header-Body-Message-最常用和推荐"><a href="#4-3-3-消息头-消息体法-Header-Body-Message-最常用和推荐" class="headerlink" title="4.3. 3. 消息头+消息体法 (Header + Body Message) - 最常用和推荐"></a>4.3. 3. 消息头+消息体法 (Header + Body Message) - <strong>最常用和推荐</strong></h4><ul>
<li><strong>原理：</strong> 每个消息由两部分组成：<ul>
<li><strong>消息头 (Header)：</strong> 包含消息的元数据，<strong>最重要的就是消息体的长度</strong>。</li>
<li><strong>消息体 (Body&#x2F;Payload)：</strong> 实际的业务数据。</li>
</ul>
</li>
<li><strong>发送方：</strong><ol>
<li>计算消息体的长度。</li>
<li>将长度信息编码到消息头中（例如，用4个字节表示）。</li>
<li>将消息头和消息体拼接起来发送。</li>
</ol>
</li>
<li><strong>接收方：</strong><ol>
<li>首先尝试读取固定长度的“消息头”（例如，4个字节）。</li>
<li>从消息头中解析出消息体的预期长度。</li>
<li>根据解析出的长度，继续从缓冲区中读取相应数量的字节，直到读取完整个消息体。</li>
<li>如果缓冲区数据不足，则等待，直到数据足够再读取。</li>
</ol>
</li>
<li><strong>优点：</strong><ul>
<li><strong>可靠性高：</strong> 不会受消息内容影响，只要长度字段不被破坏。</li>
<li><strong>效率高：</strong> 可以一次性读取指定长度的数据，减少迭代。</li>
<li><strong>灵活性强：</strong> 消息体长度可以动态变化。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>实现相对复杂，需要状态机管理读取过程。</li>
<li>需要定义消息头的格式（长度字段的位数、字节序等）。</li>
</ul>
</li>
</ul>
<p><strong>示例状态机（消息头+消息体法接收端）：</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">状态<span class="number">1</span>：等待消息头</span><br><span class="line">    尝试读取 <span class="number">4</span> 字节（消息长度）</span><br><span class="line">    如果不足 <span class="number">4</span> 字节，则等待</span><br><span class="line">    读取到 <span class="number">4</span> 字节后，解析出消息体长度 <span class="built_in">N</span></span><br><span class="line">    进入状态<span class="number">2</span></span><br><span class="line"></span><br><span class="line">状态<span class="number">2</span>：等待消息体</span><br><span class="line">    尝试读取 <span class="built_in">N</span> 字节（消息体）</span><br><span class="line">    如果不足 <span class="built_in">N</span> 字节，则等待</span><br><span class="line">    读取到 <span class="built_in">N</span> 字节后，得到完整消息</span><br><span class="line">    处理消息，然后返回状态<span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-关于-Nagle-算法的额外说明"><a href="#5-关于-Nagle-算法的额外说明" class="headerlink" title="5. 关于 Nagle 算法的额外说明"></a>5. 关于 Nagle 算法的额外说明</h3><p>虽然 Nagle 算法会导致粘包，但其目的是为了提高网络利用率，减少小包数量。在某些对延迟非常敏感的场景（如实时游戏），你可能希望禁用 Nagle 算法（通过设置 <code>TCP_NODELAY</code> 选项为 true），但这会增加网络上的小包数量，可能导致网络拥堵或效率下降。即使禁用 Nagle 算法，仍然无法避免所有粘包和拆包问题，因为还有缓冲区和其他因素的影响。因此，<strong>正确的做法始终是在应用层处理消息边界。</strong></p>
<hr>
<p>理解粘包和拆包，以及如何处理它们，是编写健壮、高效的 TCP 网络程序的基础。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/">https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP-四次挥手"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCP-四次挥手</div></div><div class="info-2"><div class="info-item-1">TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。 假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。 四次挥手过程详解：第一次挥手：FIN 报文段（客户端 A → 服务器 B）  客户端 A (主动关闭方)：  当客户端 A 的应用层想要关闭连接时（例如调用 close() 或 shutdown()），客户端 A 的 TCP 会发送一个带有 FIN (Finish) 标志的报文段给服务器 B。 这个 FIN 报文段的序列号通常是它发送的最后一个数据字节的序列号的下一个。 发送 FIN 后，客户端 A 进入 FIN_WAIT_1 状态。这意味着客户端 A 不再发送数据，但仍然可以接收数据。  状态变化： ESTABLISHED → FIN_WAIT_1   第二次挥手：ACK 报文段（服务器 B → 客户端 A）  服务器 B (被动关闭方)：  当...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP 超时重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TCP 超时重传机制</div></div><div class="info-2"><div class="info-item-1">除了标准的 TCP 四次挥手，还有一些其他方法或特殊情况可以导致连接断开，但它们通常不如四次挥手那样优雅和受控，可能会伴随数据丢失或异常。 1. RST 报文断开连接 (Reset)RST (Reset) 报文是一种 TCP 错误或异常的指示，它会立即终止连接，不会进行标准的四次挥手过程，也不会等待任何未发送或未确认的数据。 RST 报文的常见使用场景：  连接被拒绝： 当客户端尝试连接到一个不存在的端口或一个拒绝连接的服务器端口时，服务器通常会回复一个 RST 报文，表示连接无法建立。 中止连接： 当一方决定突然中止一个连接，而不是通过正常的挥手过程关闭时，会发送 RST。这意味着不再关心对方是否已收到所有数据，也不希望进一步的通信。例如，应用程序调用 SO_LINGER 且 l_onoff 为真，l_linger 为 0 时。 检测半开连接： 如果一方的连接已经关闭（比如进程崩溃），而另一方在试图向已关闭的连接发送数据时，操作系统会检测到这个异常并回复一个 RST 报文。 端口扫描： 端口扫描工具通常会向目标端口发送 SYN 包，根据收到的响应（SYN-ACK 或 RST）来...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP-四次挥手"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP-四次挥手</div></div><div class="info-2"><div class="info-item-1">TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。 假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。 四次挥手过程详解：第一次挥手：FIN 报文段（客户端 A → 服务器 B）  客户端 A (主动关闭方)：  当客户端 A 的应用层想要关闭连接时（例如调用 close() 或 shutdown()），客户端 A 的 TCP 会发送一个带有 FIN (Finish) 标志的报文段给服务器 B。 这个 FIN 报文段的序列号通常是它发送的最后一个数据字节的序列号的下一个。 发送 FIN 后，客户端 A 进入 FIN_WAIT_1 状态。这意味着客户端 A 不再发送数据，但仍然可以接收数据。  状态变化： ESTABLISHED → FIN_WAIT_1   第二次挥手：ACK 报文段（服务器 B → 客户端 A）  服务器 B (被动关闭方)：  当...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E4%B8%BA%E4%BB%80%E4%B9%88%20TCP%20%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E6%9C%89%20TIME_WAIT%20%E7%8A%B6%E6%80%81/" title="为什么 TCP 挥手需要有 TIME_WAIT 状态"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">为什么 TCP 挥手需要有 TIME_WAIT 状态</div></div><div class="info-2"><div class="info-item-1">TIME_WAIT 状态是 TCP 四次挥手过程中一个非常关键且必要的阶段，它主要位于主动关闭连接的一方。它的存在是为了解决两个核心问题： 问题一：确保四次挥手最后一个 ACK 报文可靠到达，防止服务器端重传 FIN 报文。 场景： 假设 TCP 没有 TIME_WAIT 状态，客户端（主动关闭方）发送了最后一个 ACK 后立即关闭连接，进入 CLOSED 状态。 潜在问题： 如果最后一个 ACK 在网络中丢失了，服务器端就没有收到这个 ACK。根据 TCP 的可靠性机制，服务器会认为它的 FIN 报文没有被确认，就会尝试重传 FIN 报文。 后果： 如果客户端已经立即进入 CLOSED 状态并释放了端口，而服务器重传的 FIN 报文到达时，如果客户端的该端口已经被新的连接占用（或直接拒绝接收），服务器将永远无法收到对 FIN 的确认，它会一直停留在 LAST_ACK 状态，耗尽资源并最终超时。 TIME_WAIT 状态让客户端保持一个足够长的时间（2 MSL，通常是 1-4 分钟），如果服务器重传 FIN 报文，客户端依然可以发送新的 ACK 报文作为回应，并重置 TIME_W...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ICMP/" title="ICMP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ICMP</div></div><div class="info-2"><div class="info-item-1">什么是 ICMP 协议？ICMP (Internet Control Message Protocol)，即互联网控制消息协议，是 IP 协议的辅助协议，是 TCP&#x2F;IP 协议族中的一个核心组成部分。ICMP 通常被认为是网络层的协议（与 IP 协议同层），因为它处理 IP 数据包的错误和控制信息。 核心特点：  控制和错误报告： ICMP 的主要作用是报告 IP 数据包传输过程中的错误以及提供网络诊断信息。它不传输用户数据，而是传输网络层面的控制和错误消息。 不可靠性： ICMP 报文本身不提供可靠传输机制。如果一个 ICMP 报文在传输过程中丢失，IP 层不会重传它。 承载于 IP： ICMP 报文是“封装”在 IP 数据包中的。换句话说，一个 ICMP 报文会作为 IP 数据包的有效载荷（payload）进行传输。  ICMP 的主要作用：ICMP 的主要作用可以归纳为以下几点，主要围绕错误报告和网络诊断：  报告差错信息 (Error Reporting):当 IP 数据包在传输过程中遇到问题时，ICMP 被用来向数据包的源主机报告这些错误。常见的 ICMP 差...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F/" title="TCP 的三次握手？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 的三次握手？</div></div><div class="info-2"><div class="info-item-1"> 好的，我们来详细解释 TCP 的三次握手（Three-Way Handshake）过程。这是 TCP 协议建立连接的关键步骤，确保客户端和服务器都准备好进行数据传输。 1. TCP 三次握手的目的三次握手的核心目的是：  确认双方的发送和接收能力正常： 确保客户端能够发送数据，也能接收数据；服务器也能发送数据，也能接收数据。 为会话同步初始序列号 (ISN)： TCP 会为发送的每一个字节数据编号。为了实现可靠传输和乱序重排，需要一个起始的序列号。双方需要知道对方的起始序列号，并在此基础上进行数据传输的确认和管理。 防止已失效的连接请求报文段（SYN）突然又传送到了服务器，从而产生错误： 后面会详细解释这一点。  2. TCP 三次握手的过程假设客户端是发起连接的一方，服务器是等待连接的一方。 第一次握手：客户端 -&gt; 服务器 (SYN) 客户端发送： SYN (Synchronize) 标志位设置为 1： 表示这是一个连接请求报文。 seq (Sequence Number) &#x3D; 客户端的初始序列号 (client_ISN)： 客户端随机选择一个初始序列号。 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/NAT/" title="NAT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">NAT</div></div><div class="info-2"><div class="info-item-1">什么是网络地址转换（NAT）？NAT (Network Address Translation)，即网络地址转换，是一种在 IP 网络中改变数据包的 IP 地址信息的技术。它的主要目的是解决 IPv4 地址枯竭的问题，同时也能提供一定程度的网络安全隔离。 简单来说，NAT 允许一个拥有私有 IP 地址的网络（如家庭网络或企业内部网络）连接到使用公共 IP 地址的外部网络（如互联网），而无需为内部的每台设备都分配一个唯一的公共 IP 地址。 核心概念：  私有 IP 地址： 在私有网络内部使用的 IP 地址，它们不能直接在公共互联网上路由。RFC 1918 定义了以下私有 IP 地址范围： 10.0.0.0 到 10.255.255.255 (10&#x2F;8) 172.16.0.0 到 172.31.255.255 (172.16&#x2F;12) 192.168.0.0 到 192.168.255.255 (192.168&#x2F;16)   公共 IP 地址： 在公共互联网上可寻址的全球唯一的 IP 地址。 NAT 设备： 通常是路由器或防火墙，负责执行 IP 地址的转换...</div></div></div></a><a class="pagination-related" href="/2025/09/11/SNMP/" title="SNMP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">SNMP</div></div><div class="info-2"><div class="info-item-1">什么是 SNMP？SNMP (Simple Network Management Protocol)，即简单网络管理协议，是用于网络管理的标准协议。它允许网络管理员在 IP 网络上远程收集、组织和修改信息，以监控网络设备（如路由器、交换机、服务器、打印机、防火墙等）的运行状态、性能数据以及配置信息。 本质上，SNMP 提供了一种通用的语言和框架，让不同的网络设备能够向管理系统报告自己的状态，并接收管理系统的指令。 SNMP 的核心组件：SNMP 模型由三个主要组件组成：  SNMP 管理站 (NMS - Network Management System)：  通常是一个运行着特定网络管理软件的计算机。 它是网络管理员与 SNMP 协议交互的界面。 负责向代理发送请求、接收代理的响应、处理陷阱 (Traps) 和通知 (Informs)，并以图形或文本形式展示网络设备的健康状况和性能数据。 例如：Nagios, Zabbix, PRTG, SolarWinds 等监控软件都可以作为 NMS。   SNMP 代理 (SNMP Agent)：  运行在被管理网络设备（如路由器、交换机...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. 为什么会出现粘包和拆包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2. 什么是粘包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%86%E5%8C%85%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3. 什么是拆包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4. 如何处理粘包和拆包问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%AE%9A%E9%95%BF%E6%B6%88%E6%81%AF%E6%B3%95-Fixed-Length-Message"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 1. 定长消息法 (Fixed Length Message)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6-%E5%88%86%E9%9A%94%E7%AC%A6%E6%B3%95-Delimiter-Based-Message"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 2. 特殊字符&#x2F;分隔符法 (Delimiter Based Message)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E6%B6%88%E6%81%AF%E5%A4%B4-%E6%B6%88%E6%81%AF%E4%BD%93%E6%B3%95-Header-Body-Message-%E6%9C%80%E5%B8%B8%E7%94%A8%E5%92%8C%E6%8E%A8%E8%8D%90"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. 3. 消息头+消息体法 (Header + Body Message) - 最常用和推荐</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B3%E4%BA%8E-Nagle-%E7%AE%97%E6%B3%95%E7%9A%84%E9%A2%9D%E5%A4%96%E8%AF%B4%E6%98%8E"><span class="toc-number">5.</span> <span class="toc-text">5. 关于 Nagle 算法的额外说明</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>