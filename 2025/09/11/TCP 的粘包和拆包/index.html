<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP 的粘包和拆包 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="好的，我们来深入讨论 TCP 的“粘包”和“拆包”问题。这两个概念是 TCP 编程中非常基础但又极其重要的，理解它们是正确处理 TCP 数据流的关键。  1. 为什么会出现粘包和拆包？根本原因在于 TCP 是一个“面向字节流”（Byte Stream）的协议，而不是“面向消息&#x2F;数据报”（Message&#x2F;Datagram Oriented）的协议。  TCP 的特性：  缓冲区：">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP 的粘包和拆包">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="好的，我们来深入讨论 TCP 的“粘包”和“拆包”问题。这两个概念是 TCP 编程中非常基础但又极其重要的，理解它们是正确处理 TCP 数据流的关键。  1. 为什么会出现粘包和拆包？根本原因在于 TCP 是一个“面向字节流”（Byte Stream）的协议，而不是“面向消息&#x2F;数据报”（Message&#x2F;Datagram Oriented）的协议。  TCP 的特性：  缓冲区：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:07:05.379Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP 的粘包和拆包",
  "url": "https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:07:05.379Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP 的粘包和拆包',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP 的粘包和拆包</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP 的粘包和拆包</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:07:05.379Z" title="更新于 2025-09-11 22:07:05">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>好的，我们来深入讨论 TCP 的“粘包”和“拆包”问题。这两个概念是 TCP 编程中非常基础但又极其重要的，理解它们是正确处理 TCP 数据流的关键。</p>
<hr>
<h3 id="1-为什么会出现粘包和拆包？"><a href="#1-为什么会出现粘包和拆包？" class="headerlink" title="1. 为什么会出现粘包和拆包？"></a>1. 为什么会出现粘包和拆包？</h3><p><strong>根本原因在于 TCP 是一个“面向字节流”（Byte Stream）的协议，而不是“面向消息&#x2F;数据报”（Message&#x2F;Datagram Oriented）的协议。</strong></p>
<ul>
<li><p><strong>TCP 的特性：</strong></p>
<ul>
<li><strong>缓冲区：</strong> TCP 有自己的发送缓冲区和接收缓冲区。</li>
<li><strong>全双工：</strong> 数据可以双向独立传输。</li>
<li><strong>可靠的、按序的、无界限的字节流：</strong> TCP 传输的只是字节序列，它不关心你在应用层发送了多少次数据，每次发送了多少字节，或者每次发送的内容之间有什么逻辑边界。</li>
</ul>
</li>
<li><p><strong>发送方：</strong> 当应用程序调用 <code>send()</code> 或 <code>write()</code> 发送数据时，数据首先被复制到 TCP 的发送缓冲区。TCP 协议栈会根据自身的拥塞控制、流量控制以及发送缓冲区的大小，<strong>决定何时、发送多少数据到网络上</strong>。它可能会：</p>
<ul>
<li>将多次小的发送请求合并成一个大的 TCP 段发送（<strong>粘包</strong>）。</li>
<li>将一次大的发送请求拆分成多个小的 TCP 段发送（<strong>拆包</strong>）。</li>
<li>将不同应用程序的发送请求（如果它们使用同一个 TCP 连接）合并发送（<strong>粘包</strong>）。</li>
</ul>
</li>
<li><p><strong>接收方：</strong> 当 TCP 接收到数据时，它会将其放入接收缓冲区，并按照序列号重新排序，然后将其交付给应用程序。应用程序调用 <code>recv()</code> 或 <code>read()</code> 从这个缓冲区读取数据。一次 <code>recv()</code> 调用可能：</p>
<ul>
<li>读取到单个完整的数据包。</li>
<li>读取到多个粘连在一起的数据包（<strong>粘包</strong>）。</li>
<li>只读取到单个数据包的一部分内容（<strong>拆包</strong>）。</li>
<li>读取到单个数据包的开头一部分和前一个数据包的末尾一部分（<strong>粘包</strong>）。</li>
</ul>
</li>
</ul>
<p><strong>核心问题：TCP 不保留消息边界。</strong> 应用程序发送的“消息”概念在 TCP 层被抹平了，只剩下一串无结构的字节。</p>
<hr>
<h3 id="2-什么是粘包？"><a href="#2-什么是粘包？" class="headerlink" title="2. 什么是粘包？"></a>2. 什么是粘包？</h3><p><strong>粘包 (Nagle’s Algorithm and Delayed ACKs):</strong><br>当发送方发送的多个数据包很小，或者发送方和接收方的发送&#x2F;接收速度不匹配时，TCP 可能会将多个小的数据包封装成一个大的 TCP 段（Segment）进行发送。</p>
<p><strong>图示示例（发送方行为）：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用程序发送： <span class="selector-attr">[Msg A]</span> <span class="selector-attr">[Msg B]</span> <span class="selector-attr">[Msg C]</span></span><br><span class="line"></span><br><span class="line">TCP 发送缓冲区：</span><br><span class="line"><span class="selector-attr">[Msg A]</span> <span class="selector-attr">[Msg B]</span> <span class="selector-attr">[Msg C]</span></span><br><span class="line"></span><br><span class="line">TCP 实际发送（可能合并）：</span><br><span class="line"><span class="selector-attr">[            Msg A Msg B Msg C             ]</span>  -&gt; 一个TCP段</span><br></pre></td></tr></table></figure>

<p><strong>图示示例（接收方行为）：</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TCP 接收缓冲区：</span><br><span class="line"><span class="selector-attr">[Msg A_part1 Msg A_part2 Msg B_part1 Msg B_part2 Msg C]</span></span><br><span class="line"></span><br><span class="line">应用程序一次 <span class="built_in">recv</span>() 读取：</span><br><span class="line"><span class="selector-attr">[Msg A_part1 Msg A_part2]</span> -&gt; 第一次 <span class="built_in">recv</span>() (拆包)</span><br><span class="line"><span class="selector-attr">[Msg B_part1 Msg B_part2 Msg C]</span> -&gt; 第二次 <span class="built_in">recv</span>() (粘包 + 剩余部分)</span><br></pre></td></tr></table></figure>

<p><strong>触发粘包的常见情况：</strong></p>
<ol>
<li><strong>Nagle算法：</strong> TCP 默认会启用 Nagle 算法（通常用于优化网络利用率）。该算法会延迟发送小数据包，直到确认收到前一个数据包，或者缓冲器达到最大段大小（MSS），或者达到一定的延迟时间。这会导致多个小数据包被“粘”在一起发送。</li>
<li><strong>发送&#x2F;接收缓冲区：</strong> 如果发送端数据很小，而发送缓冲区还有空间，TCP 可能不会立即发送，而是等待更多数据“填满”缓冲区或达到一定条件再发送。同样，接收方可能一次性从缓冲区读取多个完整的逻辑消息。</li>
<li><strong>MSS（最大段大小）：</strong> TCP 会将大于 MSS 的数据拆分，但小于 MSS 的数据可能会被整合。</li>
</ol>
<hr>
<h3 id="3-什么是拆包？"><a href="#3-什么是拆包？" class="headerlink" title="3. 什么是拆包？"></a>3. 什么是拆包？</h3><p><strong>拆包 (Fragmentation):</strong><br>当发送的数据包比较大，或者一次发送的数据量超过了 TCP 的最大段大小（MSS），或者网络条件不佳时，TCP 可能会将一个大的数据包拆分成多个小的 TCP 段进行发送。</p>
<p><strong>图示示例（发送方行为）：</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">应用程序发送： [                  Big Msg A                         ]</span><br><span class="line"></span><br><span class="line">TCP 发送缓冲区：</span><br><span class="line">[                  Big Msg A                         ]</span><br><span class="line"></span><br><span class="line">TCP 实际发送（拆分）：</span><br><span class="line">[       B<span class="function"><span class="title">ig</span> Msg A part 1       ] -&gt;</span> 第<span class="number">1</span>个TCP段</span><br><span class="line">[       B<span class="function"><span class="title">ig</span> Msg A part 2       ] -&gt;</span> 第<span class="number">2</span>个TCP段</span><br><span class="line">[       B<span class="function"><span class="title">ig</span> Msg A part 3       ] -&gt;</span> 第<span class="number">3</span>个TCP段</span><br></pre></td></tr></table></figure>

<p><strong>图示示例（接收方行为）：</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCP 接收缓冲区：</span><br><span class="line"><span class="selector-attr">[Big Msg A part 1 Big Msg A part 2 Big Msg A part 3]</span></span><br><span class="line"></span><br><span class="line">应用程序一次 <span class="built_in">recv</span>() 读取：</span><br><span class="line"><span class="selector-attr">[Big Msg A part 1]</span> -&gt; 第一次 <span class="built_in">recv</span>()</span><br><span class="line"><span class="selector-attr">[Big Msg A part 2]</span> -&gt; 第二次 <span class="built_in">recv</span>()</span><br><span class="line"><span class="selector-attr">[Big Msg A part 3]</span> -&gt; 第三次 <span class="built_in">recv</span>()</span><br></pre></td></tr></table></figure>

<p><strong>触发拆包的常见情况：</strong></p>
<ol>
<li><strong>MSS（最大段大小）：</strong> 这是最常见的原因。TCP 会将大于 MSS 的数据拆分成 MSS 大小的数据段进行传输。</li>
<li><strong>发送缓冲区不足（极端情况）：</strong> 虽然不常见，但如果应用程序写入的数据量非常大，超出了发送缓冲区当前可用的空间，发送操作可能会被阻塞或部分写入，后续再写入剩下的部分，导致数据被动拆分。</li>
<li><strong>网络拥塞或拥塞窗口限制：</strong> TCP 的拥塞控制机制可能会限制一次能发送的数据量，导致即使发送缓冲区有足够数据，也只能分批发送。</li>
</ol>
<hr>
<h3 id="4-如何处理粘包和拆包问题？"><a href="#4-如何处理粘包和拆包问题？" class="headerlink" title="4. 如何处理粘包和拆包问题？"></a>4. 如何处理粘包和拆包问题？</h3><p>由于 TCP 不提供消息边界，应用程序必须自己定义和处理消息边界。这是 TCP 编程中最关键的一步。</p>
<p>主要的处理策略是在应用层为数据添加“消息边界”信息：</p>
<h4 id="4-1-1-定长消息法-Fixed-Length-Message"><a href="#4-1-1-定长消息法-Fixed-Length-Message" class="headerlink" title="4.1. 1. 定长消息法 (Fixed Length Message)"></a>4.1. 1. 定长消息法 (Fixed Length Message)</h4><ul>
<li><strong>原理：</strong> 约定每个逻辑消息的长度都是固定的。</li>
<li><strong>发送方：</strong> 即使数据不足固定长度，也要填充到固定长度再发送。</li>
<li><strong>接收方：</strong> 每次从缓冲区中读取固定长度字节的数据，认为是一个完整的消息。如果读取到的不足固定长度，则等待直到足够数据。</li>
<li><strong>优点：</strong> 实现简单。</li>
<li><strong>缺点：</strong><ul>
<li>灵活性差：所有消息必须是固定长度。</li>
<li>效率低：如果实际消息很小，会浪费带宽用于填充。</li>
<li>不适合：消息长度经常变化或数据量很大的场景。</li>
</ul>
</li>
</ul>
<h4 id="4-2-2-特殊字符-分隔符法-Delimiter-Based-Message"><a href="#4-2-2-特殊字符-分隔符法-Delimiter-Based-Message" class="headerlink" title="4.2. 2. 特殊字符&#x2F;分隔符法 (Delimiter Based Message)"></a>4.2. 2. 特殊字符&#x2F;分隔符法 (Delimiter Based Message)</h4><ul>
<li><strong>原理：</strong> 在每个消息的末尾添加一个特殊的字符或字符串作为消息的结束标志。</li>
<li><strong>发送方：</strong> 在每个消息后面添加分隔符。</li>
<li><strong>接收方：</strong> 持续从缓冲区读取数据，直到检测到分隔符。</li>
<li><strong>优点：</strong> 实现相对简单，无需固定长度。</li>
<li><strong>缺点：</strong><ul>
<li><strong>数据中不能包含分隔符：</strong> 这是最大的缺陷，如果消息内容中也包含了分隔符，就会导致错误解析。</li>
<li>效率相对较低：需要逐字节处理查找分隔符。</li>
<li>如果分隔符丢失或损坏，数据会无法正确解析。</li>
</ul>
</li>
</ul>
<h4 id="4-3-3-消息头-消息体法-Header-Body-Message-最常用和推荐"><a href="#4-3-3-消息头-消息体法-Header-Body-Message-最常用和推荐" class="headerlink" title="4.3. 3. 消息头+消息体法 (Header + Body Message) - 最常用和推荐"></a>4.3. 3. 消息头+消息体法 (Header + Body Message) - <strong>最常用和推荐</strong></h4><ul>
<li><strong>原理：</strong> 每个消息由两部分组成：<ul>
<li><strong>消息头 (Header)：</strong> 包含消息的元数据，<strong>最重要的就是消息体的长度</strong>。</li>
<li><strong>消息体 (Body&#x2F;Payload)：</strong> 实际的业务数据。</li>
</ul>
</li>
<li><strong>发送方：</strong><ol>
<li>计算消息体的长度。</li>
<li>将长度信息编码到消息头中（例如，用4个字节表示）。</li>
<li>将消息头和消息体拼接起来发送。</li>
</ol>
</li>
<li><strong>接收方：</strong><ol>
<li>首先尝试读取固定长度的“消息头”（例如，4个字节）。</li>
<li>从消息头中解析出消息体的预期长度。</li>
<li>根据解析出的长度，继续从缓冲区中读取相应数量的字节，直到读取完整个消息体。</li>
<li>如果缓冲区数据不足，则等待，直到数据足够再读取。</li>
</ol>
</li>
<li><strong>优点：</strong><ul>
<li><strong>可靠性高：</strong> 不会受消息内容影响，只要长度字段不被破坏。</li>
<li><strong>效率高：</strong> 可以一次性读取指定长度的数据，减少迭代。</li>
<li><strong>灵活性强：</strong> 消息体长度可以动态变化。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>实现相对复杂，需要状态机管理读取过程。</li>
<li>需要定义消息头的格式（长度字段的位数、字节序等）。</li>
</ul>
</li>
</ul>
<p><strong>示例状态机（消息头+消息体法接收端）：</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">状态<span class="number">1</span>：等待消息头</span><br><span class="line">    尝试读取 <span class="number">4</span> 字节（消息长度）</span><br><span class="line">    如果不足 <span class="number">4</span> 字节，则等待</span><br><span class="line">    读取到 <span class="number">4</span> 字节后，解析出消息体长度 <span class="built_in">N</span></span><br><span class="line">    进入状态<span class="number">2</span></span><br><span class="line"></span><br><span class="line">状态<span class="number">2</span>：等待消息体</span><br><span class="line">    尝试读取 <span class="built_in">N</span> 字节（消息体）</span><br><span class="line">    如果不足 <span class="built_in">N</span> 字节，则等待</span><br><span class="line">    读取到 <span class="built_in">N</span> 字节后，得到完整消息</span><br><span class="line">    处理消息，然后返回状态<span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-关于-Nagle-算法的额外说明"><a href="#5-关于-Nagle-算法的额外说明" class="headerlink" title="5. 关于 Nagle 算法的额外说明"></a>5. 关于 Nagle 算法的额外说明</h3><p>虽然 Nagle 算法会导致粘包，但其目的是为了提高网络利用率，减少小包数量。在某些对延迟非常敏感的场景（如实时游戏），你可能希望禁用 Nagle 算法（通过设置 <code>TCP_NODELAY</code> 选项为 true），但这会增加网络上的小包数量，可能导致网络拥堵或效率下降。即使禁用 Nagle 算法，仍然无法避免所有粘包和拆包问题，因为还有缓冲区和其他因素的影响。因此，<strong>正确的做法始终是在应用层处理消息边界。</strong></p>
<hr>
<p>理解粘包和拆包，以及如何处理它们，是编写健壮、高效的 TCP 网络程序的基础。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/">https://huiaz.github.io/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP-四次挥手"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCP-四次挥手</div></div><div class="info-2"><div class="info-item-1">TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。 假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。 四次挥手过程详解：第一次挥手：FIN 报文段（客户端 A → 服务器 B）  客户端 A (主动关闭方)：  当客户端 A 的应用层想要关闭连接时（例如调用 close() 或 shutdown()），客户端 A 的 TCP 会发送一个带有 FIN (Finish) 标志的报文段给服务器 B。 这个 FIN 报文段的序列号通常是它发送的最后一个数据字节的序列号的下一个。 发送 FIN 后，客户端 A 进入 FIN_WAIT_1 状态。这意味着客户端 A 不再发送数据，但仍然可以接收数据。  状态变化： ESTABLISHED → FIN_WAIT_1   第二次挥手：ACK 报文段（服务器 B → 客户端 A）  服务器 B (被动关闭方)：  当...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP 超时重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TCP 超时重传机制</div></div><div class="info-2"><div class="info-item-1">除了标准的 TCP 四次挥手，还有一些其他方法或特殊情况可以导致连接断开，但它们通常不如四次挥手那样优雅和受控，可能会伴随数据丢失或异常。 1. RST 报文断开连接 (Reset)RST (Reset) 报文是一种 TCP 错误或异常的指示，它会立即终止连接，不会进行标准的四次挥手过程，也不会等待任何未发送或未确认的数据。 RST 报文的常见使用场景：  连接被拒绝： 当客户端尝试连接到一个不存在的端口或一个拒绝连接的服务器端口时，服务器通常会回复一个 RST 报文，表示连接无法建立。 中止连接： 当一方决定突然中止一个连接，而不是通过正常的挥手过程关闭时，会发送 RST。这意味着不再关心对方是否已收到所有数据，也不希望进一步的通信。例如，应用程序调用 SO_LINGER 且 l_onoff 为真，l_linger 为 0 时。 检测半开连接： 如果一方的连接已经关闭（比如进程崩溃），而另一方在试图向已关闭的连接发送数据时，操作系统会检测到这个异常并回复一个 RST 报文。 端口扫描： 端口扫描工具通常会向目标端口发送 SYN 包，根据收到的响应（SYN-ACK 或 RST）来...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/TCP%20%E4%B8%AD%E7%9A%84%20%60RST%60%EF%BC%88Reset%EF%BC%89%E6%8A%A5%E6%96%87/" title="TCP 中的 &#96;RST&#96;（Reset）报文"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 中的 &#96;RST&#96;（Reset）报文</div></div><div class="info-2"><div class="info-item-1">TCP 中的 RST（Reset）报文是一种特殊的控制报文，它表示连接的异常终止或拒绝。与正常关闭连接的 FIN 报文不同，RST 是一种“硬”关闭，它强制终止连接，不进行正常的四次挥手过程，也不保证任何未发送或未确认的数据被可靠传递。 以下是 TCP 中出现 RST 报文的几种常见情况： 1. 端口未开放（连接被拒绝）当客户端向一个服务器的某个端口发起 TCP 连接（发送 SYN 报文），但该端口并没有任何进程在监听（即端口未开放或服务器不接受该连接），或者服务器明确拒绝接收该连接时，服务器会立即返回一个 RST 报文作为对 SYN 报文的响应。  场景： 你尝试 telnet 192.168.1.100 80，但服务器上没有 web 服务运行在 80 端口。 表现： 客户端收到 RST 后，会报告“Connection refused”之类的错误。  2. 半开连接或无效连接当一方的 TCP 连接意外关闭（例如，进程崩溃、拔掉网线、操作系统重启等），而另一方没有意识到连接已经中断，仍然尝试向此已关闭的连接发送数据时，已关闭的一方（或其操作系统）会发送一个 RST 报文，告知对...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/" title="TCP 客户端在发送 SYN 之后宕机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 客户端在发送 SYN 之后宕机</div></div><div class="info-2"><div class="info-item-1">这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。 假设客户端 A 尝试连接服务器 B。 1. 客户端发送 SYN (第一次握手) 客户端 A： 生成一个 SYN 包，Seq = client_ISN，发送给服务器 B。 发送后，客户端 A 的 TCP 状态会从 CLOSED 变为 SYN_SENT。  2. 客户端 A 宕机 就在发送 SYN 包之后，客户端 A 突然崩溃（例如，操作系统蓝屏、电源故障、进程被杀掉等）。这意味着客户端 A 的所有网络状态、定时器、内存中的 TCP 控制块信息都瞬间丢失了。  3. 服务器 B 的处理 服务器 B 收到 SYN： 服务器 B 收到了客户端 A 发送的 SYN 包。 服务器 B 响应 SYN+ACK： 服务器 B 按照 TCP 握手流程，会进入 SYN_RCVD 状态，并向客户端 A 发送 SYN+ACK 包 (Seq = server_ISN, Ack = client_ISN + 1)。 服务器 B 等待客户端 ACK： 服务器 B 此时会启动一个定时...</div></div></div></a><a class="pagination-related" href="/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/" title="DHCP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">DHCP 协议</div></div><div class="info-2"><div class="info-item-1">DHCP 协议的工作原理及应用场景什么是 DHCP 协议？DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 是一种网络协议，用于自动化管理和分配网络中的 IP 地址以及其他相关配置信息（如子网掩码、默认网关、DNS 服务器地址等）。它的核心思想是取代手动配置每台设备的网络参数，实现即插即用，大大简化了大型网络的管理。 DHCP 协议的工作原理 (DORA 过程)DHCP 协议通常通过四步过程（称为 DORA 过程）来完成 IP 地址分配：  Discover (发现)  客户端行为： 当一台新设备（或一台没有配置 IP 地址的设备）连接到网络时，它不知道网络中是否有 DHCP 服务器，也不知道自己的 IP 地址。因此，它会广播一个 DHCP Discover 消息到局域网内的所有设备（使用目的 IP 地址 255.255.255.255，源 IP 地址 0.0.0.0）。 目的： 寻找网络中的 DHCP 服务器。   Offer (提供)  服务器行为： 网络中的 DHCP 服务器收到 DHCP Discover 消息后，会从...</div></div></div></a><a class="pagination-related" href="/2025/09/11/PPP%20%E5%8D%8F%E8%AE%AE/" title="PPP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">PPP 协议</div></div><div class="info-2"><div class="info-item-1">PPP 协议（点对点协议 &#x2F; Point-to-Point Protocol）PPP (Point-to-Point Protocol) 是一种用于在两个网络节点之间建立直接连接的数据链路层协议。它主要用于通过串行线缆（如电话线、ISDN、DSL、光纤）连接计算机到互联网，或者在路由器之间建立点对点连接。它是替代早期的 SLIP (Serial Line Internet Protocol) 协议而生的，并解决了 SLIP 的许多限制。 核心作用： PPP 提供了一种标准的方法来：  封装网络层数据包（如 IP 数据包），以便在点对点链路上传输。 建立、配置和测试数据链路连接的可靠性。 提供网络层地址协商（例如，分配 IP 地址）。 提供身份验证机制（可选）。  简而言之，PPP 就是在两点之间架起一座数据传输的桥梁，并确保桥梁能正常工作和通信。  PPP 协议的基本工作流程PPP 的工作流程分为几个阶段，通过使用不同的子协议来完成：  **链路控制协议 (LCP - Link Control Protocol)**：负责建立、配置和测试数据链路。 **网络控制协议 (...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E4%B8%BA%E4%BB%80%E4%B9%88%20TCP%20%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E6%9C%89%20TIME_WAIT%20%E7%8A%B6%E6%80%81/" title="为什么 TCP 挥手需要有 TIME_WAIT 状态"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">为什么 TCP 挥手需要有 TIME_WAIT 状态</div></div><div class="info-2"><div class="info-item-1">TIME_WAIT 状态是 TCP 四次挥手过程中一个非常关键且必要的阶段，它主要位于主动关闭连接的一方。它的存在是为了解决两个核心问题： 问题一：确保四次挥手最后一个 ACK 报文可靠到达，防止服务器端重传 FIN 报文。 场景： 假设 TCP 没有 TIME_WAIT 状态，客户端（主动关闭方）发送了最后一个 ACK 后立即关闭连接，进入 CLOSED 状态。 潜在问题： 如果最后一个 ACK 在网络中丢失了，服务器端就没有收到这个 ACK。根据 TCP 的可靠性机制，服务器会认为它的 FIN 报文没有被确认，就会尝试重传 FIN 报文。 后果： 如果客户端已经立即进入 CLOSED 状态并释放了端口，而服务器重传的 FIN 报文到达时，如果客户端的该端口已经被新的连接占用（或直接拒绝接收），服务器将永远无法收到对 FIN 的确认，它会一直停留在 LAST_ACK 状态，耗尽资源并最终超时。 TIME_WAIT 状态让客户端保持一个足够长的时间（2 MSL，通常是 1-4 分钟），如果服务器重传 FIN 报文，客户端依然可以发送新的 ACK 报文作为回应，并重置 TIME_W...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/" title="TCP 滑动窗口的作用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 滑动窗口的作用</div></div><div class="info-2"><div class="info-item-1">TCP 滑动窗口（Sliding Window）是 TCP 协议中一个核心且关键的机制，它主要实现了以下几个重要的作用：  实现流量控制 (Flow Control):  问题： 发送方发送数据的速度如果远超接收方的处理速度，接收方的缓冲区最终会被填满，导致数据溢出丢失。 解决方案： 接收方会通过 TCP 报文段中的窗口大小字段（Window size）告诉发送方，其当前还有多少接收缓冲区是可用的。发送方收到的窗口大小就是它当前可以发送的最大数据量，它绝对不能发送超过这个窗口大小的数据。 动态调整： 随着接收方处理数据的速度和可用缓冲区空间的变化，窗口大小会动态调整。如果接收方处理得慢，窗口就会变小；如果处理得快，窗口就会变大。这确保了发送方的发送速率能与接收方的处理速率相匹配，避免接收方缓冲区溢出。   实现可靠传输 (Reliable Transmission):  问题： 网络传输可能导致数据包丢失、乱序或错误。TCP 需要确保所有数据在发送方和接收方之间都能完整、按序地到达。 解决方案： 滑动窗口机制与确认（ACK）和重传机制紧密结合。 发送窗口： 发送窗口维护着一系列允...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. 为什么会出现粘包和拆包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2. 什么是粘包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%86%E5%8C%85%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3. 什么是拆包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4. 如何处理粘包和拆包问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%AE%9A%E9%95%BF%E6%B6%88%E6%81%AF%E6%B3%95-Fixed-Length-Message"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 1. 定长消息法 (Fixed Length Message)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6-%E5%88%86%E9%9A%94%E7%AC%A6%E6%B3%95-Delimiter-Based-Message"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 2. 特殊字符&#x2F;分隔符法 (Delimiter Based Message)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E6%B6%88%E6%81%AF%E5%A4%B4-%E6%B6%88%E6%81%AF%E4%BD%93%E6%B3%95-Header-Body-Message-%E6%9C%80%E5%B8%B8%E7%94%A8%E5%92%8C%E6%8E%A8%E8%8D%90"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. 3. 消息头+消息体法 (Header + Body Message) - 最常用和推荐</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B3%E4%BA%8E-Nagle-%E7%AE%97%E6%B3%95%E7%9A%84%E9%A2%9D%E5%A4%96%E8%AF%B4%E6%98%8E"><span class="toc-number">5.</span> <span class="toc-text">5. 关于 Nagle 算法的额外说明</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>