<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Nginx重定向 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Nginx 中如何实现请求的重定向请求重定向是 Nginx 中一项非常常用且重要的功能，主要用于：  URL 规范化： 例如，将 http:&#x2F;&#x2F;example.com 重定向到 https:&#x2F;&#x2F;example.com，或将 example.com 重定向到 www.example.com。 网站结构调整： 当你更改了网站某些页面的 URL 路径，需要将旧 URL 重定向到新 URL，以避免用户遇到">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx重定向">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/%E9%87%8D%E5%AE%9A%E5%90%91/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="Nginx 中如何实现请求的重定向请求重定向是 Nginx 中一项非常常用且重要的功能，主要用于：  URL 规范化： 例如，将 http:&#x2F;&#x2F;example.com 重定向到 https:&#x2F;&#x2F;example.com，或将 example.com 重定向到 www.example.com。 网站结构调整： 当你更改了网站某些页面的 URL 路径，需要将旧 URL 重定向到新 URL，以避免用户遇到">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:20:58.780Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Nginx重定向",
  "url": "https://huiaz.github.io/2025/09/11/%E9%87%8D%E5%AE%9A%E5%90%91/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:20:58.780Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/%E9%87%8D%E5%AE%9A%E5%90%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Nginx重定向',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Nginx重定向</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Nginx重定向</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:20:58.780Z" title="更新于 2025-09-11 22:20:58">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Nginx/">Nginx</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Nginx-中如何实现请求的重定向"><a href="#Nginx-中如何实现请求的重定向" class="headerlink" title="Nginx 中如何实现请求的重定向"></a>Nginx 中如何实现请求的重定向</h1><p>请求重定向是 Nginx 中一项非常常用且重要的功能，主要用于：</p>
<ol>
<li><strong>URL 规范化：</strong> 例如，将 <code>http://example.com</code> 重定向到 <code>https://example.com</code>，或将 <code>example.com</code> 重定向到 <code>www.example.com</code>。</li>
<li><strong>网站结构调整：</strong> 当你更改了网站某些页面的 URL 路径，需要将旧 URL 重定向到新 URL，以避免用户遇到 <code>404 Not Found</code> 错误，并保持搜索引擎排名。</li>
<li><strong>负载均衡或维护：</strong> 在特定情况下将所有请求重定向到另一个域名或一个维护页面。</li>
<li><strong>强制添加&#x2F;移除斜杠：</strong> 规范 URL 格式。</li>
</ol>
<p>Nginx 中实现重定向主要通过以下两个指令：<code>return</code> 和 <code>rewrite</code>。</p>
<hr>
<h3 id="1-return-指令-简单重定向"><a href="#1-return-指令-简单重定向" class="headerlink" title="1. return 指令 (简单重定向)"></a>1. <code>return</code> 指令 (简单重定向)</h3><p><code>return</code> 指令是实现简单重定向最直接、最高效的方式。它会立即停止处理请求，并向客户端发送指定的 HTTP 状态码及其对应的 URL。</p>
<p><strong>语法：</strong> <code>return code [text];</code><br>或 <code>return code URL;</code></p>
<p><strong>常用状态码：</strong></p>
<ul>
<li><strong><code>301 Moved Permanently</code>：</strong> 永久重定向。最常用，告诉浏览器和搜索引擎这个资源已经永久移动到新的 URL。对 SEO 非常重要。</li>
<li><strong><code>302 Found</code>：</strong> 临时重定向。告诉浏览器和搜索引擎这个资源暂时移动到新的 URL。不常用，因为搜索引擎可能不传递权重。</li>
<li><strong><code>307 Temporary Redirect</code>：</strong> 临时重定向。与 <code>302</code> 类似，但更明确地指示客户端在重定向时不改变请求方法（POST 请求仍然是 POST）。</li>
<li><strong><code>308 Permanent Redirect</code>：</strong> 永久重定向。与 <code>301</code> 类似，但更明确地指示客户端在重定向时不改变请求方法。</li>
</ul>
<p><strong>配置位置：</strong> <code>server</code>、<code>location</code> 块。</p>
<hr>
<h4 id="示例-1-1-HTTP-强制跳转-HTTPS-最常见场景"><a href="#示例-1-1-HTTP-强制跳转-HTTPS-最常见场景" class="headerlink" title="示例 1.1: HTTP 强制跳转 HTTPS (最常见场景)"></a>示例 1.1: HTTP 强制跳转 HTTPS (最常见场景)</h4><p>通常我们的网站都会强制使用 HTTPS。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment"># 监听 HTTP 端口</span></span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com; <span class="comment"># 监听的域名</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>; <span class="comment"># 强制跳转到 HTTPS，并保留原路径和查询参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl; <span class="comment"># 监听 HTTPS 端口</span></span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置 SSL 证书和密钥，省略...</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/certs/example.com.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/certs/example.com.key;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... 其他 HTTPS 站点的配置 (如动静分离、API 代理等)</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong> 任何通过 HTTP (端口 80) 访问 <code>example.com</code> 或 <code>www.example.com</code> 的请求，都会被 <code>301</code> 永久重定向到对应的 HTTPS 地址。<code>$host</code> 变量会是请求中的 Host 头（<code>example.com</code> 或 <code>www.example.com</code>），<code>$request_uri</code> 包含完整的路径和查询参数。</p>
<hr>
<h4 id="示例-1-2-强制跳转到带-www-的域名"><a href="#示例-1-2-强制跳转到带-www-的域名" class="headerlink" title="示例 1.2: 强制跳转到带 www 的域名"></a>示例 1.2: 强制跳转到带 <code>www</code> 的域名</h4><p>许多网站习惯将非 <code>www</code> 域名重定向到 <code>www</code> 域名，或反之，以规范 URL。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com; <span class="comment"># 监听没有 www 的域名</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> http://www.example.com<span class="variable">$request_uri</span>; <span class="comment"># 重定向到 www 域名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com; <span class="comment"># 监听带 www 的域名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... www.example.com 网站的配置</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong> 当用户访问 <code>http://example.com/path</code> 时，会被 <code>301</code> 重定向到 <code>http://www.example.com/path</code>。这种配置通常与 HTTPS 跳转结合使用，形成以下组合：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. HTTP -&gt; HTTPS (no-www -&gt; www)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 优先处理 no-www 到 www 的跳转，通常先跳 HTTPS</span></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$host</span> = <span class="string">&#x27;example.com&#x27;</span>) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 已经带 www 的 HTTP 请求跳 HTTPS</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. HTTPS (no-www -&gt; www)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com; <span class="comment"># 监听没有 www 的 HTTPS 域名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># SSL 配置...</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/certs/example.com.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/certs/example.com.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>; <span class="comment"># 将 https://example.com 重定向到 https://www.example.com</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 目标 HTTPS 站点</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SSL 配置...</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/certs/example.com.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/certs/example.com.key;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：<code>if</code> 指令的滥用在 Nginx 中不被推荐，但对于简单的 <code>$host</code> 判断，其副作用有限。更健壮的做法是为 <code>example.com</code> 和 <code>www.example.com</code> 定义不同的 <code>server</code> 块。</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server block for example.com (HTTP) redirects to www.example.com (HTTPS)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># server block for www.example.com (HTTP) redirects to www.example.com (HTTPS)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># server block for example.com (HTTPS) redirects to www.example.com (HTTPS)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/certs/example.com.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/certs/example.com.key;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://www.example.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># server block for official www.example.com (HTTPS)</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/certs/www.example.com.crt; <span class="comment"># 最好使用匹配 www 的证书</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/certs/www.example.com.key;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种多 <code>server</code> 块的写法更清晰且符合 Nginx 的设计哲学。</p>
<hr>
<h3 id="2-rewrite-指令-高级重定向-URL-重写"><a href="#2-rewrite-指令-高级重定向-URL-重写" class="headerlink" title="2. rewrite 指令 (高级重定向&#x2F;URL 重写)"></a>2. <code>rewrite</code> 指令 (高级重定向&#x2F;URL 重写)</h3><p><code>rewrite</code> 指令更为强大和灵活，它可以使用正则表达式来匹配 URL，并根据匹配结果修改 URL。它不仅可以实现重定向，还可以进行 URL 重写（URL 内部跳转到代理）。</p>
<p><strong>语法：</strong> <code>rewrite regex replacement [flag];</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>regex</code>：用于匹配 URL 的正则表达式。</li>
<li><code>replacement</code>：重写后的 URL 或要重定向到的 URL。</li>
<li><code>flag</code>：控制重写行为的标志。<ul>
<li><code>last</code>：停止当前 <code>location</code> 块的 <code>rewrite</code> 指令，继续在新的 URI 下面进行其他 <code>location</code> 的匹配。</li>
<li><code>break</code>：停止当前 <code>location</code> 块的所有 <code>rewrite</code> 指令，并停止处理当前 <code>location</code> 块的请求，但不会在新的 URI 下面进行其他 <code>location</code> 的匹配。</li>
<li><code>redirect</code>：返回 <code>302 Temporary Redirect</code> 响应码。</li>
<li><code>permanent</code>：返回 <code>301 Moved Permanently</code> 响应码。</li>
</ul>
</li>
</ul>
<p><strong>执行顺序：</strong></p>
<ol>
<li>首先在 <code>server</code> 块中按顺序执行 <code>rewrite</code> 指令。</li>
<li>然后根据 <code>server</code> 块中重写后的 URI 寻找匹配的 <code>location</code> 块。</li>
<li>如果在 <code>location</code> 块中还有 <code>rewrite</code> 指令，则按顺序执行。</li>
</ol>
<p><strong>配置位置：</strong> <code>server</code>、<code>location</code> 块。</p>
<hr>
<h4 id="示例-2-1-重定向旧-URL-到新-URL-使用-permanent-flag"><a href="#示例-2-1-重定向旧-URL-到新-URL-使用-permanent-flag" class="headerlink" title="示例 2.1: 重定向旧 URL 到新 URL (使用 permanent flag)"></a>示例 2.1: 重定向旧 URL 到新 URL (使用 <code>permanent</code> flag)</h4><p>假设你的网站结构调整，旧产品详情页的 URL 格式是 <code>/product?id=123</code>，现在变成了 <code>/products/item-123.html</code>。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 重定向旧格式的 /product?id=N 到新格式 /products/item-N.html</span></span><br><span class="line">        <span class="comment"># (?&lt;id&gt;\d+) 是捕获组，名为 id，匹配一个或多个数字</span></span><br><span class="line">        <span class="comment"># $arg_id 获取 URL query string 中的 id 参数</span></span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$arg_id</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/product$</span> /products/item-<span class="variable">$arg_id</span>.html <span class="literal">permanent</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 另一种写法，更推荐在 location 块中使用</span></span><br><span class="line">        <span class="comment"># location = /product &#123; # 精确匹配 /product</span></span><br><span class="line">        <span class="comment">#     if ($arg_id) &#123;</span></span><br><span class="line">        <span class="comment">#         rewrite ^ /products/item-$arg_id.html permanent;</span></span><br><span class="line">        <span class="comment">#     &#125;</span></span><br><span class="line">        <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 或者如果旧 URL 是 /old-product-page.html</span></span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/old-product-page.html$</span> /new-product-page.html <span class="literal">permanent</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ... 其他网站的配置</span></span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>当请求 <code>http://example.com/product?id=123</code> 时，由于 <code>id</code> 参数存在，Nginx 会执行 <code>rewrite</code> 规则，将请求 <code>301</code> 重定向到 <code>http://example.com/products/item-123.html</code>。</li>
<li>当请求 <code>http://example.com/old-product-page.html</code> 时，会被 <code>301</code> 重定向到 <code>http://example.com/new-product-page.html</code>。</li>
</ul>
<hr>
<h4 id="示例-2-2-实现伪静态（URL-重写，内部跳转）"><a href="#示例-2-2-实现伪静态（URL-重写，内部跳转）" class="headerlink" title="示例 2.2: 实现伪静态（URL 重写，内部跳转）"></a>示例 2.2: 实现伪静态（URL 重写，内部跳转）</h4><p>许多 PHP 框架（如 WordPress、Laravel）会把所有请求都通过一个入口文件 <code>index.php</code> 来处理。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="attribute">root</span> /var/www/html; <span class="comment"># 网站的根目录</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 尝试查找对应的文件或目录</span></span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ =<span class="number">404</span>; <span class="comment"># 如果找不到，返回 404</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于所有不匹配现有文件或目录的请求（非静态文件），重写到 index.php</span></span><br><span class="line">        <span class="comment"># 如果你的应用要求所有请求都通过 index.php 处理，可以这样配置 (WordPress 常用)</span></span><br><span class="line">        <span class="comment"># rewrite ^/(.*)$ /index.php/$1 last; # 将 /abc/xyz 重写为 /index.php/abc/xyz</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更常见的单入口应用配置 (例如 Laravel, Symfony)</span></span><br><span class="line">        <span class="comment"># try_files $uri $uri/ /index.php?$query_string;</span></span><br><span class="line">        <span class="comment"># 这里的 try_files 如果找不到文件或目录，会尝试将请求内部转发给 /index.php，</span></span><br><span class="line">        <span class="comment"># 并带上原始的查询参数。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># PHP-FPM 配置</span></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">        <span class="comment"># root /var/www/html; # 与 server 块的 root 一致</span></span><br><span class="line">        <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; <span class="comment"># PHP-FPM 地址和端口</span></span><br><span class="line">        <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>当请求 <code>http://example.com/posts/hello-world</code> 时，<code>try_files</code> 会先检查 <code>/var/www/html/posts/hello-world</code> 文件和 <code>/var/www/html/posts/hello-world/</code> 目录是否存在。</li>
<li>如果都不存在，它会将请求内部转发到 <code>/index.php</code>，并把原始的 <code>$query_string</code>（如果有）传递过去。Nginx 不会向浏览器发送重定向响应，浏览器仍认为自己访问的是 <code>/posts/hello-world</code>。</li>
<li>然后 <code>location ~ \.php$</code> 块会捕获 <code>/index.php</code> 的请求，并将其转发给 PHP-FPM 处理。</li>
</ul>
<hr>
<h4 id="示例-2-3-添加或移除-URL-尾部斜杠"><a href="#示例-2-3-添加或移除-URL-尾部斜杠" class="headerlink" title="示例 2.3: 添加或移除 URL 尾部斜杠"></a>示例 2.3: 添加或移除 URL 尾部斜杠</h4><p>统一 URL 格式有时需要处理尾部斜杠。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="attribute">root</span> /var/www/html;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 移除 URL 结尾的斜杠 (如果不是目录)</span></span><br><span class="line">    <span class="comment"># /path/ -&gt; /path</span></span><br><span class="line">    <span class="comment"># 但不移除根目录 / 的斜杠</span></span><br><span class="line">    <span class="comment"># 注意：这个通常适用于文件，对于目录，保留斜杠更好。</span></span><br><span class="line">    <span class="comment"># rewrite ^/(.*)/$ /$1 permanent; # 这会把 / 重定向到空，不建议这样用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更安全的方式，只处理文件请求，确保没有斜杠</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 确保所有以 .html 结尾的文件没有尾部斜杠</span></span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$uri</span> <span class="regexp">~ ^(.*)\.html/$)</span>&#123;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">301</span> <span class="variable">$1</span>.html;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 添加尾部斜杠到非文件、非根路径的目录，让搜索引擎识别为目录</span></span><br><span class="line">        <span class="comment"># 但是，try_files $uri $uri/ 已经能很好地处理这个问题，通常不需要此 rewrite</span></span><br><span class="line">        <span class="comment"># if (-d $request_filename) &#123; # 如果请求的是目录</span></span><br><span class="line">        <span class="comment">#    rewrite ^/(.*)([^/])$ /$1$2/ permanent;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 常见的强制为目录添加尾部斜杠的写法</span></span><br><span class="line">        <span class="comment"># 如果不是文件，且 URI 不以 / 结尾，则添加斜杠</span></span><br><span class="line">        <span class="comment"># 需配合 try_files 确保文件不被误判</span></span><br><span class="line">        <span class="comment"># rewrite ^(/.*[^/])$ $1/ permanent; # 简单粗暴，但可能影响文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 推荐使用 try_files 配合默认行为，更稳健</span></span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 尾部斜杠的处理比较复杂，因为文件的 URL 通常不带斜杠，而目录的 URL 通常带斜杠。滥用 <code>rewrite</code> 可能导致无限重定向或错误。通常 <code>try_files</code> 指令能更好地处理目录和文件的匹配逻辑。如果你需要强制规范，建议精细化匹配。</p>
<hr>
<h3 id="选择-return-还是-rewrite？"><a href="#选择-return-还是-rewrite？" class="headerlink" title="选择 return 还是 rewrite？"></a>选择 <code>return</code> 还是 <code>rewrite</code>？</h3><ul>
<li><strong>使用 <code>return</code>：</strong><ul>
<li><strong>首选！</strong> 当你只需要将请求从一个 URL <strong>重定向到另一个完整的 URL</strong>（包括协议、域名、路径）时。</li>
<li>处理规则简单，不涉及复杂的正则表达式匹配或内部 URL 转换。</li>
<li>性能更好，因为 Nginx 会立即停止处理，并发送响应。</li>
</ul>
</li>
<li><strong>使用 <code>rewrite</code>：</strong><ul>
<li>当你需要基于请求的 URL <strong>进行复杂的模式匹配和替换</strong>，以生成新的 URL 时。</li>
<li>当你需要进行 <strong>URL 重写</strong>（即内部跳转到另一个文件或 URL，而不向客户端发送重定向响应）时，通常结合 <code>last</code> 或 <code>break</code> 标志，或者 <code>try_files</code> 指令。</li>
<li>涉及到变量和正则表达式的捕获。</li>
</ul>
</li>
</ul>
<p><strong>一般原则：</strong> 优先使用 <code>return</code> 解决重定向问题。只有当 <code>return</code> 无法满足需求时，才考虑使用 <code>rewrite</code>，并谨慎使用 <code>last</code> 或 <code>break</code> 标志，因为它们的行为可能比较复杂，容易导致非预期的结果。</p>
<p>通过这些示例，你应该能理解 Nginx 中重定向的工作原理和配置方法了。记住，每次修改 Nginx 配置后，都要进行语法检查 (<code>nginx -t</code>) 并重载服务 (<code>systemctl reload nginx</code>)。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/%E9%87%8D%E5%AE%9A%E5%90%91/">https://huiaz.github.io/2025/09/11/%E9%87%8D%E5%AE%9A%E5%90%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/%E9%97%AD%E5%8C%85/" title="闭包"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">闭包</div></div><div class="info-2"><div class="info-item-1">Go语言中闭包的实现在Go语言中，闭包（Closure）是指一个函数值，它引用了其函数体之外的变量。Go语言通过匿名函数（或称为函数字面量）结合对外层变量的引用来实现闭包。 让我们通过一个具体的例子来理解： 123456789101112131415161718192021222324252627package mainimport (	&quot;fmt&quot;)func createCounter() func() int &#123;	// 这是一个外部变量，被内部函数捕获	count := 0 		// 返回一个匿名函数，这个匿名函数就是闭包	return func() int &#123;		count++ // 内部函数引用并修改了外部变量 count		return count	&#125;&#125;func main() &#123;	// 每次调用 createCounter 都会创建一个独立的闭包实例	counter1 := createCounter() 	fmt.Println(&quot;Counter 1:&quot;, counter1()) ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/" title="路由算法与协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">路由算法与协议</div></div><div class="info-2"><div class="info-item-1">路由协议 (Routing Protocols) 和路由选择算法 (Routing Algorithms) 是网络路由领域紧密相关但又截然不同的两个概念。理解它们之间的区别对于掌握网络路由的精髓至关重要。 路由选择算法 (Routing Algorithms)核心： 路由选择算法是决定数据包在网络中从源到目的地最佳路径的逻辑或计算过程。它关注的是“如何计算出最佳路径”。 特点：  数学模型&#x2F;逻辑： 它们是一套定义了如何根据特定度量（如跳数、延迟、带宽、成本等）来计算最优路径的数学模型或逻辑步骤。 通用性： 许多路由算法是通用的计算机科学概念，不局限于特定的网络设备或协议。 独立于实现： 算法本身只是一套理论，它不关心具体如何被实现或在哪个设备上运行。 输入： 它们通常需要网络拓扑信息（节点和链路）以及链路成本&#x2F;度量作为输入。 输出： 输出是到达网络中各个目的地的最佳路径。  常见的路由选择算法：  Dijkstra (迪克斯特拉) 算法： 经典的最短路径算法，常用于链路状态路由（如 OSPF）。它计算从单个源到所有其他节点的单源最短路径。 Bellman-Fo...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/" title="集群模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">集群模式</div></div><div class="info-2"><div class="info-item-1">集群模式对于低于每秒一百万个数据点的摄取率，建议使用单节点版本而不是集群版本。单节点版本可根据 CPU 内核、RAM 和可用存储空间的数量进行扩展。单节点版本比集群版本更容易配置和操作，所以在使用集群版本之前要三思而后行。上面我们介绍了 VM 的单节点版本的基本使用，接下来我们来介绍下如何使用集群版。 集群版主要特点：  支持单节点版本的所有功能。 性能和容量水平扩展。 支持时间序列数据的多个独立命名空间（多租户）。 支持多副本。  组件服务前面我们了解了 VM 的基本架构，对于集群模式下主要包含以下几个服务：  vmstorage：存储原始数据并返回指定标签过滤器在给定时间范围内的查询数据，当 -storageDataPath 指向的目录包含的可用空间少于 -storage.minFreeDiskSpaceBytes 时，vmstorage 节点会自动切换到只读模式，vminsert 节点也会停止向此类节点发送数据并开始将数据重新路由到剩余的 vmstorage 节点。 vminsert：接受摄取的数据并根据指标名称及其所有标签的一致性哈希将其分散存储到 vmstorage 节...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Kafka%20%E4%B8%AD%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Kafka 中关于事务消息的实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Kafka 中关于事务消息的实现</div></div><div class="info-2"><div class="info-item-1">Kafka 自 0.11.0 版本引入了事务（Transactions）功能，旨在提供端到端（End-to-End）的“精确一次（Exactly-Once）”语义。这与 RocketMQ 的事务消息（主要解决本地事务与消息发送的原子性）在设计目标和实现机制上有所不同。 Kafka 的事务功能主要解决以下两个问题：  原子写入： 保证生产者（Producer）向多个 Topic 的多个分区写入的一组消息是原子性的，要么全部写入成功并对消费者可见，要么全部失败并不可见。 原子读写： 结合消费者（Consumer）的偏移量提交，可以在一个事务中原子地处理“消费消息 -&gt; 处理逻辑 -&gt; 生产新消息 -&gt; 提交消费偏移量”这整个流程，从而实现“读取-处理-写入”的精确一次语义。   Kafka 事务消息的实现核心Kafka 的事务机制基于 两阶段提交（Two-Phase Commit, 2PC）的变种，但它是针对 Kafka 内部消息处理的 2PC，不直接涵盖外部数据库事务。 1. 前提：幂等生产者（Idempotent Producer）这是实现事务的基础。在 Kaf...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4/" title="Linux 排查命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 排查命令</div></div><div class="info-2"><div class="info-item-1">(1) 如何在 Linux 中查看系统资源使用情况？比如内存、CPU、网络端口。  一、 CPU 使用情况1. top 命令 (实时交互式)top 命令是最常用的 CPU 监控工具，它提供了一个实时更新的进程列表，并显示 CPU 使用率、内存使用率、进程 ID (PID)、用户、运行时间等信息。 1top  关键信息解读：  第一行（top line）： load average 显示了过去 1、5、15 分钟的系统平均负载。这是衡量系统忙碌程度的重要指标，数值大于 CPU 核心数时通常表示系统存在瓶颈。 第二行（Tasks）： 显示进程总数，以及运行、睡眠、停止和僵尸进程的数量。 第三行（Cpu(s)）： 显示 CPU 的使用率，各项指标含义如下： us (user): 用户空间程序的 CPU 使用率。 sy (system): 内核空间程序的 CPU 使用率。 ni (nice): 改变过优先级的用户进程的 CPU 使用率。 id (idle): 空闲 CPU 百分比。 wa (iowait): CPU 等待 I&#x2F;O 操作完成的百分比。 hi (hardware i...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP-四次挥手"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP-四次挥手</div></div><div class="info-2"><div class="info-item-1">TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。 假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。 四次挥手过程详解：第一次挥手：FIN 报文段（客户端 A → 服务器 B）  客户端 A (主动关闭方)：  当客户端 A 的应用层想要关闭连接时（例如调用 close() 或 shutdown()），客户端 A 的 TCP 会发送一个带有 FIN (Finish) 标志的报文段给服务器 B。 这个 FIN 报文段的序列号通常是它发送的最后一个数据字节的序列号的下一个。 发送 FIN 后，客户端 A 进入 FIN_WAIT_1 状态。这意味着客户端 A 不再发送数据，但仍然可以接收数据。  状态变化： ESTABLISHED → FIN_WAIT_1   第二次挥手：ACK 报文段（服务器 B → 客户端 A）  服务器 B (被动关闭方)：  当...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s_11/" title="k8s_11"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s_11</div></div><div class="info-2"><div class="info-item-1">描述在 Kubernetes 中如何进行安全配置，并解释常用的方法。🤔 分析过程：该问题旨在考察对Kubernetes端到端安全体系的理解，这是一个综合性很强的话题。一个优秀的回答需要结构化地展示安全措施如何应用于从底层基础设施到应用代码的每一个层面。业界公认的“4C安全模型”（Cloud, Cluster, Container, Code）是阐述此问题的最佳框架。本回答将以此模型为骨架，逐层解释每一个层面需要关注的安全配置和常用方法，确保覆盖全面且逻辑清晰。 💡 答案生成：1. 概念或定义Kubernetes安全配置是指在Kubernetes集群的各个层面（基础设施、集群组件、容器、应用代码）实施的一系列策略、工具和实践，旨在保护集群及其上运行的应用免受未经授权的访问、数据泄露、恶意活动和其他安全威胁。其核心原则是纵深防御（Defense in Depth）和最小权限原则（Principle of Least Privilege）。 2. “4C”安全模型与常用方法层面一：Cloud&#x2F;Corporate Data Center (云&#x2F;基础设施层)这是最外...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Kubernetes%20%E7%AE%80%E4%BB%8B/" title="Kubernetes 简介"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Kubernetes 简介</div></div><div class="info-2"><div class="info-item-1">Kubernetes 简介Kubernetes（简称 K8S） 的出现是容器化技术发展的必然结果，容器化是应用程序级别的虚拟化，运行单个内核上有多个独立的用户空间实例，这些实例就是容器；容器提供了将应用程序的代码、运行时、系统工具、系统库和配置打包到一个实例中的标准方法，而且容器是共享一个内核的；由于容器技术的兴起，导致大量的容器应用出现，所以就出现了一些用来支持应用程序容器化部署和组织的容器编排技术，一些流行的开源容器编排工具有 Docker Swarm、Kubernetes 等，但是在发展过程中 Kubernetes 现在已经成为了容器编排领域事实上的一个标准了。  Kubernetes 是 Google 团队发起的一个开源项目，它的目标是管理跨多个主机的容器，用于自动部署、扩展和管理容器化的应用程序，主要实现语言为 Go 语言，他的理论基础来源与 Google 内部的 Borg 项目，所以 Kubernetes 项目的理论基础就比其他开源项目要“先进”很多，因为 Borg 系统一直依赖就被称为 Google 公司内部最强大的“私密武器”。 架构Kubernetes 项目依托...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.</span> <span class="toc-text">Nginx 中如何实现请求的重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-return-%E6%8C%87%E4%BB%A4-%E7%AE%80%E5%8D%95%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. return 指令 (简单重定向)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-1-HTTP-%E5%BC%BA%E5%88%B6%E8%B7%B3%E8%BD%AC-HTTPS-%E6%9C%80%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">示例 1.1: HTTP 强制跳转 HTTPS (最常见场景)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-2-%E5%BC%BA%E5%88%B6%E8%B7%B3%E8%BD%AC%E5%88%B0%E5%B8%A6-www-%E7%9A%84%E5%9F%9F%E5%90%8D"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">示例 1.2: 强制跳转到带 www 的域名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-rewrite-%E6%8C%87%E4%BB%A4-%E9%AB%98%E7%BA%A7%E9%87%8D%E5%AE%9A%E5%90%91-URL-%E9%87%8D%E5%86%99"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. rewrite 指令 (高级重定向&#x2F;URL 重写)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-1-%E9%87%8D%E5%AE%9A%E5%90%91%E6%97%A7-URL-%E5%88%B0%E6%96%B0-URL-%E4%BD%BF%E7%94%A8-permanent-flag"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">示例 2.1: 重定向旧 URL 到新 URL (使用 permanent flag)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-2-%E5%AE%9E%E7%8E%B0%E4%BC%AA%E9%9D%99%E6%80%81%EF%BC%88URL-%E9%87%8D%E5%86%99%EF%BC%8C%E5%86%85%E9%83%A8%E8%B7%B3%E8%BD%AC%EF%BC%89"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">示例 2.2: 实现伪静态（URL 重写，内部跳转）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-3-%E6%B7%BB%E5%8A%A0%E6%88%96%E7%A7%BB%E9%99%A4-URL-%E5%B0%BE%E9%83%A8%E6%96%9C%E6%9D%A0"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">示例 2.3: 添加或移除 URL 尾部斜杠</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-return-%E8%BF%98%E6%98%AF-rewrite%EF%BC%9F"><span class="toc-number">1.0.3.</span> <span class="toc-text">选择 return 还是 rewrite？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>