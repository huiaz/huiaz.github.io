<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP-四次挥手 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。 假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。 四次挥手过程详解：第一次挥手：FIN 报文段（客户端 A →">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP-四次挥手">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。 假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。 四次挥手过程详解：第一次挥手：FIN 报文段（客户端 A →">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:07:17.507Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP-四次挥手",
  "url": "https://huiaz.github.io/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:07:17.507Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP-四次挥手',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP-四次挥手</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP-四次挥手</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:07:17.507Z" title="更新于 2025-09-11 22:07:17">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。</p>
<p>假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。</p>
<h3 id="四次挥手过程详解："><a href="#四次挥手过程详解：" class="headerlink" title="四次挥手过程详解："></a>四次挥手过程详解：</h3><p><strong>第一次挥手：FIN 报文段（客户端 A → 服务器 B）</strong></p>
<ul>
<li><p><strong>客户端 A (主动关闭方)：</strong></p>
<ul>
<li>当客户端 A 的应用层想要关闭连接时（例如调用 <code>close()</code> 或 <code>shutdown()</code>），客户端 A 的 TCP 会发送一个带有 <code>FIN</code> (Finish) 标志的报文段给服务器 B。</li>
<li>这个 FIN 报文段的序列号通常是它发送的最后一个数据字节的序列号的下一个。</li>
<li>发送 <code>FIN</code> 后，客户端 A 进入 <code>FIN_WAIT_1</code> 状态。这意味着客户端 A 不再发送数据，但仍然可以接收数据。</li>
</ul>
<p><strong>状态变化：</strong> <code>ESTABLISHED</code> → <code>FIN_WAIT_1</code></p>
</li>
</ul>
<p><strong>第二次挥手：ACK 报文段（服务器 B → 客户端 A）</strong></p>
<ul>
<li><p><strong>服务器 B (被动关闭方)：</strong></p>
<ul>
<li>当服务器 B 收到客户端 A 的 <code>FIN</code> 报文段时，它会发送一个 <code>ACK</code> (Acknowledgement) 报文段作为回应。</li>
<li>这个 ACK 报文段的确认号是客户端 A 的 FIN 报文段的序列号加 1（<code>Seq(FIN) + 1</code>）。</li>
<li>发送 <code>ACK</code> 后，服务器 B 进入 <code>CLOSE_WAIT</code> 状态。这意味着服务器 B 已经得知客户端 A 不再发送数据了，但服务器 B 可能还有数据要发送给客户端 A，并且会继续接收客户端 A 的 ACK。**<code>CLOSE_WAIT</code> 状态表示服务器正在等待本地应用关闭连接。**</li>
</ul>
<p><strong>状态变化：</strong> <code>ESTABLISHED</code> → <code>CLOSE_WAIT</code></p>
</li>
<li><p><strong>客户端 A：</strong></p>
<ul>
<li>客户端 A 收到服务器 B 的 <code>ACK</code> 后，进入 <code>FIN_WAIT_2</code> 状态。这表示客户端 A 已经确认服务器 B 接收到了它的关闭请求，并且正在等待服务器 B 发送自己的 <code>FIN</code> 报文段。此时客户端 A 仍然可以接收数据。</li>
</ul>
<p><strong>状态变化：</strong> <code>FIN_WAIT_1</code> → <code>FIN_WAIT_2</code></p>
</li>
</ul>
<p><strong>第三次挥手：FIN 报文段（服务器 B → 客户端 A）</strong></p>
<ul>
<li><p><strong>服务器 B (被动关闭方)：</strong></p>
<ul>
<li>当服务器 B 的应用层也决定关闭连接时（例如，其所有待发送的数据都已发送完毕，并调用 <code>close()</code> 或 <code>shutdown()</code>），服务器 B 的 TCP 会发送一个带有 <code>FIN</code> 标志的报文段给客户端 A。</li>
<li>这个 FIN 报文段的序列号是它发送的最后一个数据字节的序列号的下一个。</li>
<li>发送 <code>FIN</code> 后，服务器 B 进入 <code>LAST_ACK</code> 状态。这意味着服务器 B 已经发送了所有数据，正在等待客户端 A 的最终 ACK。</li>
</ul>
<p><strong>状态变化：</strong> <code>CLOSE_WAIT</code> → <code>LAST_ACK</code></p>
</li>
</ul>
<p><strong>第四次挥手：ACK 报文段（客户端 A → 服务器 B）</strong></p>
<ul>
<li><p><strong>客户端 A (主动关闭方)：</strong></p>
<ul>
<li>当客户端 A 收到服务器 B 的 <code>FIN</code> 报文段时，它会发送一个 <code>ACK</code> 报文段作为回应。</li>
<li>这个 ACK 报文段的确认号是服务器 B 的 FIN 报文段的序列号加 1（<code>Seq(FIN) + 1</code>）。</li>
<li>发送 <code>ACK</code> 后，客户端 A 进入 <code>TIME_WAIT</code> 状态。</li>
</ul>
<p><strong>状态变化：</strong> <code>FIN_WAIT_2</code> → <code>TIME_WAIT</code></p>
</li>
<li><p><strong>TIME_WAIT 状态：</strong></p>
<ul>
<li>客户端 A 在进入 <code>TIME_WAIT</code> 状态后，会启动一个定时器，等待 2 * MSL (Maximum Segment Lifetime，最长报文段寿命) 的时间。MSL 是一个 TCP 报文段在网络中能够存活的最长时间。</li>
<li><strong>为什么要等待 2 MSL？</strong><ul>
<li><strong>确保确认报文可靠到达：</strong> 确保客户端 A 发送的最后一个 ACK 报文段能够安全到达服务器 B。如果这个 ACK 丢失，服务器 B 会重传其 FIN 报文段。2 MSL 的时间足以保证客户端 A 能够接收到重传的 FIN 并重新发送 ACK，或者让服务器 B 等待超时并关闭连接。</li>
<li><strong>防止旧连接的迟到报文段：</strong> 确保这个连接上迟到的、旧的（可能是前一个连接的）数据报文段都在网络中消逝，不会被新的、使用相同端口号的连接所接收。这避免了“串线”问题。</li>
</ul>
</li>
<li>在 2 MSL 时间过后，客户端 A 才会真正进入 <code>CLOSED</code> 状态，并释放其端口资源。</li>
</ul>
</li>
<li><p><strong>服务器 B：</strong></p>
<ul>
<li>当服务器 B 收到客户端 A 的最后一个 <code>ACK</code> 报文段后，会立即进入 <code>CLOSED</code> 状态，并释放资源。</li>
</ul>
<p><strong>状态变化：</strong> <code>LAST_ACK</code> → <code>CLOSED</code></p>
</li>
</ul>
<h3 id="四次挥手的必要性："><a href="#四次挥手的必要性：" class="headerlink" title="四次挥手的必要性："></a>四次挥手的必要性：</h3><p>之所以不能像三次握手那样三次挥手，是因为 TCP 是全双工的。当一方发送 <code>FIN</code> 报文时，表示它自己的数据已经发送完毕，不再有数据要发送给对方了。但是：</p>
<ol>
<li>它仍然可以<strong>接收</strong>对方发送的数据。</li>
<li>对方<strong>可能还有数据要发送</strong>给它。</li>
</ol>
<p>所以，收到 <code>FIN</code> 的一方需要先发送一个 <code>ACK</code> 来确认收到对方的关闭请求（第二次挥手），然后等到自己所有的数据都发送完毕，并也准备好关闭自己的发送端时，再发送自己的 <code>FIN</code> 报文（第三次挥手）。这两步（ACK 和 FIN）不能合并发送，因为它们通常发生在不同的时间点（应用程序关闭其写端的时间）。</p>
<p>只有当双方都明确表示不再发送数据并收到对方的确认时，连接才能安全地关闭。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/ue114n.png" alt="image-20250717161147217"></p>
<p>好的，我们来分析一下你提供的 Wireshark 抓包信息，这是典型的 TCP 四次挥手过程：</p>
<p><strong>假设：</strong></p>
<ul>
<li><code>10.20.11.73</code> 是 <strong>客户端</strong> (源端口 64136)</li>
<li><code>10.10.4.3</code> 是 <strong>服务器</strong> (目标端口 80)</li>
</ul>
<p><strong>分析：</strong></p>
<hr>
<p><strong>第 497 行：客户端 → 服务器</strong><br><code>497 16.103047 10.20.11.73 10.10.4.3 TCP 66 64136 → 80 [ACK] Seq=73 Ack=346 Win=131520 Len=0 TSval=3155782880 TSecr=1168528558</code></p>
<ul>
<li><strong>发送方：</strong> 客户端 <code>10.20.11.73</code> (端口 64136)</li>
<li><strong>接收方：</strong> 服务器 <code>10.10.4.3</code> (端口 80)</li>
<li><strong>标志位：</strong> <code>[ACK]</code></li>
<li><strong>Seq&#x3D;73：</strong> 客户端当前发送的序列号是 73。</li>
<li><strong>Ack&#x3D;346：</strong> 客户端确认收到了服务器序列号到 345 的所有数据，期望收到服务器的下一个字节是 346。</li>
<li><strong>Len&#x3D;0：</strong> 这个报文段不包含数据负载，它只是一个纯 ACK。</li>
<li><strong>Timestamp (TSval&#x2F;TSecr):</strong> 时间戳选项，用于计算 RTT 和防止序列号回绕 (PAWS)。</li>
</ul>
<p><strong>解释：</strong> 这个 ACK 包可能是客户端对之前收到的服务器数据的一个确认，或者是一个延迟的 ACK。它本身还不是挥手的一部分，但紧接着就有一个 FIN 包发过来了。</p>
<hr>
<p><strong>第 498 行：客户端 → 服务器 (第一次挥手)</strong><br><code>498 16.103167 10.20.11.73 10.10.4.3 TCP 66 64136 → 80 [FIN, ACK] Seq=73 Ack=346 Win=131520 Len=0 TSval=3155782880 TSecr=1168528558</code></p>
<ul>
<li><strong>发送方：</strong> 客户端 <code>10.20.11.73</code> (端口 64136)</li>
<li><strong>接收方：</strong> 服务器 <code>10.10.4.3</code> (端口 80)</li>
<li><strong>标志位：</strong> <code>[FIN, ACK]</code></li>
<li><strong>Seq&#x3D;73：</strong> 注意，这个 <code>Seq=73</code> 与上一个 ACK 包的 <code>Seq=73</code> 相同，这意味着客户端在发送完上一个 ACK 后，没有再发送任何数据，紧接着就发送了 FIN。FIN 包本身会占用一个序列号。</li>
<li><strong>Ack&#x3D;346：</strong> 客户端依然确认收到了服务器序列号到 345 的数据，期望下一个是 346。</li>
<li><strong>Len&#x3D;0：</strong> 没有数据负载。</li>
</ul>
<p><strong>解释：</strong> <strong>这是四次挥手的第一步。</strong> 客户端 <code>10.20.11.73</code> 发送 <code>FIN</code> 包，表明它已经没有数据要发送了，并请求关闭其发送方向的连接。</p>
<p><strong>客户端状态：</strong> <code>ESTABLISHED</code> → <code>FIN_WAIT_1</code></p>
<hr>
<p><strong>第 499 行：服务器 → 客户端 (第二次挥手 和 第三次挥手)</strong><br><code>499 16.115764 10.10.4.3 10.20.11.73 TCP 66 80 → 64136 [FIN, ACK] Seq=346 Ack=74 Win=29184 Len=0 TSval=1168528571 TSecr=3155782880</code></p>
<ul>
<li><strong>发送方：</strong> 服务器 <code>10.10.4.3</code> (端口 80)</li>
<li><strong>接收方：</strong> 客户端 <code>10.20.11.73</code> (端口 64136)</li>
<li><strong>标志位：</strong> <code>[FIN, ACK]</code></li>
<li><strong>Seq&#x3D;346：</strong> 服务器当前发送的序列号是 346 (与客户端期望的下一个序列号一致)。</li>
<li><strong>Ack&#x3D;74：</strong> 服务器确认收到了客户端的 Seq&#x3D;73 的 FIN 包 (FIN 包占用一个序列号)，所以期望客户端的下一个字节是 74。</li>
<li><strong>Len&#x3D;0：</strong> 没有数据负载。</li>
</ul>
<p><strong>解释：</strong> <strong>这是四次挥手的第二步和第三步的合并。</strong></p>
<ol>
<li><strong>作为第二次挥手：</strong> 服务器发送 <code>ACK</code> (Ack&#x3D;74) 来确认收到了客户端的 <code>FIN</code>。</li>
<li><strong>作为第三次挥手：</strong> 服务器也发送了自己的 <code>FIN</code> (Seq&#x3D;346)，表明它也没有数据要发送了，并请求关闭其发送方向的连接。</li>
</ol>
<p><strong>为什么是合并的？</strong> 这种情况很常见，当服务器收到客户端的 <code>FIN</code> 后，如果没有其他数据需要发送给客户端，它会立即发送一个包含 <code>FIN</code> 和 <code>ACK</code> 的报文段。这节省了一个来回，但在逻辑上仍然是第二步和第三步。</p>
<p><strong>服务器状态：</strong> <code>ESTABLISHED</code> → <code>CLOSE_WAIT</code> (收到客户端FIN并ACK) → <code>LAST_ACK</code> (发送自己的FIN)<br><strong>客户端状态：</strong> <code>FIN_WAIT_1</code> → <code>FIN_WAIT_2</code> (收到服务器的ACK) → (此时客户端还未发送最终ACK)</p>
<hr>
<p><strong>第 500 行：客户端 → 服务器 (第四次挥手)</strong><br><code>500 16.115878 10.20.11.73 10.10.4.3 TCP 66 64136 → 80 [ACK] Seq=74 Ack=347 Win=131520 Len=0 TSval=3155782893 TSecr=1168528571</code></p>
<ul>
<li><strong>发送方：</strong> 客户端 <code>10.20.11.73</code> (端口 64136)</li>
<li><strong>接收方：</strong> 服务器 <code>10.10.4.3</code> (端口 80)</li>
<li><strong>标志位：</strong> <code>[ACK]</code></li>
<li><strong>Seq&#x3D;74：</strong> 客户端新的序列号是 74 (这是客户端发送的最后一个 FIN 包的序列号之后）。</li>
<li><strong>Ack&#x3D;347：</strong> 客户端确认收到了服务器的 Seq&#x3D;346 的 FIN 包，期望服务器的下一个字节是 347。</li>
<li><strong>Len&#x3D;0：</strong> 没有数据负载。</li>
</ul>
<p><strong>解释：</strong> <strong>这是四次挥手的第四步。</strong> 客户端 <code>10.20.11.73</code> 发送最终的 <code>ACK</code> 包，确认收到了服务器的 <code>FIN</code>。</p>
<p><strong>客户端状态：</strong> <code>FIN_WAIT_2</code> → <code>TIME_WAIT</code> (并开始 2MSL 计时)<br><strong>服务器状态：</strong> <code>LAST_ACK</code> → <code>CLOSED</code> (收到客户端的最终ACK后立即关闭)</p>
<hr>
<p><strong>总结整个过程：</strong></p>
<ol>
<li><strong>客户端 10.20.11.73 (64136) 说：“我没东西发了，我想关了。”</strong> (498 行：<code>FIN, ACK</code> from client)</li>
<li><strong>服务器 10.10.4.3 (80) 说：“好的，我知道你没东西发了。我也没东西发了，我也想关了。”</strong> (499 行：<code>FIN, ACK</code> from server - 合并了对客户端 FIN 的 ACK 和自己的 FIN)</li>
<li><strong>客户端 10.20.11.73 (64136) 说：“好的，我也收到你关的请求了。”</strong> (500 行：<code>ACK</code> from client)</li>
</ol>
<p>至此，TCP 连接的双向数据流都已关闭。客户端进入 <code>TIME_WAIT</code> 状态，等待 2 MSL 后彻底关闭；服务器在收到最后一个 ACK 后立即关闭。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">https://huiaz.github.io/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/TCPIP%204%20%E5%B1%82%E6%A8%A1%E5%9E%8B/" title="TCPIP 4 层模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCPIP 4 层模型</div></div><div class="info-2"><div class="info-item-1">TCP&#x2F;IP 四层模型（也称为 TCP&#x2F;IP 协议栈、TCP&#x2F;IP 参考模型）是计算机网络中最常用和最重要的分层模型之一。它将复杂的网络通信过程划分为若干个逻辑层，每层负责不同的功能。 这个模型与 OSI 七层模型有所不同，虽然它们都致力于解决网络通信的复杂性，但 TCP&#x2F;IP 模型更注重实际应用和协议实现。 TCP&#x2F;IP 四层模型的构成：TCP&#x2F;IP 模型通常被划分为以下四层：  应用层 (Application Layer) 传输层 (Transport Layer) 网络层 (Internet Layer) 网络接口层 (Network Access Layer) 或 数据链路层&#x2F;物理层  让我们逐一详细了解每一层的功能、协议和数据单元。  1. 应用层 (Application Layer) 功能： 提供应用程序之间的通信服务。它是用户与网络进行交互的最高层，负责处理特定应用程序的数据，并将其转换为通过网络传输的格式。 代表协议： HTTP&#x2F;HTTPS： (超文本传输协议) 用于网页浏览。 F...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/" title="TCP 的粘包和拆包"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TCP 的粘包和拆包</div></div><div class="info-2"><div class="info-item-1">好的，我们来深入讨论 TCP 的“粘包”和“拆包”问题。这两个概念是 TCP 编程中非常基础但又极其重要的，理解它们是正确处理 TCP 数据流的关键。  1. 为什么会出现粘包和拆包？根本原因在于 TCP 是一个“面向字节流”（Byte Stream）的协议，而不是“面向消息&#x2F;数据报”（Message&#x2F;Datagram Oriented）的协议。  TCP 的特性：  缓冲区： TCP 有自己的发送缓冲区和接收缓冲区。 全双工： 数据可以双向独立传输。 可靠的、按序的、无界限的字节流： TCP 传输的只是字节序列，它不关心你在应用层发送了多少次数据，每次发送了多少字节，或者每次发送的内容之间有什么逻辑边界。   发送方： 当应用程序调用 send() 或 write() 发送数据时，数据首先被复制到 TCP 的发送缓冲区。TCP 协议栈会根据自身的拥塞控制、流量控制以及发送缓冲区的大小，决定何时、发送多少数据到网络上。它可能会：  将多次小的发送请求合并成一个大的 TCP 段发送（粘包）。 将一次大的发送请求拆分成多个小的 TCP 段发送（拆包）。 将不同应用...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/RIP%20(Routing%20Information%20Protocol)%20%E5%8D%8F%E8%AE%AE/" title="RIP (Routing Information Protocol) 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">RIP (Routing Information Protocol) 协议</div></div><div class="info-2"><div class="info-item-1">RIP (Routing Information Protocol) 协议的工作原理及特点RIP (Routing Information Protocol) 是一种经典的**距离向量路由协议 (Distance-Vector Routing Protocol)**，用于在内部网关 (Interior Gateway Protocol, IGP) 环境中交换路由信息。它历史悠久，简单易用，但存在一些固有的局限性。  RIP 的工作原理：RIP 的工作原理基于 Bellman-Ford 算法的变体，其核心思想是每个路由器维护一个到所有已知目的地的距离向量，并定期与邻居交换此信息。  里程 (Metric) - 跳数 (Hop Count)：  RIP 使用跳数 (Hop Count) 作为唯一的路由度量（metric）。 每经过一个路由器，跳数就增加 1。 最大跳数限制： RIP 的最大跳数限制为 15 跳。这意味着任何超过 15 跳的目的地都被认为是不可达的（即距离为无穷大）。这是 RIP 最大的局限性之一，使其不适合大型网络。   距离向量的维护：  每个 RIP 路由器维护一...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="代理模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">代理模式</div></div><div class="info-2"><div class="info-item-1">什么是正向代理？正向代理（Forward Proxy），通常我们所说的“代理服务器”指的就是正向代理。它是一个位于客户端和目标服务器之间的服务器。  工作原理： 客户端明确知道自己要访问的目标服务器，但它不直接与目标服务器通信，而是将请求发送给正向代理服务器，由代理服务器去访问目标服务器，然后将目标服务器的响应返回给客户端。 隐藏谁？ 隐藏的是真实的客户端。对于目标服务器来说，它只知道请求来自代理服务器，而不知道是哪个客户端发起的。 应用场景： 规避防火墙或网络限制： 例如，在某些地区或公司网络中，访问特定网站被限制，可以通过境外或未受限地区的正向代理服务器进行访问。 访问内部资源： 例如，公司内部网络通过一个统一的正向代理出口访问互联网资源。 提高访问速度： 代理服务器可以缓存内容，当多个用户访问同一资源时，可以直接从代理缓存中获取，加快速度。 匿名访问： 隐藏真实 IP 地址，保护用户隐私。 网络安全审计： 记录所有经过代理的请求，进行内容过滤和安全检查。    简单理解： 客户端请求一个它想访问的网站A，告诉代理服务器，代理服务器代替客户端去访问网站A，然后把网站A的内容返...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/" title="TCP 的粘包和拆包"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 的粘包和拆包</div></div><div class="info-2"><div class="info-item-1">好的，我们来深入讨论 TCP 的“粘包”和“拆包”问题。这两个概念是 TCP 编程中非常基础但又极其重要的，理解它们是正确处理 TCP 数据流的关键。  1. 为什么会出现粘包和拆包？根本原因在于 TCP 是一个“面向字节流”（Byte Stream）的协议，而不是“面向消息&#x2F;数据报”（Message&#x2F;Datagram Oriented）的协议。  TCP 的特性：  缓冲区： TCP 有自己的发送缓冲区和接收缓冲区。 全双工： 数据可以双向独立传输。 可靠的、按序的、无界限的字节流： TCP 传输的只是字节序列，它不关心你在应用层发送了多少次数据，每次发送了多少字节，或者每次发送的内容之间有什么逻辑边界。   发送方： 当应用程序调用 send() 或 write() 发送数据时，数据首先被复制到 TCP 的发送缓冲区。TCP 协议栈会根据自身的拥塞控制、流量控制以及发送缓冲区的大小，决定何时、发送多少数据到网络上。它可能会：  将多次小的发送请求合并成一个大的 TCP 段发送（粘包）。 将一次大的发送请求拆分成多个小的 TCP 段发送（拆包）。 将不同应用...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ICMP/" title="ICMP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ICMP</div></div><div class="info-2"><div class="info-item-1">什么是 ICMP 协议？ICMP (Internet Control Message Protocol)，即互联网控制消息协议，是 IP 协议的辅助协议，是 TCP&#x2F;IP 协议族中的一个核心组成部分。ICMP 通常被认为是网络层的协议（与 IP 协议同层），因为它处理 IP 数据包的错误和控制信息。 核心特点：  控制和错误报告： ICMP 的主要作用是报告 IP 数据包传输过程中的错误以及提供网络诊断信息。它不传输用户数据，而是传输网络层面的控制和错误消息。 不可靠性： ICMP 报文本身不提供可靠传输机制。如果一个 ICMP 报文在传输过程中丢失，IP 层不会重传它。 承载于 IP： ICMP 报文是“封装”在 IP 数据包中的。换句话说，一个 ICMP 报文会作为 IP 数据包的有效载荷（payload）进行传输。  ICMP 的主要作用：ICMP 的主要作用可以归纳为以下几点，主要围绕错误报告和网络诊断：  报告差错信息 (Error Reporting):当 IP 数据包在传输过程中遇到问题时，ICMP 被用来向数据包的源主机报告这些错误。常见的 ICMP 差...</div></div></div></a><a class="pagination-related" href="/2025/09/11/RIR%20%E5%8D%8F%E8%AE%AE/" title="RIR 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">RIR 协议</div></div><div class="info-2"><div class="info-item-1">RIP (Routing Information Protocol) 协议的工作原理及特点RIP (Routing Information Protocol) 是一种经典的**距离向量路由协议 (Distance-Vector Routing Protocol)**，用于在内部网关 (Interior Gateway Protocol, IGP) 环境中交换路由信息。它历史悠久，简单易用，但存在一些固有的局限性。  RIP 的工作原理：RIP 的工作原理基于 Bellman-Ford 算法的变体，其核心思想是每个路由器维护一个到所有已知目的地的距离向量，并定期与邻居交换此信息。  里程 (Metric) - 跳数 (Hop Count)：  RIP 使用跳数 (Hop Count) 作为唯一的路由度量（metric）。 每经过一个路由器，跳数就增加 1。 最大跳数限制： RIP 的最大跳数限制为 15 跳。这意味着任何超过 15 跳的目的地都被认为是不可达的（即距离为无穷大）。这是 RIP 最大的局限性之一，使其不适合大型网络。   距离向量的维护：  每个 RIP 路由器维护一...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%201.0%20%E5%92%8C%202.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" title="HTTP 1.0 和 2.0 有什么区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 1.0 和 2.0 有什么区别</div></div><div class="info-2"><div class="info-item-1">HTTP 1.0 和 2.0 有什么区别？HTTP 1.0 和 2.0 在性能、效率和功能方面存在显著差异。以下是它们的关键区别： HTTP 1.0 (最初的成功)  核心概念：每次请求&#x2F;响应一个连接。 这是它最主要的特点。 短连接 (Short-lived connections): 每个请求和响应都需要建立一个新的TCP连接，在完成传输后立即关闭。这导致了大量的连接建立和关闭开销（三次握手和四次挥手）。   串行请求 (Serial requests): 浏览器一次只能发送一个请求，必须等待当前请求的响应，才能发送下一个请求。这导致了“队头阻塞 (Head-of-Line Blocking)”问题，即一个慢的响应会阻碍后续所有请求。 无头部压缩 (No header compression): 每个请求和响应的头部信息都是原始的，可能包含大量重复信息。 无服务器推送 (No server push): 服务器无法主动向客户端发送资源，只能响应客户端的请求。 无二进制分帧 (No binary framing): 数据以文本形式传输，效率较低。 Cookie (部分支...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">四次挥手过程详解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">四次挥手的必要性：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>