<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP 的拥塞控制 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP 拥塞控制的目的在于防止过多的数据注入到网络中，避免或减轻网络的拥塞，从而提高网络利用率，同时保证主机间的有效通信。它不是为了防止发送方发送数据过快淹没接收方（那是流量控制），而是为了防止发送方发送数据过快淹没整个网络。 TCP 的拥塞控制主要包括以下四个核心算法（通常被称为拥塞控制的“四大家族”）：  慢启动 (Slow Start) 拥塞避免 (Congestion Avoidance)">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP 的拥塞控制">
<meta property="og:url" content="http://example.com/2025/09/11/TCP%20%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="TCP 拥塞控制的目的在于防止过多的数据注入到网络中，避免或减轻网络的拥塞，从而提高网络利用率，同时保证主机间的有效通信。它不是为了防止发送方发送数据过快淹没接收方（那是流量控制），而是为了防止发送方发送数据过快淹没整个网络。 TCP 的拥塞控制主要包括以下四个核心算法（通常被称为拥塞控制的“四大家族”）：  慢启动 (Slow Start) 拥塞避免 (Congestion Avoidance)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:07:02.504Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP 的拥塞控制",
  "url": "http://example.com/2025/09/11/TCP%20%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:07:02.504Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/11/TCP%20%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP 的拥塞控制',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP 的拥塞控制</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP 的拥塞控制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:07:02.504Z" title="更新于 2025-09-11 22:07:02">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>TCP 拥塞控制的目的在于<strong>防止过多的数据注入到网络中，避免或减轻网络的拥塞</strong>，从而提高网络利用率，同时保证主机间的有效通信。它不是为了防止发送方发送数据过快淹没接收方（那是流量控制），而是为了防止发送方发送数据过快淹没<strong>整个网络</strong>。</p>
<p>TCP 的拥塞控制主要包括以下四个核心算法（通常被称为<strong>拥塞控制的“四大家族”</strong>）：</p>
<ol>
<li><strong>慢启动 (Slow Start)</strong></li>
<li><strong>拥塞避免 (Congestion Avoidance)</strong></li>
<li><strong>快速重传 (Fast Retransmit)</strong></li>
<li><strong>快速恢复 (Fast Recovery)</strong></li>
</ol>
<p>这些算法协同工作，共同管理发送方的发送速率，即调整<strong>拥塞窗口 (cwnd)</strong> 的大小。</p>
<hr>
<h3 id="1-慢启动-Slow-Start"><a href="#1-慢启动-Slow-Start" class="headerlink" title="1. 慢启动 (Slow Start)"></a>1. 慢启动 (Slow Start)</h3><p><strong>目标：</strong> 在连接刚建立或长时间中断后，逐步探测网络的承载能力，快速找到一个合适的发送速率，避免一开始就对网络造成冲击。</p>
<p><strong>过程：</strong></p>
<ul>
<li><strong>初始状态：</strong> 连接建立时，拥塞窗口 (cwnd) 被初始化为一个较小的值（通常是 1-10 MSS，具体取决于操作系统和TCP版本，RFC 2581 最初建议 1 MSS，现在通常是 10 MSS）。</li>
<li><strong>指数增长：</strong> 发送方每收到一个**确认 (ACK)**，<code>cwnd</code> 的大小就增加一个 MSS（最大报文段大小）。这意味着在每个 RTT（往返时间）内，<code>cwnd</code> 会翻倍。</li>
<li><strong>退出条件：</strong> 当 <code>cwnd</code> 达到<strong>慢启动门限 (ssthresh)</strong> 时，慢启动阶段结束，进入拥塞避免阶段。<code>ssthresh</code> 的初始值通常非常大，或者与接收窗口大小相同。</li>
</ul>
<p><strong>特点：</strong> 窗口增长速度快，呈指数级。</p>
<hr>
<h3 id="2-拥塞避免-Congestion-Avoidance"><a href="#2-拥塞避免-Congestion-Avoidance" class="headerlink" title="2. 拥塞避免 (Congestion Avoidance)"></a>2. 拥塞避免 (Congestion Avoidance)</h3><p><strong>目标：</strong> 在探测到网络承载能力后，以更谨慎的方式逐步增加发送速率，避免再次引起拥塞。</p>
<p><strong>过程：</strong></p>
<ul>
<li><strong>线性增长：</strong> 当 <code>cwnd</code> 达到 <code>ssthresh</code> 后，<code>cwnd</code> 的增长方式从指数级变为线性级。发送方每收到<strong>一个 RTT 内的 ACK 集合</strong> (<code>cwnd</code> 个 ACK)，<code>cwnd</code> 才增加一个 MSS 大小。<ul>
<li>更精确地说：<code>cwnd = cwnd + MSS * (MSS / cwnd)</code>，或者 <code>cwnd = cwnd + 1/cwnd</code> MSS。这意味着只有当收到足够多的 ACK 确认后，<code>cwnd</code> 才会增加一个 MSS。</li>
</ul>
</li>
<li><strong>退出条件：</strong> 拥塞避免阶段会持续，直到发生丢包事件（无论是超时还是收到重复 ACK）。</li>
</ul>
<p><strong>特点：</strong> 窗口增长速度慢，呈线性级。这个阶段旨在平稳地利用网络带宽。</p>
<hr>
<h3 id="3-快速重传-Fast-Retransmit"><a href="#3-快速重传-Fast-Retransmit" class="headerlink" title="3. 快速重传 (Fast Retransmit)"></a>3. 快速重传 (Fast Retransmit)</h3><p><strong>目标：</strong> 在不等待超时的情况下，通过接收方发送的重复 ACK 提前发现丢包，并立即重传丢失的数据包，提高重传效率。</p>
<p><strong>过程：</strong></p>
<ul>
<li><strong>信号：</strong> 当发送方收到<strong>三个或更多的对同一个数据包的重复 ACK</strong> 时，就认为这个数据包已经丢失。</li>
<li><strong>操作：</strong><ol>
<li><strong>立即重传：</strong> 不等待定时器超时，而是立即重传丢失的报文段。</li>
<li><strong>调整 <code>ssthresh</code>：</strong> 将 <code>ssthresh</code> 设置为当前 <code>cwnd</code> 的一半。</li>
<li><strong>调整 <code>cwnd</code>：</strong> 将 <code>cwnd</code> 设置为 <code>ssthresh</code> 加上 3 个 MSS（这 3 个 MSS 是为了弥补已经收到的 3 个重复 ACK 确认了后续数据）。这个 <code>cwnd</code> 的值会将连接带入快速恢复状态。</li>
</ol>
</li>
</ul>
<p><strong>特点：</strong> 是一种基于快速反馈的丢包发现机制，比超时重传更快。</p>
<hr>
<h3 id="4-快速恢复-Fast-Recovery"><a href="#4-快速恢复-Fast-Recovery" class="headerlink" title="4. 快速恢复 (Fast Recovery)"></a>4. 快速恢复 (Fast Recovery)</h3><p><strong>目标：</strong> 与快速重传配合，在检测到少量丢包时，保持较高的发送速率，避免将 <code>cwnd</code> 降到 1 MSS，从而更快地恢复到拥塞避免状态。</p>
<p><strong>过程：</strong></p>
<ul>
<li><strong>进入条件：</strong> 当快速重传被触发后（即收到三个重复 ACK），TCP 会进入快速恢复阶段。</li>
<li><strong>临时增加 <code>cwnd</code>：</strong> 发送方每收到一个额外的重复 ACK，<code>cwnd</code> 就会再增加一个 MSS。这是因为每个重复 ACK 都表明一个数据包离开了网络，从而释放了网络中的一个缓冲空间。</li>
<li><strong>发送新数据：</strong> 在快速恢复期间，发送方可以发送新的数据（如果拥塞窗口和接收窗口允许）。</li>
<li><strong>退出条件：</strong><ul>
<li><strong>收到对丢失报文段的 ACK：</strong> 当发送方收到对最初触发快速重传的那个丢失报文段的 ACK 时，表明该数据已经成功重传并被接收方确认。此时，拥塞窗口 <code>cwnd</code> 会被设置回 <code>ssthresh</code> 的值，然后重新进入<strong>拥塞避免</strong>阶段。</li>
<li><strong>超时：</strong> 如果在快速恢复阶段发生了超时（表明情况比之前想的更糟，可能有更多丢包），则 TCP 会回退到慢启动阶段，将 <code>ssthresh</code> 设置为当前 <code>cwnd</code> 的一半，<code>cwnd</code> 设置为 1 MSS。</li>
</ul>
</li>
</ul>
<p><strong>特点：</strong> 在丢包不严重的情况下，保持较高的 <code>cwnd</code>，避免剧烈地降低发送速率。</p>
<hr>
<h3 id="拥塞控制状态机概览："><a href="#拥塞控制状态机概览：" class="headerlink" title="拥塞控制状态机概览："></a>拥塞控制状态机概览：</h3><table>
<thead>
<tr>
<th align="left">事件触发</th>
<th align="left"><code>ssthresh</code></th>
<th align="left"><code>cwnd</code></th>
<th align="left">进入状态</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">连接建立</td>
<td align="left">大值&#x2F;Max</td>
<td align="left">1 MSS</td>
<td align="left">慢启动</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">收到 ACK</td>
<td align="left"></td>
<td align="left"><code>+1 MSS</code></td>
<td align="left">慢启动</td>
<td align="left">每次收到一个 ACK</td>
</tr>
<tr>
<td align="left"><code>cwnd &gt;= ssthresh</code></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">拥塞避免</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">收到 ACK</td>
<td align="left"></td>
<td align="left"><code>+1/cwnd MSS</code></td>
<td align="left">拥塞避免</td>
<td align="left">每个 RTT 增加 1 MSS</td>
</tr>
<tr>
<td align="left"><strong>3个重复 ACK</strong></td>
<td align="left"><code>cwnd / 2</code></td>
<td align="left"><code>ssthresh + 3 MSS</code></td>
<td align="left"><strong>快速恢复</strong></td>
<td align="left"><em>重要</em>，表示轻微丢包</td>
</tr>
<tr>
<td align="left"><strong>超时</strong></td>
<td align="left"><code>cwnd / 2</code></td>
<td align="left"><code>1 MSS</code></td>
<td align="left"><strong>慢启动</strong></td>
<td align="left"><em>重要</em>，表示严重丢包（网络状况恶化）</td>
</tr>
<tr>
<td align="left">快速恢复中收到新 ACK</td>
<td align="left"></td>
<td align="left"><code>ssthresh</code></td>
<td align="left">拥塞避免</td>
<td align="left">恢复完成，继续线性增长</td>
</tr>
<tr>
<td align="left">快速恢复中收到重复 ACK</td>
<td align="left"></td>
<td align="left"><code>+1 MSS</code></td>
<td align="left">快速恢复</td>
<td align="left">继续补偿在途的确认</td>
</tr>
</tbody></table>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>TCP 的拥塞控制是一个动态调整发送速率的过程，旨在高效利用网络资源的同时避免网络拥塞。它通过慢启动、拥塞避免、快速重传和快速恢复这四个核心算法，根据网络反馈（ACK、重复 ACK、超时）来实时调整拥塞窗口 <code>cwnd</code>，从而达到平衡的目标。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/TCP%20%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">http://example.com/2025/09/11/TCP%20%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP 超时重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCP 超时重传机制</div></div><div class="info-2"><div class="info-item-1">除了标准的 TCP 四次挥手，还有一些其他方法或特殊情况可以导致连接断开，但它们通常不如四次挥手那样优雅和受控，可能会伴随数据丢失或异常。 1. RST 报文断开连接 (Reset)RST (Reset) 报文是一种 TCP 错误或异常的指示，它会立即终止连接，不会进行标准的四次挥手过程，也不会等待任何未发送或未确认的数据。 RST 报文的常见使用场景：  连接被拒绝： 当客户端尝试连接到一个不存在的端口或一个拒绝连接的服务器端口时，服务器通常会回复一个 RST 报文，表示连接无法建立。 中止连接： 当一方决定突然中止一个连接，而不是通过正常的挥手过程关闭时，会发送 RST。这意味着不再关心对方是否已收到所有数据，也不希望进一步的通信。例如，应用程序调用 SO_LINGER 且 l_onoff 为真，l_linger 为 0 时。 检测半开连接： 如果一方的连接已经关闭（比如进程崩溃），而另一方在试图向已关闭的连接发送数据时，操作系统会检测到这个异常并回复一个 RST 报文。 端口扫描： 端口扫描工具通常会向目标端口发送 SYN 包，根据收到的响应（SYN-ACK 或 RST）来...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F/" title="TCP 的三次握手？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TCP 的三次握手？</div></div><div class="info-2"><div class="info-item-1"> 好的，我们来详细解释 TCP 的三次握手（Three-Way Handshake）过程。这是 TCP 协议建立连接的关键步骤，确保客户端和服务器都准备好进行数据传输。 1. TCP 三次握手的目的三次握手的核心目的是：  确认双方的发送和接收能力正常： 确保客户端能够发送数据，也能接收数据；服务器也能发送数据，也能接收数据。 为会话同步初始序列号 (ISN)： TCP 会为发送的每一个字节数据编号。为了实现可靠传输和乱序重排，需要一个起始的序列号。双方需要知道对方的起始序列号，并在此基础上进行数据传输的确认和管理。 防止已失效的连接请求报文段（SYN）突然又传送到了服务器，从而产生错误： 后面会详细解释这一点。  2. TCP 三次握手的过程假设客户端是发起连接的一方，服务器是等待连接的一方。 第一次握手：客户端 -&gt; 服务器 (SYN) 客户端发送： SYN (Synchronize) 标志位设置为 1： 表示这是一个连接请求报文。 seq (Sequence Number) &#x3D; 客户端的初始序列号 (client_ISN)： 客户端随机选择一个初始序列号。 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/" title="TCP 滑动窗口的作用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 滑动窗口的作用</div></div><div class="info-2"><div class="info-item-1">TCP 滑动窗口（Sliding Window）是 TCP 协议中一个核心且关键的机制，它主要实现了以下几个重要的作用：  实现流量控制 (Flow Control):  问题： 发送方发送数据的速度如果远超接收方的处理速度，接收方的缓冲区最终会被填满，导致数据溢出丢失。 解决方案： 接收方会通过 TCP 报文段中的窗口大小字段（Window size）告诉发送方，其当前还有多少接收缓冲区是可用的。发送方收到的窗口大小就是它当前可以发送的最大数据量，它绝对不能发送超过这个窗口大小的数据。 动态调整： 随着接收方处理数据的速度和可用缓冲区空间的变化，窗口大小会动态调整。如果接收方处理得慢，窗口就会变小；如果处理得快，窗口就会变大。这确保了发送方的发送速率能与接收方的处理速率相匹配，避免接收方缓冲区溢出。   实现可靠传输 (Reliable Transmission):  问题： 网络传输可能导致数据包丢失、乱序或错误。TCP 需要确保所有数据在发送方和接收方之间都能完整、按序地到达。 解决方案： 滑动窗口机制与确认（ACK）和重传机制紧密结合。 发送窗口： 发送窗口维护着一系列允...</div></div></div></a><a class="pagination-related" href="/2025/09/11/NAT/" title="NAT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">NAT</div></div><div class="info-2"><div class="info-item-1">什么是网络地址转换（NAT）？NAT (Network Address Translation)，即网络地址转换，是一种在 IP 网络中改变数据包的 IP 地址信息的技术。它的主要目的是解决 IPv4 地址枯竭的问题，同时也能提供一定程度的网络安全隔离。 简单来说，NAT 允许一个拥有私有 IP 地址的网络（如家庭网络或企业内部网络）连接到使用公共 IP 地址的外部网络（如互联网），而无需为内部的每台设备都分配一个唯一的公共 IP 地址。 核心概念：  私有 IP 地址： 在私有网络内部使用的 IP 地址，它们不能直接在公共互联网上路由。RFC 1918 定义了以下私有 IP 地址范围： 10.0.0.0 到 10.255.255.255 (10&#x2F;8) 172.16.0.0 到 172.31.255.255 (172.16&#x2F;12) 192.168.0.0 到 192.168.255.255 (192.168&#x2F;16)   公共 IP 地址： 在公共互联网上可寻址的全球唯一的 IP 地址。 NAT 设备： 通常是路由器或防火墙，负责执行 IP 地址的转换...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%A7%A3%E6%9E%90%20HTTP%20%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/" title="服务端解析 HTTP 请求数据"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">服务端解析 HTTP 请求数据</div></div><div class="info-2"><div class="info-item-1">服务端解析 HTTP 请求数据是一个多步的、结构化的过程，它依赖于 HTTP 请求的严格格式定义。理解这个过程，有助于我们更好地进行网络编程和故障排查。 HTTP 请求通常由以下几个部分组成：  请求行 (Request Line) 请求头 (Request Headers) 空行 (Empty Line) 请求体 (Request Body) (可选，通常用于 POST&#x2F;PUT 请求)  服务端（通常是 Web 服务器如 Nginx, Apache, Tomcat, Node.js Express，或自定义的网络应用）在底层接收到客户端发送的原始字节流后，会按照这些部分的定义逐步解析。  服务端解析 HTTP 请求数据的步骤：步骤 1：建立 TCP 连接并接收原始字节流 底层网络通信： 客户端通过 TCP&#x2F;IP 协议向服务器的指定端口（HTTP 默认 80，HTTPS 默认 443）发起连接。 服务器监听： 服务器程序（如 Apache, Nginx 或 Node.js 应用）在这些端口上监听传入连接。 数据接收： 一旦 TCP 连接建立，服务器开始从这个连...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ICMP/" title="ICMP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ICMP</div></div><div class="info-2"><div class="info-item-1">什么是 ICMP 协议？ICMP (Internet Control Message Protocol)，即互联网控制消息协议，是 IP 协议的辅助协议，是 TCP&#x2F;IP 协议族中的一个核心组成部分。ICMP 通常被认为是网络层的协议（与 IP 协议同层），因为它处理 IP 数据包的错误和控制信息。 核心特点：  控制和错误报告： ICMP 的主要作用是报告 IP 数据包传输过程中的错误以及提供网络诊断信息。它不传输用户数据，而是传输网络层面的控制和错误消息。 不可靠性： ICMP 报文本身不提供可靠传输机制。如果一个 ICMP 报文在传输过程中丢失，IP 层不会重传它。 承载于 IP： ICMP 报文是“封装”在 IP 数据包中的。换句话说，一个 ICMP 报文会作为 IP 数据包的有效载荷（payload）进行传输。  ICMP 的主要作用：ICMP 的主要作用可以归纳为以下几点，主要围绕错误报告和网络诊断：  报告差错信息 (Error Reporting):当 IP 数据包在传输过程中遇到问题时，ICMP 被用来向数据包的源主机报告这些错误。常见的 ICMP 差...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP 超时重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 超时重传机制</div></div><div class="info-2"><div class="info-item-1">除了标准的 TCP 四次挥手，还有一些其他方法或特殊情况可以导致连接断开，但它们通常不如四次挥手那样优雅和受控，可能会伴随数据丢失或异常。 1. RST 报文断开连接 (Reset)RST (Reset) 报文是一种 TCP 错误或异常的指示，它会立即终止连接，不会进行标准的四次挥手过程，也不会等待任何未发送或未确认的数据。 RST 报文的常见使用场景：  连接被拒绝： 当客户端尝试连接到一个不存在的端口或一个拒绝连接的服务器端口时，服务器通常会回复一个 RST 报文，表示连接无法建立。 中止连接： 当一方决定突然中止一个连接，而不是通过正常的挥手过程关闭时，会发送 RST。这意味着不再关心对方是否已收到所有数据，也不希望进一步的通信。例如，应用程序调用 SO_LINGER 且 l_onoff 为真，l_linger 为 0 时。 检测半开连接： 如果一方的连接已经关闭（比如进程崩溃），而另一方在试图向已关闭的连接发送数据时，操作系统会检测到这个异常并回复一个 RST 报文。 端口扫描： 端口扫描工具通常会向目标端口发送 SYN 包，根据收到的响应（SYN-ACK 或 RST）来...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP-四次挥手"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP-四次挥手</div></div><div class="info-2"><div class="info-item-1">TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。 假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。 四次挥手过程详解：第一次挥手：FIN 报文段（客户端 A → 服务器 B）  客户端 A (主动关闭方)：  当客户端 A 的应用层想要关闭连接时（例如调用 close() 或 shutdown()），客户端 A 的 TCP 会发送一个带有 FIN (Finish) 标志的报文段给服务器 B。 这个 FIN 报文段的序列号通常是它发送的最后一个数据字节的序列号的下一个。 发送 FIN 后，客户端 A 进入 FIN_WAIT_1 状态。这意味着客户端 A 不再发送数据，但仍然可以接收数据。  状态变化： ESTABLISHED → FIN_WAIT_1   第二次挥手：ACK 报文段（服务器 B → 客户端 A）  服务器 B (被动关闭方)：  当...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%85%A2%E5%90%AF%E5%8A%A8-Slow-Start"><span class="toc-number">1.</span> <span class="toc-text">1. 慢启动 (Slow Start)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D-Congestion-Avoidance"><span class="toc-number">2.</span> <span class="toc-text">2. 拥塞避免 (Congestion Avoidance)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0-Fast-Retransmit"><span class="toc-number">3.</span> <span class="toc-text">3. 快速重传 (Fast Retransmit)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D-Fast-Recovery"><span class="toc-number">4.</span> <span class="toc-text">4. 快速恢复 (Fast Recovery)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A6%82%E8%A7%88%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">拥塞控制状态机概览：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">总结：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>