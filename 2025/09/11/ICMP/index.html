<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ICMP | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是 ICMP 协议？ICMP (Internet Control Message Protocol)，即互联网控制消息协议，是 IP 协议的辅助协议，是 TCP&#x2F;IP 协议族中的一个核心组成部分。ICMP 通常被认为是网络层的协议（与 IP 协议同层），因为它处理 IP 数据包的错误和控制信息。 核心特点：  控制和错误报告： ICMP 的主要作用是报告 IP 数据包传输过程中的错误">
<meta property="og:type" content="article">
<meta property="og:title" content="ICMP">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/ICMP/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="什么是 ICMP 协议？ICMP (Internet Control Message Protocol)，即互联网控制消息协议，是 IP 协议的辅助协议，是 TCP&#x2F;IP 协议族中的一个核心组成部分。ICMP 通常被认为是网络层的协议（与 IP 协议同层），因为它处理 IP 数据包的错误和控制信息。 核心特点：  控制和错误报告： ICMP 的主要作用是报告 IP 数据包传输过程中的错误">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:39:42.685Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ICMP",
  "url": "https://huiaz.github.io/2025/09/11/ICMP/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:39:42.685Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/ICMP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ICMP',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">ICMP</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">ICMP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:39:42.685Z" title="更新于 2025-09-11 21:39:42">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="什么是-ICMP-协议？"><a href="#什么是-ICMP-协议？" class="headerlink" title="什么是 ICMP 协议？"></a>什么是 ICMP 协议？</h3><p><strong>ICMP (Internet Control Message Protocol)<strong>，即</strong>互联网控制消息协议</strong>，是 <strong>IP 协议</strong>的<strong>辅助协议</strong>，是 TCP&#x2F;IP 协议族中的一个核心组成部分。ICMP 通常被认为是网络层的协议（与 IP 协议同层），因为它处理 IP 数据包的错误和控制信息。</p>
<p><strong>核心特点：</strong></p>
<ul>
<li><strong>控制和错误报告：</strong> ICMP 的主要作用是报告 IP 数据包传输过程中的错误以及提供网络诊断信息。它不传输用户数据，而是传输网络层面的控制和错误消息。</li>
<li><strong>不可靠性：</strong> ICMP 报文本身不提供可靠传输机制。如果一个 ICMP 报文在传输过程中丢失，IP 层不会重传它。</li>
<li><strong>承载于 IP：</strong> ICMP 报文是“封装”在 IP 数据包中的。换句话说，一个 ICMP 报文会作为 IP 数据包的有效载荷（payload）进行传输。</li>
</ul>
<h3 id="ICMP-的主要作用："><a href="#ICMP-的主要作用：" class="headerlink" title="ICMP 的主要作用："></a>ICMP 的主要作用：</h3><p>ICMP 的主要作用可以归纳为以下几点，主要围绕<strong>错误报告</strong>和<strong>网络诊断</strong>：</p>
<ol>
<li><p><strong>报告差错信息 (Error Reporting):</strong><br>当 IP 数据包在传输过程中遇到问题时，ICMP 被用来向数据包的源主机报告这些错误。常见的 ICMP 差错报文类型包括：</p>
<ul>
<li><p><strong>目标不可达 (Destination Unreachable):</strong></p>
<ul>
<li>当路由器无法将数据包送达目的地时生成。</li>
<li><strong>示例场景：</strong><ul>
<li><strong>网络不可达：</strong> 路由器没有到达目标网络的路由。</li>
<li><strong>主机不可达：</strong> 目标网络存在，但目标主机不响应（可能已关机或地址错误）。</li>
<li><strong>协议不可达：</strong> 目标主机不支持数据包指定的上层协议（如 TCP 或 UDP）。</li>
<li><strong>端口不可达：</strong> 目标主机上没有应用程序在监听数据包指定的端口。</li>
<li><strong>需要分片但禁止分片 (Fragmentation Needed and Don’t Fragment Bit Set):</strong> 当数据包太大需要分片，但设置了“不分片”标志位时。常用于 <strong>MTU (Maximum Transmission Unit) 路径发现</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>源抑制 (Source Quench):</strong></p>
<ul>
<li>当路由器或目标主机缓冲区已满，无法处理更多传入数据包时，它会向源主机发送源抑制消息，请求降低发送速率。</li>
<li><strong>注意：</strong> 现代网络中，这种机制已很少使用，更多地依赖于 TCP 的流量控制来管理拥塞。</li>
</ul>
</li>
<li><p><strong>时间超时 (Time Exceeded):</strong></p>
<ul>
<li>当数据包的<strong>生存时间 (TTL - Time To Live)</strong> 字段减到 0 时，路由器会丢弃该数据包并向源主机发送时间超时消息。TTL 字段用于防止数据包在网络中无限循环。</li>
<li><strong>示例场景：</strong> 路由循环、网络拥塞导致数据包长时间滞留。</li>
<li><strong>应用：</strong> <strong><code>traceroute</code> (Windows 下 <code>tracert</code>)</strong> 命令就利用了 ICMP 的时间超时报文来发现数据包从源到目的地的路径上的所有路由器。</li>
</ul>
</li>
<li><p><strong>参数问题 (Parameter Problem):</strong></p>
<ul>
<li>当 IP 数据包头部中的字段不正确或缺失时，会生成此消息。</li>
<li><strong>示例场景：</strong> IP 头部字段值非法，导致无法正确处理数据包。</li>
</ul>
</li>
<li><p><strong>重定向 (Redirect):</strong></p>
<ul>
<li>路由器可能会发送重定向消息，告诉源主机有更优的路由路径可以到达特定的目的地。这通常发生在主机连接到多个路由器，但使用了次优路由的情况下。</li>
<li><strong>示例场景：</strong> 主机通过路由器A发送数据包到目的地X，但路由器A知道路由器B有一条更短或更直接的路径到X，于是路由器A会发送重定向消息给主机，让主机下次直接通过路由器B发送。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>提供网络诊断和查询功能 (Diagnostic and Query Functions):</strong></p>
<p>ICMP 不仅仅用于报告错误，还用于查询网络状态、测试连通性等。</p>
<ul>
<li><p><strong>回送请求&#x2F;回送应答 (Echo Request &#x2F; Echo Reply):</strong></p>
<ul>
<li>这是 ICMP 最广为人知和常用的功能。源主机发送一个<strong>回送请求</strong>报文到目标主机，目标主机接收到后回复一个<strong>回送应答</strong>报文。</li>
<li><strong>应用：</strong><ul>
<li><strong><code>ping</code> 命令：</strong> <code>ping</code> 命令就是基于 ICMP Echo Request&#x2F;Reply 来测试两台主机之间的网络连通性、统计丢包率和往返时间 (RTT)。</li>
<li><strong>网络故障排查：</strong> 验证主机是否在线、网络路径是否正常。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>时间戳请求&#x2F;时间戳应答 (Timestamp Request &#x2F; Timestamp Reply):</strong></p>
<ul>
<li>请求和应答报文中包含发送和接收报文时的时间戳信息，用于测量网络的延迟。</li>
<li><strong>应用：</strong> 测量精细的网络延时。</li>
</ul>
</li>
<li><p><strong>信息请求&#x2F;信息应答 (Information Request &#x2F; Information Reply):</strong></p>
<ul>
<li>早期用于无盘工作站获取其网络信息（如网络掩码）。</li>
<li><strong>注意：</strong> 已废弃，被 DHCP 等协议取代。</li>
</ul>
</li>
<li><p><strong>地址掩码请求&#x2F;地址掩码应答 (Address Mask Request &#x2F; Address Mask Reply):</strong></p>
<ul>
<li>用于获取已知 IP 地址的网络掩码。</li>
<li><strong>注意：</strong> 已废弃，被 DHCP 等协议取代。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>ICMP 协议虽然不直接承载用户数据，但它在 IP 网络中扮演着至关重要的角色，就像交通警察和路标一样。它负责：</p>
<ul>
<li><strong>通知发送方网络中出现的问题</strong> (如目标不可达、流量过载、数据包超时等)。</li>
<li><strong>提供诊断工具</strong> (如 <code>ping</code> 命令测试连通性，<code>traceroute</code> 命令跟踪路由路径)。</li>
</ul>
<p>因此，尽管它只是 IP 协议的辅助，但却是网络错误处理和故障排查中不可或缺的一部分。由于其诊断功能，ICMP 也常常被攻击者利用进行扫描探测，或者被防火墙作为攻击防护的目标。</p>
<h3 id="ICMP-重定向-ICMP-Redirect-的作用及工作原理"><a href="#ICMP-重定向-ICMP-Redirect-的作用及工作原理" class="headerlink" title="ICMP 重定向 (ICMP Redirect) 的作用及工作原理"></a>ICMP 重定向 (ICMP Redirect) 的作用及工作原理</h3><p>ICMP 重定向是 <strong>ICMP 协议</strong>的一种消息类型，它的主要作用是<strong>优化本地网络中的路由路径</strong>，帮助主机发现更优（通常是更直接的）出站路由器。它不是为了告诉主机整个网络的最佳路径，而是为了在主机最初选择的路由是“次优”时，提供一种纠正机制。</p>
<p><strong>作用：</strong></p>
<p>当路由器检测到某个连接到其本地局域网（LAN）的主机，正在通过它发送数据包到某个目的地，但实际上有另一个路由器在同一个局域网内，可以为这个目的地提供更直接或更优的路由路径时，会向发送数据包的主机发送 <strong>ICMP 重定向消息</strong>。</p>
<p><strong>核心目标：</strong></p>
<ul>
<li><strong>避免多余的跳 (Hop):</strong> 减少主机到最终目的地之间的跳数。</li>
<li><strong>优化路由效率:</strong> 提高数据包的转发效率，减少延迟和路由器负载。</li>
</ul>
<p><strong>工作原理：</strong></p>
<p>假设一个主机 (Host A) 和两个路由器 (Router X 和 Router Y) 都连接在同一个局域网 (LAN) 上。Host A 的默认网关设置为 Router X。Router X 可以通往互联网，Router Y 也可以通往互联网的某些部分。</p>
<ol>
<li><p><strong>初始状态：</strong></p>
<ul>
<li>Host A 的路由表配置了默认网关：指向 Router X 的 IP 地址。</li>
<li>Router X 知道如何到达整个互联网 (或至少大部分网络)。</li>
<li>Router Y 也连接到相同的 LAN，并且可能知道一些 Router X 不知道的，或者通过 Router Y 连接更优的特定网络路径 (例如，Router Y 是到达特定子网的更直接路径)。</li>
</ul>
</li>
<li><p><strong>次优路由发生：</strong></p>
<ul>
<li>Host A 需要向目的地 D 发送一个数据包。</li>
<li>根据其默认网关设置，Host A 将数据包发送给 Router X。</li>
<li>Router X 接收到 Host A 发来的数据包后，<strong>检查其自身的路由表</strong>。</li>
<li>Router X 发现：<ul>
<li>它确实可以到达目的地 D。</li>
<li><strong>更重要的是，它发现到达目的地 D 的“下一跳”实际上是 LAN 上的另一个路由器——Router Y。</strong> 也就是说，如果 Host A 直接将数据包发送给 Router Y，而不是先发送给自己，再由自己转发给 Router Y，那么数据包可以少走一段路径（即少了一个跳：Host A -&gt; Router X 这一跳）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>发送 ICMP 重定向消息：</strong></p>
<ul>
<li>Router X 在它将数据包转发给 Router Y 的同时，会向 Host A 发送一个 <strong>ICMP 重定向 (Type 5)</strong> 消息。</li>
<li>这个 ICMP 重定向消息会告诉 Host A：<ul>
<li>“嘿，下次你要去目的地 (或目的地所在的网络) D 时，不要再发给我了。”</li>
<li>“你应该直接把数据包发给 **Router Y (给出 Router Y 的 IP 地址)**，那条路径更直接。”</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>主机更新路由表：</strong></p>
<ul>
<li>Host A 收到 ICMP 重定向消息后，会<strong>更新自己的路由表</strong>。</li>
<li>具体来说，Host A 会为目的地 D（或目的地所在的网络）添加一条新的路由条目，将下一跳设置为 Router Y 的 IP 地址。此条目通常是临时性的，并且优先级低于静态配置或动态路由协议学习到的路由。</li>
</ul>
</li>
<li><p><strong>后续流量优化：</strong></p>
<ul>
<li>当 Host A 再次需要向目的地 D 发送数据包时，它会首先查询更新后的路由表。</li>
<li>由于有了新的路由条目，Host A 会直接将数据包发送给 Router Y，从而绕过不必要的 Router X。这减少了网络延迟和 Router X 的处理负担。</li>
</ul>
</li>
</ol>
<p><strong>ICMP 重定向的报文结构简要说明：</strong></p>
<p>ICMP 重定向报文是一个 ICMP Type 5 的消息。它包含以下关键信息：</p>
<ul>
<li><strong>Type:</strong> 5 (表示重定向)</li>
<li><strong>Code:</strong> 指示重定向的类型（例如，0 表示重定向到网络，1 表示重定向到主机）。</li>
<li><strong>Gateway Internet Address:</strong> 告知发送方应将数据包发送给的“更优”路由器的 IP 地址 (即 Router Y 的 IP)。</li>
<li><strong>Internet Header + First 64 bits of Original Data:</strong> 包含触发重定向的原始 IP 数据包的头部以及原始数据的前 64 位。这有助于主机识别是哪个数据包触发了重定向，从而知道为哪个目的地更新路由。</li>
</ul>
<p><strong>需要注意的事项：</strong></p>
<ul>
<li><strong>本地网络限制：</strong> ICMP 重定向只能在同一物理网络（或广播域）中的路由器和主机之间进行。路由器不能向来自另一个网络的流量发送重定向消息。</li>
<li><strong>安全性考量：</strong> 由于 ICMP 重定向消息可以修改主机的路由表，它可能被恶意攻击者利用进行重定向攻击，将流量重定向到攻击者控制的设备上。因此，大多数生产环境的路由器和防火墙会配置为：<ul>
<li><strong>忽略 ICMP 重定向消息</strong>（对于主机）。</li>
<li><strong>不发送 ICMP 重定向消息</strong>（对于路由器），除非确实需要且网络管理者完全理解其影响。</li>
<li><strong>防火墙策略：</strong> 经常配置防火墙（例如 Linux 的 <code>iptables</code>）来限制或完全阻止 ICMP 重定向报文的传入和传出，以增强安全性。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>ICMP 重定向是一种在路由器发现其转发的流量可以由同一局域网内更直接的路由器处理时，用于通知源主机的一种机制。它的目标是优化本地网络内的路由路径，但鉴于其潜在的安全风险，在生产环境中对其的使用通常受到严格控制。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/ICMP/">https://huiaz.github.io/2025/09/11/ICMP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Ingress/" title="Ingress"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Ingress</div></div><div class="info-2"><div class="info-item-1">Ingress前面我们学习了在 Kubernetes 集群内部使用 kube-dns 实现服务发现的功能，那么我们部署在 Kubernetes 集群中的应用如何暴露给外部的用户使用呢？我们知道可以使用 NodePort 和 LoadBlancer 类型的 Service 可以把应用暴露给外部用户使用，除此之外，Kubernetes 还为我们提供了一个非常重要的资源对象可以用来暴露服务给外部用户，那就是 Ingress。对于小规模的应用我们使用 NodePort 或许能够满足我们的需求，但是当你的应用越来越多的时候，你就会发现对于 NodePort 的管理就非常麻烦了，这个时候使用 Ingress 就非常方便了，可以避免管理大量的端口。 资源对象Ingress 资源对象是 Kubernetes 内置定义的一个对象，是从 Kuberenets 集群外部访问集群的一个入口，将外部的请求转发到集群内不同的 Service 上，其实就相当于 nginx、haproxy 等负载均衡代理服务器，可能你会觉得我们直接使用 nginx 就实现了，但是只使用 nginx 这种方式有很大缺陷，每次有新...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HPA/" title="HPA"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">HPA</div></div><div class="info-2"><div class="info-item-1">HPA 控制器在前面的学习中我们使用了一个 kubectl scale 命令可以来实现 Pod 的扩缩容功能，但是这个是完全手动操作的，要应对线上的各种复杂情况，我们需要能够做到自动化去感知业务，来自动进行扩缩容。为此，Kubernetes 也为我们提供了这样的一个资源对象：Horizontal Pod Autoscaling（Pod 水平自动伸缩），简称 HPA，HPA 通过监控分析一些控制器控制的所有 Pod 的负载变化情况来确定是否需要调整 Pod 的副本数量，这是 HPA 最基本的原理：  我们可以简单的通过 kubectl autoscale 命令来创建一个 HPA 资源对象，HPA Controller 默认30s轮询一次（可通过 kube-controller-manager 的--horizontal-pod-autoscaler-sync-period 参数进行设置），查询指定的资源中的 Pod 资源使用率，并且与创建时设定的值和指标做对比，从而实现自动伸缩的功能。 Metrics Server在 HPA 的第一个版本中，我们需要 Heapster 提供 CPU...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/HTTP%20%E8%AF%B7%E6%B1%82%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9/" title="HTTP 请求包含哪些内容"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 请求包含哪些内容</div></div><div class="info-2"><div class="info-item-1">HTTP 请求包含哪些内容，请求头和请求体有哪些类型？一个 HTTP 请求通常包含三个主要部分：请求行 (Request Line)、请求头 (Request Headers) 和 **请求体 (Request Body)**。 HTTP 请求的组成部分 请求行 (Request Line)这是请求的第一行，它定义了请求的基本信息。它包含三部分：  **方法 (Method)**：指示对资源所执行的操作类型（例如 GET、POST、PUT 等）。 **URI (Uniform Resource Identifier)**：要访问的资源的路径。 **HTTP 版本 (HTTP Version)**：客户端使用的 HTTP 协议版本（例如 HTTP&#x2F;1.1、HTTP&#x2F;2.0）。  示例：GET /index.html HTTP/1.1  请求头 (Request Headers)请求头提供了关于请求的附加信息、客户端的信息以及响应的期望行为。每个请求头都是一个键值对，以冒号分隔，然后是回车换行符。 示例： 1234567Host: www.example.comU...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ARP%E5%8D%8F%E8%AE%AE/" title="ARP协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ARP协议</div></div><div class="info-2"><div class="info-item-1">好的，我们来详细了解一下 ARP 和 RARP。  1. ARP (Address Resolution Protocol) - 地址解析协议作用： 将网络层（IP 地址） 地址解析为数据链路层（MAC 地址） 的协议。 应用场景：当一个主机想与同一局域网内的另一个主机进行通信时，它知道目标主机的 IP 地址，但数据链路层（如以太网）需要目标主机的 MAC 地址来封装帧。此时就需要 ARP 来完成 IP 到 MAC 的映射。 工作原理（简化流程）：  ARP 请求： 主机 A（已知主机 B 的 IP 地址）希望获取主机 B 的 MAC 地址，它会构建一个 ARP 请求报文，其中包含自己的 IP 地址和 MAC 地址，以及目标主机 B 的 IP 地址。 广播： 主机 A 将这个 ARP 请求报文封装在一个以太网帧中，并将目的 MAC 地址设置为广播地址（FFFF.FFFF.FFFF），然后发送到局域网中。 接收与响应： 局域网中的所有主机都会收到这个广播帧。 每个主机都会检查 ARP 请求报文中的目标 IP 地址是否是自己的 IP 地址。 只有目标主机 B 会识别出这个 IP 地址...</div></div></div></a><a class="pagination-related" href="/2025/09/11/CoreDNS/" title="CoreDNS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">CoreDNS</div></div><div class="info-2"><div class="info-item-1">服务发现上面我们讲解了 Service 的用法，我们可以通过 Service 生成的 ClusterIP(VIP) 来访问 Pod 提供的服务，但是在使用的时候还有一个问题：我们怎么知道某个应用的 VIP 呢？比如我们有两个应用，一个是 api 应用，一个是 db 应用，两个应用都是通过 Deployment 进行管理的，并且都通过 Service 暴露出了端口提供服务。api 需要连接到 db 这个应用，我们只知道 db 应用的名称和 db 对应的 Service 的名称，但是并不知道它的 VIP 地址，我们前面的 Service 课程中是不是学习到我们通过 ClusterIP 就可以访问到后面的 Pod 服务，如果我们知道了 VIP 的地址是不是就行了？ 环境变量为了解决上面的问题，在之前的版本中，Kubernetes 采用了环境变量的方法，每个 Pod 启动的时候，会通过环境变量设置所有服务的 IP 和 port 信息，这样 Pod 中的应用可以通过读取环境变量来获取依赖服务的地址信息，这种方法使用起来相对简单，但是有一个很大的问题就是依赖的服务必须在 Pod 启动之前就存...</div></div></div></a><a class="pagination-related" href="/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/" title="DHCP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">DHCP 协议</div></div><div class="info-2"><div class="info-item-1">DHCP 协议的工作原理及应用场景什么是 DHCP 协议？DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 是一种网络协议，用于自动化管理和分配网络中的 IP 地址以及其他相关配置信息（如子网掩码、默认网关、DNS 服务器地址等）。它的核心思想是取代手动配置每台设备的网络参数，实现即插即用，大大简化了大型网络的管理。 DHCP 协议的工作原理 (DORA 过程)DHCP 协议通常通过四步过程（称为 DORA 过程）来完成 IP 地址分配：  Discover (发现)  客户端行为： 当一台新设备（或一台没有配置 IP 地址的设备）连接到网络时，它不知道网络中是否有 DHCP 服务器，也不知道自己的 IP 地址。因此，它会广播一个 DHCP Discover 消息到局域网内的所有设备（使用目的 IP 地址 255.255.255.255，源 IP 地址 0.0.0.0）。 目的： 寻找网络中的 DHCP 服务器。   Offer (提供)  服务器行为： 网络中的 DHCP 服务器收到 DHCP Discover 消息后，会从...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Cookie%E3%80%81Session%20%E5%92%8C%20Token%20/" title="Cookie、Session 和 Token"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Cookie、Session 和 Token</div></div><div class="info-2"><div class="info-item-1">Cookie、Session 和 Token 都是在 Web 开发中用于管理用户状态、实现身份认证和授权的关键机制，但它们在存储位置、工作原理、安全性、无状态性等方面存在显著差异。 1. Cookie 定义： Cookie 是存储在用户浏览器（客户端） 的一小段文本信息。 作用： 会话管理： 记录用户的登录状态、购物车内容等。 个性化设置： 记住用户的偏好（如语言、主题）。 追踪： 记录用户行为，用于数据分析和广告推送。   工作原理： 当用户第一次访问服务器时，服务器在响应头中包含 Set-Cookie 字段，将 Cookie 发送给浏览器。 浏览器接收到 Cookie 后，将其存储起来。 之后，浏览器每次向同一个域发送请求时，都会在请求头中自动带上该域相关的所有 Cookie。 服务器接收到请求后，从 Cookie 中读取信息。   特点： 存储位置： 客户端（浏览器）。 由谁管理： 浏览器自动发送，服务器设置。 安全性： 易受 CSRF 攻击： 因为浏览器会自动发送 Cookie，攻击者可能利用这一点伪造请求。 易受 XSS 攻击： 如果未设置 HttpOnly 标志，JS...</div></div></div></a><a class="pagination-related" href="/2025/09/11/NAT/" title="NAT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">NAT</div></div><div class="info-2"><div class="info-item-1">什么是网络地址转换（NAT）？NAT (Network Address Translation)，即网络地址转换，是一种在 IP 网络中改变数据包的 IP 地址信息的技术。它的主要目的是解决 IPv4 地址枯竭的问题，同时也能提供一定程度的网络安全隔离。 简单来说，NAT 允许一个拥有私有 IP 地址的网络（如家庭网络或企业内部网络）连接到使用公共 IP 地址的外部网络（如互联网），而无需为内部的每台设备都分配一个唯一的公共 IP 地址。 核心概念：  私有 IP 地址： 在私有网络内部使用的 IP 地址，它们不能直接在公共互联网上路由。RFC 1918 定义了以下私有 IP 地址范围： 10.0.0.0 到 10.255.255.255 (10&#x2F;8) 172.16.0.0 到 172.31.255.255 (172.16&#x2F;12) 192.168.0.0 到 192.168.255.255 (192.168&#x2F;16)   公共 IP 地址： 在公共互联网上可寻址的全球唯一的 IP 地址。 NAT 设备： 通常是路由器或防火墙，负责执行 IP 地址的转换...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ICMP-%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是 ICMP 协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP-%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">ICMP 的主要作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP-%E9%87%8D%E5%AE%9A%E5%90%91-ICMP-Redirect-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">ICMP 重定向 (ICMP Redirect) 的作用及工作原理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>