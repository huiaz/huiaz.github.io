<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ICMP | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是 ICMP 协议？ICMP (Internet Control Message Protocol)，即互联网控制消息协议，是 IP 协议的辅助协议，是 TCP&#x2F;IP 协议族中的一个核心组成部分。ICMP 通常被认为是网络层的协议（与 IP 协议同层），因为它处理 IP 数据包的错误和控制信息。 核心特点：  控制和错误报告： ICMP 的主要作用是报告 IP 数据包传输过程中的错误">
<meta property="og:type" content="article">
<meta property="og:title" content="ICMP">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/ICMP/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="什么是 ICMP 协议？ICMP (Internet Control Message Protocol)，即互联网控制消息协议，是 IP 协议的辅助协议，是 TCP&#x2F;IP 协议族中的一个核心组成部分。ICMP 通常被认为是网络层的协议（与 IP 协议同层），因为它处理 IP 数据包的错误和控制信息。 核心特点：  控制和错误报告： ICMP 的主要作用是报告 IP 数据包传输过程中的错误">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:39:42.685Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ICMP",
  "url": "https://huiaz.github.io/2025/09/11/ICMP/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:39:42.685Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/ICMP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ICMP',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">ICMP</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">ICMP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:39:42.685Z" title="更新于 2025-09-11 21:39:42">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="什么是-ICMP-协议？"><a href="#什么是-ICMP-协议？" class="headerlink" title="什么是 ICMP 协议？"></a>什么是 ICMP 协议？</h3><p><strong>ICMP (Internet Control Message Protocol)<strong>，即</strong>互联网控制消息协议</strong>，是 <strong>IP 协议</strong>的<strong>辅助协议</strong>，是 TCP&#x2F;IP 协议族中的一个核心组成部分。ICMP 通常被认为是网络层的协议（与 IP 协议同层），因为它处理 IP 数据包的错误和控制信息。</p>
<p><strong>核心特点：</strong></p>
<ul>
<li><strong>控制和错误报告：</strong> ICMP 的主要作用是报告 IP 数据包传输过程中的错误以及提供网络诊断信息。它不传输用户数据，而是传输网络层面的控制和错误消息。</li>
<li><strong>不可靠性：</strong> ICMP 报文本身不提供可靠传输机制。如果一个 ICMP 报文在传输过程中丢失，IP 层不会重传它。</li>
<li><strong>承载于 IP：</strong> ICMP 报文是“封装”在 IP 数据包中的。换句话说，一个 ICMP 报文会作为 IP 数据包的有效载荷（payload）进行传输。</li>
</ul>
<h3 id="ICMP-的主要作用："><a href="#ICMP-的主要作用：" class="headerlink" title="ICMP 的主要作用："></a>ICMP 的主要作用：</h3><p>ICMP 的主要作用可以归纳为以下几点，主要围绕<strong>错误报告</strong>和<strong>网络诊断</strong>：</p>
<ol>
<li><p><strong>报告差错信息 (Error Reporting):</strong><br>当 IP 数据包在传输过程中遇到问题时，ICMP 被用来向数据包的源主机报告这些错误。常见的 ICMP 差错报文类型包括：</p>
<ul>
<li><p><strong>目标不可达 (Destination Unreachable):</strong></p>
<ul>
<li>当路由器无法将数据包送达目的地时生成。</li>
<li><strong>示例场景：</strong><ul>
<li><strong>网络不可达：</strong> 路由器没有到达目标网络的路由。</li>
<li><strong>主机不可达：</strong> 目标网络存在，但目标主机不响应（可能已关机或地址错误）。</li>
<li><strong>协议不可达：</strong> 目标主机不支持数据包指定的上层协议（如 TCP 或 UDP）。</li>
<li><strong>端口不可达：</strong> 目标主机上没有应用程序在监听数据包指定的端口。</li>
<li><strong>需要分片但禁止分片 (Fragmentation Needed and Don’t Fragment Bit Set):</strong> 当数据包太大需要分片，但设置了“不分片”标志位时。常用于 <strong>MTU (Maximum Transmission Unit) 路径发现</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>源抑制 (Source Quench):</strong></p>
<ul>
<li>当路由器或目标主机缓冲区已满，无法处理更多传入数据包时，它会向源主机发送源抑制消息，请求降低发送速率。</li>
<li><strong>注意：</strong> 现代网络中，这种机制已很少使用，更多地依赖于 TCP 的流量控制来管理拥塞。</li>
</ul>
</li>
<li><p><strong>时间超时 (Time Exceeded):</strong></p>
<ul>
<li>当数据包的<strong>生存时间 (TTL - Time To Live)</strong> 字段减到 0 时，路由器会丢弃该数据包并向源主机发送时间超时消息。TTL 字段用于防止数据包在网络中无限循环。</li>
<li><strong>示例场景：</strong> 路由循环、网络拥塞导致数据包长时间滞留。</li>
<li><strong>应用：</strong> <strong><code>traceroute</code> (Windows 下 <code>tracert</code>)</strong> 命令就利用了 ICMP 的时间超时报文来发现数据包从源到目的地的路径上的所有路由器。</li>
</ul>
</li>
<li><p><strong>参数问题 (Parameter Problem):</strong></p>
<ul>
<li>当 IP 数据包头部中的字段不正确或缺失时，会生成此消息。</li>
<li><strong>示例场景：</strong> IP 头部字段值非法，导致无法正确处理数据包。</li>
</ul>
</li>
<li><p><strong>重定向 (Redirect):</strong></p>
<ul>
<li>路由器可能会发送重定向消息，告诉源主机有更优的路由路径可以到达特定的目的地。这通常发生在主机连接到多个路由器，但使用了次优路由的情况下。</li>
<li><strong>示例场景：</strong> 主机通过路由器A发送数据包到目的地X，但路由器A知道路由器B有一条更短或更直接的路径到X，于是路由器A会发送重定向消息给主机，让主机下次直接通过路由器B发送。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>提供网络诊断和查询功能 (Diagnostic and Query Functions):</strong></p>
<p>ICMP 不仅仅用于报告错误，还用于查询网络状态、测试连通性等。</p>
<ul>
<li><p><strong>回送请求&#x2F;回送应答 (Echo Request &#x2F; Echo Reply):</strong></p>
<ul>
<li>这是 ICMP 最广为人知和常用的功能。源主机发送一个<strong>回送请求</strong>报文到目标主机，目标主机接收到后回复一个<strong>回送应答</strong>报文。</li>
<li><strong>应用：</strong><ul>
<li><strong><code>ping</code> 命令：</strong> <code>ping</code> 命令就是基于 ICMP Echo Request&#x2F;Reply 来测试两台主机之间的网络连通性、统计丢包率和往返时间 (RTT)。</li>
<li><strong>网络故障排查：</strong> 验证主机是否在线、网络路径是否正常。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>时间戳请求&#x2F;时间戳应答 (Timestamp Request &#x2F; Timestamp Reply):</strong></p>
<ul>
<li>请求和应答报文中包含发送和接收报文时的时间戳信息，用于测量网络的延迟。</li>
<li><strong>应用：</strong> 测量精细的网络延时。</li>
</ul>
</li>
<li><p><strong>信息请求&#x2F;信息应答 (Information Request &#x2F; Information Reply):</strong></p>
<ul>
<li>早期用于无盘工作站获取其网络信息（如网络掩码）。</li>
<li><strong>注意：</strong> 已废弃，被 DHCP 等协议取代。</li>
</ul>
</li>
<li><p><strong>地址掩码请求&#x2F;地址掩码应答 (Address Mask Request &#x2F; Address Mask Reply):</strong></p>
<ul>
<li>用于获取已知 IP 地址的网络掩码。</li>
<li><strong>注意：</strong> 已废弃，被 DHCP 等协议取代。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>ICMP 协议虽然不直接承载用户数据，但它在 IP 网络中扮演着至关重要的角色，就像交通警察和路标一样。它负责：</p>
<ul>
<li><strong>通知发送方网络中出现的问题</strong> (如目标不可达、流量过载、数据包超时等)。</li>
<li><strong>提供诊断工具</strong> (如 <code>ping</code> 命令测试连通性，<code>traceroute</code> 命令跟踪路由路径)。</li>
</ul>
<p>因此，尽管它只是 IP 协议的辅助，但却是网络错误处理和故障排查中不可或缺的一部分。由于其诊断功能，ICMP 也常常被攻击者利用进行扫描探测，或者被防火墙作为攻击防护的目标。</p>
<h3 id="ICMP-重定向-ICMP-Redirect-的作用及工作原理"><a href="#ICMP-重定向-ICMP-Redirect-的作用及工作原理" class="headerlink" title="ICMP 重定向 (ICMP Redirect) 的作用及工作原理"></a>ICMP 重定向 (ICMP Redirect) 的作用及工作原理</h3><p>ICMP 重定向是 <strong>ICMP 协议</strong>的一种消息类型，它的主要作用是<strong>优化本地网络中的路由路径</strong>，帮助主机发现更优（通常是更直接的）出站路由器。它不是为了告诉主机整个网络的最佳路径，而是为了在主机最初选择的路由是“次优”时，提供一种纠正机制。</p>
<p><strong>作用：</strong></p>
<p>当路由器检测到某个连接到其本地局域网（LAN）的主机，正在通过它发送数据包到某个目的地，但实际上有另一个路由器在同一个局域网内，可以为这个目的地提供更直接或更优的路由路径时，会向发送数据包的主机发送 <strong>ICMP 重定向消息</strong>。</p>
<p><strong>核心目标：</strong></p>
<ul>
<li><strong>避免多余的跳 (Hop):</strong> 减少主机到最终目的地之间的跳数。</li>
<li><strong>优化路由效率:</strong> 提高数据包的转发效率，减少延迟和路由器负载。</li>
</ul>
<p><strong>工作原理：</strong></p>
<p>假设一个主机 (Host A) 和两个路由器 (Router X 和 Router Y) 都连接在同一个局域网 (LAN) 上。Host A 的默认网关设置为 Router X。Router X 可以通往互联网，Router Y 也可以通往互联网的某些部分。</p>
<ol>
<li><p><strong>初始状态：</strong></p>
<ul>
<li>Host A 的路由表配置了默认网关：指向 Router X 的 IP 地址。</li>
<li>Router X 知道如何到达整个互联网 (或至少大部分网络)。</li>
<li>Router Y 也连接到相同的 LAN，并且可能知道一些 Router X 不知道的，或者通过 Router Y 连接更优的特定网络路径 (例如，Router Y 是到达特定子网的更直接路径)。</li>
</ul>
</li>
<li><p><strong>次优路由发生：</strong></p>
<ul>
<li>Host A 需要向目的地 D 发送一个数据包。</li>
<li>根据其默认网关设置，Host A 将数据包发送给 Router X。</li>
<li>Router X 接收到 Host A 发来的数据包后，<strong>检查其自身的路由表</strong>。</li>
<li>Router X 发现：<ul>
<li>它确实可以到达目的地 D。</li>
<li><strong>更重要的是，它发现到达目的地 D 的“下一跳”实际上是 LAN 上的另一个路由器——Router Y。</strong> 也就是说，如果 Host A 直接将数据包发送给 Router Y，而不是先发送给自己，再由自己转发给 Router Y，那么数据包可以少走一段路径（即少了一个跳：Host A -&gt; Router X 这一跳）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>发送 ICMP 重定向消息：</strong></p>
<ul>
<li>Router X 在它将数据包转发给 Router Y 的同时，会向 Host A 发送一个 <strong>ICMP 重定向 (Type 5)</strong> 消息。</li>
<li>这个 ICMP 重定向消息会告诉 Host A：<ul>
<li>“嘿，下次你要去目的地 (或目的地所在的网络) D 时，不要再发给我了。”</li>
<li>“你应该直接把数据包发给 **Router Y (给出 Router Y 的 IP 地址)**，那条路径更直接。”</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>主机更新路由表：</strong></p>
<ul>
<li>Host A 收到 ICMP 重定向消息后，会<strong>更新自己的路由表</strong>。</li>
<li>具体来说，Host A 会为目的地 D（或目的地所在的网络）添加一条新的路由条目，将下一跳设置为 Router Y 的 IP 地址。此条目通常是临时性的，并且优先级低于静态配置或动态路由协议学习到的路由。</li>
</ul>
</li>
<li><p><strong>后续流量优化：</strong></p>
<ul>
<li>当 Host A 再次需要向目的地 D 发送数据包时，它会首先查询更新后的路由表。</li>
<li>由于有了新的路由条目，Host A 会直接将数据包发送给 Router Y，从而绕过不必要的 Router X。这减少了网络延迟和 Router X 的处理负担。</li>
</ul>
</li>
</ol>
<p><strong>ICMP 重定向的报文结构简要说明：</strong></p>
<p>ICMP 重定向报文是一个 ICMP Type 5 的消息。它包含以下关键信息：</p>
<ul>
<li><strong>Type:</strong> 5 (表示重定向)</li>
<li><strong>Code:</strong> 指示重定向的类型（例如，0 表示重定向到网络，1 表示重定向到主机）。</li>
<li><strong>Gateway Internet Address:</strong> 告知发送方应将数据包发送给的“更优”路由器的 IP 地址 (即 Router Y 的 IP)。</li>
<li><strong>Internet Header + First 64 bits of Original Data:</strong> 包含触发重定向的原始 IP 数据包的头部以及原始数据的前 64 位。这有助于主机识别是哪个数据包触发了重定向，从而知道为哪个目的地更新路由。</li>
</ul>
<p><strong>需要注意的事项：</strong></p>
<ul>
<li><strong>本地网络限制：</strong> ICMP 重定向只能在同一物理网络（或广播域）中的路由器和主机之间进行。路由器不能向来自另一个网络的流量发送重定向消息。</li>
<li><strong>安全性考量：</strong> 由于 ICMP 重定向消息可以修改主机的路由表，它可能被恶意攻击者利用进行重定向攻击，将流量重定向到攻击者控制的设备上。因此，大多数生产环境的路由器和防火墙会配置为：<ul>
<li><strong>忽略 ICMP 重定向消息</strong>（对于主机）。</li>
<li><strong>不发送 ICMP 重定向消息</strong>（对于路由器），除非确实需要且网络管理者完全理解其影响。</li>
<li><strong>防火墙策略：</strong> 经常配置防火墙（例如 Linux 的 <code>iptables</code>）来限制或完全阻止 ICMP 重定向报文的传入和传出，以增强安全性。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>ICMP 重定向是一种在路由器发现其转发的流量可以由同一局域网内更直接的路由器处理时，用于通知源主机的一种机制。它的目标是优化本地网络内的路由路径，但鉴于其潜在的安全风险，在生产环境中对其的使用通常受到严格控制。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/ICMP/">https://huiaz.github.io/2025/09/11/ICMP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Ingress/" title="Ingress"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Ingress</div></div><div class="info-2"><div class="info-item-1">Ingress前面我们学习了在 Kubernetes 集群内部使用 kube-dns 实现服务发现的功能，那么我们部署在 Kubernetes 集群中的应用如何暴露给外部的用户使用呢？我们知道可以使用 NodePort 和 LoadBlancer 类型的 Service 可以把应用暴露给外部用户使用，除此之外，Kubernetes 还为我们提供了一个非常重要的资源对象可以用来暴露服务给外部用户，那就是 Ingress。对于小规模的应用我们使用 NodePort 或许能够满足我们的需求，但是当你的应用越来越多的时候，你就会发现对于 NodePort 的管理就非常麻烦了，这个时候使用 Ingress 就非常方便了，可以避免管理大量的端口。 资源对象Ingress 资源对象是 Kubernetes 内置定义的一个对象，是从 Kuberenets 集群外部访问集群的一个入口，将外部的请求转发到集群内不同的 Service 上，其实就相当于 nginx、haproxy 等负载均衡代理服务器，可能你会觉得我们直接使用 nginx 就实现了，但是只使用 nginx 这种方式有很大缺陷，每次有新...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HPA/" title="HPA"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">HPA</div></div><div class="info-2"><div class="info-item-1">HPA 控制器在前面的学习中我们使用了一个 kubectl scale 命令可以来实现 Pod 的扩缩容功能，但是这个是完全手动操作的，要应对线上的各种复杂情况，我们需要能够做到自动化去感知业务，来自动进行扩缩容。为此，Kubernetes 也为我们提供了这样的一个资源对象：Horizontal Pod Autoscaling（Pod 水平自动伸缩），简称 HPA，HPA 通过监控分析一些控制器控制的所有 Pod 的负载变化情况来确定是否需要调整 Pod 的副本数量，这是 HPA 最基本的原理：  我们可以简单的通过 kubectl autoscale 命令来创建一个 HPA 资源对象，HPA Controller 默认30s轮询一次（可通过 kube-controller-manager 的--horizontal-pod-autoscaler-sync-period 参数进行设置），查询指定的资源中的 Pod 资源使用率，并且与创建时设定的值和指标做对比，从而实现自动伸缩的功能。 Metrics Server在 HPA 的第一个版本中，我们需要 Heapster 提供 CPU...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP快速重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP快速重传机制</div></div><div class="info-2"><div class="info-item-1">TCP 引入快速重传（Fast Retransmit）机制，是为了弥补仅仅依靠超时重传的不足，提高网络吞吐量和链路利用率，尤其是在数据包丢失不严重但仍存在的情况下。 让我们来详细了解一下： 超时重传的不足：超时重传是 TCP 可靠性最基本的保障，但它有一个致命的弱点：等待时间过长。  重传超时时间 (RTO) 的计算： RTO 是根据网络中的往返时间 (RTT) 动态调整的，通常比 RTT 要长一些。即使网络状况良好，RTO 至少也得几十毫秒甚至几百毫秒。 等待 RTO 的代价： 吞吐量下降： 如果一个数据包丢失了，发送方必须一直等到 RTO 到期才能重传。在这漫长的等待期间，发送方可能无法发送新的数据（如果拥塞窗口和接收窗口限制），导致网络带宽得不到充分利用，吞吐量显著下降。 延迟增加： 对于实时性要求较高的应用，长时间的等待会导致明显的延迟增加。 可能触发不必要的拥塞控制： 当超时发生时，TCP 会认为发生了一次严重的丢包事件，通常会大幅度降低拥塞窗口（例如，将拥塞窗口降到 1 MSS），这会极大地限制后续的数据发送，加剧吞吐量下降，即便实际上可能只丢失了一个包。    快速...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%201.0%20%E5%92%8C%202.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" title="HTTP 1.0 和 2.0 有什么区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 1.0 和 2.0 有什么区别</div></div><div class="info-2"><div class="info-item-1">HTTP 1.0 和 2.0 有什么区别？HTTP 1.0 和 2.0 在性能、效率和功能方面存在显著差异。以下是它们的关键区别： HTTP 1.0 (最初的成功)  核心概念：每次请求&#x2F;响应一个连接。 这是它最主要的特点。 短连接 (Short-lived connections): 每个请求和响应都需要建立一个新的TCP连接，在完成传输后立即关闭。这导致了大量的连接建立和关闭开销（三次握手和四次挥手）。   串行请求 (Serial requests): 浏览器一次只能发送一个请求，必须等待当前请求的响应，才能发送下一个请求。这导致了“队头阻塞 (Head-of-Line Blocking)”问题，即一个慢的响应会阻碍后续所有请求。 无头部压缩 (No header compression): 每个请求和响应的头部信息都是原始的，可能包含大量重复信息。 无服务器推送 (No server push): 服务器无法主动向客户端发送资源，只能响应客户端的请求。 无二进制分帧 (No binary framing): 数据以文本形式传输，效率较低。 Cookie (部分支...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP 超时重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 超时重传机制</div></div><div class="info-2"><div class="info-item-1">除了标准的 TCP 四次挥手，还有一些其他方法或特殊情况可以导致连接断开，但它们通常不如四次挥手那样优雅和受控，可能会伴随数据丢失或异常。 1. RST 报文断开连接 (Reset)RST (Reset) 报文是一种 TCP 错误或异常的指示，它会立即终止连接，不会进行标准的四次挥手过程，也不会等待任何未发送或未确认的数据。 RST 报文的常见使用场景：  连接被拒绝： 当客户端尝试连接到一个不存在的端口或一个拒绝连接的服务器端口时，服务器通常会回复一个 RST 报文，表示连接无法建立。 中止连接： 当一方决定突然中止一个连接，而不是通过正常的挥手过程关闭时，会发送 RST。这意味着不再关心对方是否已收到所有数据，也不希望进一步的通信。例如，应用程序调用 SO_LINGER 且 l_onoff 为真，l_linger 为 0 时。 检测半开连接： 如果一方的连接已经关闭（比如进程崩溃），而另一方在试图向已关闭的连接发送数据时，操作系统会检测到这个异常并回复一个 RST 报文。 端口扫描： 端口扫描工具通常会向目标端口发送 SYN 包，根据收到的响应（SYN-ACK 或 RST）来...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCPIP%204%20%E5%B1%82%E6%A8%A1%E5%9E%8B/" title="TCPIP 4 层模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCPIP 4 层模型</div></div><div class="info-2"><div class="info-item-1">TCP&#x2F;IP 四层模型（也称为 TCP&#x2F;IP 协议栈、TCP&#x2F;IP 参考模型）是计算机网络中最常用和最重要的分层模型之一。它将复杂的网络通信过程划分为若干个逻辑层，每层负责不同的功能。 这个模型与 OSI 七层模型有所不同，虽然它们都致力于解决网络通信的复杂性，但 TCP&#x2F;IP 模型更注重实际应用和协议实现。 TCP&#x2F;IP 四层模型的构成：TCP&#x2F;IP 模型通常被划分为以下四层：  应用层 (Application Layer) 传输层 (Transport Layer) 网络层 (Internet Layer) 网络接口层 (Network Access Layer) 或 数据链路层&#x2F;物理层  让我们逐一详细了解每一层的功能、协议和数据单元。  1. 应用层 (Application Layer) 功能： 提供应用程序之间的通信服务。它是用户与网络进行交互的最高层，负责处理特定应用程序的数据，并将其转换为通过网络传输的格式。 代表协议： HTTP&#x2F;HTTPS： (超文本传输协议) 用于网页浏览。 F...</div></div></div></a><a class="pagination-related" href="/2025/09/11/CoreDNS/" title="CoreDNS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">CoreDNS</div></div><div class="info-2"><div class="info-item-1">服务发现上面我们讲解了 Service 的用法，我们可以通过 Service 生成的 ClusterIP(VIP) 来访问 Pod 提供的服务，但是在使用的时候还有一个问题：我们怎么知道某个应用的 VIP 呢？比如我们有两个应用，一个是 api 应用，一个是 db 应用，两个应用都是通过 Deployment 进行管理的，并且都通过 Service 暴露出了端口提供服务。api 需要连接到 db 这个应用，我们只知道 db 应用的名称和 db 对应的 Service 的名称，但是并不知道它的 VIP 地址，我们前面的 Service 课程中是不是学习到我们通过 ClusterIP 就可以访问到后面的 Pod 服务，如果我们知道了 VIP 的地址是不是就行了？ 环境变量为了解决上面的问题，在之前的版本中，Kubernetes 采用了环境变量的方法，每个 Pod 启动的时候，会通过环境变量设置所有服务的 IP 和 port 信息，这样 Pod 中的应用可以通过读取环境变量来获取依赖服务的地址信息，这种方法使用起来相对简单，但是有一个很大的问题就是依赖的服务必须在 Pod 启动之前就存...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F/" title="TCP 的三次握手？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 的三次握手？</div></div><div class="info-2"><div class="info-item-1"> 好的，我们来详细解释 TCP 的三次握手（Three-Way Handshake）过程。这是 TCP 协议建立连接的关键步骤，确保客户端和服务器都准备好进行数据传输。 1. TCP 三次握手的目的三次握手的核心目的是：  确认双方的发送和接收能力正常： 确保客户端能够发送数据，也能接收数据；服务器也能发送数据，也能接收数据。 为会话同步初始序列号 (ISN)： TCP 会为发送的每一个字节数据编号。为了实现可靠传输和乱序重排，需要一个起始的序列号。双方需要知道对方的起始序列号，并在此基础上进行数据传输的确认和管理。 防止已失效的连接请求报文段（SYN）突然又传送到了服务器，从而产生错误： 后面会详细解释这一点。  2. TCP 三次握手的过程假设客户端是发起连接的一方，服务器是等待连接的一方。 第一次握手：客户端 -&gt; 服务器 (SYN) 客户端发送： SYN (Synchronize) 标志位设置为 1： 表示这是一个连接请求报文。 seq (Sequence Number) &#x3D; 客户端的初始序列号 (client_ISN)： 客户端随机选择一个初始序列号。 ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ICMP-%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是 ICMP 协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP-%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">ICMP 的主要作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP-%E9%87%8D%E5%AE%9A%E5%90%91-ICMP-Redirect-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">ICMP 重定向 (ICMP Redirect) 的作用及工作原理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>