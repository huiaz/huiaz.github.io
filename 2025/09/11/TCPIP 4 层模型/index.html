<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCPIP 4 层模型 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP&#x2F;IP 四层模型（也称为 TCP&#x2F;IP 协议栈、TCP&#x2F;IP 参考模型）是计算机网络中最常用和最重要的分层模型之一。它将复杂的网络通信过程划分为若干个逻辑层，每层负责不同的功能。 这个模型与 OSI 七层模型有所不同，虽然它们都致力于解决网络通信的复杂性，但 TCP&#x2F;IP 模型更注重实际应用和协议实现。 TCP&#x2F;IP 四层模型的构成：TCP&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="TCPIP 4 层模型">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/TCPIP%204%20%E5%B1%82%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="TCP&#x2F;IP 四层模型（也称为 TCP&#x2F;IP 协议栈、TCP&#x2F;IP 参考模型）是计算机网络中最常用和最重要的分层模型之一。它将复杂的网络通信过程划分为若干个逻辑层，每层负责不同的功能。 这个模型与 OSI 七层模型有所不同，虽然它们都致力于解决网络通信的复杂性，但 TCP&#x2F;IP 模型更注重实际应用和协议实现。 TCP&#x2F;IP 四层模型的构成：TCP&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:07:24.658Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCPIP 4 层模型",
  "url": "https://huiaz.github.io/2025/09/11/TCPIP%204%20%E5%B1%82%E6%A8%A1%E5%9E%8B/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:07:24.658Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/TCPIP%204%20%E5%B1%82%E6%A8%A1%E5%9E%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCPIP 4 层模型',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCPIP 4 层模型</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCPIP 4 层模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:07:24.658Z" title="更新于 2025-09-11 22:07:24">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>TCP&#x2F;IP 四层模型（也称为 TCP&#x2F;IP 协议栈、TCP&#x2F;IP 参考模型）是计算机网络中最常用和最重要的分层模型之一。它将复杂的网络通信过程划分为若干个逻辑层，每层负责不同的功能。</p>
<p>这个模型与 OSI 七层模型有所不同，虽然它们都致力于解决网络通信的复杂性，但 TCP&#x2F;IP 模型更注重实际应用和协议实现。</p>
<h3 id="TCP-IP-四层模型的构成："><a href="#TCP-IP-四层模型的构成：" class="headerlink" title="TCP&#x2F;IP 四层模型的构成："></a>TCP&#x2F;IP 四层模型的构成：</h3><p>TCP&#x2F;IP 模型通常被划分为以下四层：</p>
<ol>
<li><strong>应用层 (Application Layer)</strong></li>
<li><strong>传输层 (Transport Layer)</strong></li>
<li><strong>网络层 (Internet Layer)</strong></li>
<li><strong>网络接口层 (Network Access Layer) 或 数据链路层&#x2F;物理层</strong></li>
</ol>
<p>让我们逐一详细了解每一层的功能、协议和数据单元。</p>
<hr>
<h3 id="1-应用层-Application-Layer"><a href="#1-应用层-Application-Layer" class="headerlink" title="1. 应用层 (Application Layer)"></a>1. 应用层 (Application Layer)</h3><ul>
<li><strong>功能：</strong> 提供应用程序之间的通信服务。它是用户与网络进行交互的最高层，负责处理特定应用程序的数据，并将其转换为通过网络传输的格式。</li>
<li><strong>代表协议：</strong><ul>
<li><strong>HTTP&#x2F;HTTPS：</strong> (超文本传输协议) 用于网页浏览。</li>
<li><strong>FTP：</strong> (文件传输协议) 用于文件传输。</li>
<li><strong>SMTP&#x2F;POP3&#x2F;IMAP：</strong> (简单邮件传输协议&#x2F;邮局协议&#x2F;互联网邮件访问协议) 用于电子邮件的发送和接收。</li>
<li><strong>DNS：</strong> (域名系统) 用于将域名解析为 IP 地址。</li>
<li><strong>Telnet&#x2F;SSH：</strong> 用于远程登录。</li>
<li><strong>SNMP：</strong> (简单网络管理协议) 用于网络设备管理。</li>
</ul>
</li>
<li><strong>数据单元：</strong> 报文 (Message) 或 数据 (Data)</li>
</ul>
<hr>
<h3 id="2-传输层-Transport-Layer"><a href="#2-传输层-Transport-Layer" class="headerlink" title="2. 传输层 (Transport Layer)"></a>2. 传输层 (Transport Layer)</h3><ul>
<li><strong>功能：</strong> 提供端到端（应用程序到应用程序）的数据传输服务。它负责数据的分段、传输、接收和重组，以及保证数据传输的可靠性（或不可靠性）。</li>
<li><strong>代表协议：</strong><ul>
<li><strong>TCP (Transmission Control Protocol)：</strong> (传输控制协议) 提供<strong>面向连接的、可靠的、基于字节流</strong>的传输服务。它提供流量控制、拥塞控制和错误恢复等机制，确保数据完整无误地到达。</li>
<li><strong>UDP (User Datagram Protocol)：</strong> (用户数据报协议) 提供<strong>无连接的、不可靠的</strong>传输服务。它不保证数据包的顺序、完整性或是否到达，但传输效率高，适用于对实时性要求高、少量丢包可接受的应用（如视频会议、网络游戏）。</li>
</ul>
</li>
<li><strong>数据单元：</strong><ul>
<li><strong>TCP：</strong> 段 (Segment)</li>
<li><strong>UDP：</strong> 用户数据报 (User Datagram)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-网络层-Internet-Layer-互联网层"><a href="#3-网络层-Internet-Layer-互联网层" class="headerlink" title="3. 网络层 (Internet Layer) &#x2F; 互联网层"></a>3. 网络层 (Internet Layer) &#x2F; 互联网层</h3><ul>
<li><strong>功能：</strong> 负责数据包在不同网络（广域网）之间的路由和转发。它定义了数据包的寻址（IP 地址）和路由选择，使得数据可以跨越异构网络到达目标主机。</li>
<li><strong>代表协议：</strong><ul>
<li><strong>IP (Internet Protocol)：</strong> (互联网协议) 核心协议，提供<strong>无连接的、不可靠的</strong>数据包传输服务。它只负责将数据包从源主机转发到目的主机，不关心数据包是否丢失或乱序。</li>
<li><strong>ARP (Address Resolution Protocol)：</strong> (地址解析协议) 将 IP 地址解析为 MAC 地址。</li>
<li><strong>ICMP (Internet Control Message Protocol)：</strong> (互联网控制报文协议) 用于在 IP 主机和路由器之间传递控制消息和错误报告（如 Ping 命令）。</li>
<li><strong>IGMP (Internet Group Management Protocol)：</strong> (互联网组管理协议) 用于管理多播组成员。</li>
</ul>
</li>
<li><strong>数据单元：</strong> 数据包 (Packet) 或 IP 数据报 (IP Datagram)</li>
</ul>
<hr>
<h3 id="4-网络接口层-Network-Access-Layer-主机到网络层-数据链路层与物理层"><a href="#4-网络接口层-Network-Access-Layer-主机到网络层-数据链路层与物理层" class="headerlink" title="4. 网络接口层 (Network Access Layer) &#x2F; 主机到网络层 &#x2F; 数据链路层与物理层"></a>4. 网络接口层 (Network Access Layer) &#x2F; 主机到网络层 &#x2F; 数据链路层与物理层</h3><ul>
<li><strong>功能：</strong> 负责将 IP 数据报封装和解封装成适合物理网络传输的帧，并处理在物理介质上的比特流传输。它包括了数据链路层和物理层的功能。<ul>
<li><strong>数据链路层：</strong> 处理帧的传输、错误检测和纠正、MAC 地址寻址，以及介质访问控制 (MAC)。</li>
<li><strong>物理层：</strong> 定义物理介质（如电缆、光纤、无线电波）的特性、电压、接口形式、数据传输速率等。</li>
</ul>
</li>
<li><strong>代表协议：</strong><ul>
<li><strong>以太网 (Ethernet)：</strong> 最常用的局域网技术。</li>
<li><strong>Wi-Fi (IEEE 802.11)：</strong> 无线局域网标准。</li>
<li><strong>PPP (Point-to-Point Protocol)：</strong> (点对点协议) 用于拨号连接。</li>
</ul>
</li>
<li><strong>数据单元：</strong> 帧 (Frame)</li>
</ul>
<hr>
<h3 id="TCP-IP-模型与-OSI-模型的对比："><a href="#TCP-IP-模型与-OSI-模型的对比：" class="headerlink" title="TCP&#x2F;IP 模型与 OSI 模型的对比："></a>TCP&#x2F;IP 模型与 OSI 模型的对比：</h3><table>
<thead>
<tr>
<th align="left">OSI 七层模型</th>
<th align="left">TCP&#x2F;IP 四层模型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">7. 应用层 (Application)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6. 表示层 (Presentation)</td>
<td align="left"><strong>4. 应用层 (Application)</strong></td>
</tr>
<tr>
<td align="left">5. 会话层 (Session)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4. 传输层 (Transport)</td>
<td align="left"><strong>3. 传输层 (Transport)</strong></td>
</tr>
<tr>
<td align="left">3. 网络层 (Network)</td>
<td align="left"><strong>2. 网络层 (Internet)</strong></td>
</tr>
<tr>
<td align="left">2. 数据链路层 (Data Link)</td>
<td align="left"><strong>1. 网络接口层 (Network Access)</strong></td>
</tr>
<tr>
<td align="left">1. 物理层 (Physical)</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>主要区别：</strong></p>
<ul>
<li><strong>层数：</strong> OSI 模型有 7 层，TCP&#x2F;IP 模型有 4 层。</li>
<li><strong>表示层和会话层：</strong> OSI 模型中独立的表示层和会话层的功能在 TCP&#x2F;IP 模型中被<strong>合并</strong>到应用层中。</li>
<li><strong>数据链路层和物理层：</strong> OSI 模型中独立的这两层在 TCP&#x2F;IP 模型中被<strong>合并</strong>为网络接口层。</li>
<li><strong>重点：</strong> OSI 模型更偏向理论和概念化，旨在提供一个通用的参考标准；TCP&#x2F;IP 模型则更注重实际操作和协议实现，是互联网的核心。</li>
</ul>
<hr>
<h3 id="TCP-IP-模型的封装和解封装过程："><a href="#TCP-IP-模型的封装和解封装过程：" class="headerlink" title="TCP&#x2F;IP 模型的封装和解封装过程："></a>TCP&#x2F;IP 模型的封装和解封装过程：</h3><p>当数据从应用层向下传递时，每一层都会给数据添加自己的<strong>首部 (Header)</strong> 信息，这个过程称为**封装 (Encapsulation)<strong>。当数据到达目标主机后，数据从底层向上层传递时，每一层会剥离相应的首部信息，这个过程称为</strong>解封装 (Decapsulation)**。</p>
<ol>
<li><strong>应用层：</strong> 生成原始数据 (Message)。</li>
<li><strong>传输层：</strong> 将 Message 分割成数据段 (Segment&#x2F;Datagram)，并添加 TCP&#x2F;UDP 首部。</li>
<li><strong>网络层：</strong> 将 Segment&#x2F;Datagram 封装成 IP 数据报 (Datagram)，并添加 IP 首部。</li>
<li><strong>网络接口层：</strong> 将 IP 数据报封装成帧 (Frame)，并添加数据链路层首部（和尾部），然后将帧转换为比特流通过物理介质传输。</li>
</ol>
<p>这个分层的模型使得网络通信具有高度的模块化和灵活性，每一层只需要关注自身的功能，同时也方便协议的开发和维护。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/TCPIP%204%20%E5%B1%82%E6%A8%A1%E5%9E%8B/">https://huiaz.github.io/2025/09/11/TCPIP%204%20%E5%B1%82%E6%A8%A1%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Network/">Network</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/TCP%E8%BF%9E%E6%8E%A5/" title="TCP连接"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCP连接</div></div><div class="info-2"><div class="info-item-1">好的，我们来深入理解一下 TCP 连接。 TCP (Transmission Control Protocol，传输控制协议) 连接是计算机网络中一种可靠的、面向连接的、基于字节流的通信方式。它是互联网的基础协议之一，位于 OSI 模型的传输层。 要理解 TCP 连接，首先要明白它解决了哪些问题，以及它是如何解决的。  TCP 解决了什么问题？想象一下你给朋友寄包裹。如果你想确保包裹一定能送到、顺序不错乱、没有丢失、没有重复，并且能知道朋友是否收到了，这就是 TCP 试图在数据传输中实现的目标。 具体来说，TCP 针对底层的 IP (Internet Protocol，网际协议) 的局限性，提供了以下关键服务：  可靠性 (Reliability)： IP 是不可靠的，它只负责尽力而为地转发数据包，不保证数据包是否到达，也不保证顺序。TCP通过以下机制确保可靠性：  确认机制 (Acknowledgements - ACK)： 接收方收到数据后会发送确认包给发送方。 重传机制 (Retransmission)： 如果发送方在一定时间内没有收到确认包，它会认为数据包丢失，并重新发送...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP-四次挥手"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TCP-四次挥手</div></div><div class="info-2"><div class="info-item-1">TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。 假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。 四次挥手过程详解：第一次挥手：FIN 报文段（客户端 A → 服务器 B）  客户端 A (主动关闭方)：  当客户端 A 的应用层想要关闭连接时（例如调用 close() 或 shutdown()），客户端 A 的 TCP 会发送一个带有 FIN (Finish) 标志的报文段给服务器 B。 这个 FIN 报文段的序列号通常是它发送的最后一个数据字节的序列号的下一个。 发送 FIN 后，客户端 A 进入 FIN_WAIT_1 状态。这意味着客户端 A 不再发送数据，但仍然可以接收数据。  状态变化： ESTABLISHED → FIN_WAIT_1   第二次挥手：ACK 报文段（服务器 B → 客户端 A）  服务器 B (被动关闭方)：  当...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/" title="TCP 客户端在发送 SYN 之后宕机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 客户端在发送 SYN 之后宕机</div></div><div class="info-2"><div class="info-item-1">这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。 假设客户端 A 尝试连接服务器 B。 1. 客户端发送 SYN (第一次握手) 客户端 A： 生成一个 SYN 包，Seq = client_ISN，发送给服务器 B。 发送后，客户端 A 的 TCP 状态会从 CLOSED 变为 SYN_SENT。  2. 客户端 A 宕机 就在发送 SYN 包之后，客户端 A 突然崩溃（例如，操作系统蓝屏、电源故障、进程被杀掉等）。这意味着客户端 A 的所有网络状态、定时器、内存中的 TCP 控制块信息都瞬间丢失了。  3. 服务器 B 的处理 服务器 B 收到 SYN： 服务器 B 收到了客户端 A 发送的 SYN 包。 服务器 B 响应 SYN+ACK： 服务器 B 按照 TCP 握手流程，会进入 SYN_RCVD 状态，并向客户端 A 发送 SYN+ACK 包 (Seq = server_ISN, Ack = client_ISN + 1)。 服务器 B 等待客户端 ACK： 服务器 B 此时会启动一个定时...</div></div></div></a><a class="pagination-related" href="/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/" title="DHCP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">DHCP 协议</div></div><div class="info-2"><div class="info-item-1">DHCP 协议的工作原理及应用场景什么是 DHCP 协议？DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 是一种网络协议，用于自动化管理和分配网络中的 IP 地址以及其他相关配置信息（如子网掩码、默认网关、DNS 服务器地址等）。它的核心思想是取代手动配置每台设备的网络参数，实现即插即用，大大简化了大型网络的管理。 DHCP 协议的工作原理 (DORA 过程)DHCP 协议通常通过四步过程（称为 DORA 过程）来完成 IP 地址分配：  Discover (发现)  客户端行为： 当一台新设备（或一台没有配置 IP 地址的设备）连接到网络时，它不知道网络中是否有 DHCP 服务器，也不知道自己的 IP 地址。因此，它会广播一个 DHCP Discover 消息到局域网内的所有设备（使用目的 IP 地址 255.255.255.255，源 IP 地址 0.0.0.0）。 目的： 寻找网络中的 DHCP 服务器。   Offer (提供)  服务器行为： 网络中的 DHCP 服务器收到 DHCP Discover 消息后，会从...</div></div></div></a><a class="pagination-related" href="/2025/09/11/HTTP%202.0%20%E5%92%8C%203.0%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" title="HTTP 2.0 和 3.0 有什么区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">HTTP 2.0 和 3.0 有什么区别</div></div><div class="info-2"><div class="info-item-1">HTTP 2.0 和 3.0 有什么区别？HTTP 2.0 和 HTTP 3.0 在核心传输协议、解决的问题以及它们所针对的应用场景上存在革命性的差异。HTTP 3.0 不仅仅是 HTTP 2.0 的简单升级，它是一个范式转变，因为它彻底抛弃了 TCP，转而使用 UDP 作为其底层传输协议。 HTTP 2.0 (基于 TCP 的增强)  底层协议： 基于 TCP（传输控制协议）。 主要目标： 解决 HTTP 1.x 的队头阻塞（Head-of-Line Blocking）问题以及效率低下。 主要特性（回顾）： 多路复用 (Multiplexing)： 在单个 TCP 连接上同时发送和接收多个独立的请求和响应流。这解决了应用层的队头阻塞。 头部压缩 (HPACK)： 减少请求和响应头部的大小。 服务器推送 (Server Push)： 服务器主动将客户端可能需要的资源推送到客户端。 二进制分帧： 数据以二进制格式传输，提高解析效率。    HTTP 3.0 (基于 UDP&#x2F;QUIC 的革命)  底层协议： 基于 UDP（用户数据报协议）之上的 QUIC (Quick UD...</div></div></div></a><a class="pagination-related" href="/2025/09/11/RIP%20(Routing%20Information%20Protocol)%20%E5%8D%8F%E8%AE%AE/" title="RIP (Routing Information Protocol) 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">RIP (Routing Information Protocol) 协议</div></div><div class="info-2"><div class="info-item-1">RIP (Routing Information Protocol) 协议的工作原理及特点RIP (Routing Information Protocol) 是一种经典的**距离向量路由协议 (Distance-Vector Routing Protocol)**，用于在内部网关 (Interior Gateway Protocol, IGP) 环境中交换路由信息。它历史悠久，简单易用，但存在一些固有的局限性。  RIP 的工作原理：RIP 的工作原理基于 Bellman-Ford 算法的变体，其核心思想是每个路由器维护一个到所有已知目的地的距离向量，并定期与邻居交换此信息。  里程 (Metric) - 跳数 (Hop Count)：  RIP 使用跳数 (Hop Count) 作为唯一的路由度量（metric）。 每经过一个路由器，跳数就增加 1。 最大跳数限制： RIP 的最大跳数限制为 15 跳。这意味着任何超过 15 跳的目的地都被认为是不可达的（即距离为无穷大）。这是 RIP 最大的局限性之一，使其不适合大型网络。   距离向量的维护：  每个 RIP 路由器维护一...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ARP%E5%8D%8F%E8%AE%AE/" title="ARP协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ARP协议</div></div><div class="info-2"><div class="info-item-1">好的，我们来详细了解一下 ARP 和 RARP。  1. ARP (Address Resolution Protocol) - 地址解析协议作用： 将网络层（IP 地址） 地址解析为数据链路层（MAC 地址） 的协议。 应用场景：当一个主机想与同一局域网内的另一个主机进行通信时，它知道目标主机的 IP 地址，但数据链路层（如以太网）需要目标主机的 MAC 地址来封装帧。此时就需要 ARP 来完成 IP 到 MAC 的映射。 工作原理（简化流程）：  ARP 请求： 主机 A（已知主机 B 的 IP 地址）希望获取主机 B 的 MAC 地址，它会构建一个 ARP 请求报文，其中包含自己的 IP 地址和 MAC 地址，以及目标主机 B 的 IP 地址。 广播： 主机 A 将这个 ARP 请求报文封装在一个以太网帧中，并将目的 MAC 地址设置为广播地址（FFFF.FFFF.FFFF），然后发送到局域网中。 接收与响应： 局域网中的所有主机都会收到这个广播帧。 每个主机都会检查 ARP 请求报文中的目标 IP 地址是否是自己的 IP 地址。 只有目标主机 B 会识别出这个 IP 地址...</div></div></div></a><a class="pagination-related" href="/2025/09/11/RIR%20%E5%8D%8F%E8%AE%AE/" title="RIR 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">RIR 协议</div></div><div class="info-2"><div class="info-item-1">RIP (Routing Information Protocol) 协议的工作原理及特点RIP (Routing Information Protocol) 是一种经典的**距离向量路由协议 (Distance-Vector Routing Protocol)**，用于在内部网关 (Interior Gateway Protocol, IGP) 环境中交换路由信息。它历史悠久，简单易用，但存在一些固有的局限性。  RIP 的工作原理：RIP 的工作原理基于 Bellman-Ford 算法的变体，其核心思想是每个路由器维护一个到所有已知目的地的距离向量，并定期与邻居交换此信息。  里程 (Metric) - 跳数 (Hop Count)：  RIP 使用跳数 (Hop Count) 作为唯一的路由度量（metric）。 每经过一个路由器，跳数就增加 1。 最大跳数限制： RIP 的最大跳数限制为 15 跳。这意味着任何超过 15 跳的目的地都被认为是不可达的（即距离为无穷大）。这是 RIP 最大的局限性之一，使其不适合大型网络。   距离向量的维护：  每个 RIP 路由器维护一...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%9E%84%E6%88%90%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">TCP&#x2F;IP 四层模型的构成：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BA%94%E7%94%A8%E5%B1%82-Application-Layer"><span class="toc-number">2.</span> <span class="toc-text">1. 应用层 (Application Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%A0%E8%BE%93%E5%B1%82-Transport-Layer"><span class="toc-number">3.</span> <span class="toc-text">2. 传输层 (Transport Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BD%91%E7%BB%9C%E5%B1%82-Internet-Layer-%E4%BA%92%E8%81%94%E7%BD%91%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">3. 网络层 (Internet Layer) &#x2F; 互联网层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82-Network-Access-Layer-%E4%B8%BB%E6%9C%BA%E5%88%B0%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text">4. 网络接口层 (Network Access Layer) &#x2F; 主机到网络层 &#x2F; 数据链路层与物理层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-%E6%A8%A1%E5%9E%8B%E4%B8%8E-OSI-%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">TCP&#x2F;IP 模型与 OSI 模型的对比：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8C%E8%A7%A3%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">TCP&#x2F;IP 模型的封装和解封装过程：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>