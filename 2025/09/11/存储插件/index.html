<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>存储插件 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="存储插件前面的章节中我们介绍了在 Kubernetes 中的持久化存储的使用，了解了 PV、PVC 以及 StorageClass 的使用方法，从本地存储到 NFS 共享存储都有学习，到这里我们其实已经可以完成应用各种场景的数据持久化了，但是难免在实际的使用过程中会遇到各种各样的问题，要解决这些问题最好的方式就是来了解下 Kubernetes 中存储的实现原理。 Kubernetes 默认情况下就">
<meta property="og:type" content="article">
<meta property="og:title" content="存储插件">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="存储插件前面的章节中我们介绍了在 Kubernetes 中的持久化存储的使用，了解了 PV、PVC 以及 StorageClass 的使用方法，从本地存储到 NFS 共享存储都有学习，到这里我们其实已经可以完成应用各种场景的数据持久化了，但是难免在实际的使用过程中会遇到各种各样的问题，要解决这些问题最好的方式就是来了解下 Kubernetes 中存储的实现原理。 Kubernetes 默认情况下就">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:10:54.264Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "存储插件",
  "url": "https://huiaz.github.io/2025/09/11/%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:10:54.264Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '存储插件',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">存储插件</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">存储插件</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:10:54.264Z" title="更新于 2025-09-11 22:10:54">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E5%AD%98%E5%82%A8/">存储</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="存储插件"><a href="#存储插件" class="headerlink" title="存储插件"></a>存储插件</h1><p>前面的章节中我们介绍了在 Kubernetes 中的持久化存储的使用，了解了 PV、PVC 以及 StorageClass 的使用方法，从本地存储到 NFS 共享存储都有学习，到这里我们其实已经可以完成应用各种场景的数据持久化了，但是难免在实际的使用过程中会遇到各种各样的问题，要解决这些问题最好的方式就是来了解下 Kubernetes 中存储的实现原理。</p>
<p>Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 <code>kubectl explain pod.spec.volumes</code> 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存储服务接入到 Kubernetes 系统中来，在 Kubernetes 中就对应 <code>In-Tree</code> 和 <code>Out-Of-Tree</code> 两种方式，<code>In-Tree</code> 就是在 Kubernetes 源码内部实现的，和 Kubernetes 一起发布、管理的，但是更新迭代慢、灵活性比较差，<code>Out-Of-Tree</code> 是独立于 Kubernetes 的，目前主要有 <code>CSI</code> 和 <code>FlexVolume</code> 两种机制，开发者可以根据自己的存储类型实现不同的存储插件接入到 Kubernetes 中去，其中 <code>CSI</code> 是现在也是以后主流的方式，所以当然我们的重点也会是 <code>CSI</code> 的使用介绍。</p>
<h2 id="FlexVolume"><a href="#FlexVolume" class="headerlink" title="FlexVolume"></a>FlexVolume</h2><p>FlexVolume 提供了一种扩展 Kubernetes 存储插件的方式，用户可以自定义自己的存储插件。要使用 FlexVolume 需要在每个节点上安装存储插件二进制文件，该二进制需要实现 FlexVolume 的相关接口，默认存储插件的存放路径为 <code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/&lt;vendor~driver&gt;/&lt;driver&gt;</code>，<code>VolumePlugins</code> 组件会不断 watch 这个目录来实现插件的添加、删除等功能。</p>
<p>其中 <code>vendor~driver</code> 的名字需要和 Pod 中<code>flexVolume.driver</code> 的字段名字匹配，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/kubernetes/kubelet-plugins/volume/exec/foo~cifs/cifs</span><br></pre></td></tr></table></figure>



<p>对应的 Pod 中的 <code>flexVolume.driver</code> 属性为：<code>foo/cifs</code>。</p>
<p>在我们实现自定义存储插件的时候，需要实现 FlexVolume 的部分接口，因为要看实际需求，并不一定所有接口都需要实现。比如对于类似于 NFS 这样的存储就没必要实现 <code>attach/detach</code> 这些接口了，因为不需要，只需要实现 <code>init/mount/umount</code> 3 个接口即可。</p>
<ul>
<li>init: <code>&lt;driver executable&gt; init</code> - <code>kubelet/kube-controller-manager</code> 初始化存储插件时调用，插件需要返回是否需要要 attach 和 detach 操作</li>
<li>attach: <code>&lt;driver executable&gt; attach &lt;json options&gt; &lt;node name&gt;</code> - 将存储卷挂载到 Node 节点上</li>
<li>detach: <code>&lt;driver executable&gt; detach &lt;mount device&gt; &lt;node name&gt;</code> - 将存储卷从 Node 上卸载</li>
<li>waitforattach: <code>&lt;driver executable&gt; waitforattach &lt;mount device&gt; &lt;json options&gt;</code> - 等待 attach 操作成功（超时时间为 10 分钟）</li>
<li>isattached: <code>&lt;driver executable&gt; isattached &lt;json options&gt; &lt;node name&gt;</code> - 检查存储卷是否已经挂载</li>
<li>mountdevice: <code>&lt;driver executable&gt; mountdevice &lt;mount dir&gt; &lt;mount device&gt; &lt;json options&gt;</code> - 将设备挂载到指定目录中以便后续 bind mount 使用</li>
<li>unmountdevice: <code>&lt;driver executable&gt; unmountdevice &lt;mount device&gt;</code> - 将设备取消挂载</li>
<li>mount: <code>&lt;driver executable&gt; mount &lt;mount dir&gt; &lt;json options&gt;</code> - 将存储卷挂载到指定目录中</li>
<li>unmount: <code>&lt;driver executable&gt; unmount &lt;mount dir&gt;</code> - 将存储卷取消挂载</li>
</ul>
<p>实现上面的这些接口需要返回如下所示的 JSON 格式的数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;Success/Failure/Not supported&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;Reason for success/failure&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;device&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;Path to the device attached. This field is valid only for attach &amp; waitforattach call-outs&gt;&quot;</span></span><br><span class="line">    <span class="attr">&quot;volumeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;Cluster wide unique name of the volume. Valid only for getvolumename call-out&gt;&quot;</span></span><br><span class="line">    <span class="attr">&quot;attached&quot;</span><span class="punctuation">:</span> &lt;True/False (Return <span class="literal"><span class="keyword">true</span></span> if volume is attached on the node. Valid only for isattached call-out)&gt;</span><br><span class="line">    <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> &lt;Only included as part of the Init response&gt;</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attach&quot;</span><span class="punctuation">:</span> &lt;True/False (Return <span class="literal"><span class="keyword">true</span></span> if the driver implements attach and detach)&gt;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>比如我们来实现一个 NFS 的 FlexVolume 插件，最简单的方式就是写一个脚本，然后实现 init、mount、unmount 3 个命令即可，然后按照上面的 JSON 格式返回数据，最后把这个脚本放在节点的 FlexVolume 插件目录下面即可。</p>
<p>下面就是官方给出的一个 NFS 的 FlexVolume 插件示例，可以从 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/examples/blob/master/staging/volumes/flexvolume/nfs">https://github.com/kubernetes/examples/blob/master/staging/volumes/flexvolume/nfs</a> 获取脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> - 在使用插件之前需要先安装 jq。</span></span><br><span class="line">usage() &#123;</span><br><span class="line">    err &quot;Invalid usage. Usage: &quot;</span><br><span class="line">    err &quot;\t$0 init&quot;</span><br><span class="line">    err &quot;\t$0 mount &lt;mount dir&gt; &lt;json params&gt;&quot;</span><br><span class="line">    err &quot;\t$0 unmount &lt;mount dir&gt;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err() &#123;</span><br><span class="line">    echo -ne $* 1&gt;&amp;2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log() &#123;</span><br><span class="line">    echo -ne $* &gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ismounted() &#123;</span><br><span class="line">    MOUNT=`findmnt -n $&#123;MNTPATH&#125; 2&gt;/dev/null | cut -d&#x27; &#x27; -f1`</span><br><span class="line">    if [ &quot;$&#123;MOUNT&#125;&quot; == &quot;$&#123;MNTPATH&#125;&quot; ]; then</span><br><span class="line">        echo &quot;1&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;0&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">domount() &#123;</span><br><span class="line">    MNTPATH=$1</span><br><span class="line"></span><br><span class="line">    NFS_SERVER=$(echo $2 | jq -r &#x27;.server&#x27;)</span><br><span class="line">    SHARE=$(echo $2 | jq -r &#x27;.share&#x27;)</span><br><span class="line"></span><br><span class="line">    if [ $(ismounted) -eq 1 ] ; then</span><br><span class="line">        log &#x27;&#123;&quot;status&quot;: &quot;Success&quot;&#125;&#x27;</span><br><span class="line">        exit 0</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    mkdir -p $&#123;MNTPATH&#125; &amp;&gt; /dev/null</span><br><span class="line"></span><br><span class="line">    mount -t nfs $&#123;NFS_SERVER&#125;:/$&#123;SHARE&#125; $&#123;MNTPATH&#125; &amp;&gt; /dev/null</span><br><span class="line">    if [ $? -ne 0 ]; then</span><br><span class="line">        err &quot;&#123; \&quot;status\&quot;: \&quot;Failure\&quot;, \&quot;message\&quot;: \&quot;Failed to mount $&#123;NFS_SERVER&#125;:$&#123;SHARE&#125; at $&#123;MNTPATH&#125;\&quot;&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">    log &#x27;&#123;&quot;status&quot;: &quot;Success&quot;&#125;&#x27;</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unmount() &#123;</span><br><span class="line">    MNTPATH=$1</span><br><span class="line">    if [ $(ismounted) -eq 0 ] ; then</span><br><span class="line">        log &#x27;&#123;&quot;status&quot;: &quot;Success&quot;&#125;&#x27;</span><br><span class="line">        exit 0</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    umount $&#123;MNTPATH&#125; &amp;&gt; /dev/null</span><br><span class="line">    if [ $? -ne 0 ]; then</span><br><span class="line">        err &quot;&#123; \&quot;status\&quot;: \&quot;Failed\&quot;, \&quot;message\&quot;: \&quot;Failed to unmount volume at $&#123;MNTPATH&#125;\&quot;&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    log &#x27;&#123;&quot;status&quot;: &quot;Success&quot;&#125;&#x27;</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">op=$1</span><br><span class="line"></span><br><span class="line">if ! command -v jq &gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">    err &quot;&#123; \&quot;status\&quot;: \&quot;Failure\&quot;, \&quot;message\&quot;: \&quot;&#x27;jq&#x27; binary not found. Please install jq package before using this driver\&quot;&#125;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$op&quot; = &quot;init&quot; ]; then</span><br><span class="line">    log &#x27;&#123;&quot;status&quot;: &quot;Success&quot;, &quot;capabilities&quot;: &#123;&quot;attach&quot;: false&#125;&#125;&#x27;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $# -lt 2 ]; then</span><br><span class="line">    usage</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">shift</span><br><span class="line"></span><br><span class="line">case &quot;$op&quot; in</span><br><span class="line">    mount)</span><br><span class="line">        domount $*</span><br><span class="line">        ;;</span><br><span class="line">    unmount)</span><br><span class="line">        unmount $*</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        log &#x27;&#123;&quot;status&quot;: &quot;Not supported&quot;&#125;&#x27;</span><br><span class="line">        exit 0</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 1</span><br></pre></td></tr></table></figure>



<p>将上面脚本命名成 nfs，放置到 node1 节点对应的插件下面： <code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs</code>，并设置权限为 700：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ chmod 700 /usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 jq 工具</span></span><br><span class="line">➜ yum -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line">➜ yum install jq -y</span><br></pre></td></tr></table></figure>



<p>这个时候我们部署一个应用到 node1 节点上，并用 <code>flexVolume</code> 来持久化容器中的数据（当然也可以通过定义 flexvolume 类型的 PV、PVC 来使用），如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test-flexvolume.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-flexvolume</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="string">node1</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">flexVolume:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">&#x27;ydzs/nfs&#x27;</span> <span class="comment"># 定义插件类型，根据这个参数在对应的目录下面找到插件的可执行文件</span></span><br><span class="line">        <span class="attr">fsType:</span> <span class="string">&#x27;nfs&#x27;</span> <span class="comment"># 定义存储卷文件系统类型</span></span><br><span class="line">        <span class="attr">options:</span> <span class="comment"># 定义所有与存储相关的一些具体参数</span></span><br><span class="line">          <span class="attr">server:</span> <span class="string">&#x27;192.168.31.31&#x27;</span></span><br><span class="line">          <span class="attr">share:</span> <span class="string">&#x27;var/lib/k8s/data/&#x27;</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">testflexvolume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br></pre></td></tr></table></figure>



<p>其中 <code>flexVolume.driver</code> 就是插件目录 <code>ydzs~nfs</code> 对应的 <code>ydzs/nfs</code> 名称，<code>flexVolume.options</code> 中根据上面的 nfs 脚本可以得知里面配置的是 NFS 的 Server 地址和挂载目录路径，直接创建上面的资源对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl apply -f test-flexvolume.yaml</span><br><span class="line">➜ kubectl get pods</span><br><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">test-flexvolume                           1/1     Running   0          13h</span><br><span class="line">......</span><br><span class="line">➜ kubectl exec -it test-flexvolume mount |grep test</span><br><span class="line">192.168.31.31:/var/lib/k8s/data/testflexvolume on /usr/share/nginx/html type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.31.108,local_lock=none,addr=192.168.31.31)</span><br><span class="line">➜ mount |grep test # node1节点上执行</span><br><span class="line">192.168.31.31:/var/lib/k8s/data on /var/lib/kubelet/pods/d1b108d8-2640-4f2b-a08c-14392e163b97/volumes/ydzs~nfs/test type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.31.108,local_lock=none,addr=192.168.31.31)</span><br><span class="line">192.168.31.31:/var/lib/k8s/data/testflexvolume on /var/lib/kubelet/pods/d1b108d8-2640-4f2b-a08c-14392e163b97/volume-subpaths/test/web/0 type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.31.108,local_lock=none,addr=192.168.31.31)</span><br></pre></td></tr></table></figure>



<p>同样我们可以查看到 Pod 的本地持久化目录是被 mount 到了 NFS 上面，证明上面我们的 FlexVolume 插件是正常的。</p>
<p>!!! info “调用”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们要去真正的 mount NFS 的时候，就是通过 kubelet 调用 `VolumePlugin`，然后直接执行命令`/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs mount &lt;mount dir&gt; &lt;json param&gt;` 来完成的，就相当于平时我们在宿主机上面手动挂载 NFS 的方式一样的，所以存储插件 nfs 是一个可执行的二进制文件或者 shell 脚本都是可以的。</span><br></pre></td></tr></table></figure>



<h2 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h2><p>既然已经有了 <code>FlexVolume</code> 插件了，为什么还需要 <code>CSI</code> 插件呢？上面我们使用 FlexVolume 插件的时候可以看出 FlexVolume 插件实际上相当于就是一个普通的 shell 命令，类似于平时我们在 Linux 下面执行的 <code>ls</code> 命令一样，只是返回的信息是 JSON 格式的数据，并不是我们通常认为的一个常驻内存的进程，而 CSI 是一个更加完善、编码更加方便友好的一种存储插件扩展方式。</p>
<p><a target="_blank" rel="noopener" href="https://kubernetes-csi.github.io/docs/">CSI</a> 是 <code>Container Storage Interface</code> 的简称，旨在能为容器编排引擎和存储系统间建立一套标准的存储调用接口，通过该接口能为容器编排引擎提供存储服务。在 CSI 之前，K8S 里提供存储服务基本上是通过 <code>in-tree</code> 的方式来提供，如下图：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/bwszp4.png" alt="without csi"></p>
<p>这种方式需要将存储提供者的代码逻辑放到 K8S 的代码库中运行，调用引擎与插件间属于强耦合，这种方式会带来一些问题：</p>
<ul>
<li>存储插件需要一同随 K8S 发布</li>
<li>K8S 社区需要对存储插件的测试、维护负责</li>
<li>存储插件的问题有可能会影响 K8S 部件正常运行</li>
<li>存储插件享有 K8S 部件同等的特权存在安全隐患</li>
<li>存储插件开发者必须遵循 K8S 社区的规则开发代码</li>
</ul>
<p>基于这些问题和挑战，CO（Container Orchestrator） 厂商提出 Container Storage Interface 用来定义容器存储标准，它独立于 Kubernetes Storage SIG，由 Kubernetes、Mesos、Cloud Foundry 三家一起推动。CSI 规范定义了存储提供商实现 CSI 兼容插件的最小操作集合和部署建议，CSI 规范的主要焦点是声明插件必须实现的接口。</p>
<p>在 Kubernetes 上整合 CSI 插件的整体架构如下图所示：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/q1am9u.png" alt="kubernetes csi structrue"></p>
<p>Kubernetes CSI 存储体系主要由两部分组成：</p>
<ul>
<li><p>Kubernetes 外部组件：包含 <code>Driver registrar</code>、<code>External provisioner</code>、<code>External attacher</code> 三部分，这三个组件是从 Kubernetes 原本的 in-tree 存储体系中剥离出来的存储管理功能，实际上是 Kubernetes 中的一种外部 controller，它们 watch kubernetes 的 API 资源对象，根据 watch 到的状态来调用下面提到的第二部分的 CSI 插件来实现存储的管理和操作。这部分是 Kubernetes 团队维护的，插件开发者完全不必关心其实现细节。</p>
<ul>
<li><code>Driver registra</code>：一个 Sidecar 容器，向 Kubernetes 注册 CSI Driver，添加 Drivers 的一些信息</li>
<li><code>External provisioner</code>：也是一个 Sidecar 容器，watch Kubernetes 的 PVC 对象，调用对应 CSI 的 Volum e 创建、删除等操作</li>
<li><code>External attacher</code>：一个 Sidecar 容器，watch Kubernetes 系统里的 <code>VolumeAttachment</code> 对象，调用对应 CSI 的 ControllerPublish 和 ControllerUnpublish 操作来完成对应的 Volume 的 Attach&#x2F;Detach。而 Volume 的 Mount&#x2F;Unmount 阶段并不属于外部组件，当真正需要执行 Mount 操作的时候，kubelet 会去直接调用下面的 CSI Node 服务来完成 Volume 的 Mount&#x2F;UnMount 操作。</li>
</ul>
</li>
<li><p>CSI 存储插件: 这部分正是开发者需要实现的 CSI 插件部分，都是通过 gRPC 实现的服务，一般会用一个二进制文件对外提供服务，主要包含三部分：<code>CSI Identity</code>、<code>CSI Controller</code>、<code>CSI Node</code>。</p>
<ul>
<li><p><code>CSI Identity</code> — 主要用于负责对外暴露这个插件本身的信息，确保插件的健康状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service Identity &#123;</span><br><span class="line">    <span class="comment">// 返回插件的名称和版本</span></span><br><span class="line">    rpc GetPluginInfo(GetPluginInfoRequest)</span><br><span class="line">        returns (GetPluginInfoResponse) &#123;&#125;</span><br><span class="line">    <span class="comment">// 返回这个插件的包含的功能，比如非块存储类型的 CSI 插件不需要实现 Attach 功能，GetPluginCapabilities 就可以在返回中标注这个 CSI 插件不包含 Attach 功能</span></span><br><span class="line">    rpc GetPluginCapabilities(GetPluginCapabilitiesRequest)</span><br><span class="line">        returns (GetPluginCapabilitiesResponse) &#123;&#125;</span><br><span class="line">    <span class="comment">// 插件插件是否正在运行</span></span><br><span class="line">    rpc Probe (ProbeRequest)</span><br><span class="line">        returns (ProbeResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>CSI Controller</code> - 主要实现 Volume 管理流程当中的 Provision 和 Attach 阶段，Provision 阶段是指创建和删除 Volume 的流程，而 Attach 阶段是指把存储卷附着在某个节点或脱离某个节点的流程，另外只有块存储类型的 CSI 插件才需要 Attach 功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">service Controller &#123;</span><br><span class="line">    <span class="comment">// 创建存储卷，包括云端存储介质以及PV对象</span></span><br><span class="line">    rpc CreateVolume (CreateVolumeRequest)</span><br><span class="line">        returns (CreateVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  删除存储卷</span></span><br><span class="line">    rpc DeleteVolume (DeleteVolumeRequest)</span><br><span class="line">        returns (DeleteVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载存储卷，将存储介质挂载到目标节点</span></span><br><span class="line">    rpc ControllerPublishVolume (ControllerPublishVolumeRequest)</span><br><span class="line">        returns (ControllerPublishVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载存储卷</span></span><br><span class="line">    rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)</span><br><span class="line">        returns (ControllerUnpublishVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例如：是否可以同时用于多个节点的读/写</span></span><br><span class="line">    rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)</span><br><span class="line">        returns (ValidateVolumeCapabilitiesResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回所有可用的 volumes</span></span><br><span class="line">    rpc ListVolumes (ListVolumesRequest)</span><br><span class="line">        returns (ListVolumesResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可用存储池的总容量</span></span><br><span class="line">    rpc GetCapacity (GetCapacityRequest)</span><br><span class="line">        returns (GetCapacityResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例如. 插件可能未实现 GetCapacity、Snapshotting</span></span><br><span class="line">    rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest)</span><br><span class="line">        returns (ControllerGetCapabilitiesResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建快照</span></span><br><span class="line">    rpc CreateSnapshot (CreateSnapshotRequest)</span><br><span class="line">        returns (CreateSnapshotResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定的快照</span></span><br><span class="line">    rpc DeleteSnapshot (DeleteSnapshotRequest)</span><br><span class="line">        returns (DeleteSnapshotResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有的快照</span></span><br><span class="line">    rpc ListSnapshots (ListSnapshotsRequest)</span><br><span class="line">        returns (ListSnapshotsResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>CSI Node</code> — 负责控制 Kubernetes 节点上的 Volume 的相关功能。其中 Volume 的挂载被分成了 NodeStageVolume 和 NodePublishVolume 两个阶段。NodeStageVolume 接口主要是针对块存储类型的 CSI 插件而提供的，块设备在 “Attach” 阶段被附着在 Node 上后，需要挂载至 Pod 对应目录上，但因为块设备在 linux 上只能 mount 一次，而在 kubernetes volume 的使用场景中，一个 volume 可能被挂载进同一个 Node 上的多个 Pod 实例中，所以这里提供了 NodeStageVolume 这个接口，使用这个接口把块设备格式化后先挂载至 Node 上的一个临时全局目录，然后再调用 NodePublishVolume 使用 linux 中的 <code>bind mount</code> 技术把这个全局目录挂载进 Pod 中对应的目录上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">service Node &#123;</span><br><span class="line">    <span class="comment">// 在节点上初始化存储卷（格式化），并执行挂载到Global目录</span></span><br><span class="line">    rpc NodeStageVolume (NodeStageVolumeRequest)</span><br><span class="line">        returns (NodeStageVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// umount 存储卷在节点上的 Global 目录</span></span><br><span class="line">    rpc NodeUnstageVolume (NodeUnstageVolumeRequest)</span><br><span class="line">        returns (NodeUnstageVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在节点上将存储卷的 Global 目录挂载到 Pod 的实际挂载目录</span></span><br><span class="line">    rpc NodePublishVolume (NodePublishVolumeRequest)</span><br><span class="line">        returns (NodePublishVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unmount 存储卷在节点上的 Pod 挂载目录</span></span><br><span class="line">    rpc NodeUnpublishVolume (NodeUnpublishVolumeRequest)</span><br><span class="line">        returns (NodeUnpublishVolumeResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取节点上Volume挂载文件系统统计信息（总空间、可用空间等）</span></span><br><span class="line">    rpc NodeGetVolumeStats (NodeGetVolumeStatsRequest)</span><br><span class="line">        returns (NodeGetVolumeStatsResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取节点的唯一 ID</span></span><br><span class="line">    rpc NodeGetId (NodeGetIdRequest)</span><br><span class="line">        returns (NodeGetIdResponse) &#123;</span><br><span class="line">        option deprecated = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回节点插件的能力</span></span><br><span class="line">    rpc NodeGetCapabilities (NodeGetCapabilitiesRequest)</span><br><span class="line">        returns (NodeGetCapabilitiesResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取节点的一些信息</span></span><br><span class="line">    rpc NodeGetInfo (NodeGetInfoRequest)</span><br><span class="line">        returns (NodeGetInfoResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>只需要实现上面的接口就可以实现一个 CSI 插件了。虽然 Kubernetes 并未规定 CSI 插件的打包安装，但是提供了以下建议来简化我们在 Kubernetes 上容器化 CSI Volume 驱动程序的部署方案，具体的方案介绍可以查看 CSI 规范介绍文档 <a target="_blank" rel="noopener" href="https://github.com/container-storage-interface/spec/blob/master/spec.md">https://github.com/container-storage-interface/spec/blob/master/spec.md</a></p>
<p><img src="https://mudutestmenu.mudu.tv/upload/1oaqhg.png" alt="container storage interface deploy"></p>
<p>按照上图的推荐方案，<code>CSI Controller</code> 负责 Volumes 的创建删除等操作，整个集群只需要部署一个，以 StatefulSet 或者 Deployment 方式部署均可，<code>CSI Node</code> 部分负责 Volumes 的 attach、detach 等操作，需要在每个节点部署一个，所以用 DaemonSet 方式部署，因为这两部分实现在同一个 CSI 插件程序中，因此只需要把这个 CSI 插件与 <code>External Components</code> 以容器方式部署在同一个 Pod 中，把这个 CSI 插件与 <code>Driver registrar</code> 以容器方式部署在 DaemonSet 的 Pod 中，即可完成 CSI 的部署。</p>
<p>比如在训练营第一期中我们使用的 Rook 部署的 Ceph 集群就实现了 CSI 插件的:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pods -n rook-ceph |grep plugin</span><br><span class="line">csi-cephfsplugin-2s9d5                                 3/3     Running     0          21d</span><br><span class="line">csi-cephfsplugin-fgp4v                                 3/3     Running     0          17d</span><br><span class="line">csi-cephfsplugin-fv5nx                                 3/3     Running     0          21d</span><br><span class="line">csi-cephfsplugin-mn8q4                                 3/3     Running     0          17d</span><br><span class="line">csi-cephfsplugin-nf6h8                                 3/3     Running     0          21d</span><br><span class="line">csi-cephfsplugin-provisioner-56c8b7ddf4-68h6d          4/4     Running     0          21d</span><br><span class="line">csi-cephfsplugin-provisioner-56c8b7ddf4-rq4t6          4/4     Running     0          21d</span><br><span class="line">csi-cephfsplugin-xwnl4                                 3/3     Running     0          21d</span><br><span class="line">csi-rbdplugin-7r88w                                    3/3     Running     0          21d</span><br><span class="line">csi-rbdplugin-95g5j                                    3/3     Running     0          21d</span><br><span class="line">csi-rbdplugin-bnzpr                                    3/3     Running     0          21d</span><br><span class="line">csi-rbdplugin-dvftb                                    3/3     Running     0          21d</span><br><span class="line">csi-rbdplugin-jzmj2                                    3/3     Running     0          17d</span><br><span class="line">csi-rbdplugin-provisioner-6ff4dd4b94-bvtss             5/5     Running     0          21d</span><br><span class="line">csi-rbdplugin-provisioner-6ff4dd4b94-lfn68             5/5     Running     0          21d</span><br><span class="line">csi-rbdplugin-trxb4                                    3/3     Running     0          17d</span><br></pre></td></tr></table></figure>



<p>这里其实是实现了 RBD 和 CephFS 两种 CSI，用 DaemonSet 在每个节点上运行了一个包含 <code>Driver registra</code> 容器的 Pod，当然和节点相关的操作比如 Mount&#x2F;Unmount 也是在这个 Pod 里面执行的，其他的比如 Provision、Attach 都是在另外的 <code>csi-rbdplugin-provisioner-xxx</code> Pod 中执行的。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在我们来测试通过 CSI 的形式使用 NFS 存储，当然首先我们需要在 Kubernetes 集群中安装 NFS CSI 的驱动，<a target="_blank" rel="noopener" href="https://github.com/kubernetes-csi/csi-driver-nfs">https://github.com/kubernetes-csi/csi-driver-nfs</a> 就是一个 NFS 的 CSI 驱动实现的项目。</p>
<p>如果能访问 github 则可以直接使用下面的命令一键安装 NFS CSI 驱动程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ curl -skSL https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/deploy/install-driver.sh | bash -s master --</span><br></pre></td></tr></table></figure>



<p>也可以本地安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ git clone https://github.com/kubernetes-csi/csi-driver-nfs.git</span><br><span class="line">➜ cd csi-driver-nfs</span><br><span class="line">➜ ./deploy/install-driver.sh master local</span><br></pre></td></tr></table></figure>



<p>和上面介绍的部署方式基本上也是一致的，首先会用 DaemonSet 的形式在每个节点上运行了一个包含 <code>Driver registra</code> 容器的 Pod，当然和节点相关的操作比如 Mount&#x2F;Unmount 也是在这个 Pod 里面执行的，其他的比如 Provision、Attach 都是在另外的 <code>csi-nfs-controller-xxx</code> Pod 中执行的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl -n kube-system get pod -o wide -l app=csi-nfs-controller</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE     IP               NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">csi-nfs-controller-bd6dbb598-fx4hj   3/3     Running   0          6m20s   192.168.31.108   node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">➜ kubectl -n kube-system get pod -o wide -l app=csi-nfs-node</span><br><span class="line">NAME                 READY   STATUS    RESTARTS   AGE     IP               NODE      NOMINATED NODE   READINESS GATES</span><br><span class="line">csi-nfs-node-bx5rc   3/3     Running   0          6m13s   192.168.31.108   node1     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">csi-nfs-node-llwqz   3/3     Running   0          6m20s   192.168.31.46    node2     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">csi-nfs-node-rkcpm   3/3     Running   0          6m15s   192.168.31.31    master1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>



<p>当 csi 的驱动安装完成后我们就可以通过 csi 的方式来使用我们的 nfs 存储了。</p>
<p>比如我们创建</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv-nfs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">mountOptions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hard</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nfsvers=4.1</span></span><br><span class="line">  <span class="attr">csi:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">nfs.csi.k8s.io</span></span><br><span class="line">    <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">volumeHandle:</span> <span class="string">unique-volumeid</span> <span class="comment"># make sure it&#x27;s a unique id in the cluster</span></span><br><span class="line">    <span class="attr">volumeAttributes:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.31</span></span><br><span class="line">      <span class="attr">share:</span> <span class="string">/var/lib/k8s/data</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc-nfs-static</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">pv-nfs</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<p>直接创建上面的资源对象后我们的 PV 和 PVC 就绑定在一起了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get pv pv-nfs</span><br><span class="line">NAME     CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                    STORAGECLASS   REASON   AGE</span><br><span class="line">pv-nfs   10Gi       RWX            Retain           Bound    default/pvc-nfs-static                           15s</span><br><span class="line">➜ kubectl get pvc pvc-nfs-static</span><br><span class="line">NAME             STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc-nfs-static   Bound    pv-nfs   10Gi       RWX                           30s</span><br></pre></td></tr></table></figure>



<p>这里的核心配置是 PV 中的 <code>csi</code> 属性的配置，需要通过 <code>csi.driver</code> 来指定我们要使用的驱动名称，比如我们这里使用 nfs 的名称为 <code>nfs.csi.k8s.io</code>，然后就是根据具体的驱动配置相关的参数。</p>
<p>同样还可以创建一个用于动态创建 PV 的 StorageClass 对象：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-csi</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">nfs.csi.k8s.io</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.31</span></span><br><span class="line">  <span class="attr">share:</span> <span class="string">/var/lib/k8s/data</span></span><br><span class="line">  <span class="comment"># csi.storage.k8s.io/provisioner-secret is only needed for providing mountOptions in DeleteVolume</span></span><br><span class="line">  <span class="comment"># csi.storage.k8s.io/provisioner-secret-name: &quot;mount-options&quot;</span></span><br><span class="line">  <span class="comment"># csi.storage.k8s.io/provisioner-secret-namespace: &quot;default&quot;</span></span><br><span class="line"><span class="attr">reclaimPolicy:</span> <span class="string">Delete</span></span><br><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">Immediate</span></span><br><span class="line"><span class="attr">mountOptions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hard</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nfsvers=4.1</span></span><br></pre></td></tr></table></figure>



<p>对于我们普通用户来说使用起来都是一样的，只需要管理员提供何时的 PV 或 StorageClass 即可，这里我们就使用的 CSI 的形式来提供 NFS 的存储。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6/">https://huiaz.github.io/2025/09/11/%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5/" title="处理阶段"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">处理阶段</div></div><div class="info-2"><div class="info-item-1">Nginx 处理 HTTP 请求的核心模型Nginx 采用事件驱动（Event-Driven）、异步非阻塞（Asynchronous Non-Blocking I&#x2F;O）的架构。这意味着 Nginx 不会为每个新连接创建一个新的进程或线程。相反，它使用少量的工作进程 (worker processes) 通过事件循环（event loop）来监听和处理大量的并发连接。 当一个客户端连接接入时，Nginx 并不会立即为它分配一个长时间运行的资源。相反，它注册一个事件（例如“有数据可读”），然后回去处理其他连接。当那个事件发生时，Nginx 才回来处理相应的数据。这种模型使得 Nginx 在高并发场景下表现出色，内存消耗低，CPU 利用率高。 Nginx 请求处理过程包含的阶段Nginx 的请求处理是一个多阶段的管道（pipeline）过程。当一个请求到达 Nginx 后，它会依次经过一系列内部定义好的处理阶段。这些阶段允许 Nginx 在不同时间点执行不同的模块和指令。理解这些阶段有助于我们知道何时何地的配置指令会生效。 以下是 Nginx 请求处理的主要阶段（大致顺序）：...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%AE%89%E8%A3%85%20prometheus/" title="安装 prometheus"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">安装 prometheus</div></div><div class="info-2"><div class="info-item-1">在 Kubernetes 上部署 Prometheus前面我们已经了解了 Prometheus 的基本使用方式，主要是使用的二进制方式进行部署的，在实际生产环境来说，Prometheus 更适合用来部署在 Kubernetes 集群中，本节我们将介绍如何用手动方式在 Kubernetes 集群上部署 Prometheus，关于 Kubernetes 本身的使用可以参考我们的另外课程《Kubernetes 进阶训练营》。 安装由于我们这里是要运行在 Kubernetes 系统中，所以我们直接用 Docker 镜像的方式运行。这里我们使用的实验环境是基于 Kubernetes v1.22 版本，一共 3 个节点： 12345☸ ➜ kubectl get nodesNAME      STATUS   ROLES                  AGE   VERSIONmaster1   Ready    control-plane,master   49d   v1.22.2node1     Ready    &lt;none&gt;                 49d ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Ingress/" title="Ingress"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Ingress</div></div><div class="info-2"><div class="info-item-1">Ingress前面我们学习了在 Kubernetes 集群内部使用 kube-dns 实现服务发现的功能，那么我们部署在 Kubernetes 集群中的应用如何暴露给外部的用户使用呢？我们知道可以使用 NodePort 和 LoadBlancer 类型的 Service 可以把应用暴露给外部用户使用，除此之外，Kubernetes 还为我们提供了一个非常重要的资源对象可以用来暴露服务给外部用户，那就是 Ingress。对于小规模的应用我们使用 NodePort 或许能够满足我们的需求，但是当你的应用越来越多的时候，你就会发现对于 NodePort 的管理就非常麻烦了，这个时候使用 Ingress 就非常方便了，可以避免管理大量的端口。 资源对象Ingress 资源对象是 Kubernetes 内置定义的一个对象，是从 Kuberenets 集群外部访问集群的一个入口，将外部的请求转发到集群内不同的 Service 上，其实就相当于 nginx、haproxy 等负载均衡代理服务器，可能你会觉得我们直接使用 nginx 就实现了，但是只使用 nginx 这种方式有很大缺陷，每次有新...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Consule%20%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" title="Consule 服务发现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Consule 服务发现</div></div><div class="info-2"><div class="info-item-1">基于 Consul 的服务发现Consul 是由 HashiCorp 开发的一个支持多数据中心的分布式服务发现和键值对存储服务的开源软件，是一个通用的服务发现和注册中心工具，被大量应用于基于微服务的软件架构当中。 接下来我们就来尝试使用 Prometheus 基于 Consul 的服务发现来监控前面的 3 个 demo 服务： 123192.168.31.46:10000192.168.31.46:10001192.168.31.46:10002  我们将 demo 服务注册到 Consul，然后配置 Prometheus 从 Consul 中发现演示服务实例，并使用 Relabeling 操作来过滤调整目标标签。关于 Consul 本身的使用可以查看官方文档 https://learn.hashicorp.com/consul 了解更多。  安装配置 Consul在页面 https://www.consul.io/downloads 下载符合自己系统的安装文件，比如我们这里是 Linux 系统，使用下面命令下载安装即可： 12345678☸ ➜ wget https://rel...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%9C%A8%20Kubernetes%20%E4%B8%8A%E9%83%A8%E7%BD%B2%20LLM%20%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/" title="在 Kubernetes 上部署 LLM 大语言模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">在 Kubernetes 上部署 LLM 大语言模型</div></div><div class="info-2"><div class="info-item-1">在 Kubernetes 上部署 LLM 大语言模型从今年开始，人们对大型语言模型 (LLM) 及其在 GPU 基础设施上的部署的兴趣显着增加。这种不断增长的热情是由人工智能和机器学习的进步推动的，这需要 GPU 能够有效提供大量的计算能力。GPU 领先制造商 Nvidia 的股价也因这一趋势而飙升。同样诞生了大量的大模型，对于这些模型的部署和管理也变得越来越重要，在这方面 Ollama 和 OpenUI 是一个不错的选择。 Ollama 是一个开源的机器学习模型部署工具，它可以帮助您将模型部署到生产环境中，简化大型语言模型 (LLM) 的管理和交互。Ollama 拥有各种一流的开源模型，例如 Llama 3、Phi 3、Mistral 等等，我们可以将 Ollama 看成是 Docker，但是专注于机器学习模型。  使用 Ollama 部署模型非常简单，就类似于使用 Docker 部署应用程序一样。但是，如果你对 CLI 不熟悉，那么使用 Ollama 会有点痛苦。为了解决这个问题，我们可以使用一个 open-webui 的项目，它提供了一个漂亮的界面，可以让您更轻松地部署模型...</div></div></div></a><a class="pagination-related" href="/2025/09/11/CRD/" title="CRD"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">CRD</div></div><div class="info-2"><div class="info-item-1">CRDCustom Resource Define 简称 CRD，是 Kubernetes（v1.7+）为提高可扩展性，让开发者去自定义资源的一种方式。CRD 资源可以动态注册到集群中，注册完毕后，用户可以通过 kubectl 来创建访问这个自定义的资源对象，类似于操作 Pod 一样。不过需要注意的是 CRD 仅仅是资源的定义而已，需要一个 Controller 去监听 CRD 的各种事件来添加自定义的业务逻辑。 定义如果说只是对 CRD 资源本身进行 CRUD 操作的话，不需要 Controller 也是可以实现的，相当于就是只有数据存入了 etcd 中，而没有对这个数据的相关操作而已。比如我们可以定义一个如下所示的 CRD 资源清单文件： 12345678910111213141516171819202122232425262728293031323334353637383940# crd-demo.yamlapiVersion: apiextensions.k8s.io/v1kind: CustomResourceDefinitionmetadata:  # name 必须...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Pod%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="Pod 生命周期"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Pod 生命周期</div></div><div class="info-2"><div class="info-item-1">Pod 生命周期 前面我们已经了解了 Pod 的设计原理，接下来我们来了解下 Pod 的生命周期。下图展示了一个 Pod 的完整生命周期过程，其中包含 Init Container、Pod Hook、健康检查 三个主要部分，接下来我们就来分别介绍影响 Pod 生命周期的部分： 首先在介绍 Pod 的生命周期之前，我们先了解下 Pod 的状态，因为 Pod 状态可以反应出当前我们的 Pod 的具体状态信息，也是我们分析排错的一个必备的方式。 Pod 状态首先先了解下 Pod 的状态值，我们可以通过 kubectl explain pod.status 命令来了解关于 Pod 状态的一些信息，Pod 的状态定义在 PodStatus 对象中，其中有一个 phase 字段，下面是 phase 的可能取值：  挂起（Pending）：Pod 信息已经提交给了集群，但是还没有被调度器调度到合适的节点或者 Pod 里的镜像正在下载 运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态 成功（Succee...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Thanos%20Compactor/" title="Thanos Compactor"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Thanos Compactor</div></div><div class="info-2"><div class="info-item-1">Compactor 组件现在历史监控数据已经上传到对象存储中去了，但是由于监控数据量非常庞大，所以一般情况下我们会去安装一个 Thanos 的 Compactor 组件，用来将对象存储中的数据进行压缩。Compactor 组件只与对象存储交互，是唯一拥有删除对象存储数据权限的组件，主要有两个作用：压缩 block（将多个 block 合并成一个）、降采样（可禁用，5m&#x2F;1h 采样数据）。可设置数据保留时长，原始数据、5m&#x2F;1h 降采样数据可分别设置保留时长。 下采样Compactor 用于定时对远端对象存储中的历史数据块进行下采样，Compactor 会将小的存储块合并为大的存储块，提升在做大时间跨度查询时的速度。 下采样有三个主要的配置参数：  --retention.resolution-raw（单位：d，默认 0d） --retention.resolution-5m（单位：d，默认 0d） --retention.resolution-1h（单位：d，默认 0d）  当开启 raw 之后，原有的历史数据会以该项所配置的时间长度保留于远端对象存储中，超过...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">存储插件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FlexVolume"><span class="toc-number">1.1.</span> <span class="toc-text">FlexVolume</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSI"><span class="toc-number">1.2.</span> <span class="toc-text">CSI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.</span> <span class="toc-text">测试</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>