<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>新一代云原生存储系统 CubeFS | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="新一代云原生存储系统 CubeFSCubeFS是一种新一代云原生存储系统，支持 S3、HDFS 和 POSIX 等访问协议，支持多副本与纠删码两种存储引擎，为用户提供多租户、 多 AZ 部署以及跨区域复制等多种特性。  CubeFS 作为一个云原生的分布式存储平台，提供了多种访问协议，因此其应用场景也非常广泛，下面简单介绍几种比较典型的应用场景  大数据分析：兼容 HDFS 协议，为 Hadoop">
<meta property="og:type" content="article">
<meta property="og:title" content="新一代云原生存储系统 CubeFS">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/%E6%96%B0%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%20CubeFS/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="新一代云原生存储系统 CubeFSCubeFS是一种新一代云原生存储系统，支持 S3、HDFS 和 POSIX 等访问协议，支持多副本与纠删码两种存储引擎，为用户提供多租户、 多 AZ 部署以及跨区域复制等多种特性。  CubeFS 作为一个云原生的分布式存储平台，提供了多种访问协议，因此其应用场景也非常广泛，下面简单介绍几种比较典型的应用场景  大数据分析：兼容 HDFS 协议，为 Hadoop">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:18:53.975Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "新一代云原生存储系统 CubeFS",
  "url": "https://huiaz.github.io/2025/09/11/%E6%96%B0%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%20CubeFS/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:18:53.975Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/%E6%96%B0%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%20CubeFS/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '新一代云原生存储系统 CubeFS',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">新一代云原生存储系统 CubeFS</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">新一代云原生存储系统 CubeFS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:18:53.975Z" title="更新于 2025-09-11 22:18:53">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/">集群管理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="新一代云原生存储系统-CubeFS"><a href="#新一代云原生存储系统-CubeFS" class="headerlink" title="新一代云原生存储系统 CubeFS"></a>新一代云原生存储系统 CubeFS</h1><p><a target="_blank" rel="noopener" href="https://cubefs.io/zh/">CubeFS</a>是一种新一代云原生存储系统，支持 S3、HDFS 和 POSIX 等访问协议，支持多副本与纠删码两种存储引擎，为用户提供多租户、 多 AZ 部署以及跨区域复制等多种特性。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/44u60m.png" alt="CubeFS"></p>
<p>CubeFS 作为一个云原生的分布式存储平台，提供了多种访问协议，因此其应用场景也非常广泛，下面简单介绍几种比较典型的应用场景</p>
<ul>
<li>大数据分析：兼容 HDFS 协议，为 Hadoop 生态（如 Spark、Hive）提供统一存储底座，为计算引擎提供无限的存储空间以及大带宽的数据存储能力。</li>
<li>深度训练&#x2F;机器学习：作为分布式并行文件系统，支撑 AI 训练、模型存储及分发、IO 加速等需求。</li>
<li>容器共享存储：容器集群可以将容器镜像的配置文件或初始化加载数据存储在 CubeFS 上，在容器批量加载时实时读取。多 Pod 间通过 CubeFS 共享持久化数据，在 Pod 故障时可以进行快速故障切换。</li>
<li>数据库&amp;中间件：为数据库应用如 MySQL、ElasticSearch、ClickHouse 提供高并发、低时延云盘服务，实现彻底的存算分离。</li>
<li>在线服务：为在线业务(如广告、点击流、搜索)或终端用户的图、文、音视频等内容提供高可靠、低成本的对象存储服务。</li>
<li>传统 NAS 上云：替换线下传统本地存储及 NAS，助力 IT 业务上云。</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><code>CubeFS</code> 具有众多特性，包括：</p>
<p><strong>多协议</strong></p>
<p>兼容 S3、POSIX、HDFS 等多种访问协议，协议间访问可互通</p>
<ul>
<li>POSIX 兼容：兼容 POSIX 接口，让上层应用的开发变得极其简单，就跟使用本地文件系统一样便捷。此外，CubeFS 在实现时放松了对 POSIX 语义的一致性要求来兼顾文件和元文件操作的性能。</li>
<li>对象存储兼容：兼容 AWS 的 S3 对象存储协议，用户可以使用原生的 Amazon S3 SDK 管理 CubeFS 中的资源。</li>
<li>Hadoop 协议兼容：兼容 Hadoop FileSystem 接口协议，用户可以使用 CubeFS 来替换 HDFS，做到上层业务无感。</li>
</ul>
<p><strong>双引擎</strong></p>
<p>支持多副本及纠删码两种引擎，用户可以根据业务场景灵活选择</p>
<ul>
<li>多副本存储引擎：副本之间的数据为镜像关系，通过强一致的复制协议来保证副本之间的数据一致性，用户可以根据应用场景灵活的配置不同副本数。</li>
<li>纠删码存储引擎：纠删码引擎具备高可靠、高可用、低成本、支持超大规模(EB)的特性，根据不同 AZ 模型可以灵活选择纠删码模式。</li>
</ul>
<p><strong>多租户</strong></p>
<p>支持多租户管理，提供细粒度的租户隔离策略</p>
<p><strong>可扩展</strong></p>
<p>可以轻松构建 PB 或者 EB 级规模的分布式存储服务，各模块可水平扩展</p>
<p><strong>高性能</strong></p>
<p>支持多级缓存，针对小文件特定优化，支持多种高性能的复制协议</p>
<ul>
<li>元数据管理：元数据集群为内存元数据存储，在设计上使用两个 B-Tree（inodeBTree 与 dentryBTree）来管理索引，进而提升元数据访问性能；</li>
<li>强一致副本协议 ：CubeFS 根据文件写入方式的不同采用不同的复制协议来保证副本间的数据一致性。（如果文件按照顺序写入，则会使用主备复制协议来优化 IO 吞吐量；如果是随机写入覆盖现有文件内容时，则是采用一种基于 Multi-Raft 的复制协议，来确保数据的强一致性）；</li>
<li>多级缓存：纠删码卷支持多级缓存加速能力，针对热点数据，提供更高数据访问性能：</li>
<li>本地缓存：可以在 Client 机器上同机部署 BlockCache 组件，将本地磁盘作为本地缓存. 可以不经过网络直接读取本地 Cache, 但容量受本地磁盘限制；</li>
<li>全局缓存：使用副本组件 DataNode 搭建的分布式全局 Cache, 比如可以通过部署客户端同机房的 SSD 磁盘的 DataNode 作为全局 cache, 相对于本地 cache, 需要经过网络, 但是容量更大, 可动态扩缩容,副本数可调。</li>
</ul>
<p><img src="https://mudutestmenu.mudu.tv/upload/gi2c8s.png" alt="img"></p>
<p><strong>云原生</strong></p>
<p>基于 CSI 插件可以快速地在 Kubernetes 上使用 CubeFS。</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>整体上 CubeFS 由元数据子系统（Metadata Subsystem）、数据子系统（Data Subsystem）和资源管理节点（Master）以及对象网关（Object Subsystem）组成，可以通过 POSIX&#x2F;HDFS&#x2F;S3 接口访问存储数据。</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/s2rcaw.png" alt="img"></p>
<p><strong>资源管理节点</strong></p>
<p>由多个 Master 节点组成，负责异步处理不同类型的任务，如管理数据分片与元数据分片（包括创建、删除、更新以及一致性检查等），检查数据节点或者元数据节点的健康状态，维护管理卷信息等</p>
<blockquote>
<p>Master 节点可以有多个，节点之间通过 Raft 算法保证元数据的一致性，并且持久化到 <code>RocksDB</code> 中。</p>
</blockquote>
<p><strong>元数据子系统</strong></p>
<p>由多个 Meta Node 节点组成，多个元数据分片（Meta Partition）和 Raft 实例（基于 Multi-Raft 复制协议）组成，每个元数据分片表示一个 Inode 范围元数据，其中包含两棵内存 B-Tree 树：inode BTree 与 dentry BTree。</p>
<blockquote>
<p>元数据实例最少需要 3 个，支持水平扩容。</p>
</blockquote>
<p><strong>数据子系统</strong></p>
<p>分为副本子系统和纠删码子系统，两种子系统可同时存在，也都可单独存在：</p>
<ul>
<li>副本子系统由 DataNode 组成，每个节点管理一组数据分片，多个节点的数据分片构成一个副本组；</li>
<li>纠删码子系统（Blobstore）主要由 BlobNode 模块组成，每个节点管理一组数据块，多个节点的数据块构成一个纠删码条带。</li>
</ul>
<blockquote>
<p>数据节点支持水平扩容。</p>
</blockquote>
<p><strong>对象子系统</strong></p>
<p>由对象节点（ObjectNode）组成，提供了兼容标准 S3 语义的访问协议，可以通过 Amazon S3 SDK 或者是 s3cmd 等工具访问存储资源。</p>
<p><strong>卷</strong></p>
<p>逻辑上的概念，由多个元数据和数据分片组成，从客户端的角度看，卷可以被看作是可被容器访问的文件系统实例。从对象存储的角度来看，一个卷对应着一个 bucket。一个卷可以在多个容器中挂载，使得文件可以被不同客户端同时访问。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>CubeFS 的安装方式有很多，包括 Docker、YUM 等等，由于我们这里直接直接在 Kubernetes 上使用，因此我们可以通过 Helm 来安装 CubeFS，各组件会直接使用宿主机网络，使用 <code>hostPath</code> 将磁盘映射到容器中。</p>
<p>在 Kubernetes 集群中部署 CubeFS 可以按照下图所示的架构进行部署：</p>
<p><img src="https://mudutestmenu.mudu.tv/upload/zo97cs.png" alt="img"></p>
<p>CubeFS 目前由这四部分组成：</p>
<ul>
<li><code>Master</code>：资源管理节点，负责维护整个集群的元信息，部署为 StatefulSet 资源。</li>
<li><code>DataNode</code>：数据存储节点，需要挂载大量磁盘负责文件数据的实际存储，部署为 DaemonSet 资源。</li>
<li><code>MetaNode</code>：元数据节点，负责存储所有的文件元信息，部署为 DaemonSet 资源。</li>
<li><code>ObjectNode</code>：负责提供转换 S3 协议提供对象存储的能力，无状态服务，部署为 Deployment 资源。</li>
</ul>
<p>在部署之前，我们需要拥有一个至少有 3 个节点（最好 4 个以上，可以容灾）的 Kubernetes 集群，且集群版本需要大于等于 1.15。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME     STATUS   ROLES           AGE   VERSION</span><br><span class="line">master   Ready    control-plane   46d   v1.28.7</span><br><span class="line">node1    Ready    &lt;none&gt;          46d   v1.28.7</span><br><span class="line">node2    Ready    &lt;none&gt;          46d   v1.28.7</span><br></pre></td></tr></table></figure>

<p>首先我们需要给节点打上各自的标签，标明这台机器要在 CubeFS 集群中承担的角色：</p>
<blockquote>
<p>由于我们这里只有 3 个节点，所以需要这些节点承担一些共同的角色。</p>
</blockquote>
<ul>
<li><code>Master</code> 节点，至少三个，建议为奇数个:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node master component.cubefs.io/master=enabled</span><br><span class="line">kubectl label node node1 component.cubefs.io/master=enabled</span><br><span class="line">kubectl label node node2 component.cubefs.io/master=enabled</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MetaNode</code> 元数据节点，至少 3 个，奇偶无所谓:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node master component.cubefs.io/metanode=enabled</span><br><span class="line">kubectl label node node1 component.cubefs.io/metanode=enabled</span><br><span class="line">kubectl label node node2 component.cubefs.io/metanode=enabled</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Datanode</code> 数据节点，至少 3 个，奇偶无所谓:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node master component.cubefs.io/datanode=enabled</span><br><span class="line">kubectl label node node1 component.cubefs.io/datanode=enabled</span><br><span class="line">kubectl label node node2 component.cubefs.io/datanode=enabled</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ObjectNode</code> 对象存储节点，可以按需进行标记，不需要对象存储功能的话也可以不部署这个组件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node node1 component.cubefs.io/objectnode=enabled</span><br><span class="line">kubectl label node node2 component.cubefs.io/objectnode=enabled</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CSI</code> 组件，用于在 Kubernetes 中使用 CubeFS，需要在所有节点上部署：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node node1 component.cubefs.io/csi=enabled</span><br><span class="line">kubectl label node node2 component.cubefs.io/csi=enabled</span><br></pre></td></tr></table></figure>

<p>CubeFS 安装时会根据这些标签通过 <code>nodeSelector</code> 进行匹配，然后在机器创建起对应的 Pod。</p>
<p>接下来我们就可以通过 Helm 来安装 CubeFS 了，首先我们需要将 CubeFS 的 Helm Chart 下载到本地：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/cubefs/cubefs-helm</span><br><span class="line"><span class="built_in">cd</span> cubefs-helm</span><br></pre></td></tr></table></figure>

<p>然后根据自身环境定制 values 文件，比如下面是一个简单的 values 文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cubefs-values.yaml</span></span><br><span class="line"><span class="attr">component:</span></span><br><span class="line">  <span class="attr">master:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">datanode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">metanode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">objectnode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">client:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">csi:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">monitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">ingress:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="comment"># 3.3.0 版本之前会出现 /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21&#x27; not found 错误</span></span><br><span class="line">  <span class="attr">server:</span> <span class="string">cubefs/cfs-server:v3.3.0</span></span><br><span class="line">  <span class="attr">client:</span> <span class="string">cubefs/cfs-client:v3.3.0</span></span><br><span class="line">  <span class="attr">csi_driver:</span> <span class="string">cnych/cubefs-cfs-csi-driver:3.2.0.150.0</span></span><br><span class="line">  <span class="attr">csi_provisioner:</span> <span class="string">cnych/csi-provisioner:v2.2.2</span></span><br><span class="line">  <span class="attr">csi_attacher:</span> <span class="string">cnych/csi-attacher:v3.4.0</span></span><br><span class="line">  <span class="attr">csi_resizer:</span> <span class="string">cnych/csi-resizer:v1.3.0</span></span><br><span class="line">  <span class="attr">driver_registrar:</span> <span class="string">cnych/csi-node-driver-registrar:v2.5.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">master:</span></span><br><span class="line">  <span class="comment"># The replicas of master component, at least 3, recommend to be an odd number</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;node-role.kubernetes.io/control-plane&quot;</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metanode:</span></span><br><span class="line">  <span class="attr">total_mem:</span> <span class="string">&quot;4000000000&quot;</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;node-role.kubernetes.io/control-plane&quot;</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">datanode:</span></span><br><span class="line">  <span class="comment"># DataNode 要使用的磁盘，可以挂载多块</span></span><br><span class="line">  <span class="comment"># 格式: 挂载点:保留的空间</span></span><br><span class="line">  <span class="comment"># 保留的空间: 单位字节，当磁盘剩余空间小于该值时将不会再在该磁盘上写入数据</span></span><br><span class="line">  <span class="attr">disks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/data0:10000000000</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;node-role.kubernetes.io/control-plane&quot;</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">csi:</span></span><br><span class="line">  <span class="attr">driverName:</span> <span class="string">csi.cubefs.com</span></span><br><span class="line">  <span class="attr">logLevel:</span> <span class="string">error</span></span><br><span class="line">  <span class="attr">kubeletPath:</span> <span class="string">/var/lib/kubelet</span></span><br><span class="line">  <span class="attr">controller:</span></span><br><span class="line">    <span class="attr">tolerations:</span> []</span><br><span class="line">    <span class="attr">nodeSelector:</span></span><br><span class="line">      <span class="attr">component.cubefs.io/csi:</span> <span class="string">&quot;enabled&quot;</span></span><br><span class="line">  <span class="attr">node:</span></span><br><span class="line">    <span class="attr">tolerations:</span> []</span><br><span class="line">    <span class="attr">nodeSelector:</span></span><br><span class="line">      <span class="attr">component.cubefs.io/csi:</span> <span class="string">&quot;enabled&quot;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">storageClass:</span></span><br><span class="line">    <span class="attr">setToDefault:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">reclaimPolicy:</span> <span class="string">&quot;Delete&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CSI 客户端配置</span></span><br><span class="line"><span class="attr">provisioner:</span></span><br><span class="line">  <span class="comment"># Kubelet 的主目录</span></span><br><span class="line">  <span class="attr">kubelet_path:</span> <span class="string">/var/lib/kubelet</span></span><br></pre></td></tr></table></figure>

<p>然后使用如下命令进行 CubeFS 部署：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade --install cubefs -n cubefs-system ./cubefs-helm/cubefs -f cubefs-values.yaml --create-namespace</span><br></pre></td></tr></table></figure>

<p>部署完成后可以使用命令 <code>kubectl get pods -n cubefs-system</code> 等待所有组件状态变为 Running 即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -n cubefs-system</span><br><span class="line">NAME                                  READY   STATUS     RESTARTS   AGE</span><br><span class="line">cfs-csi-controller-66cdbb664f-pqkp6   4/4     Running    0          28m</span><br><span class="line">cfs-csi-node-966t9                    2/2     Running    0          25m</span><br><span class="line">cfs-csi-node-9f4ts                    2/2     Running    0          25m</span><br><span class="line">datanode-4zfhc                        1/1     Running    0          28m</span><br><span class="line">datanode-blc8w                        1/1     Running    0          28m</span><br><span class="line">datanode-ldj72                        1/1     Running    0          28m</span><br><span class="line">master-0                              1/1     Running    0          28m</span><br><span class="line">master-1                              1/1     Running    0          23m</span><br><span class="line">master-2                              1/1     Running    0          23m</span><br><span class="line">metanode-5csgt                        1/1     Running    0          7m31s</span><br><span class="line">metanode-jvqnl                        1/1     Running    0          7m31s</span><br><span class="line">metanode-vpjtj                        1/1     Running    0          7m31s</span><br></pre></td></tr></table></figure>

<p>各个组件的关键日志会在容器标准输出中输出。</p>
<p>此外还会自动创建一个 <code>StorageClass</code> 对象，可以通过 <code>kubectl get sc</code> 查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get sc</span><br><span class="line">NAME         PROVISIONER                                   RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class="line">cfs-sc       csi.cubefs.com                                Delete          Immediate           <span class="literal">true</span>                   29m</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在我们有了一个可用的 StorageClass 对象了，接下来可以创建一个 PVC 对象来测试 CubeFS 的存储功能。如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cubefs-pvc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cubefs-pvc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">cfs-sc</span></span><br></pre></td></tr></table></figure>

<p>上面的 PVC 对象中我们通过 <code>storageClassName</code> 指定了使用的 StorageClass 名称，这里是 <code>cfs-sc</code>，这个名称需要和我们之前创建的 StorageClass 名称一致，这样就会根据 <code>cubefs-sc</code> 中定义的参数来创建存储卷。当我们在编写 pvc yaml 主要注意一下参数：</p>
<ul>
<li><code>metadata.name</code>：pvc 的名称，可以按需修改，同一个 namespace 下 pvc 名称是唯一的，不允许有两个相同的名称。</li>
<li><code>metadata.namespace</code>：pvc 所在的命名空间，按需修改</li>
<li><code>spec.resources.request.storage</code>：pvc 容量大小。</li>
<li><code>storageClassName</code>：这是 storage class 的名称。如果想知道当前集群有哪些 storageclass，可以通过命令 <code>kubectl get sc</code> 来查看。</li>
</ul>
<p>这里直接应用这个 yaml 文件即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f cubefs-pvc.yaml</span><br></pre></td></tr></table></figure>

<p>执行命令完成后，可以通过命令 <code>kubectl get pvc -n 命名空间</code> 来查看对应 pvc 的状态，Pending 代表正在等待，Bound 代表创建成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME         STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">cubefs-pvc   Bound    pvc-53cc95b7-8a05-43f8-8903-f1c6f7b11c05   5Gi        RWO            cfs-sc         3s</span><br></pre></td></tr></table></figure>

<p>如果 PVC 的状态一直处于 Pending，可以通过命令查看原因：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pvc -n 命名空间 PVC 名称</span><br></pre></td></tr></table></figure>

<p>如果报错消息不明显或者看不出错误，则可以使用 <code>kubectl logs</code> 相关命令先查看 csi controller pod 里面的 <code>csi-provisioner</code> 容器的报错信息，<code>csi-provisioner</code> 是 k8s 与 csi driver 的中间桥梁，很多信息都可以在这里的日志查看。</p>
<p>如果 <code>csi-provisioner</code> 的日志还看不出具体问题，则使用 <code>kubectl exec</code> 相关命令查看 csi controller pod 里面的 cfs-driver 容器的日志，它的日志放在容器里面的 <code>/cfs/logs</code> 下。</p>
<p>这里不能使用 Kubectl logs 相关命令是因为 cfs-driver 的日志并不是打印到标准输出，而其它几个类似 <code>csi-provisioner</code> 的 sidecar 容器的日志是打印到标准输出的，所以可以使用 <code>kubectl logs</code> 相关命令查看。</p>
<p>有了 PVC 则接下来就可以在应用中挂载到指定目录了，比如我们这里有一个如下所示的示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cfs-csi-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cfs-csi-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">cfs-csi-demo-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">cfs-csi-demo-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">component.cubefs.io/csi:</span> <span class="string">enabled</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cfs-csi-demo</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.9</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">&quot;IfNotPresent&quot;</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">&quot;http-server&quot;</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span></span><br><span class="line">              <span class="attr">mountPropagation:</span> <span class="string">HostToContainer</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mypvc</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mypvc</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">cubefs-pvc</span></span><br></pre></td></tr></table></figure>

<p>上面的资源清单中我们将一个名称为 <code>cubefs-pvc</code> 的 PVC 挂载到 <code>cfs-csi-demo</code> 容器里面的 <code>/usr/share/nginx/html</code> 下。</p>
<p>同样直接创建这个资源清单即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f cfs-csi-demo.yaml</span><br></pre></td></tr></table></figure>

<p>创建完成后可以通过 <code>kubectl get pods</code> 查看 Pod 的状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -owide</span><br><span class="line">NAME                                      READY   STATUS    RESTARTS       AGE   IP           NODE    NOMINATED NODE   READINESS GATES</span><br><span class="line">cfs-csi-demo-5d456c8d97-sjsvw             1/1     Running   0              78s   10.0.1.85    node1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以直接通过往 <code>/usr/share/nginx/html</code> 目录写入文件来测试 CubeFS 的存储功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> -it cfs-csi-demo-5d456c8d97-sjsvw -- /bin/bash</span><br><span class="line">root@cfs-csi-demo-5d456c8d97-sjsvw:/# <span class="built_in">echo</span> <span class="string">&quot;Hello, CubeFS&quot;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line">root@cfs-csi-demo-5d456c8d97-sjsvw:/#</span><br></pre></td></tr></table></figure>

<p>然后我们可以将这个 Pod 删除重建，然后查看是否还有这个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pod cfs-csi-demo-5d456c8d97-sjsvw</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                                      READY   STATUS    RESTARTS       AGE</span><br><span class="line">cfs-csi-demo-5d456c8d97-c245z             1/1     Running   0              3m22s</span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it cfs-csi-demo-5d456c8d97-c245z -- <span class="built_in">ls</span> /usr/share/nginx/html</span><br><span class="line">index.html</span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it cfs-csi-demo-5d456c8d97-c245z -- <span class="built_in">cat</span> /usr/share/nginx/html/index.html</span><br><span class="line">Hello, CubeFS</span><br></pre></td></tr></table></figure>

<p>如果能够看到 <code>Hello, CubeFS</code> 则说明 CubeFS 的存储功能正常。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/%E6%96%B0%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%20CubeFS/">https://huiaz.github.io/2025/09/11/%E6%96%B0%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%20CubeFS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%20KubeBlocks/" title="数据管理平台 KubeBlocks"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据管理平台 KubeBlocks</div></div><div class="info-2"><div class="info-item-1">云原生数据管理平台 KubeBlocksKubeBlocks 是基于 Kubernetes 的云原生数据基础设施，将顶级云服务提供商的大规模生产经验与增强的可用性和稳定性改进相结合，帮助用户轻松构建容器化、声明式的关系型、NoSQL、流计算和向量型数据库服务。  为什么需要 KubeBlocks？Kubernetes 已经成为容器编排的事实标准。它利用 ReplicaSet 提供的可扩展性和可用性以及 Deployment 提供的发布和回滚功能来管理日益增加的无状态工作负载。然而，管理有状态工作负载给 Kubernetes 带来了巨大的挑战，尽管 StatefulSet 提供了稳定的持久存储和唯一的网络标识符，但这些功能对于复杂的有状态工作负载来说远远不够。 为了应对这些挑战，并解决复杂性问题，KubeBlocks 引入了 ReplicationSet 和 ConsensusSet，具备以下能力：  基于角色的更新顺序可减少因升级版本、缩放和重新启动而导致的停机时间。 维护数据复制的状态，并自动修复复制错误或延迟。  KubeBlocks 具有以下特点：  支持多云，与 AWS、...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" title="服务发现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">服务发现</div></div><div class="info-2"><div class="info-item-1">服务发现由于我们这里每个节点上面都运行了 node-exporter 程序，当然我们也可以手动的把所有节点用静态的方式配置到 Prometheus 中去，但是以后要新增或者去掉节点的时候就还得手动去配置，那么有没有一种方式可以让 Prometheus 去自动发现我们节点的 node-exporter 程序，并且按节点进行分组呢？这就是 Prometheus 里面非常重要的服务发现功能了。 节点发现在 Kubernetes 下，Promethues 通过与 Kubernetes API 集成，主要支持 5 中服务发现模式，分别是：Node、Service、Pod、Endpoints、Ingress。 我们通过 kubectl 命令可以很方便的获取到当前集群中的所有节点信息： 12345☸ ➜ kubectl get nodesNAME      STATUS   ROLES                  AGE   VERSIONmaster1   Ready    control-plane,master   55d   v1.22.2node1     Ready    &...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/k8s_12/" title="k8s_12"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s_12</div></div><div class="info-2"><div class="info-item-1">如何在 Kubernetes 中实现服务的自动伸缩（autoscaling）？Of course. Automating the scaling of services is one of Kubernetes’ most powerful features, enabling applications to be both resilient to traffic spikes and cost-effective during quiet periods. This is achieved through a combination of several components. 🤔 分析过程：该问题旨在考察对Kubernetes核心动态管理能力的理解。一个全面的回答不能只提及一种自动伸缩方式，而应结构化地介绍Kubernetes中三个主要层次的自动伸缩器：HPA (水平), VPA (垂直), 和 CA (集群)。回答的重点在于阐明每种伸缩器的触发机制、作用范围和典型用例，并解释它们如何协同工作，共同构建一个弹性的、资源高效的系统。 💡 答案生成：1. 概念或定义Kube...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Gitlab%20CI%20%E5%9C%A8%20Kubernetes%20%E4%B8%AD%E7%9A%84%20Docker%20%E7%BC%93%E5%AD%98/" title="Gitlab CI 在 Kubernetes 中的 Docker 缓存"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Gitlab CI 在 Kubernetes 中的 Docker 缓存</div></div><div class="info-2"><div class="info-item-1">Gitlab CI 在 Kubernetes 中的 Docker 缓存前面我们有文章介绍过如何在 Kubernetes 集群中使用 GitLab CI 来实现 CI&#x2F;CD，在构建镜像的环节我们基本上都是使用的 Docker On Docker 的模式，这是因为 Kubernetes 集群使用的是 Docker 这种容器运行时，所以我们可以将宿主机的 docker.sock 文件挂载到容器中构建镜像，而最近我们在使用 Kubernetes 1.22.X 版本后将容器运行时更改为了 Containerd，这样节点上没有可用的 Docker 服务了，这个时候就需要更改构建镜像的模式了，当然要实现构建镜像的方式有很多，我们这里还是选择使用 Docker 来构建我们的 Docker 镜像，也就是使用 Docker IN Docker 的模式。 在每次构建镜像的时候，GitLab Runner 都会启动一个包含 3 个容器的 Pod，其中一个就是运行 Docker 守护进程的 Docker DIND 容器，构建的容器会去连接到运行在同一个 Pod 上的 Docker 守护进程，由于...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Longhorn/" title="Longhorn"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Longhorn</div></div><div class="info-2"><div class="info-item-1">Longhorn前面我们学习了本地存储、NFS 共享存储，除了这些存储类型之外，还有一个块存储，同样为 Kubernetes 提供块存储的方案有很多，比如 Ceph RBD，今天我们为大家介绍的是 Rancher 开源的一款 Kubernetes 的云原生分布式块存储方案 - Longhorn。 使用 Longhorn，可以：  使用 Longhorn 卷作为 Kubernetes 集群中分布式有状态应用程序的持久存储 将你的块存储分区为 Longhorn 卷，以便你可以在有或没有云提供商的情况下使用 Kubernetes 卷 跨多个节点和数据中心复制块存储以提高可用性 将备份数据存储在 NFS 或 AWS S3 等外部存储中 创建跨集群灾难恢复卷，以便可以从第二个 Kubernetes 集群中的备份中快速恢复主 Kubernetes 集群中的数据 调度一个卷的快照，并将备份调度到 NFS 或 S3 兼容的二级存储 从备份还原卷 不中断持久卷的情况下升级 Longhorn  Longhorn 还带有独立的 UI，可以使用 Helm、kubectl 或 Rancher 应用程序目录...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Pod%20%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/" title="Pod 使用进阶"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Pod 使用进阶</div></div><div class="info-2"><div class="info-item-1">Pod 使用进阶-深入理解 Pod 对象Pod 资源配置实际上上面几个步骤就是影响一个 Pod 生命周期的大的部分，但是还有一些细节也会在 Pod 的启动过程进行设置，比如在容器启动之前还会为当前的容器设置分配的 CPU、内存等资源，我们知道我们可以通过 CGroup 来对容器的资源进行限制，同样的，在 Pod 中我们也可以直接配置某个容器的使用的 CPU 或者内存的上限。那么 Pod 是如何来使用和控制这些资源的分配的呢？ 首先对于 CPU，我们知道计算机里 CPU 的资源是按“时间片”的方式来进行分配的，系统里的每一个操作都需要 CPU 的处理，所以，哪个任务要是申请的 CPU 时间片越多，那么它得到的 CPU 资源就越多，这个很容器理解。 然后还需要了解下 CGroup 里面对于 CPU 资源的单位换算： 121 CPU =  1000 millicpu（1 Core = 1000m）0.5 CPU = 500 millicpu （0.5 Core = 500m）  这里的 m 就是毫、毫核的意思，Kubernetes 集群中的每一个节点可以通过操作系统的命令来确认本节点的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/DaemonSet/" title="DaemonSet"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">DaemonSet</div></div><div class="info-2"><div class="info-item-1">DaemonSet 控制器通过该控制器的名称我们可以看出它的用法：Daemon，就是用来部署守护进程的，DaemonSet用于在每个 Kubernetes 节点中将守护进程的副本作为后台进程运行，说白了就是在每个节点部署一个 Pod 副本，当节点加入到 Kubernetes 集群中，Pod 会被调度到该节点上运行，当节点从集群只能够被移除后，该节点上的这个 Pod 也会被移除，当然，如果我们删除 DaemonSet，所有和这个对象相关的 Pods 都会被删除。那么在哪种情况下我们会需要用到这种业务场景呢？其实这种场景还是比较普通的，比如：  集群存储守护程序，如 glusterd、ceph 要部署在每个节点上以提供持久性存储； 节点监控守护进程，如 Prometheus 监控集群，可以在每个节点上运行一个 node-exporter 进程来收集监控节点的信息； 日志收集守护程序，如 fluentd 或 logstash，在每个节点上运行以收集容器的日志 节点网络插件，比如 flannel、calico，在每个节点上运行为 Pod 提供网络服务。  这里需要特别说明的一个就是关于 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ingress-nginx/" title="ingress-nginx"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ingress-nginx</div></div><div class="info-2"><div class="info-item-1">ingress-nginx我们已经了解了 Ingress 资源对象只是一个路由请求描述配置文件，要让其真正生效还需要对应的 Ingress 控制器才行，Ingress 控制器有很多，这里我们先介绍使用最多的 ingress-nginx，它是基于 Nginx 的 Ingress 控制器。 运行原理ingress-nginx 控制器主要是用来组装一个 nginx.conf 的配置文件，当配置文件发生任何变动的时候就需要重新加载 Nginx 来生效，但是并不会只在影响 upstream 配置的变更后就重新加载 Nginx，控制器内部会使用一个 lua-nginx-module 来实现该功能。 我们知道 Kubernetes 控制器使用控制循环模式来检查控制器中所需的状态是否已更新或是否需要变更，所以 ingress-nginx 需要使用集群中的不同对象来构建模型，比如 Ingress、Service、Endpoints、Secret、ConfigMap 等可以生成反映集群状态的配置文件的对象，控制器需要一直 Watch 这些资源对象的变化，但是并没有办法知道特定的更改是否会影响到最终生...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-CubeFS"><span class="toc-number">1.</span> <span class="toc-text">新一代云原生存储系统 CubeFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">整体架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.4.</span> <span class="toc-text">测试</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>