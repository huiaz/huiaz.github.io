<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Nginx Cache | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="为什么需要缓存静态文件？ 减少服务器负载： 对于静态文件，Nginx 每次请求都需要从磁盘读取并发送。缓存后，Nginx 可以直接从内存发送，或告诉浏览器文件未修改，无需再次下载。 加速页面加载： 用户客户端不需要每次都从服务器下载 CSS、JavaScript、图片等文件，可以直接从浏览器本地缓存中获取，从而极大提高网站的响应速度。 节省网络带宽： 减少了重复传输相同静态文件的次数，从而降低了服">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx Cache">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/Cache/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="为什么需要缓存静态文件？ 减少服务器负载： 对于静态文件，Nginx 每次请求都需要从磁盘读取并发送。缓存后，Nginx 可以直接从内存发送，或告诉浏览器文件未修改，无需再次下载。 加速页面加载： 用户客户端不需要每次都从服务器下载 CSS、JavaScript、图片等文件，可以直接从浏览器本地缓存中获取，从而极大提高网站的响应速度。 节省网络带宽： 减少了重复传输相同静态文件的次数，从而降低了服">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:25:00.377Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Nginx Cache",
  "url": "https://huiaz.github.io/2025/09/11/Cache/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:25:00.377Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/Cache/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Nginx Cache',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Nginx Cache</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Nginx Cache</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:25:00.377Z" title="更新于 2025-09-11 22:25:00">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Nginx/">Nginx</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="为什么需要缓存静态文件？"><a href="#为什么需要缓存静态文件？" class="headerlink" title="为什么需要缓存静态文件？"></a>为什么需要缓存静态文件？</h3><ol>
<li><strong>减少服务器负载：</strong> 对于静态文件，Nginx 每次请求都需要从磁盘读取并发送。缓存后，Nginx 可以直接从内存发送，或告诉浏览器文件未修改，无需再次下载。</li>
<li><strong>加速页面加载：</strong> 用户客户端不需要每次都从服务器下载 CSS、JavaScript、图片等文件，可以直接从浏览器本地缓存中获取，从而极大提高网站的响应速度。</li>
<li><strong>节省网络带宽：</strong> 减少了重复传输相同静态文件的次数，从而降低了服务器和客户端的网络带宽消耗。</li>
</ol>
<h3 id="Nginx-中配置静态文件缓存的关键指令"><a href="#Nginx-中配置静态文件缓存的关键指令" class="headerlink" title="Nginx 中配置静态文件缓存的关键指令"></a>Nginx 中配置静态文件缓存的关键指令</h3><p>Nginx 配置静态文件缓存主要涉及到以下几个方面：</p>
<ol>
<li><strong>浏览器缓存 (Expires 和 Cache-Control Header)：</strong> 告诉客户端（浏览器）如何缓存文件。</li>
<li><strong>Nginx 自身缓存 (proxy_cache)：</strong> Nginx 作为反向代理时，缓存来自后端服务器的响应。</li>
<li><strong>ETag 和 If-Modified-Since：</strong> 实现条件请求，进一步优化缓存。</li>
</ol>
<h4 id="1-配置浏览器缓存-Browser-Caching"><a href="#1-配置浏览器缓存-Browser-Caching" class="headerlink" title="1. 配置浏览器缓存 (Browser Caching)"></a>1. 配置浏览器缓存 (Browser Caching)</h4><p>这是最常用也是最直接的静态文件缓存方式。Nginx 通过设置响应头 <code>Expires</code> 和 <code>Cache-Control</code> 来告诉浏览器是否以及如何缓存文件。</p>
<p><strong>a. 使用 <code>expires</code> 指令</strong></p>
<p><code>expires</code> 指令允许你根据文件类型设置缓存时间。它可以用于 <code>http</code>、<code>server</code>、<code>location</code> 块中。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># ... 其他 http 配置 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line">        <span class="attribute">root</span> /var/www/your_website; <span class="comment"># 网站根目录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 针对图片文件设置缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(jpg|jpeg|gif|png|svg|ico)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>; <span class="comment"># 缓存 30 天</span></span><br><span class="line">            <span class="comment"># 可选：禁止访问文件列表（例如禁止访问 .svn、.git 目录）</span></span><br><span class="line">            <span class="comment"># access_log off; # 访问日志也可以关闭，减少IO</span></span><br><span class="line">            <span class="comment"># log_not_found off; # 不记录找不到文件的日志</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 针对 CSS 和 JavaScript 文件设置缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(css|js)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">7d</span>; <span class="comment"># 缓存 7 天</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 针对字体文件设置缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(woff|woff2|ttf|otf|eot)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>; <span class="comment"># 缓存 30 天</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 针对其他静态文件（如PDF, MP3等）</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(pdf|mp3|mp4)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于HTML页面，通常保持不缓存或短时间缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.html$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">1h</span>; <span class="comment"># HTML 通常只缓存 1 小时或更短，因为内容更新频繁</span></span><br><span class="line">            <span class="comment"># 或 expires off; # 不缓存 HTML</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于根目录下的所有文件以及未被上述规则捕获的文件</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 默认的 expires 设置，如果前面没匹配到，就用这个</span></span><br><span class="line">            <span class="comment"># expires 0; 或 expires off; # 表示不缓存或每次都检查</span></span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html; <span class="comment"># 对于动态内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>expires</code> 指令详解：</strong></p>
<ul>
<li><strong><code>expires time;</code></strong>: 设置缓存时间，例如 <code>30d</code> (30天), <code>12h</code> (12小时), <code>30m</code> (30分钟), <code>1s</code> (1秒)。</li>
<li><strong><code>expires epoch;</code></strong>: 设置为 Unix 纪元（GMT 1 Jan 1970 00:00:01），表示立即过期，浏览器不缓存。</li>
<li><strong><code>expires max;</code></strong>: 设置为 GMT 31 Dec 2037 23:59:59，表示浏览器尽可能长时间缓存。</li>
<li><strong><code>expires off;</code></strong>: 禁用 <code>Expires</code> 和 <code>Cache-Control</code> 头。</li>
<li><strong><code>expires -1;</code></strong>: <code>Cache-Control: no-cache</code>，意味着浏览器每次都必须向服务器验证文件是否已修改，但不重新下载内容。</li>
</ul>
<p>Nginx 会根据 <code>expires</code> 的设置，自动生成 <code>Expires</code> 头和 <code>Cache-Control</code> 头。</p>
<p>例如，<code>expires 30d;</code> 会生成：<br><code>Cache-Control: public, max-age=2592000</code> (2592000 秒 &#x3D; 30 天)<br><code>Expires: Thu, 01 Jan 20XX 12:00:00 GMT</code> (具体的过期时间)</p>
<p><strong>b. <code>add_header Cache-Control</code> (更精细的控制)</strong></p>
<p>虽然 <code>expires</code> 已经很方便，但 <code>Cache-Control</code> 提供了更细粒度的控制，例如 <code>no-store</code>、<code>no-cache</code>、<code>private</code> 等。如果你想更精确地控制 <code>Cache-Control</code> 头，可以直接使用 <code>add_header</code> 指令。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~* \.(jpg|png)$</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Cache-Control <span class="string">&quot;public, max-age=2592000&quot;</span>; <span class="comment"># 等同于 expires 30d;</span></span><br><span class="line">    <span class="comment"># add_header Cache-Control &quot;no-cache&quot;; # 每次都验证</span></span><br><span class="line">    <span class="comment"># add_header Cache-Control &quot;no-store&quot;; # 绝对不缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-配置-Nginx-自身缓存-Proxy-Caching"><a href="#2-配置-Nginx-自身缓存-Proxy-Caching" class="headerlink" title="2. 配置 Nginx 自身缓存 (Proxy Caching)"></a>2. 配置 Nginx 自身缓存 (Proxy Caching)</h4><p>当 Nginx 作为反向代理时，它可以缓存后端服务器的响应。这对于动态生成但内容不经常变化的页面或 API 响应非常有用，也可以缓存后端服务器提供的静态文件，避免每次都向后端请求。</p>
<p><strong>a. 定义缓存区域</strong></p>
<p>首先，在 <code>http</code> 块中定义一个缓存区域：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># 定义一个名为 &quot;my_cache_zone&quot; 的缓存区域</span></span><br><span class="line">    <span class="comment"># path: /var/cache/nginx/proxy_cache_dir 是缓存文件存放的路径</span></span><br><span class="line">    <span class="comment"># levels: 定义两级子目录结构，例如 1:2，即 /dir/a/b/filename，有助于提高查找效率</span></span><br><span class="line">    <span class="comment"># keys_zone: 定义共享内存区域，用于存储缓存键和元数据，name:zone_size</span></span><br><span class="line">    <span class="comment"># inactive: 如果一个缓存文件在 60 分钟内没有被使用，即使没有过期也会被清除</span></span><br><span class="line">    <span class="comment"># max_size: 缓存目录的最大大小。当达到上限时，Nginx 会根据 LRU 算法删除旧文件</span></span><br><span class="line">    <span class="attribute">proxy_cache_path</span> /var/cache/nginx/proxy_cache_dir levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache_zone:<span class="number">100m</span> inactive=<span class="number">60m</span> max_size=<span class="number">10g</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://my_backend_server; <span class="comment"># 代理到后端服务器</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 启用前面定义的缓存区域</span></span><br><span class="line">            <span class="attribute">proxy_cache</span> my_cache_zone;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 定义用于生成缓存键的字符串，通常是请求方法和 URI</span></span><br><span class="line">            <span class="attribute">proxy_cache_key</span> <span class="string">&quot;<span class="variable">$request_method</span><span class="variable">$scheme</span><span class="variable">$host</span><span class="variable">$request_uri</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 定义哪些 HTTP 状态码的响应应该被缓存以及缓存多久</span></span><br><span class="line">            <span class="comment"># 200 (OK) 和 304 (Not Modified) 缓存 10 分钟</span></span><br><span class="line">            <span class="comment"># 301 (Moved Permanently) 缓存 1 小时</span></span><br><span class="line">            <span class="comment"># 404 (Not Found) 缓存 1 分钟 (避免频繁请求不存在的资源)</span></span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">304</span> <span class="number">10m</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">301</span> <span class="number">1h</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">404</span> <span class="number">1m</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> any <span class="number">1m</span>; <span class="comment"># 默认所有其他状态码缓存 1 分钟</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 可选：如果后端返回特定的 Cache-Control 头，则可以覆盖或遵循</span></span><br><span class="line">            <span class="comment"># proxy_cache_bypass $http_pragma $http_authorization; # 不缓存的情况</span></span><br><span class="line">            <span class="comment"># proxy_cache_revalidate on; # 使用 If-Modified-Since 和 If-None-Match 验证缓存</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment"># 当缓存失效时，保持后端访问的并发连接数</span></span><br><span class="line">            <span class="attribute">proxy_cache_lock</span> <span class="literal">on</span>; <span class="comment"># 只有一个请求会去后端获取新内容，其他等待</span></span><br><span class="line">            <span class="attribute">proxy_cache_lock_timeout</span> <span class="number">5s</span>; <span class="comment"># 等待时间</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 可选：显示缓存命中状态在响应头中</span></span><br><span class="line">            <span class="attribute">add_header</span> X-Proxy-Cache <span class="variable">$upstream_cache_status</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于直接由 Nginx 服务，而不是代理的静态文件，使用上面浏览器缓存的配置</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(jpg|jpeg|gif|png|svg|ico)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">            <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>proxy_cache</code> 相关指令详解：</strong></p>
<ul>
<li><code>proxy_cache_path</code>：定义缓存区域的路径、大小、结构等。</li>
<li><code>proxy_cache</code>：在 <code>location</code> 块中启用缓存区域。</li>
<li><code>proxy_cache_key</code>：定义缓存条目的键。如果两个请求的键相同，Nginx 就会认为它们是同一个请求，并尝试从缓存中获取响应。</li>
<li><code>proxy_cache_valid</code>：指定不同 HTTP 状态码的响应缓存多久。</li>
<li><code>proxy_cache_bypass</code>：定义在某些条件下不使用缓存（例如当请求包含特定 Header 时）。</li>
<li><code>proxy_cache_revalidate</code>：在缓存过期时，Nginx 会发送条件请求到后端，而不是直接重新获取整个内容。</li>
<li><code>proxy_cache_lock</code>：防止“惊群效应”。当缓存过期时，如果大量请求同时到达，只有一个请求会穿透到后端服务器获取新数据，其他请求会等待缓存更新。</li>
<li><code>$upstream_cache_status</code>：这是一个 Nginx 变量，可以添加到响应头中，显示缓存状态（MISS, HIT, EXPIRED, UPDATING, STALE等），方便调试。</li>
</ul>
<h4 id="3-ETag-和-If-Modified-Since-条件请求"><a href="#3-ETag-和-If-Modified-Since-条件请求" class="headerlink" title="3. ETag 和 If-Modified-Since (条件请求)"></a>3. ETag 和 If-Modified-Since (条件请求)</h4><p>Nginx 默认会生成 <code>Last-Modified</code> 和 <code>ETag</code> 响应头来支持条件请求。</p>
<ul>
<li><strong><code>Last-Modified</code>：</strong> 服务器告诉浏览器文件最后一次修改的时间。</li>
<li><strong><code>ETag</code>：</strong> 服务器生成的一个文件内容的唯一标识符。</li>
</ul>
<p>当浏览器再次请求同一个文件时，它会在请求头中带上 <code>If-Modified-Since</code> (值为 <code>Last-Modified</code> 的时间) 或 <code>If-None-Match</code> (值为 <code>ETag</code>)。</p>
<p>Nginx 接收到这些头后，会进行判断：</p>
<ul>
<li>如果文件未修改 (<code>If-Modified-Since</code> 或 <code>If-None-Match</code> 匹配)，Nginx 会返回 <code>304 Not Modified</code> 响应，不发送文件内容，告知浏览器直接使用本地缓存。</li>
<li>如果文件已修改，Nginx 会发送新的文件内容，并更新 <code>Last-Modified</code> 和 <code>ETag</code> 头。</li>
</ul>
<p>这种机制可以最大限度地减少传输数据量，即使文件缓存过期，也能高效验证。通常情况下，Nginx 默认就已经支持这些特性，你无需额外配置。但如果你希望禁用 ETag 或 <code>Last-Modified</code>，可以使用 <code>etag off;</code> 和 <code>send_lowat off;</code>（不推荐）。</p>
<h3 id="最佳实践总结"><a href="#最佳实践总结" class="headerlink" title="最佳实践总结"></a>最佳实践总结</h3><ol>
<li><strong>明确文件类型和缓存策略：</strong> 不同类型的文件有不同的更新频率和重要性。图片、字体等文件可以长时间缓存，CSS&#x2F;JS 适中，HTML 页面通常短时间缓存或不缓存。</li>
<li><strong>利用版本号或哈希：</strong> 对于可以长时间缓存（如 30 天或一年）的静态资源，为了在更新时强制浏览器重新下载，可以在文件名中加入版本号或文件内容的哈希值（例如 <code>style.v1.css</code> 或 <code>script.abcdef.js</code>）。这样即使 <code>expires max;</code>，新版本的文件路径也不同，浏览器会下载新文件。</li>
<li><strong>禁用对静态文件的日志记录：</strong> <code>access_log off;</code> 和 <code>log_not_found off;</code> 可以减少磁盘 I&#x2F;O，尤其是在高流量的网站上。</li>
<li><strong>Gzip 压缩：</strong> 配合缓存，对静态文件进行 Gzip 压缩 (<code>gzip on;</code>) 可以进一步减少传输大小，提高加载速度。</li>
<li><strong>合理设置缓存路径和大小：</strong> <code>proxy_cache_path</code> 中的 <code>max_size</code> 和 <code>inactive</code> 参数需要根据你的磁盘空间和流量模式进行调整。</li>
<li><strong>监控缓存命中率：</strong> 在生产环境中，通过 Nginx 的 <code>$upstream_cache_status</code> 变量（如果使用了 <code>proxy_cache</code>）以及其他监控工具，监控缓存命中率，以评估缓存配置的效果。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/Cache/">https://huiaz.github.io/2025/09/11/Cache/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Consule%20%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" title="Consule 服务发现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Consule 服务发现</div></div><div class="info-2"><div class="info-item-1">基于 Consul 的服务发现Consul 是由 HashiCorp 开发的一个支持多数据中心的分布式服务发现和键值对存储服务的开源软件，是一个通用的服务发现和注册中心工具，被大量应用于基于微服务的软件架构当中。 接下来我们就来尝试使用 Prometheus 基于 Consul 的服务发现来监控前面的 3 个 demo 服务： 123192.168.31.46:10000192.168.31.46:10001192.168.31.46:10002  我们将 demo 服务注册到 Consul，然后配置 Prometheus 从 Consul 中发现演示服务实例，并使用 Relabeling 操作来过滤调整目标标签。关于 Consul 本身的使用可以查看官方文档 https://learn.hashicorp.com/consul 了解更多。  安装配置 Consul在页面 https://www.consul.io/downloads 下载符合自己系统的安装文件，比如我们这里是 Linux 系统，使用下面命令下载安装即可： 12345678☸ ➜ wget https://rel...</div></div></div></a><a class="pagination-related" href="/2025/09/11/CRD/" title="CRD"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CRD</div></div><div class="info-2"><div class="info-item-1">CRDCustom Resource Define 简称 CRD，是 Kubernetes（v1.7+）为提高可扩展性，让开发者去自定义资源的一种方式。CRD 资源可以动态注册到集群中，注册完毕后，用户可以通过 kubectl 来创建访问这个自定义的资源对象，类似于操作 Pod 一样。不过需要注意的是 CRD 仅仅是资源的定义而已，需要一个 Controller 去监听 CRD 的各种事件来添加自定义的业务逻辑。 定义如果说只是对 CRD 资源本身进行 CRUD 操作的话，不需要 Controller 也是可以实现的，相当于就是只有数据存入了 etcd 中，而没有对这个数据的相关操作而已。比如我们可以定义一个如下所示的 CRD 资源清单文件： 12345678910111213141516171819202122232425262728293031323334353637383940# crd-demo.yamlapiVersion: apiextensions.k8s.io/v1kind: CustomResourceDefinitionmetadata:  # name 必须...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Service/" title="Service"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Service</div></div><div class="info-2"><div class="info-item-1">Service我们前面的课程中学习了一些常用控制器的基本用法，我们也了解到 Pod 的生命是有限的，死亡过后不会复活了。然后我们知道可以用 ReplicaSet 和 Deployment 来动态的创建和销毁 Pod，每个 Pod 都有自己的 IP 地址，但是如果 Pod 重建了的话那么他的 IP 很有可能也就变化了。这就会带来一个问题：比如我们有一些后端的 Pod 集合为集群中的其他应用提供 API 服务，如果我们在前端应用中把所有的这些后端的 Pod 的地址都写死，然后以某种方式去访问其中一个 Pod 的服务，这样看上去是可以工作的，对吧？但是如果这个 Pod 挂掉了，然后重新启动起来了，是不是 IP 地址非常有可能就变了，这个时候前端就极大可能访问不到后端的服务了。 遇到这样的问题该怎么解决呢？在没有使用 Kubernetes 之前，我相信可能很多同学都遇到过这样的问题，不一定是 IP 变化的问题，比如我们在部署一个 WEB 服务的时候，前端一般部署一个 Nginx 作为服务的入口，然后 Nginx 后面肯定就是挂载的这个服务的大量后端服务，很早以前我们可能是去手动更改 Ng...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" title="负载均衡"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">负载均衡</div></div><div class="info-2"><div class="info-item-1">什么是负载均衡（Load Balancing）？在 Web 服务器环境中，负载均衡是一种将网络请求（流量）有效地分发到多个服务器（通常称为后端服务器或上游服务器）上的技术。其核心目标是：  提高系统可用性： 当某台后端服务器出现故障时，负载均衡器可以将流量自动路由到健康的服务器，避免服务中断。 提高系统性能： 通过将请求分散到多台服务器上，可以避免单台服务器过载，缩短响应时间，提高处理能力。 提高系统可伸缩性： 随着业务增长，可以通过简单地增加后端服务器来扩展系统的处理能力，而无需升级单台服务器。 优化资源利用： 确保所有后端服务器都能得到合理的利用，而不是某些服务器空闲而另一些过载。  简单来说，负载均衡器就像一个交通指挥官，它接收到客户端的请求后，不会让请求直接去某一台具体的服务器，而是根据预设的算法和规则，将其导向当前最合适（或下一个）的后端服务器去处理，并将处理结果返回给客户端。 负载均衡的常见算法负载均衡器会根据不同的算法来决定将请求分发给哪台后端服务器。Nginx 支持多种算法：  轮询 (Round Robin)： 原理： 默认算法。请求按时间顺序依次分发到后端服务...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP-四次挥手"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP-四次挥手</div></div><div class="info-2"><div class="info-item-1">TCP 的四次挥手（Four-way Handshake）是 TCP 连接断开的过程，它确保了数据传输的顺序性和完整性，即使在关闭连接时也避免了数据丢失。与三次握手不同，四次挥手需要四个步骤，这是因为 TCP 是全双工的，每个方向的流都需要独立地关闭。 假设客户端 A 和服务器 B 建立了 TCP 连接。现在客户端 A 决定关闭连接。 四次挥手过程详解：第一次挥手：FIN 报文段（客户端 A → 服务器 B）  客户端 A (主动关闭方)：  当客户端 A 的应用层想要关闭连接时（例如调用 close() 或 shutdown()），客户端 A 的 TCP 会发送一个带有 FIN (Finish) 标志的报文段给服务器 B。 这个 FIN 报文段的序列号通常是它发送的最后一个数据字节的序列号的下一个。 发送 FIN 后，客户端 A 进入 FIN_WAIT_1 状态。这意味着客户端 A 不再发送数据，但仍然可以接收数据。  状态变化： ESTABLISHED → FIN_WAIT_1   第二次挥手：ACK 报文段（服务器 B → 客户端 A）  服务器 B (被动关闭方)：  当...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/" title="数组和切片"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">数组和切片</div></div><div class="info-2"><div class="info-item-1">好的，数组（Array）和切片（Slice）是 Go 语言中非常核心的数据结构，它们的区别是 Go 开发者必须深刻理解的知识点。作为后端专家，我将从定义、内存、行为和使用场景四个方面，为您详细剖析它们的异同。 核心观点速览 数组 (Array)：定长的、值类型的数据结构。它是一个承载固定数量元素的容器，长度是其类型的一部分。可以把它想象成一个“固定长度的工具箱”，格子数量焊死了，不能多也不能少。 切片 (Slice)：动态的、引用类型的数据结构。它是一个对底层数组的“视图”或“窗口”。可以把它想象成一个“可调节大小的取景框”，你可以移动它，也可以调整它的大小（容量范围内），它框住的内容来自于一张大照片（底层数组）。  在 Go 的实际开发中，99% 的情况下你都应该优先使用切片。  对比表格：异同概览   特性 数组 (Array) 切片 (Slice)    定义 var a [5]int var s []int   长度 (Length) 固定的，在编译时确定。 可变的，可以在运行时通过 append 等操作改变。   类型特征 长度是类型的一部分。[5]int 和 [10]...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E7%9B%91%E6%8E%A7%20Pod/" title="监控 Pod"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">监控 Pod</div></div><div class="info-2"><div class="info-item-1">监控 Pod前面的 apiserver 实际上就是一种特殊的 Endpoints，现在我们同样来配置一个任务用来专门发现普通类型的 Endpoint，其实就是 Service 关联的 Pod 列表，由于并不是所有的 Endpoints 都会提供 metrics 接口，所以需要我们主动告诉 Prometheus 去发现哪些 Endpoints，当然告诉的方式有很多，不过约定俗成的一种方式是通过 annotations 注解进行通知，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940- job_name: &#x27;endpoints&#x27;  kubernetes_sd_configs:    - role: endpoints  relabel_configs:    # 保留 Service 的注解为 prometheus.io/scrape: true 的 Endpoints    - source_labels: [__meta_kubernetes_service...</div></div></div></a><a class="pagination-related" href="/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/" title="DHCP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">DHCP 协议</div></div><div class="info-2"><div class="info-item-1">DHCP 协议的工作原理及应用场景什么是 DHCP 协议？DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 是一种网络协议，用于自动化管理和分配网络中的 IP 地址以及其他相关配置信息（如子网掩码、默认网关、DNS 服务器地址等）。它的核心思想是取代手动配置每台设备的网络参数，实现即插即用，大大简化了大型网络的管理。 DHCP 协议的工作原理 (DORA 过程)DHCP 协议通常通过四步过程（称为 DORA 过程）来完成 IP 地址分配：  Discover (发现)  客户端行为： 当一台新设备（或一台没有配置 IP 地址的设备）连接到网络时，它不知道网络中是否有 DHCP 服务器，也不知道自己的 IP 地址。因此，它会广播一个 DHCP Discover 消息到局域网内的所有设备（使用目的 IP 地址 255.255.255.255，源 IP 地址 0.0.0.0）。 目的： 寻找网络中的 DHCP 服务器。   Offer (提供)  服务器行为： 网络中的 DHCP 服务器收到 DHCP Discover 消息后，会从...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BC%93%E5%AD%98%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">为什么需要缓存静态文件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx-%E4%B8%AD%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98%E7%9A%84%E5%85%B3%E9%94%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">Nginx 中配置静态文件缓存的关键指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%85%8D%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98-Browser-Caching"><span class="toc-number">2.1.</span> <span class="toc-text">1. 配置浏览器缓存 (Browser Caching)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE-Nginx-%E8%87%AA%E8%BA%AB%E7%BC%93%E5%AD%98-Proxy-Caching"><span class="toc-number">2.2.</span> <span class="toc-text">2. 配置 Nginx 自身缓存 (Proxy Caching)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ETag-%E5%92%8C-If-Modified-Since-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82"><span class="toc-number">2.3.</span> <span class="toc-text">3. ETag 和 If-Modified-Since (条件请求)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">最佳实践总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>