<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux tcpdump 命令 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="作为一名运维工程师，tcpdump 是我进行网络故障排查和性能分析时不可或缺的“瑞士军刀”。它是一个基于命令行的数据包捕获工具，能够截获并显示通过网络接口的数据包。无论是在诊断网络连接问题、分析协议行为、检测异常流量，还是验证防火墙规则时，tcpdump 都扮演着至关重要的角色。  一、tcpdump 简介 功能： 捕获网络接口上符合指定条件的数据包，并将其内容打印到标准输出或保存到文件中。 原理">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux tcpdump 命令">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/Linux%20tcpdump%20%E5%91%BD%E4%BB%A4/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="作为一名运维工程师，tcpdump 是我进行网络故障排查和性能分析时不可或缺的“瑞士军刀”。它是一个基于命令行的数据包捕获工具，能够截获并显示通过网络接口的数据包。无论是在诊断网络连接问题、分析协议行为、检测异常流量，还是验证防火墙规则时，tcpdump 都扮演着至关重要的角色。  一、tcpdump 简介 功能： 捕获网络接口上符合指定条件的数据包，并将其内容打印到标准输出或保存到文件中。 原理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:48:22.702Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux tcpdump 命令",
  "url": "https://huiaz.github.io/2025/09/11/Linux%20tcpdump%20%E5%91%BD%E4%BB%A4/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:48:22.702Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/Linux%20tcpdump%20%E5%91%BD%E4%BB%A4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux tcpdump 命令',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux tcpdump 命令</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux tcpdump 命令</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:48:22.702Z" title="更新于 2025-09-11 21:48:22">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/Command/">Command</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>作为一名运维工程师，<code>tcpdump</code> 是我进行网络故障排查和性能分析时不可或缺的“瑞士军刀”。它是一个基于命令行的数据包捕获工具，能够截获并显示通过网络接口的数据包。无论是在诊断网络连接问题、分析协议行为、检测异常流量，还是验证防火墙规则时，<code>tcpdump</code> 都扮演着至关重要的角色。</p>
<hr>
<h3 id="一、tcpdump-简介"><a href="#一、tcpdump-简介" class="headerlink" title="一、tcpdump 简介"></a>一、<code>tcpdump</code> 简介</h3><ul>
<li><strong>功能：</strong> 捕获网络接口上符合指定条件的数据包，并将其内容打印到标准输出或保存到文件中。</li>
<li><strong>原理：</strong> <code>tcpdump</code> 使用 <code>libpcap</code> 库来与网络接口进行交互，接收、过滤和解析流经接口的数据包。它工作在数据链路层，能够看到IP层及以上的所有协议数据。</li>
<li><strong>应用场景：</strong><ul>
<li><strong>诊断连通性问题：</strong> 验证客户端&#x2F;服务器之间是否有数据包传输。</li>
<li><strong>分析协议行为：</strong> 深入了解 HTTP、DNS、SSH 等协议的具体交互过程。</li>
<li><strong>排查防火墙问题：</strong> 确认流量是否被防火墙阻拦。</li>
<li><strong>检测异常流量：</strong> 发现端口扫描、拒绝服务攻击（DoS）的迹象。</li>
<li><strong>性能瓶颈分析：</strong> 识别延迟、丢包等网络性能问题。</li>
<li><strong>验证流量转发：</strong> 检查路由和 NAT 是否按预期工作。</li>
<li><strong>安全审计：</strong> 监控关键系统的网络活动。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、tcpdump-的基本使用方法"><a href="#二、tcpdump-的基本使用方法" class="headerlink" title="二、tcpdump 的基本使用方法"></a>二、<code>tcpdump</code> 的基本使用方法</h3><p>最简单的 <code>tcpdump</code> 命令会捕获所有流经默认网络接口的数据包并打印出来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 运行 <code>tcpdump</code> 通常需要 <code>root</code> 权限。若输出太快，可使用 <code>Ctrl+C</code> 停止。</p>
<p><strong>默认输出格式解释：</strong><br><code>tcpdump</code> 的输出由多列组成，通常包含：<br><code>时间戳 协议 源IP.源端口 &gt; 目的IP.目的端口 标志位 序号 确认号 窗口大小 选项 [数据长度]</code></p>
<p>示例：<br><code>15:00:00.123456 IP 192.168.1.10.54321 &gt; 192.168.1.1.80: Flags [S], seq 123, win 29200, length 0</code></p>
<ul>
<li><code>15:00:00.123456</code>: 数据包捕获的时间戳。</li>
<li><code>IP</code>: 协议类型 (此处是 IP)。</li>
<li><code>192.168.1.10.54321</code>: 源 IP 地址和端口。</li>
<li><code>192.168.1.1.80</code>: 目的 IP 地址和端口。</li>
<li><code>Flags [S]</code>: TCP 标志位，<code>S</code> 表示 SYN (同步)，用于建立连接。</li>
<li><code>seq 123</code>: TCP 序列号。</li>
<li><code>win 29200</code>: TCP 窗口大小。</li>
<li><code>length 0</code>: 应用层数据长度。</li>
</ul>
<hr>
<h3 id="三、tcpdump-的常用选项"><a href="#三、tcpdump-的常用选项" class="headerlink" title="三、tcpdump 的常用选项"></a>三、<code>tcpdump</code> 的常用选项</h3><h4 id="1-指定网络接口-i"><a href="#1-指定网络接口-i" class="headerlink" title="1. 指定网络接口 (-i)"></a>1. 指定网络接口 (<code>-i</code>)</h4><p>默认情况下，<code>tcpdump</code> 会选择第一个活动的网络接口。在多网卡系统中，务必指定接口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0             <span class="comment"># 捕获 eth0 接口上的流量</span></span><br><span class="line">tcpdump -i any              <span class="comment"># 捕获所有接口上的流量</span></span><br><span class="line">tcpdump -i lo               <span class="comment"># 捕获回环接口上的流量 (用于调试本地进程间网络通信)</span></span><br></pre></td></tr></table></figure>
<p>可以使用 <code>ip a</code> 或 <code>ifconfig</code> 命令查看系统上的网络接口名称。</p>
<h4 id="2-显示详细信息-v-vv-vvv"><a href="#2-显示详细信息-v-vv-vvv" class="headerlink" title="2. 显示详细信息 (-v, -vv, -vvv)"></a>2. 显示详细信息 (<code>-v</code>, <code>-vv</code>, <code>-vvv</code>)</h4><p>这些选项会增加输出的详细程度，对于协议分析非常有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -v                  <span class="comment"># 更详细的输出，如 TTL、ID 等</span></span><br><span class="line">tcpdump -vv                 <span class="comment"># 再详细一些，如 HTTP-INFO</span></span><br><span class="line">tcpdump -vvv                <span class="comment"># 最详细输出</span></span><br></pre></td></tr></table></figure>

<h4 id="3-不解析主机名和端口号-n-nn"><a href="#3-不解析主机名和端口号-n-nn" class="headerlink" title="3. 不解析主机名和端口号 (-n, -nn)"></a>3. 不解析主机名和端口号 (<code>-n</code>, <code>-nn</code>)</h4><ul>
<li><code>-n</code>: 不进行主机名解析，直接显示 IP 地址。这会加快捕获速度，并避免DNS解析延时。</li>
<li><code>-nn</code>: 不进行主机名和端口号解析，直接显示 IP 地址和端口号。在排查问题时非常推荐，可以避免误解服务名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -i eth0</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-显示数据包内容-A-X-XX"><a href="#4-显示数据包内容-A-X-XX" class="headerlink" title="4. 显示数据包内容 (-A, -X, -XX)"></a>4. 显示数据包内容 (<code>-A</code>, <code>-X</code>, <code>-XX</code>)</h4><ul>
<li><code>-A</code>: 以 ASCII 码形式打印每个数据包的载荷 (Payload)。适用于查看 HTTP 请求&#x2F;响应、纯文本协议内容。</li>
<li><code>-X</code>: 以十六进制和 ASCII 码形式打印每个数据包的载荷。适用于查看二进制协议或更详细的数据结构。</li>
<li><code>-XX</code>: 与 <code>-X</code> 类似，但还包含链路层头信息 (如以太网头)。</li>
</ul>
<h4 id="5-限制捕获数量-c"><a href="#5-限制捕获数量-c" class="headerlink" title="5. 限制捕获数量 (-c)"></a>5. 限制捕获数量 (<code>-c</code>)</h4><p>指定捕获多少个数据包后停止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -c 10 -i eth0       <span class="comment"># 捕获 10 个数据包后停止</span></span><br></pre></td></tr></table></figure>

<h4 id="6-将捕获写入文件-w"><a href="#6-将捕获写入文件-w" class="headerlink" title="6. 将捕获写入文件 (-w)"></a>6. 将捕获写入文件 (<code>-w</code>)</h4><p>将捕获的数据包保存到文件中，以便后续使用 <code>tcpdump -r</code> 或 Wireshark 等工具进行离线分析。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w traffic.pcap -i eth0</span><br></pre></td></tr></table></figure>
<ul>
<li><code>.pcap</code> 是标准的数据包捕获文件格式。</li>
</ul>
<h4 id="7-从文件读取捕获-r"><a href="#7-从文件读取捕获-r" class="headerlink" title="7. 从文件读取捕获 (-r)"></a>7. 从文件读取捕获 (<code>-r</code>)</h4><p>读取之前使用 <code>-w</code> 保存的 <code>.pcap</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -r traffic.pcap</span><br><span class="line">tcpdump -r traffic.pcap -nn -A  <span class="comment"># 读取并以 ASCII 码显示内容</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、tcpdump-强大的过滤表达式"><a href="#四、tcpdump-强大的过滤表达式" class="headerlink" title="四、tcpdump 强大的过滤表达式"></a>四、<code>tcpdump</code> 强大的过滤表达式</h3><p>过滤表达式是 <code>tcpdump</code> 的核心，允许你只捕获感兴趣的流量，大大减少输出量，提高分析效率。过滤表达式可以组合使用逻辑运算符 (<code>and</code>, <code>or</code>, <code>not</code>)。</p>
<h4 id="1-协议类型过滤"><a href="#1-协议类型过滤" class="headerlink" title="1. 协议类型过滤"></a>1. 协议类型过滤</h4><ul>
<li><code>tcp</code>: 只捕获 TCP 包。</li>
<li><code>udp</code>: 只捕获 UDP 包。</li>
<li><code>icmp</code>: 只捕获 ICMP 包 (如 <code>ping</code>)。</li>
<li><code>arp</code>: 只捕获 ARP 包。</li>
<li><code>ip</code>: 只捕获 IP 包。</li>
<li><code>net</code>: 只捕获网络层的特定协议（如 <code>ip</code>, <code>ip6</code>, <code>arp</code>）。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 tcp           <span class="comment"># 捕获 TCP 流量</span></span><br><span class="line">tcpdump -i eth0 icmp          <span class="comment"># 捕获 ping 包</span></span><br></pre></td></tr></table></figure>

<h4>2. 主机过滤 (<code>host</code>)</h4>

<ul>
<li><code>host &lt;ip_address&gt;</code>: 捕获与指定 IP 地址相关的所有流量（作为源或目的）。</li>
<li><code>src host &lt;ip_address&gt;</code>: 只捕获源 IP 为指定地址的流量。</li>
<li><code>dst host &lt;ip_address&gt;</code>: 只捕获目的 IP 为指定地址的流量。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 host 192.168.1.100    <span class="comment"># 与 192.168.1.100 相关的流量</span></span><br><span class="line">tcpdump -i eth0 src host 192.168.1.100 <span class="comment"># 源自 192.168.1.100 的流量</span></span><br></pre></td></tr></table></figure>

<h4 id="3-端口过滤-port"><a href="#3-端口过滤-port" class="headerlink" title="3. 端口过滤 (port)"></a>3. 端口过滤 (<code>port</code>)</h4><ul>
<li><code>port &lt;port_number&gt;</code>: 捕获与指定端口号相关的所有流量（作为源或目的）。</li>
<li><code>src port &lt;port_number&gt;</code>: 只捕获源端口为指定端口的流量。</li>
<li><code>dst port &lt;port_number&gt;</code>: 只捕获目的端口为指定端口的流量。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 port 80             <span class="comment"># 捕获所有 http 流量 (80 端口)</span></span><br><span class="line">tcpdump -i eth0 dst port 22         <span class="comment"># 捕获所有发往 22 端口的 SSH 流量</span></span><br></pre></td></tr></table></figure>

<h4 id="4-网络过滤-net"><a href="#4-网络过滤-net" class="headerlink" title="4. 网络过滤 (net)"></a>4. 网络过滤 (<code>net</code>)</h4><ul>
<li><code>net &lt;network_address&gt;</code>: 捕获与指定网段相关的所有流量。</li>
<li><code>src net &lt;network_address&gt;</code>: 只捕获源 IP 在指定网段的流量。</li>
<li><code>dst net &lt;network_address&gt;</code>: 只捕获目的 IP 在指定网段的流量。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 net 192.168.1.0/24  <span class="comment"># 捕获与 192.168.1.0/24 网段相关的流量</span></span><br></pre></td></tr></table></figure>

<h4 id="5-组合过滤表达式"><a href="#5-组合过滤表达式" class="headerlink" title="5. 组合过滤表达式"></a>5. 组合过滤表达式</h4><p>使用 <code>and</code> (或 <code>&amp;&amp;</code>), <code>or</code> (或 <code>||</code>), <code>not</code> (或 <code>!</code>) 组合多个过滤条件。<br><strong>注意：</strong> 组合时，为避免歧义，复杂表达式建议使用括号 <code>()</code>，但括号在 shell 中有特殊含义，需要用引号 <code>&#39;&#39;</code> 或 <code>\</code> 转义。</p>
<p><strong>示例：</strong></p>
<ul>
<li><strong>捕获来自 192.168.1.100 的发往 80 端口的 TCP 流量：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -i eth0 <span class="string">&#x27;src host 192.168.1.100 and tcp dst port 80&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>捕获除了 SSH (22) 和 HTTP (80) 以外的 TCP 流量：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -i eth0 <span class="string">&#x27;tcp and not (port 22 or port 80)&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>捕获 HTTP 请求 (假设是 GET 方法):</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 捕获目的端口是80的tcp流量，并且数据包中有&quot;GET&quot;字符串（区分大小写）</span></span><br><span class="line">tcpdump -nn -A -i eth0 <span class="string">&#x27;tcp dst port 80 and (tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420)&#x27;</span></span><br><span class="line"><span class="comment"># ^ 这是一个高级过滤方式，表示 TCP payload 的前 4 个字节等于 &quot;GET &quot; 的 ASCII 码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单点的，直接捕获到文件再用 grep 过滤可能更快：</span></span><br><span class="line"><span class="comment"># tcpdump -w http.pcap -nn -i eth0 tcp dst port 80</span></span><br><span class="line"><span class="comment"># strings http.pcap | grep &quot;GET /&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="五、tcpdump-实际故障排查案例"><a href="#五、tcpdump-实际故障排查案例" class="headerlink" title="五、tcpdump 实际故障排查案例"></a>五、<code>tcpdump</code> 实际故障排查案例</h3><p><strong>故障场景：</strong> Web服务器无法连接到数据库服务器，应用程序报错“无法连接数据库”。<code>ping</code> 数据库服务器正常。</p>
<ol>
<li><p><strong>确认问题出在哪里：</strong></p>
<ul>
<li><code>ping</code> 正常表示 IP 层连通性正常，网络路由可能没问题。</li>
<li>应用程序报错是连接层面。</li>
<li>检查数据库服务（MySQL）本身是否运行：<code>systemctl status mysql</code>，确认运行正常。</li>
</ul>
</li>
<li><p><strong>在 Web 服务器上捕获流量：</strong><br>我们怀疑是 Web 服务器到数据库服务器的连接问题，所以在 Web 服务器上使用 <code>tcpdump</code> 捕获到数据库服务器的 MySQL 端口 (3306) 流量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Web 服务器上执行</span></span><br><span class="line">tcpdump -nn -i eth0 <span class="string">&#x27;host &lt;DB_SERVER_IP&gt; and tcp port 3306&#x27;</span> -c 100 -s 0 -w /tmp/db_conn_issue.pcap</span><br><span class="line"><span class="comment"># -i eth0: 指定网卡</span></span><br><span class="line"><span class="comment"># host &lt;DB_SERVER_IP&gt;: 过滤掉其他IP的流量，只看数据库服务器的流量</span></span><br><span class="line"><span class="comment"># tcp port 3306: 只看3306端口的TCP流量</span></span><br><span class="line"><span class="comment"># -c 100: 捕获100个包后停止，防止文件过大</span></span><br><span class="line"><span class="comment"># -s 0: 不截断数据包，完全捕获数据包内容（默认为65535，即不截断）</span></span><br><span class="line"><span class="comment"># -w /tmp/db_conn_issue.pcap: 保存到文件，方便后面用Wireshark分析</span></span><br></pre></td></tr></table></figure>
<p>同时，触发一次应用程序连接数据库的操作（如刷新网页）。</p>
</li>
<li><p><strong>分析捕获结果：</strong></p>
<p>a. <strong>直接在命令行查看简要信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -r /tmp/db_conn_issue.pcap</span><br></pre></td></tr></table></figure>
<p><strong>可能发现的现象及解释：</strong></p>
<ul>
<li><p><strong>只有 SYN 包，没有 SYN-ACK 包：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;WEB_IP&gt;<span class="string">.54321</span> &gt; &lt;DB_IP&gt;<span class="string">.3306</span>: Flags [S], seq <span class="string">...</span> length 0</span><br><span class="line">&lt;WEB_IP&gt;<span class="string">.54322</span> &gt; &lt;DB_IP&gt;<span class="string">.3306</span>: Flags [S], seq <span class="string">...</span> length 0</span><br><span class="line"><span class="string">...</span> <span class="params">(反复出现 SYN 包)</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong> Web服务器发送了连接请求 (SYN)，但数据库服务器没有响应 (SYN-ACK)。<br><strong>原因：</strong></p>
<ol>
<li><strong>数据库服务器防火墙阻拦：</strong> 数据库服务器的 3306 端口可能没有对 Web 服务器开放。</li>
<li><strong>网络ACL&#x2F;安全组问题：</strong> 云环境中，安全组可能阻止了入站流量。</li>
<li><strong>数据库服务未监听或端口错误：</strong> MySQL 服务可能没有在 3306 端口监听，或者监听的地址不对 (例如只监听了 <code>127.0.0.1</code>)。</li>
</ol>
<p><strong>进一步排查：</strong></p>
<ul>
<li>在<strong>数据库服务器</strong>上执行 <code>tcpdump -nn -i eth0 &#39;host &lt;WEB_IP&gt; and tcp port 3306&#39;</code>，看能否收到 Web 服务器发来的 SYN 包。如果能收到，说明网络路径没问题，问题出在数据库服务器本身。</li>
<li>在<strong>数据库服务器</strong>上检查防火墙 (<code>firewalld</code>, <code>ufw</code>, <code>iptables</code>) 规则。</li>
<li>检查 MySQL 配置 (<code>my.cnf</code>)，确认 <code>bind-address</code> 和 <code>port</code> 设置是否正确。</li>
</ul>
</li>
<li><p><strong>看到 SYN, SYN-ACK，但没有 ACK 或 RST：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;WEB_IP&gt;<span class="string">.54321</span> &gt; &lt;DB_IP&gt;<span class="string">.3306</span>: Flags [S], seq <span class="string">...</span> length 0</span><br><span class="line">&lt;DB_IP&gt;<span class="string">.3306</span> &gt; &lt;WEB_IP&gt;<span class="string">.54321</span>: Flags [S.], seq <span class="string">...</span>, ack <span class="string">...</span>, length 0</span><br><span class="line"><span class="string">...</span> <span class="params">(没有第三个包)</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong> 数据库服务器成功响应用 <code>SYN-ACK</code>，但 Web 服务器没有发送最终的 <code>ACK</code> 包完成三次握手。<br><strong>原因：</strong></p>
<ol>
<li><strong>Web服务器防火墙阻拦：</strong> Web 服务器出站或入站的某些规则可能阻止了响应流量。</li>
<li><strong>网络ACL&#x2F;安全组问题：</strong> Web服务器的出站安全组可能阻止了 ACK 包。</li>
<li><strong>Web服务器端口耗尽：</strong> 连接数过多，可用临时端口耗尽。</li>
</ol>
</li>
<li><p><strong>看到 RST (复位) 包：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;WEB_IP&gt;<span class="string">.54321</span> &gt; &lt;DB_IP&gt;<span class="string">.3306</span>: Flags [S], seq <span class="string">...</span> length 0</span><br><span class="line">&lt;DB_IP&gt;<span class="string">.3306</span> &gt; &lt;WEB_IP&gt;<span class="string">.54321</span>: Flags [R.], seq <span class="string">...</span>, ack <span class="string">...</span>, win 0, length 0</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong> 数据库服务器收到了 SYN 包，但立即发送了一个 RST 包，表示连接被拒绝。<br><strong>原因：</strong></p>
<ol>
<li><strong>连接数超出限制：</strong> 数据库服务器当前连接数已达到上限。</li>
<li><strong>账号密码错误：</strong> 通常在三次握手后，应用层认证失败才会导致断开，但有时配置错误也可能在连接建立初期就 RST。</li>
<li><strong>服务异常：</strong> 数据库服务可能内部错误导致无法接受新连接。</li>
</ol>
</li>
</ul>
<p>b. <strong>使用 Wireshark 进行图形化分析：</strong><br>对于复杂的场景，将 <code>.pcap</code> 文件下载到本地，用 Wireshark 打开能提供更直观、强大的分析能力，包括：</p>
<ul>
<li>TCP Stream Reassembly (重组TCP流，看到应用层数据)</li>
<li>Expert Information (专家信息，快速识别异常)</li>
<li>Follow TCP Stream (跟踪单个TCP会话)</li>
<li>统计图表</li>
</ul>
<p>通过 Wireshark 的“专家信息”或“跟踪 TCP 流”，可以清晰地看到三次握手是否完成，以及是否有应用层协议数据（如 MySQL 协议的认证消息）被发送或接收。</p>
</li>
</ol>
<h3 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h3><ul>
<li><strong>权限：</strong> <code>tcpdump</code> 通常需要 <code>root</code> 权限。</li>
<li><strong>性能影响：</strong> 在高流量的生产环境中捕获所有数据包可能会引起显著的 CPU 和内存开销。务必使用精确的过滤条件，并限制捕获时间或数量。</li>
<li><strong>环形缓冲区：</strong> 对于长时间的捕获，可以结合 <code>split</code> 或 <code>rotat</code> 选项创建多个文件，形成环形缓冲区，避免单个文件过大：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w traffic-%Y%m%d%H%M%S.pcap -G 3600 -C 100 -i eth0 host &lt;IP&gt;</span><br><span class="line"><span class="comment"># -G 3600: 每 3600 秒 (1小时) 创建一个新文件</span></span><br><span class="line"><span class="comment"># -C 100: 每个文件最大 100MB</span></span><br></pre></td></tr></table></figure></li>
<li><strong>隐私和安全：</strong> 捕获的数据包可能包含敏感信息（如密码、API 密钥）。在非信任环境中操作时要小心，并且分析完后及时删除捕获文件。</li>
<li><strong>不足之处：</strong> <code>tcpdump</code> 捕获的是已经到达网卡的数据包。如果问题发生在更早的层面（如硬件故障、网线未插紧），<code>tcpdump</code> 可能什么都捕获不到。</li>
</ul>
<p>掌握 <code>tcpdump</code> 的使用，不仅能快速定位网络层故障，还能帮助我们更深入地理解网络协议，是任何运维工程师的必备技能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/Linux%20tcpdump%20%E5%91%BD%E4%BB%A4/">https://huiaz.github.io/2025/09/11/Linux%20tcpdump%20%E5%91%BD%E4%BB%A4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Linux%20%E4%B8%AD%E7%9A%84%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/" title="Linux 中的硬链接和软连接"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux 中的硬链接和软连接</div></div><div class="info-2"><div class="info-item-1">1. 硬链接 (Hard Link)定义：硬链接是文件系统中的一种特殊引用，它指向文件系统中的同一个文件 inode（索引节点）。简单来说，一个硬链接就是原始文件的一个别名，它们共享同一个 inode。 inode 包含了文件的所有元数据，如文件类型、权限、所有者、组、大小以及数据的物理位置等信息。 创建方式：使用 ln 命令创建硬链接： 1ln [原始文件] [硬链接文件]  特点：  共享 inode： 原始文件和硬链接文件共享同一个 inode 号。你可以通过 ls -i 命令来查看。 同等地位： 对于操作系统来说，硬链接和原始文件是完全平等的。它们只是同一个文件内容的两个不同入口。 不能跨文件系统： 硬链接只能在同一个文件系统内部创建，因为 inode 号在不同的文件系统上是独立的。 不能链接目录： 出于文件系统结构完整性和避免循环引用等复杂性，不允许创建指向目录的硬链接。 删除特性： 删除硬链接文件不会影响原始文件，也不会影响其他硬链接文件，只要还有至少一个硬链接指向该 inode，文件内容就不会被删除。 只有当所有指向该 inode 的硬链接都被删除后，操作系统才会释...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Kubernetes%20%E5%AE%89%E5%85%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E7%BD%AE%E3%80%81/" title="Kubernetes 安全上下文设置、"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Kubernetes 安全上下文设置、</div></div><div class="info-2"><div class="info-item-1">Kubernetes 安全上下文设置在 Kubernetes 中安全地运行工作负载是很困的，有很多配置都可能会影响到整个 Kubernetes API 的安全性，这需要我们有大量的知识积累来正确的实施。Kubernetes 在安全方面提供了一个强大的工具 securityContext，每个 Pod 和容器清单都可以使用这个属性。在本文中我们将了解各种 securityContext 的配置，探讨它们的含义，以及我们应该如何使用它们。  securityContext 设置在 PodSpec 和ContainerSpec 规范中都有定义，这里我们分别用[P]和[C]来表示。需要注意的是，如果一个设置在两个作用域中都可以使用和配置，那么我们应该优先考虑设置容器级别的。  1. runAsNonRoot [P&#x2F;C]我们知道容器是使用 namespaces 和 cgroups 来限制其进程，但只要在部署的时候做了一次错误的配置，就可以让这些进程访问主机上的资源。如果该进程以 root 身份运行，它对这些资源的访问权限与主机 root 账户是相同的。此外，如果其他 pod 或容...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Linux%20%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4/" title="Linux 排查命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 排查命令</div></div><div class="info-2"><div class="info-item-1">(1) 如何在 Linux 中查看系统资源使用情况？比如内存、CPU、网络端口。  一、 CPU 使用情况1. top 命令 (实时交互式)top 命令是最常用的 CPU 监控工具，它提供了一个实时更新的进程列表，并显示 CPU 使用率、内存使用率、进程 ID (PID)、用户、运行时间等信息。 1top  关键信息解读：  第一行（top line）： load average 显示了过去 1、5、15 分钟的系统平均负载。这是衡量系统忙碌程度的重要指标，数值大于 CPU 核心数时通常表示系统存在瓶颈。 第二行（Tasks）： 显示进程总数，以及运行、睡眠、停止和僵尸进程的数量。 第三行（Cpu(s)）： 显示 CPU 的使用率，各项指标含义如下： us (user): 用户空间程序的 CPU 使用率。 sy (system): 内核空间程序的 CPU 使用率。 ni (nice): 改变过优先级的用户进程的 CPU 使用率。 id (idle): 空闲 CPU 百分比。 wa (iowait): CPU 等待 I&#x2F;O 操作完成的百分比。 hi (hardware i...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86/" title="Linux 系统中的内核模块管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 系统中的内核模块管理</div></div><div class="info-2"><div class="info-item-1">Linux 内核模块的管理 一、Linux 内核模块的工作原理Linux 内核采用模块化的设计思想，其核心功能是模块化实现的。  模块化设计： 内核自身只包含最核心的功能，而将许多非核心但必要的功能（如：网卡驱动、显卡驱动、文件系统驱动、USB 支持、加密算法等）设计成可以随时加载和卸载的模块。 动态加载&#x2F;卸载： 当系统需要某个功能时（例如，插入了一个USB设备，或是需要访问某种特定的文件系统），对应的内核模块会被动态加载到内核空间中运行；当该功能不再需要时，模块可以被卸载，从而释放内存资源。 优点： 减小内核镜像大小： 核心内核保持精简，只需要加载必需的模块。 提高灵活性： 无需重新编译整个内核就能添加或更新驱动、文件系统等功能。 节省内存： 不使用的模块可以卸载，释放内存。 方便调试： 可以在运行时加载新的或修改过的模块进行测试。   模块文件： 内核模块通常以 .ko（kernel object）为扩展名，存储在 /lib/modules/&lt;kernel-version&gt;/ 目录下，按照类别（如 kernel/drivers、kernel/fs、ker...</div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-network/" title="Docker Network"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Docker Network</div></div><div class="info-2"><div class="info-item-1">|————— | :——- | :——- | :——- | :——————————— || Bridge (自定义) | 高   | 好   | 低   | 绝大多数应用，特别是多容器应用 || Host            | 无       | 最佳 | 极低 | 追求极致性能，端口不冲突的场景     || Overlay         | 高       | 中等     | 中等     | 多主机&#x2F;Docker Swarm 集群通信   || Macvlan         | 高       | 好       | 中等     | 需要容器作为物理网络独立设备的场景 || None            | 完全 | N&#x2F;A      | 极低     | 无网络需求的任务                   | 作为运维工程师，我的首选建议是：为你的多容器应用创建一个自定义的 bridge 网络。这提供了最好的平衡点——良好的隔离性、服务发现能力、可接受的性能和简单的管理。仅在有特殊需求时，才考虑其他网络模式。 </div></div></div></a><a class="pagination-related" href="/2025/09/11/docker-dockerfile/" title="Dockerfile"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Dockerfile</div></div><div class="info-2"><div class="info-item-1">一、Dockerfile 的作用Dockerfile 是一个文本文件，其核心作用是定义了构建一个 Docker 镜像所需的所有步骤和指令。它就像一份自动化的“安装说明书”或“烹饪菜谱”，Docker 根据这份说明书，就能一步不差地构建出一个标准、一致的镜像。 它的主要作用体现在：  **自动化构建 (Automation)**：将手动配置环境的繁琐步骤（安装依赖、复制文件、设置环境变量等）代码化，实现了构建过程的全自动。 **可重复性 (Reproducibility)**：只要 Dockerfile 不变，无论在谁的机器上、在什么时间执行构建，最终得到的镜像内容都是完全一致的，这从根本上保证了环境的一致性。 **版本控制 (Versioning)**：Dockerfile 可以像代码一样存放在 Git 等版本控制系统中进行管理。每一次对环境的变更，都可以通过修改 Dockerfile 并提交记录来追溯，使得环境演进有迹可循。 **透明性与审查 (Transparency &amp; Auditing)**：任何团队成员都可以通过阅读 Dockerfile，清晰地了解到一个镜像是...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E4%B8%AD%20df%20%E4%B8%8E%20du%20%E5%8C%BA%E5%88%AB/" title="Linux 中 df 与 du 区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 中 df 与 du 区别</div></div><div class="info-2"><div class="info-item-1">df 和 du 是日常工作中用于查看磁盘使用情况的两个最基本也是最重要的命令。它们都与磁盘空间有关，但它们的工作原理、关注点以及提供的信息维度截然不同。理解这两者的区别至关重要，因为它能帮助我们准确地判断磁盘空间问题，而不是被表象所迷惑。  一、df (disk free)df 命令用于报告文件系统的磁盘空间使用情况。它读取的是文件系统的超级块（superblock）信息，反映的是文件系统层面上的整体空间统计。 1. 核心特点： 报告文件系统总览： 关注的是整个文件系统（分区、挂载点）的使用情况。 读取文件系统元数据： 它直接查询文件系统的元数据（如 inode 表、块位图等），来得知已用、可用空间和总容量。 速度快： 由于只读取元数据，不遍历文件，所以执行速度通常很快。 计算已挂载文件系统： 只能报告已挂载的文件系统，包括本地磁盘、网络文件系统（NFS, Samba&#x2F;CIFS）、虚拟文件系统等。 显示已分配但未释放的空间： 如果文件被删除但仍被进程占用（即文件句柄未释放），df 会将这部分空间计入“已用”空间，因为它对文件系统来说这部分空间是“被占用的”。  2. 常...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/" title="Linux 内存异常排查"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 内存异常排查</div></div><div class="info-2"><div class="info-item-1">一、什么是 Linux 系统中的内存泄漏？简单来说，内存泄漏（Memory Leak） 指的是程序在运行过程中，动态地申请了内存空间（例如 C 语言的 malloc() 或 Java 的 new），但在使用完毕后，没有按预期释放（或无法被垃圾回收器回收）。 结果是，这部分内存既不能被当前程序再次使用，也无法被操作系统回收分配给其他程序。从操作系统的视角看，这块内存一直被该程序“合法”地占用着。随着时间的推移，泄漏的内存积少成多，最终会耗尽系统的可用物理内存和交换空间（Swap）。 一个常见的误解：很多时候，新手会把 Linux 的文件系统缓存（Cache）误认为是内存泄漏。Linux 内核会尽可能地利用空闲内存来缓存磁盘读写数据，以提高性能。在 free -h 命令中，这部分内存会显示在 buff/cache 列。这是正常且有益的行为，当应用程序需要更多内存时，内核会自动收缩这部分缓存来满足需求。 真正的内存泄漏迹象是 available（可用内存）持续、不可逆地减少，而不是 free（空闲内存）的减少。 二、内存泄漏的典型症状作为运维，我们通常不是直接看到代码，而是通过以下系统...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81tcpdump-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、tcpdump 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81tcpdump-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">二、tcpdump 的基本使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81tcpdump-%E7%9A%84%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9"><span class="toc-number">3.</span> <span class="toc-text">三、tcpdump 的常用选项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8C%87%E5%AE%9A%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3-i"><span class="toc-number">3.1.</span> <span class="toc-text">1. 指定网络接口 (-i)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%98%BE%E7%A4%BA%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF-v-vv-vvv"><span class="toc-number">3.2.</span> <span class="toc-text">2. 显示详细信息 (-v, -vv, -vvv)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%8D%E8%A7%A3%E6%9E%90%E4%B8%BB%E6%9C%BA%E5%90%8D%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7-n-nn"><span class="toc-number">3.3.</span> <span class="toc-text">3. 不解析主机名和端口号 (-n, -nn)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%8C%85%E5%86%85%E5%AE%B9-A-X-XX"><span class="toc-number">3.4.</span> <span class="toc-text">4. 显示数据包内容 (-A, -X, -XX)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%99%90%E5%88%B6%E6%8D%95%E8%8E%B7%E6%95%B0%E9%87%8F-c"><span class="toc-number">3.5.</span> <span class="toc-text">5. 限制捕获数量 (-c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%B0%86%E6%8D%95%E8%8E%B7%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6-w"><span class="toc-number">3.6.</span> <span class="toc-text">6. 将捕获写入文件 (-w)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%8D%95%E8%8E%B7-r"><span class="toc-number">3.7.</span> <span class="toc-text">7. 从文件读取捕获 (-r)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81tcpdump-%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%BF%87%E6%BB%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">四、tcpdump 强大的过滤表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B%E8%BF%87%E6%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">1. 协议类型过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.2.</span> <span class="toc-text">2. 主机过滤 (host)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%AB%AF%E5%8F%A3%E8%BF%87%E6%BB%A4-port"><span class="toc-number">4.3.</span> <span class="toc-text">3. 端口过滤 (port)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4-net"><span class="toc-number">4.4.</span> <span class="toc-text">4. 网络过滤 (net)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BB%84%E5%90%88%E8%BF%87%E6%BB%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">5. 组合过滤表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81tcpdump-%E5%AE%9E%E9%99%85%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%A1%88%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">五、tcpdump 实际故障排查案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.</span> <span class="toc-text">六、注意事项</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>