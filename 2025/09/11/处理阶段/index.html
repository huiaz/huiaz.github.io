<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>处理阶段 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Nginx 处理 HTTP 请求的核心模型Nginx 采用事件驱动（Event-Driven）、异步非阻塞（Asynchronous Non-Blocking I&#x2F;O）的架构。这意味着 Nginx 不会为每个新连接创建一个新的进程或线程。相反，它使用少量的工作进程 (worker processes) 通过事件循环（event loop）来监听和处理大量的并发连接。 当一个客户端连接接入">
<meta property="og:type" content="article">
<meta property="og:title" content="处理阶段">
<meta property="og:url" content="http://example.com/2025/09/11/%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="Nginx 处理 HTTP 请求的核心模型Nginx 采用事件驱动（Event-Driven）、异步非阻塞（Asynchronous Non-Blocking I&#x2F;O）的架构。这意味着 Nginx 不会为每个新连接创建一个新的进程或线程。相反，它使用少量的工作进程 (worker processes) 通过事件循环（event loop）来监听和处理大量的并发连接。 当一个客户端连接接入">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:10:24.991Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "处理阶段",
  "url": "http://example.com/2025/09/11/%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:10:24.991Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/11/%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '处理阶段',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">处理阶段</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">处理阶段</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:10:24.991Z" title="更新于 2025-09-11 22:10:24">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Nginx/">Nginx</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="Nginx-处理-HTTP-请求的核心模型"><a href="#Nginx-处理-HTTP-请求的核心模型" class="headerlink" title="Nginx 处理 HTTP 请求的核心模型"></a>Nginx 处理 HTTP 请求的核心模型</h3><p>Nginx 采用<strong>事件驱动（Event-Driven）</strong>、<strong>异步非阻塞（Asynchronous Non-Blocking I&#x2F;O）</strong>的架构。这意味着 Nginx 不会为每个新连接创建一个新的进程或线程。相反，它使用少量的工作进程 (worker processes) 通过事件循环（event loop）来监听和处理大量的并发连接。</p>
<p>当一个客户端连接接入时，Nginx 并不会立即为它分配一个长时间运行的资源。相反，它注册一个事件（例如“有数据可读”），然后回去处理其他连接。当那个事件发生时，Nginx 才回来处理相应的数据。这种模型使得 Nginx 在高并发场景下表现出色，内存消耗低，CPU 利用率高。</p>
<h3 id="Nginx-请求处理过程包含的阶段"><a href="#Nginx-请求处理过程包含的阶段" class="headerlink" title="Nginx 请求处理过程包含的阶段"></a>Nginx 请求处理过程包含的阶段</h3><p>Nginx 的请求处理是一个多阶段的管道（pipeline）过程。当一个请求到达 Nginx 后，它会依次经过一系列内部定义好的处理阶段。这些阶段允许 Nginx 在不同时间点执行不同的模块和指令。理解这些阶段有助于我们知道何时何地的配置指令会生效。</p>
<p>以下是 Nginx 请求处理的主要阶段（大致顺序）：</p>
<ol>
<li><p><strong>初始化阶段 (Initialization Phase)</strong></p>
<ul>
<li><strong>作用：</strong> Nginx 接收到新的客户端连接，解析连接请求头，初始化一些请求相关的内部数据结构。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li>建立 TCP 连接，完成三次握手。</li>
<li>接收并解析 HTTP 请求行（方法、URI、协议版本）和请求头。</li>
<li>Nginx 为这个请求创建一个内部 <code>ngx_http_request_t</code> 结构体，存储请求的所有信息。</li>
<li>执行 <code>server_name</code> 匹配，确定由哪个 <code>server</code> 块来处理请求。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>URI 匹配阶段 (Server&#x2F;Location Selection Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 根据请求的 URI（统一资源标识符），Nginx 查找最匹配的 <code>location</code> 块来处理请求。这是 Nginx 路由请求的核心。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li><strong><code>server_name</code>：</strong> 在初始化阶段之后，根据请求的 Host 头选择一个 <code>server</code> 块。</li>
<li><strong><code>location</code> 匹配：</strong> Nginx 按照特定的优先级顺序（精确匹配 <code>location =</code> &gt; 最长前缀匹配 <code>location ^~</code> &gt; 正则表达式匹配 <code>location ~</code> 或 <code>location ~*</code> &gt; 普通前缀匹配 <code>location /prefix</code> &gt; 通用匹配 <code>location /</code>）来匹配 <code>URI</code>。</li>
<li><strong><code>alias</code> &#x2F; <code>root</code>：</strong> 确定静态文件的根目录。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>请求头处理阶段 (Request Header Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 处理请求头信息。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li>执行一些与请求头相关的模块。</li>
<li>处理 <code>if</code> 块中与 <code>$uri</code>、<code>$args</code>、<code>$request_method</code> 等变量相关的条件判断。</li>
<li>处理 <code>set</code> 指令，设置新的 Nginx 变量。</li>
<li>进行 <code>rewrite</code> 指令（<code>server</code> 块中的 <code>rewrite</code> 会在这里执行）。如果 <code>rewrite</code> 导致 URI 改变，会重新进入 URI 匹配阶段。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>访问控制阶段 (Access Restriction Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 检查客户端是否有权限访问请求的资源。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li><strong><code>allow</code> &#x2F; <code>deny</code>：</strong> 基于 IP 地址的访问控制。</li>
<li><strong><code>auth_basic</code> &#x2F; <code>auth_basic_user_file</code>：</strong> HTTP Basic Authentication 用户密码认证。</li>
<li>其他自定义认证模块。</li>
<li>如果访问被拒绝，Nginx 会返回 <code>403 Forbidden</code> 或 <code>401 Unauthorized</code> 错误。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>认证&#x2F;授权阶段 (Authentication&#x2F;Authorization Phase)</strong></p>
<ul>
<li>这个阶段与访问控制阶段紧密相连，主要处理用户身份验证和权限判断。虽然 <code>auth_basic</code> 可以看作是访问控制的一部分，但更复杂的认证（如 OAuth2、JWT）可能会通过第三方模块在此阶段进行。</li>
</ul>
</li>
<li><p><strong>内容处理阶段 (Content Processing Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 这是请求处理的核心，根据请求的类型和 <code>location</code> 块的配置，Nginx 会决定如何生成响应内容。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li><strong><code>root</code> &#x2F; <code>alias</code>：</strong> 如果是静态文件，Nginx 会从文件系统读取文件并发送给客户端。</li>
<li><strong><code>try_files</code>：</strong> 尝试按顺序查找文件或目录，如果找不到则执行内部重定向。</li>
<li><strong><code>proxy_pass</code>：</strong> 将请求代理转发到后端服务器（如 Tomcat, Node.js）。</li>
<li><strong><code>fastcgi_pass</code> &#x2F; <code>uwsgi_pass</code> &#x2F; <code>scgi_pass</code>：</strong> 将请求转发给 FastCGI&#x2F;uWSGI&#x2F;SCGI 进程（如 PHP-FPM, Python Gunicorn）。</li>
<li><strong><code>return</code>：</strong> 直接返回一个 HTTP 状态码或重定向。</li>
<li><strong><code>index</code>：</strong> 如果请求的是目录，查找默认的索引文件。</li>
<li>执行 <code>rewrite</code> 指令（<code>location</code> 块中的 <code>rewrite</code> 会在这里执行）。如果 <code>rewrite</code> 导致 URI 改变，会重新进入 URI 匹配阶段。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>内容过滤阶段 (Filter Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 在将响应发送给客户端之前，对响应内容进行处理。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li><strong><code>gzip</code>：</strong> 启用 Gzip 压缩，减少传输大小。</li>
<li><strong><code>sub_filter</code>：</strong> 替换响应体中的字符串。</li>
<li><strong><code>chunked_transfer_encoding</code>：</strong> 启用 HTTP&#x2F;1.1 分块传输编码。</li>
<li>其他响应头修改（如 <code>add_header</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>日志记录阶段 (Log Phase)</strong></p>
<ul>
<li><strong>作用：</strong> 记录请求处理的结果。</li>
<li><strong>关键指令&#x2F;操作：</strong><ul>
<li><strong><code>access_log</code>：</strong> 将请求信息写入访问日志文件。</li>
<li><strong><code>log_format</code>：</strong> 定义日志格式。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="总结-HTTP-请求处理过程"><a href="#总结-HTTP-请求处理过程" class="headerlink" title="总结 HTTP 请求处理过程"></a>总结 HTTP 请求处理过程</h3><p>一个 HTTP 请求在 Nginx 中的处理流程大致可以概括为：</p>
<ol>
<li><strong>接收连接并解析请求头。</strong></li>
<li><strong>根据 <code>server_name</code> 匹配到合适的 <code>server</code> 块。</strong></li>
<li><strong>在 <code>server</code> 块中执行 <code>rewrite</code> 和 <code>if</code> 等指令 (如果 URI 改变，可能回到第 2 步)。</strong></li>
<li><strong>根据请求的 URI 匹配到合适的 <code>location</code> 块。</strong></li>
<li><strong>在 <code>location</code> 块中进行访问控制和认证。</strong></li>
<li><strong>在 <code>location</code> 块中执行 <code>rewrite</code> 和 <code>try_files</code> 等指令 (如果 URI 改变，可能回到第 4 步)。</strong></li>
<li><strong>确定内容处理方式：</strong><ul>
<li><strong>静态文件：</strong> 直接从文件系统读取并发送。</li>
<li><strong>反向代理：</strong> 将请求转发到后端服务器，等待响应。</li>
<li><strong>FastCGI&#x2F;uWSGI&#x2F;SCGI：</strong> 将请求转发到应用服务器进程。</li>
<li><strong>直接返回：</strong> 通过 <code>return</code> 指令直接响应。</li>
</ul>
</li>
<li><strong>对响应内容进行过滤（如 Gzip 压缩）。</strong></li>
<li><strong>发送响应头和响应体给客户端。</strong></li>
<li><strong>记录访问日志。</strong></li>
<li><strong>关闭连接。</strong></li>
</ol>
<h3 id="理解阶段的重要性"><a href="#理解阶段的重要性" class="headerlink" title="理解阶段的重要性"></a>理解阶段的重要性</h3><ul>
<li><strong>配置生效范围：</strong> 不同的指令在不同的阶段执行。例如，<code>add_header</code> 指令会在内容过滤阶段生效，而 <code>rewrite</code> 则可能在多个阶段执行。</li>
<li><strong>性能优化：</strong> 尽可能避免在每个请求中进行复杂的 <code>if</code> 和 <code>rewrite</code> 逻辑，尤其是在 <code>location /</code> 这种泛匹配块中。优先使用 <code>return</code> 命令进行简单重定向，因为它会立即终止请求处理。</li>
<li><strong>故障排查：</strong> 当请求行为不符合预期时，理解这些阶段有助于缩小问题范围，例如是 <code>location</code> 匹配有问题？还是访问控制配置不正确？或者是 <code>proxy_pass</code> 转发失败？</li>
<li><strong>自定义模块开发：</strong> 对于 Nginx 模块开发者，深入理解这些阶段是编写正确且高效模块的基础。</li>
</ul>
<p>Nginx 的请求处理流程是其高性能和灵活性的基石。作为运维工程师，熟练掌握这些概念能帮助我们更好地管理和维护 Nginx 服务器。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5/">http://example.com/2025/09/11/%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/" title="局部变量"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">局部变量</div></div><div class="info-2"><div class="info-item-1">您好！这是一个非常核心且有深度的 Go 语言问题。作为后端开发专家，我来为您详细解析。 简短的答案是：Go 语言中的局部变量分配在哪里（栈或堆），不是由开发者决定的，而是由 Go 编译器在编译时通过“逃逸分析”（Escape Analysis）来决定的。 开发者编写代码时，可以认为所有局部变量都优先分配在栈（Stack）上。只有在编译器证明一个变量的生命周期需要在其声明的函数返回后依然有效时，这个变量才会“逃逸”（escape）到堆（Heap）上。  1. 为什么优先分配在栈上？栈是为函数调用而设计的一种内存区域，具有以下显著优势：  极高的分配和回收效率： 栈内存的分配和回收仅仅是移动栈指针（SP），这是一个非常快速的 CPU 指令。当函数调用时，栈帧（stack frame）被压入栈；函数返回时，栈帧被弹出。整个过程无需复杂的内存管理和垃圾回收（GC）介入。 低 GC 压力： 因为栈上的内存在函数返回时自动回收，所以垃圾回收器不需要扫描栈上的对象，这大大减轻了 GC 的负担，提升了程序性能。 更好的缓存局部性： 栈内存通常是连续的，更容易被 CPU 缓存命中，从而提高访问速度...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6/" title="存储插件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">存储插件</div></div><div class="info-2"><div class="info-item-1">存储插件前面的章节中我们介绍了在 Kubernetes 中的持久化存储的使用，了解了 PV、PVC 以及 StorageClass 的使用方法，从本地存储到 NFS 共享存储都有学习，到这里我们其实已经可以完成应用各种场景的数据持久化了，但是难免在实际的使用过程中会遇到各种各样的问题，要解决这些问题最好的方式就是来了解下 Kubernetes 中存储的实现原理。 Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 kubectl explain pod.spec.volumes 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存储服务接入到 Kubernetes 系统中来，在 Kubernetes 中就对应 In-Tree 和 Out-Of-Tree 两种方式，In-Tree 就是在 Kubernetes 源码内部实现的，和 Kubernetes 一起发布、管理的，但是更新迭代慢、灵活性比较差，Out-Of-Tree 是独立于 Kubernetes 的，目前主要有 CSI 和 FlexVolume 两种机制，开发者可以根据自己的存储类型实现...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/NFS%20%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8/" title="NFS 共享存储"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">NFS 共享存储</div></div><div class="info-2"><div class="info-item-1">NFS 共享存储前面我们学习了 hostPath 与 Local PV 两种本地存储方式，但是平时我们的应用更多的是无状态服务，可能会同时发布在不同的节点上，这个时候本地存储就不适用了，往往就需要使用到共享存储了，比如最简单常用的网络共享存储 NFS，本节课我们就来介绍下如何在 Kubernetes 下面使用 NFS 共享存储。 安装我们这里为了演示方便，先使用相对简单的 NFS 这种存储资源，接下来我们在节点 192.168.31.31 上来安装 NFS 服务，数据目录：/var/lib/k8s/data/ 关闭防火墙 12➜ systemctl stop firewalld.service➜ systemctl disable firewalld.service    安装配置 nfs 1➜ yum -y install nfs-utils rpcbind    共享目录设置权限： 12➜ mkdir -p /var/lib/k8s/data➜ chmod 755 /var/lib/k8s/data/    配置 nfs，nfs 的默认配置文件在 /etc/exports 文...</div></div></div></a><a class="pagination-related" href="/2025/09/11/DHCP%20%E5%8D%8F%E8%AE%AE/" title="DHCP 协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">DHCP 协议</div></div><div class="info-2"><div class="info-item-1">DHCP 协议的工作原理及应用场景什么是 DHCP 协议？DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 是一种网络协议，用于自动化管理和分配网络中的 IP 地址以及其他相关配置信息（如子网掩码、默认网关、DNS 服务器地址等）。它的核心思想是取代手动配置每台设备的网络参数，实现即插即用，大大简化了大型网络的管理。 DHCP 协议的工作原理 (DORA 过程)DHCP 协议通常通过四步过程（称为 DORA 过程）来完成 IP 地址分配：  Discover (发现)  客户端行为： 当一台新设备（或一台没有配置 IP 地址的设备）连接到网络时，它不知道网络中是否有 DHCP 服务器，也不知道自己的 IP 地址。因此，它会广播一个 DHCP Discover 消息到局域网内的所有设备（使用目的 IP 地址 255.255.255.255，源 IP 地址 0.0.0.0）。 目的： 寻找网络中的 DHCP 服务器。   Offer (提供)  服务器行为： 网络中的 DHCP 服务器收到 DHCP Discover 消息后，会从...</div></div></div></a><a class="pagination-related" href="/2025/09/11/shell-%E7%AE%A1%E9%81%93/" title="shell-管道"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">shell-管道</div></div><div class="info-2"><div class="info-item-1">管道（Pipeline） 一、管道（|）的机制是什么？从机制上讲，管道符 | 做了一件非常简单但强大的事情：它将前一个命令的标准输出（stdout）连接到后一个命令的标准输入（stdin）。 为了完全理解这一点，你必须先了解三个标准的 I&#x2F;O 流：  **标准输入 (stdin)**：文件描述符为 0。命令默认从这里读取数据（通常是键盘）。 **标准输出 (stdout)**：文件描述符为 1。命令默认向这里写入正常的输出（通常是屏幕）。 **标准错误 (stderr)**：文件描述符为 2。命令默认向这里写入错误或诊断信息（通常也是屏幕）。  当你在两个命令之间放置一个 | 时，Shell 会在内存中创建一个管道，然后：  重定向：将 command1 的 stdout 重定向到这个管道的写入端。 重定向：将 command2 的 stdin 重定向到这个管道的读取端。 并发执行：command1 和 command2 同时开始执行。command1 产生输出，command2 立即可以开始读取和处理，无需等待 command1 完全结束。这极大地提高了效率，尤其是在...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/" title="TCP 客户端在发送 SYN 之后宕机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP 客户端在发送 SYN 之后宕机</div></div><div class="info-2"><div class="info-item-1">这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。 假设客户端 A 尝试连接服务器 B。 1. 客户端发送 SYN (第一次握手) 客户端 A： 生成一个 SYN 包，Seq = client_ISN，发送给服务器 B。 发送后，客户端 A 的 TCP 状态会从 CLOSED 变为 SYN_SENT。  2. 客户端 A 宕机 就在发送 SYN 包之后，客户端 A 突然崩溃（例如，操作系统蓝屏、电源故障、进程被杀掉等）。这意味着客户端 A 的所有网络状态、定时器、内存中的 TCP 控制块信息都瞬间丢失了。  3. 服务器 B 的处理 服务器 B 收到 SYN： 服务器 B 收到了客户端 A 发送的 SYN 包。 服务器 B 响应 SYN+ACK： 服务器 B 按照 TCP 握手流程，会进入 SYN_RCVD 状态，并向客户端 A 发送 SYN+ACK 包 (Seq = server_ISN, Ack = client_ISN + 1)。 服务器 B 等待客户端 ACK： 服务器 B 此时会启动一个定时...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Containerd/" title="Containerd"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Containerd</div></div><div class="info-2"><div class="info-item-1">Containerd 使用我们知道很早之前的 Docker Engine 中就有了 containerd，只不过现在是将 containerd 从 Docker Engine 里分离出来，作为一个独立的开源项目，目标是提供一个更加开放、稳定的容器运行基础设施。分离出来的 containerd 将具有更多的功能，涵盖整个容器运行时管理的所有需求，提供更强大的支持。 containerd 是一个工业级标准的容器运行时，它强调简单性、健壮性和可移植性，containerd 可以负责干下面这些事情：  管理容器的生命周期（从创建容器到销毁容器） 拉取&#x2F;推送容器镜像 存储管理（管理镜像及容器数据的存储） 调用 runc 运行容器（与 runc 等容器运行时交互） 管理容器网络接口及网络  架构containerd 可用作 Linux 和 Windows 的守护程序，它管理其主机系统完整的容器生命周期，从镜像传输和存储到容器执行和监测，再到底层存储到网络附件等等。  上图是 containerd 官方提供的架构图，可以看出 containerd 采用的也是 C&#x2F;S 架构，...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E4%B8%BA%E4%BB%80%E4%B9%88%20TCP%20%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E6%9C%89%20TIME_WAIT%20%E7%8A%B6%E6%80%81/" title="为什么 TCP 挥手需要有 TIME_WAIT 状态"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">为什么 TCP 挥手需要有 TIME_WAIT 状态</div></div><div class="info-2"><div class="info-item-1">TIME_WAIT 状态是 TCP 四次挥手过程中一个非常关键且必要的阶段，它主要位于主动关闭连接的一方。它的存在是为了解决两个核心问题： 问题一：确保四次挥手最后一个 ACK 报文可靠到达，防止服务器端重传 FIN 报文。 场景： 假设 TCP 没有 TIME_WAIT 状态，客户端（主动关闭方）发送了最后一个 ACK 后立即关闭连接，进入 CLOSED 状态。 潜在问题： 如果最后一个 ACK 在网络中丢失了，服务器端就没有收到这个 ACK。根据 TCP 的可靠性机制，服务器会认为它的 FIN 报文没有被确认，就会尝试重传 FIN 报文。 后果： 如果客户端已经立即进入 CLOSED 状态并释放了端口，而服务器重传的 FIN 报文到达时，如果客户端的该端口已经被新的连接占用（或直接拒绝接收），服务器将永远无法收到对 FIN 的确认，它会一直停留在 LAST_ACK 状态，耗尽资源并最终超时。 TIME_WAIT 状态让客户端保持一个足够长的时间（2 MSL，通常是 1-4 分钟），如果服务器重传 FIN 报文，客户端依然可以发送新的 ACK 报文作为回应，并重置 TIME_W...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx-%E5%A4%84%E7%90%86-HTTP-%E8%AF%B7%E6%B1%82%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">Nginx 处理 HTTP 请求的核心模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%E5%8C%85%E5%90%AB%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="toc-number">2.</span> <span class="toc-text">Nginx 请求处理过程包含的阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-HTTP-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">总结 HTTP 请求处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">理解阶段的重要性</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>