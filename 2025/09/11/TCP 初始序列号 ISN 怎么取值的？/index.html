<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP 初始序列号 ISN 怎么取值的？ | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP 初始序列号 (Initial Sequence Number, ISN) 的取值是一个重要且精心设计的机制，它对于 TCP 连接的健壮性、安全性以及避免“历史连接”的干扰至关重要。 ISN 的生成方式TCP 规范 (RFC 793 和后来的 RFC 1948、RFC 6528) 规定，ISN 的选择算法应该随机化。具体来说：  基于时钟（时间戳）+ 递增计数器 + 随机偏移：  大多数现代">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP 初始序列号 ISN 怎么取值的？">
<meta property="og:url" content="http://example.com/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="TCP 初始序列号 (Initial Sequence Number, ISN) 的取值是一个重要且精心设计的机制，它对于 TCP 连接的健壮性、安全性以及避免“历史连接”的干扰至关重要。 ISN 的生成方式TCP 规范 (RFC 793 和后来的 RFC 1948、RFC 6528) 规定，ISN 的选择算法应该随机化。具体来说：  基于时钟（时间戳）+ 递增计数器 + 随机偏移：  大多数现代">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:06:34.662Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP 初始序列号 ISN 怎么取值的？",
  "url": "http://example.com/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:06:34.662Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP 初始序列号 ISN 怎么取值的？',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP 初始序列号 ISN 怎么取值的？</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP 初始序列号 ISN 怎么取值的？</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:06:34.662Z" title="更新于 2025-09-11 22:06:34">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>TCP 初始序列号 (Initial Sequence Number, ISN) 的取值是一个重要且精心设计的机制，它对于 TCP 连接的健壮性、安全性以及避免“历史连接”的干扰至关重要。</p>
<h3 id="ISN-的生成方式"><a href="#ISN-的生成方式" class="headerlink" title="ISN 的生成方式"></a>ISN 的生成方式</h3><p>TCP 规范 (RFC 793 和后来的 RFC 1948、RFC 6528) 规定，ISN 的选择算法应该<strong>随机化</strong>。具体来说：</p>
<ol>
<li><p><strong>基于时钟（时间戳）+ 递增计数器 + 随机偏移：</strong></p>
<ul>
<li>大多数现代操作系统实现采用的是一个<strong>32位的计数器</strong>，该计数器以一个固定的频率（例如，每4微秒或更短）递增。</li>
<li>当需要生成新的 ISN 时，取当前计数器的值。</li>
<li>为了增加随机性，通常还会<strong>加上一个伪随机数</strong>作为偏移量。</li>
<li>这样可以确保每次连接生成的 ISN 都是不同的，并且难以预测。</li>
</ul>
</li>
<li><p><strong>每隔一段时间随机增加一个偏移量：</strong><br>为了进一步增强安全性，通常会周期性地给这个递增计数器<strong>添加一个大的随机偏移量</strong>，或者在每次系统启动时初始化为不同的随机值。</p>
</li>
</ol>
<p><strong>核心思想：随机性和不可预测性。</strong></p>
<h3 id="为什么-ISN-必须是随机的？"><a href="#为什么-ISN-必须是随机的？" class="headerlink" title="为什么 ISN 必须是随机的？"></a>为什么 ISN 必须是随机的？</h3><p>ISN 的随机性主要基于以下几个重要的原因：</p>
<ol>
<li><p><strong>防止“历史连接”对当前连接的干扰（最重要的原因）：</strong><br>这也是前面三次握手提到防止“失效的链接请求报文段”的原因。</p>
<ul>
<li>想象一个场景：一个 TCP 连接由于网络问题被中断，但网络中仍然可能存在属于这个旧连接的、过时的数据包（例如，延迟的 SYN 报文、延迟的 ACK 报文或延迟的数据报文）。</li>
<li>如果客户端和服务器每次建立连接都使用固定的或可预测的 ISN，那么一个旧连接的报文段就可能携带与新连接的 ISN 相同或接近的序列号，从而<strong>被错误地识别为属于新连接的合法数据</strong>。</li>
<li><strong>例子：</strong> 客户端 A 和服务器 B 建立连接，ISN&#x3D;1000。传输一些数据后，连接中断并被关闭（或超时）。随即，客户端 A 又立即请求与服务器 B 建立新的连接。<ul>
<li><strong>如果 ISN 是固定的 (比如总是 1000)：</strong> 服务器可能收到一个旧连接中延迟的、序列号是 1005 的数据包。如果新的连接也从 1000 开始，那么这个 1005 的数据包可能被新连接错误地接受。</li>
<li><strong>如果 ISN 是随机的 (比如新连接的 ISN&#x3D;12345678)：</strong> 旧连接中延迟的 1005 数据包将与新连接的序列号毫无关系，会被直接丢弃，因为它不在新的连接的期望序列号窗口内。</li>
</ul>
</li>
<li>通过随机化 ISN，可以大大降低旧连接的过时报文段在生命周期内“恰好”拥有与新连接相同的序列号的可能性，从而有效避免了这种“串扰”或“劫持”。</li>
</ul>
</li>
<li><p><strong>防止 TCP 劫持 (TCP Session Hijacking)：</strong></p>
<ul>
<li>如果攻击者能够预测下一个连接的 ISN，他们就可以伪造报文段。例如，攻击者可以在 TCP 连接建立过程中，抢先发送一个伪造的 ACK 包，其序列号和确认号恰好是双方期望的下一个序列号，从而欺骗一方认为连接已经成功建立，并注入恶意数据。</li>
<li>ISN 的随机性使得攻击者难以猜测正确的序列号，从而大大增加了 TCP 劫持的难度。</li>
</ul>
</li>
<li><p><strong>提高安全性：</strong></p>
<ul>
<li>随机的 ISN 使得端口扫描、会话预测等攻击变得更加困难。</li>
</ul>
</li>
</ol>
<h3 id="ISN-的生命周期"><a href="#ISN-的生命周期" class="headerlink" title="ISN 的生命周期"></a>ISN 的生命周期</h3><p>需要注意的是，一个 TCP 连接一旦建立，它的 ISN 就固定了。在连接的整个生命周期中，后续所有的数据报文的序列号都是在这个 ISN 的基础上累加的。如果连接断开并重新建立，即使是相同的客户端和服务器通过相同的端口通信，也会生成一个新的、随机的 ISN。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>TCP 初始序列号 (ISN) 的取值策略是确保其<strong>随机性和不可预测性</strong>。这主要通过一个结合时间戳（或递增计数器）和随机偏移的算法来实现。这种随机性对于防止旧连接报文的干扰（即“已失效的连接请求报文段”问题）以及增强连接的安全性（防止 TCP 劫持）至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/">http://example.com/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/" title="TCP 客户端在发送 SYN 之后宕机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCP 客户端在发送 SYN 之后宕机</div></div><div class="info-2"><div class="info-item-1">这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。 假设客户端 A 尝试连接服务器 B。 1. 客户端发送 SYN (第一次握手) 客户端 A： 生成一个 SYN 包，Seq = client_ISN，发送给服务器 B。 发送后，客户端 A 的 TCP 状态会从 CLOSED 变为 SYN_SENT。  2. 客户端 A 宕机 就在发送 SYN 包之后，客户端 A 突然崩溃（例如，操作系统蓝屏、电源故障、进程被杀掉等）。这意味着客户端 A 的所有网络状态、定时器、内存中的 TCP 控制块信息都瞬间丢失了。  3. 服务器 B 的处理 服务器 B 收到 SYN： 服务器 B 收到了客户端 A 发送的 SYN 包。 服务器 B 响应 SYN+ACK： 服务器 B 按照 TCP 握手流程，会进入 SYN_RCVD 状态，并向客户端 A 发送 SYN+ACK 包 (Seq = server_ISN, Ack = client_ISN + 1)。 服务器 B 等待客户端 ACK： 服务器 B 此时会启动一个定时...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Service/" title="Service"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Service</div></div><div class="info-2"><div class="info-item-1">Service我们前面的课程中学习了一些常用控制器的基本用法，我们也了解到 Pod 的生命是有限的，死亡过后不会复活了。然后我们知道可以用 ReplicaSet 和 Deployment 来动态的创建和销毁 Pod，每个 Pod 都有自己的 IP 地址，但是如果 Pod 重建了的话那么他的 IP 很有可能也就变化了。这就会带来一个问题：比如我们有一些后端的 Pod 集合为集群中的其他应用提供 API 服务，如果我们在前端应用中把所有的这些后端的 Pod 的地址都写死，然后以某种方式去访问其中一个 Pod 的服务，这样看上去是可以工作的，对吧？但是如果这个 Pod 挂掉了，然后重新启动起来了，是不是 IP 地址非常有可能就变了，这个时候前端就极大可能访问不到后端的服务了。 遇到这样的问题该怎么解决呢？在没有使用 Kubernetes 之前，我相信可能很多同学都遇到过这样的问题，不一定是 IP 变化的问题，比如我们在部署一个 WEB 服务的时候，前端一般部署一个 Nginx 作为服务的入口，然后 Nginx 后面肯定就是挂载的这个服务的大量后端服务，很早以前我们可能是去手动更改 Ng...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/OPA/" title="OPA"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">OPA</div></div><div class="info-2"><div class="info-item-1">OPA 策略引擎Open Policy Agent 简称 OPA，是一种开源的通用策略代理引擎，是 CNCF 毕业的项目。OPA 提供了一种高级声明式语言 Rego，简化了策略规则的定义，以减轻程序中策略的决策负担。在微服务、Kubernetes、CI&#x2F;CD、API 网关等场景中均可以使用 OPA 来定义策略。  我们这里主要讲解在 Kubernetes 中如何集成 OPA，在 Kubernetes 中 OPA 是通过 Admission Controllers 来实现安全策略的。事实上使用 Pod 安全策略（要废弃了）来执行我们的安全策略并没有什么问题，然而，根据定义，PSP 只能应用于 pods。它们不能处理其他 Kubernetes 资源，如 Ingresses、Deployments、Services 等，OPA 的强大之处在于它可以应用于任何 Kubernetes 资源。OPA 作为一个准入控制器部署到 Kubernetes，它拦截发送到 APIServer 的 API 调用，并验证和&#x2F;或修改它们。你可以有一个统一的 OPA 策略，适用于系统的不同组...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/" title="Linux 文件权限"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Linux 文件权限</div></div><div class="info-2"><div class="info-item-1">Linux 系统权限管理 一、Linux 权限管理的核心理念：用户、组与权限Linux 系统中的权限管理围绕着三个核心概念展开：用户（User）、组（Group） 和 其他（Others），以及针对这些实体设定的读（Read）、写（Write）、执行（Execute） 三种基本权限。 1. 用户 (User)：每个用户都有一个唯一的用户 ID (UID)。系统通过 UID 来识别用户。  root 用户： UID 为 0，拥有系统最高权限，可以执行任何操作。 系统用户： UID 1-999 (具体范围依发行版可能不同)，用于运行系统服务，通常不能登录。 普通用户： UID 1000 及以上，是日常操作的用户。  2. 组 (Group)：每个组都有一个唯一的组 ID (GID)。用户可以属于一个或多个组。  Primary Group (主组)： 用户创建时自动归属的组。 Secondary Groups (附加组)： 用户除了主组外，还可以加入多个附加组。 目的： 简化权限管理。可以将文件权限赋给一个组，所有属于该组的用户都将获得相应的权限，而无需单独为每个用户设置。  3. ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E8%8A%82%E7%82%B9%E7%9B%91%E6%8E%A7/" title="节点监控"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">节点监控</div></div><div class="info-2"><div class="info-item-1">节点监控前面我们和大家学习了怎样用 Promethues 来监控 Kubernetes 集群中的应用，但是对于 Kubernetes 集群本身的监控也是非常重要的，我们需要时时刻刻了解集群的运行状态。 监控方案对于集群的监控一般我们需要考虑以下几个方面：  Kubernetes 节点的监控：比如节点的 cpu、load、disk、memory 等指标 内部系统组件的状态：比如 kube-scheduler、kube-controller-manager、kubedns&#x2F;coredns 等组件的详细运行状态 编排级的 metrics：比如 Deployment 的状态、资源请求、调度和 API 延迟等数据指标  Kubernetes 集群的监控方案目前主要有以下几种方案：  cAdvisor：cAdvisor 是 Google 开源的容器资源监控和性能分析工具，它是专门为容器而生，本身也支持 Docker 容器。 kube-state-metrics：kube-state-metrics 通过监听 API Server 生成有关资源对象的状态指标，比如 Deploymen...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%8F%E8%AE%AE/" title="路由算法与协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">路由算法与协议</div></div><div class="info-2"><div class="info-item-1">路由协议 (Routing Protocols) 和路由选择算法 (Routing Algorithms) 是网络路由领域紧密相关但又截然不同的两个概念。理解它们之间的区别对于掌握网络路由的精髓至关重要。 路由选择算法 (Routing Algorithms)核心： 路由选择算法是决定数据包在网络中从源到目的地最佳路径的逻辑或计算过程。它关注的是“如何计算出最佳路径”。 特点：  数学模型&#x2F;逻辑： 它们是一套定义了如何根据特定度量（如跳数、延迟、带宽、成本等）来计算最优路径的数学模型或逻辑步骤。 通用性： 许多路由算法是通用的计算机科学概念，不局限于特定的网络设备或协议。 独立于实现： 算法本身只是一套理论，它不关心具体如何被实现或在哪个设备上运行。 输入： 它们通常需要网络拓扑信息（节点和链路）以及链路成本&#x2F;度量作为输入。 输出： 输出是到达网络中各个目的地的最佳路径。  常见的路由选择算法：  Dijkstra (迪克斯特拉) 算法： 经典的最短路径算法，常用于链路状态路由（如 OSPF）。它计算从单个源到所有其他节点的单源最短路径。 Bellman-Fo...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%20KubeBlocks/" title="数据管理平台 KubeBlocks"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">数据管理平台 KubeBlocks</div></div><div class="info-2"><div class="info-item-1">云原生数据管理平台 KubeBlocksKubeBlocks 是基于 Kubernetes 的云原生数据基础设施，将顶级云服务提供商的大规模生产经验与增强的可用性和稳定性改进相结合，帮助用户轻松构建容器化、声明式的关系型、NoSQL、流计算和向量型数据库服务。  为什么需要 KubeBlocks？Kubernetes 已经成为容器编排的事实标准。它利用 ReplicaSet 提供的可扩展性和可用性以及 Deployment 提供的发布和回滚功能来管理日益增加的无状态工作负载。然而，管理有状态工作负载给 Kubernetes 带来了巨大的挑战，尽管 StatefulSet 提供了稳定的持久存储和唯一的网络标识符，但这些功能对于复杂的有状态工作负载来说远远不够。 为了应对这些挑战，并解决复杂性问题，KubeBlocks 引入了 ReplicationSet 和 ConsensusSet，具备以下能力：  基于角色的更新顺序可减少因升级版本、缩放和重新启动而导致的停机时间。 维护数据复制的状态，并自动修复复制错误或延迟。  KubeBlocks 具有以下特点：  支持多云，与 AWS、...</div></div></div></a><a class="pagination-related" href="/2025/09/11/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/" title="TCP快速重传机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">TCP快速重传机制</div></div><div class="info-2"><div class="info-item-1">TCP 引入快速重传（Fast Retransmit）机制，是为了弥补仅仅依靠超时重传的不足，提高网络吞吐量和链路利用率，尤其是在数据包丢失不严重但仍存在的情况下。 让我们来详细了解一下： 超时重传的不足：超时重传是 TCP 可靠性最基本的保障，但它有一个致命的弱点：等待时间过长。  重传超时时间 (RTO) 的计算： RTO 是根据网络中的往返时间 (RTT) 动态调整的，通常比 RTT 要长一些。即使网络状况良好，RTO 至少也得几十毫秒甚至几百毫秒。 等待 RTO 的代价： 吞吐量下降： 如果一个数据包丢失了，发送方必须一直等到 RTO 到期才能重传。在这漫长的等待期间，发送方可能无法发送新的数据（如果拥塞窗口和接收窗口限制），导致网络带宽得不到充分利用，吞吐量显著下降。 延迟增加： 对于实时性要求较高的应用，长时间的等待会导致明显的延迟增加。 可能触发不必要的拥塞控制： 当超时发生时，TCP 会认为发生了一次严重的丢包事件，通常会大幅度降低拥塞窗口（例如，将拥塞窗口降到 1 MSS），这会极大地限制后续的数据发送，加剧吞吐量下降，即便实际上可能只丢失了一个包。    快速...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ISN-%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">ISN 的生成方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ISN-%E5%BF%85%E9%A1%BB%E6%98%AF%E9%9A%8F%E6%9C%BA%E7%9A%84%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">为什么 ISN 必须是随机的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ISN-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.</span> <span class="toc-text">ISN 的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>