<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP 初始序列号 ISN 怎么取值的？ | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP 初始序列号 (Initial Sequence Number, ISN) 的取值是一个重要且精心设计的机制，它对于 TCP 连接的健壮性、安全性以及避免“历史连接”的干扰至关重要。 ISN 的生成方式TCP 规范 (RFC 793 和后来的 RFC 1948、RFC 6528) 规定，ISN 的选择算法应该随机化。具体来说：  基于时钟（时间戳）+ 递增计数器 + 随机偏移：  大多数现代">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP 初始序列号 ISN 怎么取值的？">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="TCP 初始序列号 (Initial Sequence Number, ISN) 的取值是一个重要且精心设计的机制，它对于 TCP 连接的健壮性、安全性以及避免“历史连接”的干扰至关重要。 ISN 的生成方式TCP 规范 (RFC 793 和后来的 RFC 1948、RFC 6528) 规定，ISN 的选择算法应该随机化。具体来说：  基于时钟（时间戳）+ 递增计数器 + 随机偏移：  大多数现代">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:06:34.662Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP 初始序列号 ISN 怎么取值的？",
  "url": "https://huiaz.github.io/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:06:34.662Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP 初始序列号 ISN 怎么取值的？',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP 初始序列号 ISN 怎么取值的？</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP 初始序列号 ISN 怎么取值的？</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:06:34.662Z" title="更新于 2025-09-11 22:06:34">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/">WEB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/">Http</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WEB/Http/TCP/">TCP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>TCP 初始序列号 (Initial Sequence Number, ISN) 的取值是一个重要且精心设计的机制，它对于 TCP 连接的健壮性、安全性以及避免“历史连接”的干扰至关重要。</p>
<h3 id="ISN-的生成方式"><a href="#ISN-的生成方式" class="headerlink" title="ISN 的生成方式"></a>ISN 的生成方式</h3><p>TCP 规范 (RFC 793 和后来的 RFC 1948、RFC 6528) 规定，ISN 的选择算法应该<strong>随机化</strong>。具体来说：</p>
<ol>
<li><p><strong>基于时钟（时间戳）+ 递增计数器 + 随机偏移：</strong></p>
<ul>
<li>大多数现代操作系统实现采用的是一个<strong>32位的计数器</strong>，该计数器以一个固定的频率（例如，每4微秒或更短）递增。</li>
<li>当需要生成新的 ISN 时，取当前计数器的值。</li>
<li>为了增加随机性，通常还会<strong>加上一个伪随机数</strong>作为偏移量。</li>
<li>这样可以确保每次连接生成的 ISN 都是不同的，并且难以预测。</li>
</ul>
</li>
<li><p><strong>每隔一段时间随机增加一个偏移量：</strong><br>为了进一步增强安全性，通常会周期性地给这个递增计数器<strong>添加一个大的随机偏移量</strong>，或者在每次系统启动时初始化为不同的随机值。</p>
</li>
</ol>
<p><strong>核心思想：随机性和不可预测性。</strong></p>
<h3 id="为什么-ISN-必须是随机的？"><a href="#为什么-ISN-必须是随机的？" class="headerlink" title="为什么 ISN 必须是随机的？"></a>为什么 ISN 必须是随机的？</h3><p>ISN 的随机性主要基于以下几个重要的原因：</p>
<ol>
<li><p><strong>防止“历史连接”对当前连接的干扰（最重要的原因）：</strong><br>这也是前面三次握手提到防止“失效的链接请求报文段”的原因。</p>
<ul>
<li>想象一个场景：一个 TCP 连接由于网络问题被中断，但网络中仍然可能存在属于这个旧连接的、过时的数据包（例如，延迟的 SYN 报文、延迟的 ACK 报文或延迟的数据报文）。</li>
<li>如果客户端和服务器每次建立连接都使用固定的或可预测的 ISN，那么一个旧连接的报文段就可能携带与新连接的 ISN 相同或接近的序列号，从而<strong>被错误地识别为属于新连接的合法数据</strong>。</li>
<li><strong>例子：</strong> 客户端 A 和服务器 B 建立连接，ISN&#x3D;1000。传输一些数据后，连接中断并被关闭（或超时）。随即，客户端 A 又立即请求与服务器 B 建立新的连接。<ul>
<li><strong>如果 ISN 是固定的 (比如总是 1000)：</strong> 服务器可能收到一个旧连接中延迟的、序列号是 1005 的数据包。如果新的连接也从 1000 开始，那么这个 1005 的数据包可能被新连接错误地接受。</li>
<li><strong>如果 ISN 是随机的 (比如新连接的 ISN&#x3D;12345678)：</strong> 旧连接中延迟的 1005 数据包将与新连接的序列号毫无关系，会被直接丢弃，因为它不在新的连接的期望序列号窗口内。</li>
</ul>
</li>
<li>通过随机化 ISN，可以大大降低旧连接的过时报文段在生命周期内“恰好”拥有与新连接相同的序列号的可能性，从而有效避免了这种“串扰”或“劫持”。</li>
</ul>
</li>
<li><p><strong>防止 TCP 劫持 (TCP Session Hijacking)：</strong></p>
<ul>
<li>如果攻击者能够预测下一个连接的 ISN，他们就可以伪造报文段。例如，攻击者可以在 TCP 连接建立过程中，抢先发送一个伪造的 ACK 包，其序列号和确认号恰好是双方期望的下一个序列号，从而欺骗一方认为连接已经成功建立，并注入恶意数据。</li>
<li>ISN 的随机性使得攻击者难以猜测正确的序列号，从而大大增加了 TCP 劫持的难度。</li>
</ul>
</li>
<li><p><strong>提高安全性：</strong></p>
<ul>
<li>随机的 ISN 使得端口扫描、会话预测等攻击变得更加困难。</li>
</ul>
</li>
</ol>
<h3 id="ISN-的生命周期"><a href="#ISN-的生命周期" class="headerlink" title="ISN 的生命周期"></a>ISN 的生命周期</h3><p>需要注意的是，一个 TCP 连接一旦建立，它的 ISN 就固定了。在连接的整个生命周期中，后续所有的数据报文的序列号都是在这个 ISN 的基础上累加的。如果连接断开并重新建立，即使是相同的客户端和服务器通过相同的端口通信，也会生成一个新的、随机的 ISN。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>TCP 初始序列号 (ISN) 的取值策略是确保其<strong>随机性和不可预测性</strong>。这主要通过一个结合时间戳（或递增计数器）和随机偏移的算法来实现。这种随机性对于防止旧连接报文的干扰（即“已失效的连接请求报文段”问题）以及增强连接的安全性（防止 TCP 劫持）至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/">https://huiaz.github.io/2025/09/11/TCP%20%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%20ISN%20%E6%80%8E%E4%B9%88%E5%8F%96%E5%80%BC%E7%9A%84%EF%BC%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/TCP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%8F%91%E9%80%81%20SYN%20%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA/" title="TCP 客户端在发送 SYN 之后宕机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCP 客户端在发送 SYN 之后宕机</div></div><div class="info-2"><div class="info-item-1">这是一个非常经典的面试题和网络故障场景分析点。我们来详细分析一下 TCP 客户端在发送 SYN 之后宕机（Crash）会发生什么。 假设客户端 A 尝试连接服务器 B。 1. 客户端发送 SYN (第一次握手) 客户端 A： 生成一个 SYN 包，Seq = client_ISN，发送给服务器 B。 发送后，客户端 A 的 TCP 状态会从 CLOSED 变为 SYN_SENT。  2. 客户端 A 宕机 就在发送 SYN 包之后，客户端 A 突然崩溃（例如，操作系统蓝屏、电源故障、进程被杀掉等）。这意味着客户端 A 的所有网络状态、定时器、内存中的 TCP 控制块信息都瞬间丢失了。  3. 服务器 B 的处理 服务器 B 收到 SYN： 服务器 B 收到了客户端 A 发送的 SYN 包。 服务器 B 响应 SYN+ACK： 服务器 B 按照 TCP 握手流程，会进入 SYN_RCVD 状态，并向客户端 A 发送 SYN+ACK 包 (Seq = server_ISN, Ack = client_ISN + 1)。 服务器 B 等待客户端 ACK： 服务器 B 此时会启动一个定时...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Service/" title="Service"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Service</div></div><div class="info-2"><div class="info-item-1">Service我们前面的课程中学习了一些常用控制器的基本用法，我们也了解到 Pod 的生命是有限的，死亡过后不会复活了。然后我们知道可以用 ReplicaSet 和 Deployment 来动态的创建和销毁 Pod，每个 Pod 都有自己的 IP 地址，但是如果 Pod 重建了的话那么他的 IP 很有可能也就变化了。这就会带来一个问题：比如我们有一些后端的 Pod 集合为集群中的其他应用提供 API 服务，如果我们在前端应用中把所有的这些后端的 Pod 的地址都写死，然后以某种方式去访问其中一个 Pod 的服务，这样看上去是可以工作的，对吧？但是如果这个 Pod 挂掉了，然后重新启动起来了，是不是 IP 地址非常有可能就变了，这个时候前端就极大可能访问不到后端的服务了。 遇到这样的问题该怎么解决呢？在没有使用 Kubernetes 之前，我相信可能很多同学都遇到过这样的问题，不一定是 IP 变化的问题，比如我们在部署一个 WEB 服务的时候，前端一般部署一个 Nginx 作为服务的入口，然后 Nginx 后面肯定就是挂载的这个服务的大量后端服务，很早以前我们可能是去手动更改 Ng...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Grafana/" title="Grafana"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Grafana</div></div><div class="info-2"><div class="info-item-1">Grafana前面我们使用 Prometheus 采集了 Kubernetes 集群中的一些监控数据指标，我们也尝试使用 promQL 语句查询出了一些数据，并且在 Prometheus 的 Dashboard 中进行了展示，但是明显可以感觉到 Prometheus 的图表功能相对较弱，所以一般情况下我们还是会使用 Grafana 来进行展示，前面我们已经详细学习过 Grafana 的使用了，这里我们在 Kubernetes 集群中使用，所以同样可以将 Grafana 安装到集群中来，当然在集群外也是可以的。 安装第一步去查看 grafana 的 docker 镜像的介绍，我们可以在 dockerhub 上去搜索，也可以在官网去查看相关资料，镜像地址如下：https://hub.docker.com/r/grafana/grafana/，我们可以看到介绍中运行 grafana 容器的命令非常简单： 1docker run -d --name=grafana -p 3000:3000 grafana/grafana  但是还有一个需要注意的是 Changelog 中 v5.1.0 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Go%20%E7%A9%BA%E5%88%87%E7%89%87%E4%B8%8E%20nil%20%E5%88%87%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Go 空切片与 nil 切片的区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Go 空切片与 nil 切片的区别</div></div><div class="info-2"><div class="info-item-1">核心区别：nil 切片的底层指针是 nil，而空切片的底层指针是一个有效的、指向 0 字节内存区域的地址。 虽然它们在很多操作上表现一致（如 len、cap、for range、append），但这个根本性的指针差异导致了他们在内存表示、JSON 序列化和语义表达上的关键不同。 让我们深入剖析。  1. 结构与定义要理解它们的区别，首先要看切片在 Go 底层的结构 SliceHeader： 12345type SliceHeader struct &#123;    Data uintptr // 指向底层数组的指针    Len  int     // 切片的长度    Cap  int     // 切片的容量&#125; nil 切片和空切片的区别就体现在这个 Data 指针上。 Nil 切片 (Nil Slice)一个 nil 切片是切片类型的零值。它的指针 Data 为 nil，并且 Len 和 Cap 都是 0。  声明方式：仅声明变量而不进行初始化。 12var s []int // 此时 s 就是一个 nil 切片  内部状态： 1234s (SliceHeade...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F/" title="消息队列如何保证有序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">消息队列如何保证有序</div></div><div class="info-2"><div class="info-item-1">您好！保证消息的有序性（Ordering）在分布式系统中是一个非常复杂但又至关重要的问题。它意味着消息在生产、传输和消费的整个过程中，都必须按照其发送时的相对顺序进行处理。 在实际场景中，我们通常追求的是局部有序性，而不是严格的全局有序性。  全局有序性： 整个系统中所有消息都严格按照其生产时间顺序被消费，这在分布式环境中几乎无法实现，而且性能开销巨大。 局部有序性（更常见）： 针对某个特定维度（例如，同一个订单的所有操作、同一个用户的所有事件）的消息，需要保证它们的消费顺序与生产顺序一致。不同维度之间的消息顺序则不要求。  要保证消息的有序性，需要从消息流动的三大环节（生产者、消息队列、消费者）进行设计和控制。  一、 生产端（Producer）：确保消息按序发送到指定分区这是保证有序性的第一步，也是最关键的一步。  串行发送： 如果需要保证某个特定维度（如订单ID、用户ID）的消息有序，生产者必须确保与该维度相关的所有消息都是串行地发送到消息队列的。避免多线程并发发送同一维度的消息。  消息路由到同一分区&#x2F;队列：  这是核心。大多数主流消息队列（如 Kafka、Ro...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" title="应用监控"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">应用监控</div></div><div class="info-2"><div class="info-item-1">应用监控前面我们和大家介绍了 Prometheus 的数据指标是通过一个公开的 HTTP(S) 数据接口获取到的，我们不需要单独安装监控的 agent，只需要暴露一个 metrics 接口，Prometheus 就会定期去拉取数据；对于一些普通的 HTTP 服务，我们完全可以直接重用这个服务，添加一个 /metrics 接口暴露给 Prometheus；而且获取到的指标数据格式是非常易懂的，不需要太高的学习成本。 现在很多服务从一开始就内置了一个 /metrics 接口，比如 Kubernetes 的各个组件都直接提供了数据指标接口，有一些服务即使没有原生集成该接口，也完全可以使用一些 exporter 来获取到指标数据，比如 mysqld_exporter、node_exporter，这些 exporter 就有点类似于传统监控服务中的 agent，作为服务一直存在，用来收集目标服务的指标数据然后直接暴露给 Prometheus。 普通应用对于普通应用只需要能够提供一个满足 Prometheus 格式要求的 /metrics 接口就可以让 Prometheus 来接管监控，比如...</div></div></div></a><a class="pagination-related" href="/2025/09/11/shell-notify/" title="shell-notify"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">shell-notify</div></div><div class="info-2"><div class="info-item-1">文件监控在 Shell 中，实现文件监控主要有两种策略：  轮询检查（Polling）：定时检查文件的元数据（如修改时间、大小、校验和），适用于对实时性要求不高的场景。 事件驱动（Event-Driven）：利用系统工具（如 inotifywait）实时捕捉文件系统的事件，效率高，响应快，是生产环境中的首选方案。  下面我将分别介绍这两种方法，并重点推荐使用 inotifywait 的专业方案。  方法一：轮询检查（基于 stat 和 md5sum）这种方法简单直接，不依赖任何额外工具，但效率较低，且有延迟。 核心思路 在一个无限循环 while true; do ... done 中执行。 记录文件当前的 MD5 校验和或修改时间。 sleep 一段时间。 再次获取文件的校验和或修改时间，与之前记录的值进行比较。 如果发生变化，则执行相应操作（如发送警报、记录日志）。  示例脚本：监控 /etc/hosts 文件的内容变化1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="消息队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">消息队列</div></div><div class="info-2"><div class="info-item-1">核心构成一个典型的消息队列系统主要由以下几部分组成：  消息（Message）： 传输的数据单元，通常是结构化的二进制数据、JSON 或 XML。 生产者（Producer）： 消息的发送方，负责创建消息并将消息发送到消息队列。 消费者（Consumer）： 消息的接收方，负责从消息队列中获取消息并进行处理。 消息队列（Queue&#x2F;Broker）： 消息存储和转发的核心组件。它接收生产者发送的消息，将消息持久化存储，并管理消息的投递和确认。大型 MQ 系统通常由一个或多个 Broker 组成集群。 主题&#x2F;队列（Topic&#x2F;Queue）： 消息的逻辑分类。 Queue（队列式）： 一条消息通常只能被一个消费者组中的一个消费者消费（点对点模式）。 Topic（主题式）： 一条消息可以被多个消费者组（订阅者）的消费者同时消费（发布&#x2F;订阅模式）。     工作原理 生产者发送消息： 生产者将业务数据（消息）封装后，发送到指定的消息队列（Broker 的某个 Topic 或 Queue）。 消息存储： 消息队列接收到消息后，将消息持久化存储起来，并根...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ISN-%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">ISN 的生成方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ISN-%E5%BF%85%E9%A1%BB%E6%98%AF%E9%9A%8F%E6%9C%BA%E7%9A%84%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">为什么 ISN 必须是随机的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ISN-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.</span> <span class="toc-text">ISN 的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>