<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>k8s service | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Service 主要有以下几种类型：  ClusterIP (默认类型) NodePort LoadBalancer ExternalName  接下来，我将分别详细介绍每种类型及其应用场景。  1. ClusterIP (默认类型) 作用： 为 Service 在 Kubernetes 集群内部分配一个唯一的、虚拟的 IP 地址（ClusterIP）。这个 IP 地址只在集群内部可达。  访问方">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s service">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/k8s%20service/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="Service 主要有以下几种类型：  ClusterIP (默认类型) NodePort LoadBalancer ExternalName  接下来，我将分别详细介绍每种类型及其应用场景。  1. ClusterIP (默认类型) 作用： 为 Service 在 Kubernetes 集群内部分配一个唯一的、虚拟的 IP 地址（ClusterIP）。这个 IP 地址只在集群内部可达。  访问方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:44:01.942Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "k8s service",
  "url": "https://huiaz.github.io/2025/09/11/k8s%20service/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:44:01.942Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/k8s%20service/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'k8s service',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">k8s service</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">k8s service</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:44:01.942Z" title="更新于 2025-09-11 21:44:01">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Service 主要有以下几种类型：</p>
<ol>
<li><strong>ClusterIP (默认类型)</strong></li>
<li><strong>NodePort</strong></li>
<li><strong>LoadBalancer</strong></li>
<li><strong>ExternalName</strong></li>
</ol>
<p>接下来，我将分别详细介绍每种类型及其应用场景。</p>
<hr>
<h3 id="1-ClusterIP-默认类型"><a href="#1-ClusterIP-默认类型" class="headerlink" title="1. ClusterIP (默认类型)"></a>1. ClusterIP (默认类型)</h3><ul>
<li><p><strong>作用：</strong> 为 Service 在 Kubernetes 集群内部分配一个<strong>唯一的、虚拟的 IP 地址</strong>（ClusterIP）。这个 IP 地址只在集群内部可达。</p>
</li>
<li><p><strong>访问方式：</strong> 集群<strong>内部</strong>的其他 Pod 或组件可以通过这个 ClusterIP 和端口来访问该 Service 后端的 Pod。</p>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li><strong>内部可见：</strong> 只能在集群内部访问，外部无法直接访问。</li>
<li><strong>负载均衡：</strong> Pod 流量通过 kube-proxy 代理转发到后端的 Pod，并自动进行简单的轮询式负载均衡。</li>
<li><strong>稳定性：</strong> 提供了稳定的 IP 地址和 DNS 名称， Pod 的 IP 变化不会影响 Service 的可访问性。</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><strong>内部服务通信：</strong> 最常见的用于微服务之间互相调用的场景。例如，前端服务访问后端服务，或其他服务访问数据库服务等。</li>
<li>集群内部调试。</li>
</ul>
</li>
<li><p><strong>示例 YAML 片段:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span> <span class="comment"># 这个 Service 会关联所有带有 &#x27;app: my-app&#x27; 标签的 Pod</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># Service 监听的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># Pod 内部应用监听的端口</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span> <span class="comment"># 可以省略，因为是默认类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-NodePort"><a href="#2-NodePort" class="headerlink" title="2. NodePort"></a>2. NodePort</h3><ul>
<li><strong>作用：</strong> 在每个集群节点（Node）上开启一个<strong>静态端口</strong> (NodePort)，并将这个端口映射到 Service 的 ClusterIP 端口。这意味着，任何发送到 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 的请求都会被转发到 Service。</li>
<li><strong>访问方式：</strong> 集群<strong>内部和外部</strong>都可以通过任意节点的 IP 地址加上 NodePort 来访问 Service。</li>
<li><strong>特点：</strong><ul>
<li><strong>外部暴露：</strong> 这是将 Service 暴露给集群外部的最基本方式。</li>
<li><strong>端口范围：</strong> NodePort 的端口范围通常是 <code>30000-32767</code>，这个范围可以在 kube-apiserver 配置中修改。</li>
<li><strong>任意节点：</strong> 无论请求发送到哪个节点的 NodePort，都会被路由到正确的后端 Pod。</li>
<li><strong>不适合生产：</strong> NodePort 端口是固定的，但若有多个 NodePort Service，端口号的管理会比较繁琐。更重要的是，它不提供负载均衡能力（客户端需要知道所有节点 IP），且端口暴露在所有节点上，安全性较低。</li>
</ul>
</li>
<li><strong>使用场景：</strong><ul>
<li><strong>测试和演示：</strong> 快速验证应用程序的外部可访问性，不适合生产环境。</li>
<li><strong>非云环境的裸金属集群：</strong> 有时在没有外部负载均衡器的环境中，作为临时的外部访问方案。</li>
</ul>
</li>
<li><strong>示例 YAML 片段:</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-nodeport-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span> <span class="comment"># 可以指定，也可以由K8s自动分配一个（在30000-32767范围内）</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>
外部访问：<code>http://&lt;任何一个Node的IP&gt;:30080</code></li>
</ul>
<hr>
<h3 id="3-LoadBalancer"><a href="#3-LoadBalancer" class="headerlink" title="3. LoadBalancer"></a>3. LoadBalancer</h3><ul>
<li><strong>作用：</strong> 这是在公有云提供商（如 AWS EKS, GKE, Azure AKS 等）环境中，<strong>将 Service 暴露给外部流量的标准方式。</strong> 它会请求云提供商创建一个<strong>外部负载均衡器</strong>，并将外部流量路由到 Kubernetes 集群中的 Service。</li>
<li><strong>访问方式：</strong> 外部客户端通过云提供商分配的负载均衡器 IP 地址或 DNS 名称来访问 Service。</li>
<li><strong>特点：</strong><ul>
<li><strong>外部负载均衡器：</strong> 由云提供商管理，通常具备高可用、弹性伸缩和高级路由功能。</li>
<li><strong>自动配置：</strong> Kubernetes 会自动与云提供商 API 集成，创建、配置和管理负载均衡器。</li>
<li><strong>生产环境推荐：</strong> 这是在公有云上暴露 Web 服务和 API 服务的首选方式。</li>
<li><strong>成本：</strong> 云负载均衡器通常会产生费用。</li>
</ul>
</li>
<li><strong>使用场景：</strong><ul>
<li><strong>部署在公有云上的 Web 应用、API 服务等，需要对外提供稳定、高可用的访问入口。</strong></li>
</ul>
</li>
<li><strong>示例 YAML 片段:</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-lb-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br></pre></td></tr></table></figure>
应用此 YAML 后，Kubernetes 会在几分钟内（取决于云提供商）为这个 Service 分配一个外部 IP 地址。可以通过 <code>kubectl get svc my-app-lb-service</code> 查看 <code>EXTERNAL-IP</code> 字段。</li>
</ul>
<hr>
<h3 id="4-ExternalName"><a href="#4-ExternalName" class="headerlink" title="4. ExternalName"></a>4. ExternalName</h3><ul>
<li><strong>作用：</strong> ExternalName Service 不会代理任何 Pod，也不会分配 ClusterIP。它通过返回一个 CNAME 记录，将 Service 映射到集群外部的 DNS 名称。</li>
<li><strong>访问方式：</strong> 当集群内部的 Pod 尝试访问这个 Service 时，DNS 服务（CoreDNS）会直接返回其配置的外部 DNS 名称，客户端会直接连接到那个外部地址，而不是通过 Kube-proxy。</li>
<li><strong>特点：</strong><ul>
<li><strong>DNS 别名：</strong> 像 DNS CNAME 一样工作，将流量重定向到集群外部的服务。</li>
<li><strong>无代理：</strong> 没有代理行为，因此没有负载均衡，没有端口映射。</li>
<li><strong>不占用 IP：</strong> 不分配 ClusterIP。</li>
</ul>
</li>
<li><strong>使用场景：</strong><ul>
<li><strong>集群内部服务访问外部数据库或外部API：</strong> 允许集群内部的服务使用一个统一的、内部的 DNS 名称来访问集群外部的某个服务（如云数据库 RDS、第三方 API），而无需修改应用程序代码。</li>
<li>在不改变代码的情况下，将应用从集群内部的服务切换到外部服务。</li>
</ul>
</li>
<li><strong>示例 YAML 片段:</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-external-db</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">my-database.example.com</span> <span class="comment"># 指向集群外部的DNS名称</span></span><br></pre></td></tr></table></figure>
集群内部的 Pod 如果尝试连接 <code>my-external-db:8080</code>，DNS 查询会直接解析到 <code>my-database.example.com</code>，然后客户端会直接连接到该外部地址。</li>
</ul>
<hr>
<h3 id="总结选择指南："><a href="#总结选择指南：" class="headerlink" title="总结选择指南："></a>总结选择指南：</h3><ol>
<li><strong>内部服务通信 (Service-to-Service):</strong> 始终使用 <strong>ClusterIP</strong>。</li>
<li><strong>在公有云上暴露服务：</strong> 使用 <strong>LoadBalancer</strong>。</li>
<li><strong>开发&#x2F;测试时快速暴露服务，或裸金属环境的临时方案：</strong> 可以使用 <strong>NodePort</strong>，但需注意其局限性。</li>
<li><strong>将内部流量重定向到集群外部服务：</strong> 使用 <strong>ExternalName</strong>。</li>
</ol>
<p>在实际生产中，除了 LoadBalancer 类型 Service，更高级的外部暴露方式通常还会结合 <strong>Ingress</strong>，Ingress 提供了更灵活的 HTTP&#x2F;HTTPS 路由规则，如基于路径、基于域名的路由，以及 SSL&#x2F;TLS 终止等功能。Ingress 通常需要 Ingress Controller（如 Nginx Ingress Controller）来实际执行这些路由。</p>
<p>好的，Headless Service 是 Kubernetes Service 中的一个特殊类型，它<strong>不会为其分配 ClusterIP</strong>。这是它最主要的特征。</p>
<h3 id="Headless-Service-的定义与特点"><a href="#Headless-Service-的定义与特点" class="headerlink" title="Headless Service 的定义与特点"></a>Headless Service 的定义与特点</h3><p>当你在定义 Service 时，将 <code>clusterIP</code> 字段设置为 <code>None</code> (或者在 YAML 文件中完全不指定 <code>clusterIP</code> 字段，并确保 <code>type</code> 不是 <code>ExternalName</code> 且不是 <code>LoadBalancer</code>，对于一些早期的 Kubernetes 版本可能需要显式设置，但现在自动推断为空即可)，或者使用 <code>clusterIP: None</code>，Kubernetes 就会创建一个 Headless Service。</p>
<p><strong>核心特点：</strong></p>
<ol>
<li><strong>无 ClusterIP：</strong> 这是其名称 “Headless” 的由来。它没有一个统一的、虚拟的 Service IP。</li>
<li><strong>DNS 解析行为不同：</strong><ul>
<li><strong>常规 Service (有 ClusterIP)：</strong> 当你通过 DNS 查询一个常规 Service 时，它会返回 Service 的 ClusterIP。然后所有请求都会被代理到这个 ClusterIP。</li>
<li><strong>Headless Service：</strong> 当你通过 DNS 查询一个 Headless Service 时，Kubernetes 的 DNS 服务（CoreDNS）会直接返回<strong>所有匹配该 Service 的 Pod 的 IP 地址列表</strong>，而不是一个单一的 Service IP。<ul>
<li>如果该 Headless Service 没有 <code>selector</code>，它会直接返回 Service 定义的 <code>endpoints</code> 中的 IP 列表。</li>
</ul>
</li>
</ul>
</li>
<li><strong>无负载均衡 (通过 Kube-proxy)：</strong> 由于没有 ClusterIP，kube-proxy 不会为它进行流量代理和负载均衡。客户端需要自己处理从 DNS 返回的多个 IP 地址。</li>
<li><strong>提供 Pod 级别的可发现性：</strong> 对于需要直接连接特定 Pod 或需要客户端自己决定连接哪个 Pod 的场景非常有用。</li>
</ol>
<h3 id="Headless-Service-的应用场景"><a href="#Headless-Service-的应用场景" class="headerlink" title="Headless Service 的应用场景"></a>Headless Service 的应用场景</h3><p>Headless Service 主要用于以下几种情况：</p>
<ol>
<li><p><strong>有状态应用程序 (StatefulSets)：</strong></p>
<ul>
<li>这是 Headless Service 最常见的用途。<code>StatefulSet</code> 资源在创建 Pod 时通常需要每个 Pod 都拥有一个<strong>稳定且唯一的网络身份</strong>（稳定的主机名、稳定的存储、稳定的网络标识）。</li>
<li><code>StatefulSet</code> 通常会与一个 Headless Service 配合使用。这个 Headless Service 不仅让每个 Pod 拥有一个通过 DNS 解析的服务名称（如 <code>my-app-0.my-headless-service</code>, <code>my-app-1.my-headless-service</code>），而且客户端可以直接解析到这些 Pod 的 IP 地址。</li>
<li>这对于分布式数据库（如 Cassandra、MongoDB、Elasticsearch 集群）、消息队列（Kafka）等需要对副本进行精确控制和直接寻址的场景至关重要。</li>
</ul>
</li>
<li><p><strong>需要客户端自定义负载均衡或流量控制：</strong></p>
<ul>
<li>有些应用程序或服务网格（如 Istio、Linkerd）有自己内置的负载均衡逻辑。它们不希望 Kubernetes 的 kube-proxy 进行额外的代理。通过 Headless Service，它们可以直接获取到后端 Pod 的 IP 列表，然后根据自己的算法进行连接和负载均衡。</li>
<li>例如，gRPC 客户端通常希望进行客户端负载均衡。</li>
</ul>
</li>
<li><p><strong>需要直接操作 Pod IP 的场景：</strong></p>
<ul>
<li>某些特殊应用需要直接与 Pod IP 进行通信，而不是通过Service 的抽象 IP。Headless Service 提供了这种可能性。</li>
</ul>
</li>
</ol>
<h3 id="Headless-Service-的-DNS-解析示例"><a href="#Headless-Service-的-DNS-解析示例" class="headerlink" title="Headless Service 的 DNS 解析示例"></a>Headless Service 的 DNS 解析示例</h3><p>假设您有一个 Headless Service 叫 <code>my-app-headless</code>，它有三个 Pod 副本，IP 分别是 <code>10.42.0.10</code>、<code>10.42.0.11</code>、<code>10.42.0.12</code>。</p>
<ul>
<li><p><strong>常规查询：</strong></p>
<ul>
<li>如果你在集群内 <code>ping my-app-headless</code>，DNS 服务器会返回这三个 Pod 的 IP 地址列表。</li>
<li>如果你使用 <code>dig my-app-headless.mynamespace.svc.cluster.local</code>，你将看到返回多个 A 记录，每个记录对应一个 Pod 的 IP。</li>
</ul>
</li>
<li><p><strong>特定 Pod 查询 (通常用于 StatefulSets)：</strong></p>
<ul>
<li>如果 <code>my-app-headless</code> 是一个 StatefulSet 的 Headless Service，并且 StatefulSet 的 Pod 命名为 <code>my-app-0</code>, <code>my-app-1</code>, <code>my-app-2</code>。</li>
<li>那么你可以通过 <code>my-app-0.my-app-headless.mynamespace.svc.cluster.local</code> 来直接解析到 <code>my-app-0</code> 这个 Pod 的 IP 地址。</li>
</ul>
</li>
</ul>
<h3 id="YAML-示例"><a href="#YAML-示例" class="headerlink" title="YAML 示例"></a>YAML 示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-headless-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app-stateful</span> <span class="comment"># 匹配你的 Pod 的标签</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span>       <span class="comment"># **关键！** 将此 Service 定义为 Headless</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Headless Service 绕过了 Kubernetes 默认的 Service ClusterIP 抽象层，直接暴露了后端 Pod 的 IP 地址。它牺牲了 Service 提供的标准负载均衡能力，但换来了对单个 Pod 的精确寻址能力和更灵活的客户端负载均衡实现。这使得它成为管理有状态应用和需要更细粒度网络控制场景的理想选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/k8s%20service/">https://huiaz.github.io/2025/09/11/k8s%20service/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/k8s_10/" title="k8s_10"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">k8s_10</div></div><div class="info-2"><div class="info-item-1">请描述 Kubernetes 中的 Helm 的作用，并解释其使用场景。Of course. Helm is an indispensable tool in the Kubernetes ecosystem, and understanding its role is crucial for anyone managing applications at scale. Let’s dive into its purpose and common use cases. 🤔 分析过程：此问题旨在考察对Kubernetes应用部署和管理工具——Helm的理解。一个优秀的回答不能仅仅说“它是一个包管理器”，而需要深入解释它解决了什么核心痛点。核心痛点是：Kubernetes原生YAML文件缺乏模板化、版本控制和依赖管理能力，导致在多环境、复杂应用场景下难以管理。因此，回答的重点应围绕Helm如何通过打包（Charts）、模板化（Templating）和版本发布（Releases）来解决这些问题。 💡 答案生成：1. 概念或定义Helm 是Kubernetes的官方包管理器。它可以被...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20Service&amp;Ingress/" title="k8s Service&amp;Ingress"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">k8s Service&Ingress</div></div><div class="info-2"><div class="info-item-1">请解释 Kubernetes 中的 Service 和 Ingress 的区别，并描述各自的用途。	 🤔 分析过程：该问题旨在考察面试者对Kubernetes中两种核心网络资源——Service和Ingress的理解。核心考察点在于它们分别在哪个网络层级工作（L4 vs L7），各自解决了什么问题，以及它们如何协同工作。一个优秀的答案需要清晰地定义两者，对比其功能，并能结合实际应用场景说明何时使用哪一个。 💡 答案生成：1. 概念或定义 Service (服务): 是Kubernetes中的一个核心API对象，它定义了一组逻辑上的Pod，并为它们提供了一个单一、稳定的访问入口（一个虚拟IP地址和DNS名称）。Service主要工作在网络模型的第四层（L4 - TCP&#x2F;UDP），它关心的是如何将网络流量可靠地转发到后端的Pod，而不关心流量的具体内容。  Ingress (入口): 是一个API对象，用于管理对集群内Service的外部访问，主要工作在网络模型的第七层（L7 - HTTP&#x2F;S）。Ingress可以提供基于主机名（Host-based）和URL...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E9%98%88%E5%80%BC/" title="阈值"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">阈值</div></div><div class="info-2"><div class="info-item-1">阈值PromQL 通过提供一组过滤的二元运算符（&gt;、&lt;、== 等），允许根据其样本值过滤一组序列，这种过滤最常见的场景就是在报警规则中使用的阈值。比如我们想查找在过去 15 分钟内的 status=&quot;500&quot; 错误率大于 20% 的所有 HTTP 路径，我们在 rate 表达式后面添加一个 &gt;0.2 的过滤运算符： 1rate(demo_api_request_duration_seconds_count&#123;status=&quot;500&quot;,job=&quot;demo&quot;&#125;[15m]) &gt; 0.2    这个查询只会将错误率大于 20% 的数据过滤出来。   注意：由于在图形中的每个步长都是完全独立评估表达式的，因此根据每个步骤的过滤条件，某些比率会出现或消失（因此存在间隙）。 一般来说，二元过滤运算符在图形中并不常见，大多数在报警条件中出现，用来表示阈值。  这种过滤方式不仅适用于单个数字，PromQL 还允许你用一组时间序列过滤另一组序列。与上面的二元运算一样，比较运算符会自动应用于比较左侧和...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%AF%94/" title="数据对比"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">数据对比</div></div><div class="info-2"><div class="info-item-1">数据对比有的时候我们可能需要去访问过去的数据，并和当前数据进行对比。例如，我们可能想比较今天的请求率和一周前的请求率之间的差异。我们可以在任何区间向量或瞬时向量选择器上附加一个偏移量 offset&lt;duration&gt; 的修饰符（比如 my_metric offset 5m 或者 my_metric[1m] offset 7d）。 让我们来看一个示例，在我们的 demo 服务中暴露了一个 Counter 指标 demo_items_shipped_total，该指标追踪物品的运输情况，用 5 分钟来模拟&quot;每日&quot;流量周期，所以我们不必等待一整天才能查看该时段的数据。 我们只使用第一个演示服务实例来测试即可，首先我们来看看它的速率： 1rate(demo_items_shipped_total&#123;instance=&quot;demo-service-0:10000&quot;&#125;[1m])   该服务还暴露了一个 0 或 1 的布尔指标，告诉我们现在是否是假期：  将假期与发货商品率进行比较，注意到节假日时它会减少!我们可以尝试将当前的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ipvs%20%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/" title="ipvs 基本介绍"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ipvs 基本介绍</div></div><div class="info-2"><div class="info-item-1">ipvs 基本介绍ipvs (IP Virtual Server) 实现了传输层负载均衡，也就是我们常说的4层LAN交换，作为 Linux 内核的一部分。ipvs运行在主机上，在真实服务器集群前充当负载均衡器。ipvs可以将基于TCP和UDP的服务请求转发到真实服务器上，并使真实服务器的服务在单个 IP 地址上显示为虚拟服务。 ipvs vs. iptables我们知道kube-proxy支持 iptables 和 ipvs 两种模式， 在kubernetes v1.8 中引入了 ipvs 模式，在 v1.9 中处于 beta 阶段，在 v1.11 中已经正式可用了。iptables 模式在 v1.1 中就添加支持了，从 v1.2 版本开始 iptables 就是 kube-proxy 默认的操作模式，ipvs 和 iptables 都是基于netfilter的，那么 ipvs 模式和 iptables 模式之间有哪些差异呢？  ipvs 为大型集群提供了更好的可扩展性和性能 ipvs 支持比 iptables 更复杂的复制均衡算法（最小负载、最少连接、加权等等） ipvs 支持...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Service/" title="Service"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Service</div></div><div class="info-2"><div class="info-item-1">Service我们前面的课程中学习了一些常用控制器的基本用法，我们也了解到 Pod 的生命是有限的，死亡过后不会复活了。然后我们知道可以用 ReplicaSet 和 Deployment 来动态的创建和销毁 Pod，每个 Pod 都有自己的 IP 地址，但是如果 Pod 重建了的话那么他的 IP 很有可能也就变化了。这就会带来一个问题：比如我们有一些后端的 Pod 集合为集群中的其他应用提供 API 服务，如果我们在前端应用中把所有的这些后端的 Pod 的地址都写死，然后以某种方式去访问其中一个 Pod 的服务，这样看上去是可以工作的，对吧？但是如果这个 Pod 挂掉了，然后重新启动起来了，是不是 IP 地址非常有可能就变了，这个时候前端就极大可能访问不到后端的服务了。 遇到这样的问题该怎么解决呢？在没有使用 Kubernetes 之前，我相信可能很多同学都遇到过这样的问题，不一定是 IP 变化的问题，比如我们在部署一个 WEB 服务的时候，前端一般部署一个 Nginx 作为服务的入口，然后 Nginx 后面肯定就是挂载的这个服务的大量后端服务，很早以前我们可能是去手动更改 Ng...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Thanos%20Querier/" title="Thanos Querier"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Thanos Querier</div></div><div class="info-2"><div class="info-item-1">Querier 组件现在我们就创建成功了两个 Prometheus 实例，但是我们真正去使用的时候并不是像上面提到的在前面加一个负载均衡器去查询监控数据，而是使用 Thanos 的 Querier 组件来提供一个全局的统一查询入口。对于 Quierier 最重要的就是要配置上 Thanos 的 Sidecar 地址，我们这里完全可以直接使用 Headless Service 去自动发现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# thanos-querier.yamlapiVersion: apps/v1kind: Deploymentmetadata:  name: thanos-querier  namespace: kube-mon  labels:    app: thanos-querierspec:  replicas:...</div></div></div></a><a class="pagination-related" href="/2025/09/11/ReplicaSet/" title="ReplicaSet"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">ReplicaSet</div></div><div class="info-2"><div class="info-item-1">ReplicaSet 控制器前面我们一起学习了 Pod 的原理和一些基本使用，但是在实际使用的时候并不会直接使用 Pod，而是会使用各种控制器来满足我们的需求，Kubernetes 中运行了一系列控制器来确保集群的当前状态与期望状态保持一致，它们就是 Kubernetes 的大脑。例如，ReplicaSet 控制器负责维护集群中运行的 Pod 数量；Node 控制器负责监控节点的状态，并在节点出现故障时及时做出响应。总而言之，在 Kubernetes 中，每个控制器只负责某种类型的特定资源。 控制器Kubernetes 控制器会监听资源的 创建/更新/删除 事件，并触发 Reconcile 调谐函数作为响应，整个调整过程被称作 “Reconcile Loop”（调谐循环） 或者 “Sync Loop”（同步循环）。Reconcile 是一个使用资源对象的命名空间和资源对象名称来调用的函数，使得资源对象的实际状态与 资源清单中定义的状态保持一致。调用完成后，Reconcile 会将资源对象的状态更新为当前实际状态。我们可以用下面的一段伪代码来表示这个过程： 123456789for...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ClusterIP-%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">1. ClusterIP (默认类型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-NodePort"><span class="toc-number">2.</span> <span class="toc-text">2. NodePort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LoadBalancer"><span class="toc-number">3.</span> <span class="toc-text">3. LoadBalancer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ExternalName"><span class="toc-number">4.</span> <span class="toc-text">4. ExternalName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">总结选择指南：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headless-Service-%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">Headless Service 的定义与特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headless-Service-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.</span> <span class="toc-text">Headless Service 的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headless-Service-%E7%9A%84-DNS-%E8%A7%A3%E6%9E%90%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.</span> <span class="toc-text">Headless Service 的 DNS 解析示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YAML-%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.</span> <span class="toc-text">YAML 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>