<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>k8s service | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Service 主要有以下几种类型：  ClusterIP (默认类型) NodePort LoadBalancer ExternalName  接下来，我将分别详细介绍每种类型及其应用场景。  1. ClusterIP (默认类型) 作用： 为 Service 在 Kubernetes 集群内部分配一个唯一的、虚拟的 IP 地址（ClusterIP）。这个 IP 地址只在集群内部可达。  访问方">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s service">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/k8s%20service/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="Service 主要有以下几种类型：  ClusterIP (默认类型) NodePort LoadBalancer ExternalName  接下来，我将分别详细介绍每种类型及其应用场景。  1. ClusterIP (默认类型) 作用： 为 Service 在 Kubernetes 集群内部分配一个唯一的、虚拟的 IP 地址（ClusterIP）。这个 IP 地址只在集群内部可达。  访问方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:44:01.942Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "k8s service",
  "url": "https://huiaz.github.io/2025/09/11/k8s%20service/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:44:01.942Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/k8s%20service/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'k8s service',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">k8s service</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">k8s service</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:44:01.942Z" title="更新于 2025-09-11 21:44:01">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Service 主要有以下几种类型：</p>
<ol>
<li><strong>ClusterIP (默认类型)</strong></li>
<li><strong>NodePort</strong></li>
<li><strong>LoadBalancer</strong></li>
<li><strong>ExternalName</strong></li>
</ol>
<p>接下来，我将分别详细介绍每种类型及其应用场景。</p>
<hr>
<h3 id="1-ClusterIP-默认类型"><a href="#1-ClusterIP-默认类型" class="headerlink" title="1. ClusterIP (默认类型)"></a>1. ClusterIP (默认类型)</h3><ul>
<li><p><strong>作用：</strong> 为 Service 在 Kubernetes 集群内部分配一个<strong>唯一的、虚拟的 IP 地址</strong>（ClusterIP）。这个 IP 地址只在集群内部可达。</p>
</li>
<li><p><strong>访问方式：</strong> 集群<strong>内部</strong>的其他 Pod 或组件可以通过这个 ClusterIP 和端口来访问该 Service 后端的 Pod。</p>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li><strong>内部可见：</strong> 只能在集群内部访问，外部无法直接访问。</li>
<li><strong>负载均衡：</strong> Pod 流量通过 kube-proxy 代理转发到后端的 Pod，并自动进行简单的轮询式负载均衡。</li>
<li><strong>稳定性：</strong> 提供了稳定的 IP 地址和 DNS 名称， Pod 的 IP 变化不会影响 Service 的可访问性。</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><strong>内部服务通信：</strong> 最常见的用于微服务之间互相调用的场景。例如，前端服务访问后端服务，或其他服务访问数据库服务等。</li>
<li>集群内部调试。</li>
</ul>
</li>
<li><p><strong>示例 YAML 片段:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span> <span class="comment"># 这个 Service 会关联所有带有 &#x27;app: my-app&#x27; 标签的 Pod</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># Service 监听的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># Pod 内部应用监听的端口</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span> <span class="comment"># 可以省略，因为是默认类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-NodePort"><a href="#2-NodePort" class="headerlink" title="2. NodePort"></a>2. NodePort</h3><ul>
<li><strong>作用：</strong> 在每个集群节点（Node）上开启一个<strong>静态端口</strong> (NodePort)，并将这个端口映射到 Service 的 ClusterIP 端口。这意味着，任何发送到 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 的请求都会被转发到 Service。</li>
<li><strong>访问方式：</strong> 集群<strong>内部和外部</strong>都可以通过任意节点的 IP 地址加上 NodePort 来访问 Service。</li>
<li><strong>特点：</strong><ul>
<li><strong>外部暴露：</strong> 这是将 Service 暴露给集群外部的最基本方式。</li>
<li><strong>端口范围：</strong> NodePort 的端口范围通常是 <code>30000-32767</code>，这个范围可以在 kube-apiserver 配置中修改。</li>
<li><strong>任意节点：</strong> 无论请求发送到哪个节点的 NodePort，都会被路由到正确的后端 Pod。</li>
<li><strong>不适合生产：</strong> NodePort 端口是固定的，但若有多个 NodePort Service，端口号的管理会比较繁琐。更重要的是，它不提供负载均衡能力（客户端需要知道所有节点 IP），且端口暴露在所有节点上，安全性较低。</li>
</ul>
</li>
<li><strong>使用场景：</strong><ul>
<li><strong>测试和演示：</strong> 快速验证应用程序的外部可访问性，不适合生产环境。</li>
<li><strong>非云环境的裸金属集群：</strong> 有时在没有外部负载均衡器的环境中，作为临时的外部访问方案。</li>
</ul>
</li>
<li><strong>示例 YAML 片段:</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-nodeport-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span> <span class="comment"># 可以指定，也可以由K8s自动分配一个（在30000-32767范围内）</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>
外部访问：<code>http://&lt;任何一个Node的IP&gt;:30080</code></li>
</ul>
<hr>
<h3 id="3-LoadBalancer"><a href="#3-LoadBalancer" class="headerlink" title="3. LoadBalancer"></a>3. LoadBalancer</h3><ul>
<li><strong>作用：</strong> 这是在公有云提供商（如 AWS EKS, GKE, Azure AKS 等）环境中，<strong>将 Service 暴露给外部流量的标准方式。</strong> 它会请求云提供商创建一个<strong>外部负载均衡器</strong>，并将外部流量路由到 Kubernetes 集群中的 Service。</li>
<li><strong>访问方式：</strong> 外部客户端通过云提供商分配的负载均衡器 IP 地址或 DNS 名称来访问 Service。</li>
<li><strong>特点：</strong><ul>
<li><strong>外部负载均衡器：</strong> 由云提供商管理，通常具备高可用、弹性伸缩和高级路由功能。</li>
<li><strong>自动配置：</strong> Kubernetes 会自动与云提供商 API 集成，创建、配置和管理负载均衡器。</li>
<li><strong>生产环境推荐：</strong> 这是在公有云上暴露 Web 服务和 API 服务的首选方式。</li>
<li><strong>成本：</strong> 云负载均衡器通常会产生费用。</li>
</ul>
</li>
<li><strong>使用场景：</strong><ul>
<li><strong>部署在公有云上的 Web 应用、API 服务等，需要对外提供稳定、高可用的访问入口。</strong></li>
</ul>
</li>
<li><strong>示例 YAML 片段:</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-lb-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br></pre></td></tr></table></figure>
应用此 YAML 后，Kubernetes 会在几分钟内（取决于云提供商）为这个 Service 分配一个外部 IP 地址。可以通过 <code>kubectl get svc my-app-lb-service</code> 查看 <code>EXTERNAL-IP</code> 字段。</li>
</ul>
<hr>
<h3 id="4-ExternalName"><a href="#4-ExternalName" class="headerlink" title="4. ExternalName"></a>4. ExternalName</h3><ul>
<li><strong>作用：</strong> ExternalName Service 不会代理任何 Pod，也不会分配 ClusterIP。它通过返回一个 CNAME 记录，将 Service 映射到集群外部的 DNS 名称。</li>
<li><strong>访问方式：</strong> 当集群内部的 Pod 尝试访问这个 Service 时，DNS 服务（CoreDNS）会直接返回其配置的外部 DNS 名称，客户端会直接连接到那个外部地址，而不是通过 Kube-proxy。</li>
<li><strong>特点：</strong><ul>
<li><strong>DNS 别名：</strong> 像 DNS CNAME 一样工作，将流量重定向到集群外部的服务。</li>
<li><strong>无代理：</strong> 没有代理行为，因此没有负载均衡，没有端口映射。</li>
<li><strong>不占用 IP：</strong> 不分配 ClusterIP。</li>
</ul>
</li>
<li><strong>使用场景：</strong><ul>
<li><strong>集群内部服务访问外部数据库或外部API：</strong> 允许集群内部的服务使用一个统一的、内部的 DNS 名称来访问集群外部的某个服务（如云数据库 RDS、第三方 API），而无需修改应用程序代码。</li>
<li>在不改变代码的情况下，将应用从集群内部的服务切换到外部服务。</li>
</ul>
</li>
<li><strong>示例 YAML 片段:</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-external-db</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">my-database.example.com</span> <span class="comment"># 指向集群外部的DNS名称</span></span><br></pre></td></tr></table></figure>
集群内部的 Pod 如果尝试连接 <code>my-external-db:8080</code>，DNS 查询会直接解析到 <code>my-database.example.com</code>，然后客户端会直接连接到该外部地址。</li>
</ul>
<hr>
<h3 id="总结选择指南："><a href="#总结选择指南：" class="headerlink" title="总结选择指南："></a>总结选择指南：</h3><ol>
<li><strong>内部服务通信 (Service-to-Service):</strong> 始终使用 <strong>ClusterIP</strong>。</li>
<li><strong>在公有云上暴露服务：</strong> 使用 <strong>LoadBalancer</strong>。</li>
<li><strong>开发&#x2F;测试时快速暴露服务，或裸金属环境的临时方案：</strong> 可以使用 <strong>NodePort</strong>，但需注意其局限性。</li>
<li><strong>将内部流量重定向到集群外部服务：</strong> 使用 <strong>ExternalName</strong>。</li>
</ol>
<p>在实际生产中，除了 LoadBalancer 类型 Service，更高级的外部暴露方式通常还会结合 <strong>Ingress</strong>，Ingress 提供了更灵活的 HTTP&#x2F;HTTPS 路由规则，如基于路径、基于域名的路由，以及 SSL&#x2F;TLS 终止等功能。Ingress 通常需要 Ingress Controller（如 Nginx Ingress Controller）来实际执行这些路由。</p>
<p>好的，Headless Service 是 Kubernetes Service 中的一个特殊类型，它<strong>不会为其分配 ClusterIP</strong>。这是它最主要的特征。</p>
<h3 id="Headless-Service-的定义与特点"><a href="#Headless-Service-的定义与特点" class="headerlink" title="Headless Service 的定义与特点"></a>Headless Service 的定义与特点</h3><p>当你在定义 Service 时，将 <code>clusterIP</code> 字段设置为 <code>None</code> (或者在 YAML 文件中完全不指定 <code>clusterIP</code> 字段，并确保 <code>type</code> 不是 <code>ExternalName</code> 且不是 <code>LoadBalancer</code>，对于一些早期的 Kubernetes 版本可能需要显式设置，但现在自动推断为空即可)，或者使用 <code>clusterIP: None</code>，Kubernetes 就会创建一个 Headless Service。</p>
<p><strong>核心特点：</strong></p>
<ol>
<li><strong>无 ClusterIP：</strong> 这是其名称 “Headless” 的由来。它没有一个统一的、虚拟的 Service IP。</li>
<li><strong>DNS 解析行为不同：</strong><ul>
<li><strong>常规 Service (有 ClusterIP)：</strong> 当你通过 DNS 查询一个常规 Service 时，它会返回 Service 的 ClusterIP。然后所有请求都会被代理到这个 ClusterIP。</li>
<li><strong>Headless Service：</strong> 当你通过 DNS 查询一个 Headless Service 时，Kubernetes 的 DNS 服务（CoreDNS）会直接返回<strong>所有匹配该 Service 的 Pod 的 IP 地址列表</strong>，而不是一个单一的 Service IP。<ul>
<li>如果该 Headless Service 没有 <code>selector</code>，它会直接返回 Service 定义的 <code>endpoints</code> 中的 IP 列表。</li>
</ul>
</li>
</ul>
</li>
<li><strong>无负载均衡 (通过 Kube-proxy)：</strong> 由于没有 ClusterIP，kube-proxy 不会为它进行流量代理和负载均衡。客户端需要自己处理从 DNS 返回的多个 IP 地址。</li>
<li><strong>提供 Pod 级别的可发现性：</strong> 对于需要直接连接特定 Pod 或需要客户端自己决定连接哪个 Pod 的场景非常有用。</li>
</ol>
<h3 id="Headless-Service-的应用场景"><a href="#Headless-Service-的应用场景" class="headerlink" title="Headless Service 的应用场景"></a>Headless Service 的应用场景</h3><p>Headless Service 主要用于以下几种情况：</p>
<ol>
<li><p><strong>有状态应用程序 (StatefulSets)：</strong></p>
<ul>
<li>这是 Headless Service 最常见的用途。<code>StatefulSet</code> 资源在创建 Pod 时通常需要每个 Pod 都拥有一个<strong>稳定且唯一的网络身份</strong>（稳定的主机名、稳定的存储、稳定的网络标识）。</li>
<li><code>StatefulSet</code> 通常会与一个 Headless Service 配合使用。这个 Headless Service 不仅让每个 Pod 拥有一个通过 DNS 解析的服务名称（如 <code>my-app-0.my-headless-service</code>, <code>my-app-1.my-headless-service</code>），而且客户端可以直接解析到这些 Pod 的 IP 地址。</li>
<li>这对于分布式数据库（如 Cassandra、MongoDB、Elasticsearch 集群）、消息队列（Kafka）等需要对副本进行精确控制和直接寻址的场景至关重要。</li>
</ul>
</li>
<li><p><strong>需要客户端自定义负载均衡或流量控制：</strong></p>
<ul>
<li>有些应用程序或服务网格（如 Istio、Linkerd）有自己内置的负载均衡逻辑。它们不希望 Kubernetes 的 kube-proxy 进行额外的代理。通过 Headless Service，它们可以直接获取到后端 Pod 的 IP 列表，然后根据自己的算法进行连接和负载均衡。</li>
<li>例如，gRPC 客户端通常希望进行客户端负载均衡。</li>
</ul>
</li>
<li><p><strong>需要直接操作 Pod IP 的场景：</strong></p>
<ul>
<li>某些特殊应用需要直接与 Pod IP 进行通信，而不是通过Service 的抽象 IP。Headless Service 提供了这种可能性。</li>
</ul>
</li>
</ol>
<h3 id="Headless-Service-的-DNS-解析示例"><a href="#Headless-Service-的-DNS-解析示例" class="headerlink" title="Headless Service 的 DNS 解析示例"></a>Headless Service 的 DNS 解析示例</h3><p>假设您有一个 Headless Service 叫 <code>my-app-headless</code>，它有三个 Pod 副本，IP 分别是 <code>10.42.0.10</code>、<code>10.42.0.11</code>、<code>10.42.0.12</code>。</p>
<ul>
<li><p><strong>常规查询：</strong></p>
<ul>
<li>如果你在集群内 <code>ping my-app-headless</code>，DNS 服务器会返回这三个 Pod 的 IP 地址列表。</li>
<li>如果你使用 <code>dig my-app-headless.mynamespace.svc.cluster.local</code>，你将看到返回多个 A 记录，每个记录对应一个 Pod 的 IP。</li>
</ul>
</li>
<li><p><strong>特定 Pod 查询 (通常用于 StatefulSets)：</strong></p>
<ul>
<li>如果 <code>my-app-headless</code> 是一个 StatefulSet 的 Headless Service，并且 StatefulSet 的 Pod 命名为 <code>my-app-0</code>, <code>my-app-1</code>, <code>my-app-2</code>。</li>
<li>那么你可以通过 <code>my-app-0.my-app-headless.mynamespace.svc.cluster.local</code> 来直接解析到 <code>my-app-0</code> 这个 Pod 的 IP 地址。</li>
</ul>
</li>
</ul>
<h3 id="YAML-示例"><a href="#YAML-示例" class="headerlink" title="YAML 示例"></a>YAML 示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-headless-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app-stateful</span> <span class="comment"># 匹配你的 Pod 的标签</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span>       <span class="comment"># **关键！** 将此 Service 定义为 Headless</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Headless Service 绕过了 Kubernetes 默认的 Service ClusterIP 抽象层，直接暴露了后端 Pod 的 IP 地址。它牺牲了 Service 提供的标准负载均衡能力，但换来了对单个 Pod 的精确寻址能力和更灵活的客户端负载均衡实现。这使得它成为管理有状态应用和需要更细粒度网络控制场景的理想选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/k8s%20service/">https://huiaz.github.io/2025/09/11/k8s%20service/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/k8s_10/" title="k8s_10"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">k8s_10</div></div><div class="info-2"><div class="info-item-1">请描述 Kubernetes 中的 Helm 的作用，并解释其使用场景。Of course. Helm is an indispensable tool in the Kubernetes ecosystem, and understanding its role is crucial for anyone managing applications at scale. Let’s dive into its purpose and common use cases. 🤔 分析过程：此问题旨在考察对Kubernetes应用部署和管理工具——Helm的理解。一个优秀的回答不能仅仅说“它是一个包管理器”，而需要深入解释它解决了什么核心痛点。核心痛点是：Kubernetes原生YAML文件缺乏模板化、版本控制和依赖管理能力，导致在多环境、复杂应用场景下难以管理。因此，回答的重点应围绕Helm如何通过打包（Charts）、模板化（Templating）和版本发布（Releases）来解决这些问题。 💡 答案生成：1. 概念或定义Helm 是Kubernetes的官方包管理器。它可以被...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20Service&amp;Ingress/" title="k8s Service&amp;Ingress"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">k8s Service&Ingress</div></div><div class="info-2"><div class="info-item-1">请解释 Kubernetes 中的 Service 和 Ingress 的区别，并描述各自的用途。	 🤔 分析过程：该问题旨在考察面试者对Kubernetes中两种核心网络资源——Service和Ingress的理解。核心考察点在于它们分别在哪个网络层级工作（L4 vs L7），各自解决了什么问题，以及它们如何协同工作。一个优秀的答案需要清晰地定义两者，对比其功能，并能结合实际应用场景说明何时使用哪一个。 💡 答案生成：1. 概念或定义 Service (服务): 是Kubernetes中的一个核心API对象，它定义了一组逻辑上的Pod，并为它们提供了一个单一、稳定的访问入口（一个虚拟IP地址和DNS名称）。Service主要工作在网络模型的第四层（L4 - TCP&#x2F;UDP），它关心的是如何将网络流量可靠地转发到后端的Pod，而不关心流量的具体内容。  Ingress (入口): 是一个API对象，用于管理对集群内Service的外部访问，主要工作在网络模型的第七层（L7 - HTTP&#x2F;S）。Ingress可以提供基于主机名（Host-based）和URL...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/Pod%20%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/" title="Pod 使用进阶"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Pod 使用进阶</div></div><div class="info-2"><div class="info-item-1">Pod 使用进阶-深入理解 Pod 对象Pod 资源配置实际上上面几个步骤就是影响一个 Pod 生命周期的大的部分，但是还有一些细节也会在 Pod 的启动过程进行设置，比如在容器启动之前还会为当前的容器设置分配的 CPU、内存等资源，我们知道我们可以通过 CGroup 来对容器的资源进行限制，同样的，在 Pod 中我们也可以直接配置某个容器的使用的 CPU 或者内存的上限。那么 Pod 是如何来使用和控制这些资源的分配的呢？ 首先对于 CPU，我们知道计算机里 CPU 的资源是按“时间片”的方式来进行分配的，系统里的每一个操作都需要 CPU 的处理，所以，哪个任务要是申请的 CPU 时间片越多，那么它得到的 CPU 资源就越多，这个很容器理解。 然后还需要了解下 CGroup 里面对于 CPU 资源的单位换算： 121 CPU =  1000 millicpu（1 Core = 1000m）0.5 CPU = 500 millicpu （0.5 Core = 500m）  这里的 m 就是毫、毫核的意思，Kubernetes 集群中的每一个节点可以通过操作系统的命令来确认本节点的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%9F%BA%E4%BA%8E%20Jenkins%E3%80%81Gitlab%E3%80%81Harbor%E3%80%81Helm%20%E5%92%8C%20Kubernetes%20%E7%9A%84%20CICD/" title="基于 Jenkins、Gitlab、Harbor、Helm 和 Kubernetes 的 CICD"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">基于 Jenkins、Gitlab、Harbor、Helm 和 Kubernetes 的 CICD</div></div><div class="info-2"><div class="info-item-1">基于 Jenkins、Gitlab、Harbor、Helm 和 Kubernetes 的 CI&#x2F;CD上节课和大家介绍了Gitlab CI结合Kubernetes进行 CI&#x2F;CD 的完整过程。这节课结合前面所学的知识点给大家介绍一个完整的示例：使用 Jenkins + Gitlab + Harbor + Helm + Kubernetes 来实现一个完整的 CI&#x2F;CD 流水线作业。 其实前面的课程中我们就已经学习了 Jenkins Pipeline 与 Kubernetes 的完美结合，我们利用 Kubernetes 来动态运行 Jenkins 的 Slave 节点，可以和好的来解决传统的 Jenkins Slave 浪费大量资源的缺点。之前的示例中我们是将项目放置在 Github 仓库上的，将 Docker 镜像推送到了 Docker Hub，这节课我们来结合我们前面学习的知识点来综合运用下，使用 Jenkins、Gitlab、Harbor、Helm、Kubernetes 来实现一个完整的持续集成和持续部署的流水线作业。 流程下图是我们当前示例的流程...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E8%8A%82%E7%82%B9%E7%9B%91%E6%8E%A7/" title="节点监控"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">节点监控</div></div><div class="info-2"><div class="info-item-1">节点监控前面我们和大家学习了怎样用 Promethues 来监控 Kubernetes 集群中的应用，但是对于 Kubernetes 集群本身的监控也是非常重要的，我们需要时时刻刻了解集群的运行状态。 监控方案对于集群的监控一般我们需要考虑以下几个方面：  Kubernetes 节点的监控：比如节点的 cpu、load、disk、memory 等指标 内部系统组件的状态：比如 kube-scheduler、kube-controller-manager、kubedns&#x2F;coredns 等组件的详细运行状态 编排级的 metrics：比如 Deployment 的状态、资源请求、调度和 API 延迟等数据指标  Kubernetes 集群的监控方案目前主要有以下几种方案：  cAdvisor：cAdvisor 是 Google 开源的容器资源监控和性能分析工具，它是专门为容器而生，本身也支持 Docker 容器。 kube-state-metrics：kube-state-metrics 通过监听 API Server 生成有关资源对象的状态指标，比如 Deploymen...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20ResourceQuota/" title="k8s ResourceQuota"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s ResourceQuota</div></div><div class="info-2"><div class="info-item-1">描述在 Kubernetes 中如何配置资源配额，并解释其作用。	 🤔 分析过程：此问题旨在考察对Kubernetes资源治理和多租户管理的理解。核心是ResourceQuota对象。一个高质量的回答不仅要说明如何创建ResourceQuota，更要阐明其核心目的：为命名空间（Namespace）设置资源“预算”。这包括计算资源（CPU&#x2F;Memory）、存储资源和对象数量的限制。此外，还应提及它与LimitRange对象的关系，这能体现出对资源管理体系的深入理解。 💡 答案生成：1. 概念或定义ResourceQuota（资源配额）是Kubernetes中的一个策略对象，它为命名空间（Namespace）提供了资源消耗的总量限制。它允许集群管理员为每个命名空间分配一个“预算”，确保单个团队或应用不会消耗掉超出其分配额度的资源，从而影响到集群中的其他用户。 核心要点： 资源配额是作用于命名空间级别的，不是作用于单个Pod或节点的。 2. 作用与目的配置资源配额的主要作用是实现集群的治理和公平性，具体目标包括：  防止“邻居吵闹”问题 (Noisy Neighbor):...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Kubernetes%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" title="Kubernetes 集群部署"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Kubernetes 集群部署</div></div><div class="info-2"><div class="info-item-1">Kubernetes 集群部署现在我们使用 kubeadm 从头搭建一个使用 containerd 作为容器运行时的 Kubernetes 集群，这里我们安装最新的 v1.22.2 版本。 环境准备3 个节点，都是 Centos 7.6 系统，内核版本：3.10.0-1062.4.1.el7.x86_64，在每个节点上添加 hosts 信息： 1234➜  ~ cat /etc/hosts192.168.31.31 master1192.168.31.108 node1192.168.31.46 node2  hostname 节点的 hostname 必须使用标准的 DNS 命名，另外千万不用什么默认的localhost 的 hostname，会导致各种错误出现的。在 Kubernetes 项目里，机器的名字以及一切存储在 Etcd 中的 API 对象，都必须使用标准的 DNS 命名（RFC 1123）。可以使用命令 hostnamectl set-hostname node1 来修改 hostname。 禁用防火墙： 12➜  ~ systemctl stop firewal...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%96%B0%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%20CubeFS/" title="新一代云原生存储系统 CubeFS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">新一代云原生存储系统 CubeFS</div></div><div class="info-2"><div class="info-item-1">新一代云原生存储系统 CubeFSCubeFS是一种新一代云原生存储系统，支持 S3、HDFS 和 POSIX 等访问协议，支持多副本与纠删码两种存储引擎，为用户提供多租户、 多 AZ 部署以及跨区域复制等多种特性。  CubeFS 作为一个云原生的分布式存储平台，提供了多种访问协议，因此其应用场景也非常广泛，下面简单介绍几种比较典型的应用场景  大数据分析：兼容 HDFS 协议，为 Hadoop 生态（如 Spark、Hive）提供统一存储底座，为计算引擎提供无限的存储空间以及大带宽的数据存储能力。 深度训练&#x2F;机器学习：作为分布式并行文件系统，支撑 AI 训练、模型存储及分发、IO 加速等需求。 容器共享存储：容器集群可以将容器镜像的配置文件或初始化加载数据存储在 CubeFS 上，在容器批量加载时实时读取。多 Pod 间通过 CubeFS 共享持久化数据，在 Pod 故障时可以进行快速故障切换。 数据库&amp;中间件：为数据库应用如 MySQL、ElasticSearch、ClickHouse 提供高并发、低时延云盘服务，实现彻底的存算分离。 在线服务：为在线业务...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ClusterIP-%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">1. ClusterIP (默认类型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-NodePort"><span class="toc-number">2.</span> <span class="toc-text">2. NodePort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LoadBalancer"><span class="toc-number">3.</span> <span class="toc-text">3. LoadBalancer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ExternalName"><span class="toc-number">4.</span> <span class="toc-text">4. ExternalName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">总结选择指南：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headless-Service-%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">Headless Service 的定义与特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headless-Service-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.</span> <span class="toc-text">Headless Service 的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headless-Service-%E7%9A%84-DNS-%E8%A7%A3%E6%9E%90%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.</span> <span class="toc-text">Headless Service 的 DNS 解析示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YAML-%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.</span> <span class="toc-text">YAML 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>