<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>k8s service | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Service 主要有以下几种类型：  ClusterIP (默认类型) NodePort LoadBalancer ExternalName  接下来，我将分别详细介绍每种类型及其应用场景。  1. ClusterIP (默认类型) 作用： 为 Service 在 Kubernetes 集群内部分配一个唯一的、虚拟的 IP 地址（ClusterIP）。这个 IP 地址只在集群内部可达。  访问方">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s service">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/k8s%20service/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="Service 主要有以下几种类型：  ClusterIP (默认类型) NodePort LoadBalancer ExternalName  接下来，我将分别详细介绍每种类型及其应用场景。  1. ClusterIP (默认类型) 作用： 为 Service 在 Kubernetes 集群内部分配一个唯一的、虚拟的 IP 地址（ClusterIP）。这个 IP 地址只在集群内部可达。  访问方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T13:44:01.942Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "k8s service",
  "url": "https://huiaz.github.io/2025/09/11/k8s%20service/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T13:44:01.942Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/k8s%20service/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'k8s service',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">k8s service</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">k8s service</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T13:44:01.942Z" title="更新于 2025-09-11 21:44:01">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/">k8s</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/k8s/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Service 主要有以下几种类型：</p>
<ol>
<li><strong>ClusterIP (默认类型)</strong></li>
<li><strong>NodePort</strong></li>
<li><strong>LoadBalancer</strong></li>
<li><strong>ExternalName</strong></li>
</ol>
<p>接下来，我将分别详细介绍每种类型及其应用场景。</p>
<hr>
<h3 id="1-ClusterIP-默认类型"><a href="#1-ClusterIP-默认类型" class="headerlink" title="1. ClusterIP (默认类型)"></a>1. ClusterIP (默认类型)</h3><ul>
<li><p><strong>作用：</strong> 为 Service 在 Kubernetes 集群内部分配一个<strong>唯一的、虚拟的 IP 地址</strong>（ClusterIP）。这个 IP 地址只在集群内部可达。</p>
</li>
<li><p><strong>访问方式：</strong> 集群<strong>内部</strong>的其他 Pod 或组件可以通过这个 ClusterIP 和端口来访问该 Service 后端的 Pod。</p>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li><strong>内部可见：</strong> 只能在集群内部访问，外部无法直接访问。</li>
<li><strong>负载均衡：</strong> Pod 流量通过 kube-proxy 代理转发到后端的 Pod，并自动进行简单的轮询式负载均衡。</li>
<li><strong>稳定性：</strong> 提供了稳定的 IP 地址和 DNS 名称， Pod 的 IP 变化不会影响 Service 的可访问性。</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><strong>内部服务通信：</strong> 最常见的用于微服务之间互相调用的场景。例如，前端服务访问后端服务，或其他服务访问数据库服务等。</li>
<li>集群内部调试。</li>
</ul>
</li>
<li><p><strong>示例 YAML 片段:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span> <span class="comment"># 这个 Service 会关联所有带有 &#x27;app: my-app&#x27; 标签的 Pod</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># Service 监听的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># Pod 内部应用监听的端口</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span> <span class="comment"># 可以省略，因为是默认类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-NodePort"><a href="#2-NodePort" class="headerlink" title="2. NodePort"></a>2. NodePort</h3><ul>
<li><strong>作用：</strong> 在每个集群节点（Node）上开启一个<strong>静态端口</strong> (NodePort)，并将这个端口映射到 Service 的 ClusterIP 端口。这意味着，任何发送到 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 的请求都会被转发到 Service。</li>
<li><strong>访问方式：</strong> 集群<strong>内部和外部</strong>都可以通过任意节点的 IP 地址加上 NodePort 来访问 Service。</li>
<li><strong>特点：</strong><ul>
<li><strong>外部暴露：</strong> 这是将 Service 暴露给集群外部的最基本方式。</li>
<li><strong>端口范围：</strong> NodePort 的端口范围通常是 <code>30000-32767</code>，这个范围可以在 kube-apiserver 配置中修改。</li>
<li><strong>任意节点：</strong> 无论请求发送到哪个节点的 NodePort，都会被路由到正确的后端 Pod。</li>
<li><strong>不适合生产：</strong> NodePort 端口是固定的，但若有多个 NodePort Service，端口号的管理会比较繁琐。更重要的是，它不提供负载均衡能力（客户端需要知道所有节点 IP），且端口暴露在所有节点上，安全性较低。</li>
</ul>
</li>
<li><strong>使用场景：</strong><ul>
<li><strong>测试和演示：</strong> 快速验证应用程序的外部可访问性，不适合生产环境。</li>
<li><strong>非云环境的裸金属集群：</strong> 有时在没有外部负载均衡器的环境中，作为临时的外部访问方案。</li>
</ul>
</li>
<li><strong>示例 YAML 片段:</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-nodeport-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span> <span class="comment"># 可以指定，也可以由K8s自动分配一个（在30000-32767范围内）</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>
外部访问：<code>http://&lt;任何一个Node的IP&gt;:30080</code></li>
</ul>
<hr>
<h3 id="3-LoadBalancer"><a href="#3-LoadBalancer" class="headerlink" title="3. LoadBalancer"></a>3. LoadBalancer</h3><ul>
<li><strong>作用：</strong> 这是在公有云提供商（如 AWS EKS, GKE, Azure AKS 等）环境中，<strong>将 Service 暴露给外部流量的标准方式。</strong> 它会请求云提供商创建一个<strong>外部负载均衡器</strong>，并将外部流量路由到 Kubernetes 集群中的 Service。</li>
<li><strong>访问方式：</strong> 外部客户端通过云提供商分配的负载均衡器 IP 地址或 DNS 名称来访问 Service。</li>
<li><strong>特点：</strong><ul>
<li><strong>外部负载均衡器：</strong> 由云提供商管理，通常具备高可用、弹性伸缩和高级路由功能。</li>
<li><strong>自动配置：</strong> Kubernetes 会自动与云提供商 API 集成，创建、配置和管理负载均衡器。</li>
<li><strong>生产环境推荐：</strong> 这是在公有云上暴露 Web 服务和 API 服务的首选方式。</li>
<li><strong>成本：</strong> 云负载均衡器通常会产生费用。</li>
</ul>
</li>
<li><strong>使用场景：</strong><ul>
<li><strong>部署在公有云上的 Web 应用、API 服务等，需要对外提供稳定、高可用的访问入口。</strong></li>
</ul>
</li>
<li><strong>示例 YAML 片段:</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-lb-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br></pre></td></tr></table></figure>
应用此 YAML 后，Kubernetes 会在几分钟内（取决于云提供商）为这个 Service 分配一个外部 IP 地址。可以通过 <code>kubectl get svc my-app-lb-service</code> 查看 <code>EXTERNAL-IP</code> 字段。</li>
</ul>
<hr>
<h3 id="4-ExternalName"><a href="#4-ExternalName" class="headerlink" title="4. ExternalName"></a>4. ExternalName</h3><ul>
<li><strong>作用：</strong> ExternalName Service 不会代理任何 Pod，也不会分配 ClusterIP。它通过返回一个 CNAME 记录，将 Service 映射到集群外部的 DNS 名称。</li>
<li><strong>访问方式：</strong> 当集群内部的 Pod 尝试访问这个 Service 时，DNS 服务（CoreDNS）会直接返回其配置的外部 DNS 名称，客户端会直接连接到那个外部地址，而不是通过 Kube-proxy。</li>
<li><strong>特点：</strong><ul>
<li><strong>DNS 别名：</strong> 像 DNS CNAME 一样工作，将流量重定向到集群外部的服务。</li>
<li><strong>无代理：</strong> 没有代理行为，因此没有负载均衡，没有端口映射。</li>
<li><strong>不占用 IP：</strong> 不分配 ClusterIP。</li>
</ul>
</li>
<li><strong>使用场景：</strong><ul>
<li><strong>集群内部服务访问外部数据库或外部API：</strong> 允许集群内部的服务使用一个统一的、内部的 DNS 名称来访问集群外部的某个服务（如云数据库 RDS、第三方 API），而无需修改应用程序代码。</li>
<li>在不改变代码的情况下，将应用从集群内部的服务切换到外部服务。</li>
</ul>
</li>
<li><strong>示例 YAML 片段:</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-external-db</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">my-database.example.com</span> <span class="comment"># 指向集群外部的DNS名称</span></span><br></pre></td></tr></table></figure>
集群内部的 Pod 如果尝试连接 <code>my-external-db:8080</code>，DNS 查询会直接解析到 <code>my-database.example.com</code>，然后客户端会直接连接到该外部地址。</li>
</ul>
<hr>
<h3 id="总结选择指南："><a href="#总结选择指南：" class="headerlink" title="总结选择指南："></a>总结选择指南：</h3><ol>
<li><strong>内部服务通信 (Service-to-Service):</strong> 始终使用 <strong>ClusterIP</strong>。</li>
<li><strong>在公有云上暴露服务：</strong> 使用 <strong>LoadBalancer</strong>。</li>
<li><strong>开发&#x2F;测试时快速暴露服务，或裸金属环境的临时方案：</strong> 可以使用 <strong>NodePort</strong>，但需注意其局限性。</li>
<li><strong>将内部流量重定向到集群外部服务：</strong> 使用 <strong>ExternalName</strong>。</li>
</ol>
<p>在实际生产中，除了 LoadBalancer 类型 Service，更高级的外部暴露方式通常还会结合 <strong>Ingress</strong>，Ingress 提供了更灵活的 HTTP&#x2F;HTTPS 路由规则，如基于路径、基于域名的路由，以及 SSL&#x2F;TLS 终止等功能。Ingress 通常需要 Ingress Controller（如 Nginx Ingress Controller）来实际执行这些路由。</p>
<p>好的，Headless Service 是 Kubernetes Service 中的一个特殊类型，它<strong>不会为其分配 ClusterIP</strong>。这是它最主要的特征。</p>
<h3 id="Headless-Service-的定义与特点"><a href="#Headless-Service-的定义与特点" class="headerlink" title="Headless Service 的定义与特点"></a>Headless Service 的定义与特点</h3><p>当你在定义 Service 时，将 <code>clusterIP</code> 字段设置为 <code>None</code> (或者在 YAML 文件中完全不指定 <code>clusterIP</code> 字段，并确保 <code>type</code> 不是 <code>ExternalName</code> 且不是 <code>LoadBalancer</code>，对于一些早期的 Kubernetes 版本可能需要显式设置，但现在自动推断为空即可)，或者使用 <code>clusterIP: None</code>，Kubernetes 就会创建一个 Headless Service。</p>
<p><strong>核心特点：</strong></p>
<ol>
<li><strong>无 ClusterIP：</strong> 这是其名称 “Headless” 的由来。它没有一个统一的、虚拟的 Service IP。</li>
<li><strong>DNS 解析行为不同：</strong><ul>
<li><strong>常规 Service (有 ClusterIP)：</strong> 当你通过 DNS 查询一个常规 Service 时，它会返回 Service 的 ClusterIP。然后所有请求都会被代理到这个 ClusterIP。</li>
<li><strong>Headless Service：</strong> 当你通过 DNS 查询一个 Headless Service 时，Kubernetes 的 DNS 服务（CoreDNS）会直接返回<strong>所有匹配该 Service 的 Pod 的 IP 地址列表</strong>，而不是一个单一的 Service IP。<ul>
<li>如果该 Headless Service 没有 <code>selector</code>，它会直接返回 Service 定义的 <code>endpoints</code> 中的 IP 列表。</li>
</ul>
</li>
</ul>
</li>
<li><strong>无负载均衡 (通过 Kube-proxy)：</strong> 由于没有 ClusterIP，kube-proxy 不会为它进行流量代理和负载均衡。客户端需要自己处理从 DNS 返回的多个 IP 地址。</li>
<li><strong>提供 Pod 级别的可发现性：</strong> 对于需要直接连接特定 Pod 或需要客户端自己决定连接哪个 Pod 的场景非常有用。</li>
</ol>
<h3 id="Headless-Service-的应用场景"><a href="#Headless-Service-的应用场景" class="headerlink" title="Headless Service 的应用场景"></a>Headless Service 的应用场景</h3><p>Headless Service 主要用于以下几种情况：</p>
<ol>
<li><p><strong>有状态应用程序 (StatefulSets)：</strong></p>
<ul>
<li>这是 Headless Service 最常见的用途。<code>StatefulSet</code> 资源在创建 Pod 时通常需要每个 Pod 都拥有一个<strong>稳定且唯一的网络身份</strong>（稳定的主机名、稳定的存储、稳定的网络标识）。</li>
<li><code>StatefulSet</code> 通常会与一个 Headless Service 配合使用。这个 Headless Service 不仅让每个 Pod 拥有一个通过 DNS 解析的服务名称（如 <code>my-app-0.my-headless-service</code>, <code>my-app-1.my-headless-service</code>），而且客户端可以直接解析到这些 Pod 的 IP 地址。</li>
<li>这对于分布式数据库（如 Cassandra、MongoDB、Elasticsearch 集群）、消息队列（Kafka）等需要对副本进行精确控制和直接寻址的场景至关重要。</li>
</ul>
</li>
<li><p><strong>需要客户端自定义负载均衡或流量控制：</strong></p>
<ul>
<li>有些应用程序或服务网格（如 Istio、Linkerd）有自己内置的负载均衡逻辑。它们不希望 Kubernetes 的 kube-proxy 进行额外的代理。通过 Headless Service，它们可以直接获取到后端 Pod 的 IP 列表，然后根据自己的算法进行连接和负载均衡。</li>
<li>例如，gRPC 客户端通常希望进行客户端负载均衡。</li>
</ul>
</li>
<li><p><strong>需要直接操作 Pod IP 的场景：</strong></p>
<ul>
<li>某些特殊应用需要直接与 Pod IP 进行通信，而不是通过Service 的抽象 IP。Headless Service 提供了这种可能性。</li>
</ul>
</li>
</ol>
<h3 id="Headless-Service-的-DNS-解析示例"><a href="#Headless-Service-的-DNS-解析示例" class="headerlink" title="Headless Service 的 DNS 解析示例"></a>Headless Service 的 DNS 解析示例</h3><p>假设您有一个 Headless Service 叫 <code>my-app-headless</code>，它有三个 Pod 副本，IP 分别是 <code>10.42.0.10</code>、<code>10.42.0.11</code>、<code>10.42.0.12</code>。</p>
<ul>
<li><p><strong>常规查询：</strong></p>
<ul>
<li>如果你在集群内 <code>ping my-app-headless</code>，DNS 服务器会返回这三个 Pod 的 IP 地址列表。</li>
<li>如果你使用 <code>dig my-app-headless.mynamespace.svc.cluster.local</code>，你将看到返回多个 A 记录，每个记录对应一个 Pod 的 IP。</li>
</ul>
</li>
<li><p><strong>特定 Pod 查询 (通常用于 StatefulSets)：</strong></p>
<ul>
<li>如果 <code>my-app-headless</code> 是一个 StatefulSet 的 Headless Service，并且 StatefulSet 的 Pod 命名为 <code>my-app-0</code>, <code>my-app-1</code>, <code>my-app-2</code>。</li>
<li>那么你可以通过 <code>my-app-0.my-app-headless.mynamespace.svc.cluster.local</code> 来直接解析到 <code>my-app-0</code> 这个 Pod 的 IP 地址。</li>
</ul>
</li>
</ul>
<h3 id="YAML-示例"><a href="#YAML-示例" class="headerlink" title="YAML 示例"></a>YAML 示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-headless-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app-stateful</span> <span class="comment"># 匹配你的 Pod 的标签</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span>       <span class="comment"># **关键！** 将此 Service 定义为 Headless</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Headless Service 绕过了 Kubernetes 默认的 Service ClusterIP 抽象层，直接暴露了后端 Pod 的 IP 地址。它牺牲了 Service 提供的标准负载均衡能力，但换来了对单个 Pod 的精确寻址能力和更灵活的客户端负载均衡实现。这使得它成为管理有状态应用和需要更细粒度网络控制场景的理想选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/k8s%20service/">https://huiaz.github.io/2025/09/11/k8s%20service/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/k8s_10/" title="k8s_10"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">k8s_10</div></div><div class="info-2"><div class="info-item-1">请描述 Kubernetes 中的 Helm 的作用，并解释其使用场景。Of course. Helm is an indispensable tool in the Kubernetes ecosystem, and understanding its role is crucial for anyone managing applications at scale. Let’s dive into its purpose and common use cases. 🤔 分析过程：此问题旨在考察对Kubernetes应用部署和管理工具——Helm的理解。一个优秀的回答不能仅仅说“它是一个包管理器”，而需要深入解释它解决了什么核心痛点。核心痛点是：Kubernetes原生YAML文件缺乏模板化、版本控制和依赖管理能力，导致在多环境、复杂应用场景下难以管理。因此，回答的重点应围绕Helm如何通过打包（Charts）、模板化（Templating）和版本发布（Releases）来解决这些问题。 💡 答案生成：1. 概念或定义Helm 是Kubernetes的官方包管理器。它可以被...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20Service&amp;Ingress/" title="k8s Service&amp;Ingress"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">k8s Service&Ingress</div></div><div class="info-2"><div class="info-item-1">请解释 Kubernetes 中的 Service 和 Ingress 的区别，并描述各自的用途。	 🤔 分析过程：该问题旨在考察面试者对Kubernetes中两种核心网络资源——Service和Ingress的理解。核心考察点在于它们分别在哪个网络层级工作（L4 vs L7），各自解决了什么问题，以及它们如何协同工作。一个优秀的答案需要清晰地定义两者，对比其功能，并能结合实际应用场景说明何时使用哪一个。 💡 答案生成：1. 概念或定义 Service (服务): 是Kubernetes中的一个核心API对象，它定义了一组逻辑上的Pod，并为它们提供了一个单一、稳定的访问入口（一个虚拟IP地址和DNS名称）。Service主要工作在网络模型的第四层（L4 - TCP&#x2F;UDP），它关心的是如何将网络流量可靠地转发到后端的Pod，而不关心流量的具体内容。  Ingress (入口): 是一个API对象，用于管理对集群内Service的外部访问，主要工作在网络模型的第七层（L7 - HTTP&#x2F;S）。Ingress可以提供基于主机名（Host-based）和URL...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/PromQL%20%E4%BB%8B%E7%BB%8D/" title="PromQL 介绍"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">PromQL 介绍</div></div><div class="info-2"><div class="info-item-1">PromQL 介绍PromQL 是 Prometheus 监控系统内置的一种查询语言，PromQL 允许你以灵活的方式选择、聚合等其他方式转换和计算时间序列数据，该语言仅用于读取数据。可以说 PromQL 是我们学习 Prometheus 最困难也是最重要的部分，本章节我们将介绍 PromQL 的基础知识、理论基础，然后会深入了解更加高级的查询模式。 目标通过对本章节 PromQL 的学习你将能够有效地构建、分享和理解 PromQL 查询，可以帮助我们从容应对报警规则、仪表盘可视化等需求，还能够避免一些在使用 PromQL 表达式的时候遇到的一些陷进。 执行前面基础章节我们介绍了 Prometheus 整体的架构：  当 Prometheus 从系统和服务收集指标数据时，它会把数据存储在内置的时序数据库（TSDB）中，要对收集到的数据进行任何处理，我们都可以使用 PromQL 从 TSDB 中读取数据，同时可以对所选的数据执行过滤、聚合以及其他转换操作。 PromQL 的执行可以通过两种方式来触发：  在 Prometheus 服务器中，记录规则和警报规则会定期运行，并执行查询操...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20POD/" title="k8s POD"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s POD</div></div><div class="info-2"><div class="info-item-1">🤔 分析过程：该问题旨在考察对Kubernetes最基本操作的掌握程度，即如何创建一个Pod。一个完整的回答不仅要给出示例配置文件，还应该解释清楚创建Pod的两种主要方法（声明式和命令式）、各自的适用场景，以及为什么在生产环境中我们通常不直接创建“裸Pod”。这能体现出面试者是否具备实际的、规范的操作经验。 💡 答案生成：1. 概念或定义在Kubernetes中创建一个Pod，意味着你向集群下达一个指令，要求它运行一个或多个容器的实例。这个过程的核心是向API Server提交一个描述Pod期望状态的清单（Manifest），通常是一个YAML或JSON格式的文件。 2. 创建方法创建Pod主要有两种方法：  1. 声明式方法 (Declarative Method) - 强烈推荐  描述： 这是Kubernetes管理的标准和最佳实践。你首先编写一个YAML文件来“声明”你想要的Pod是什么样子的（例如，使用什么镜像、需要多少资源、开放哪个端口等）。然后，你使用kubectl apply -f &lt;filename.yaml&gt;命令将这个声明提交给集群。 工作机制：...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s%20Service&Ingress/" title="k8s Service&amp;Ingress"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s Service&amp;Ingress</div></div><div class="info-2"><div class="info-item-1">请解释 Kubernetes 中的 Service 和 Ingress 的区别，并描述各自的用途。	 🤔 分析过程：该问题旨在考察面试者对Kubernetes中两种核心网络资源——Service和Ingress的理解。核心考察点在于它们分别在哪个网络层级工作（L4 vs L7），各自解决了什么问题，以及它们如何协同工作。一个优秀的答案需要清晰地定义两者，对比其功能，并能结合实际应用场景说明何时使用哪一个。 💡 答案生成：1. 概念或定义 Service (服务): 是Kubernetes中的一个核心API对象，它定义了一组逻辑上的Pod，并为它们提供了一个单一、稳定的访问入口（一个虚拟IP地址和DNS名称）。Service主要工作在网络模型的第四层（L4 - TCP&#x2F;UDP），它关心的是如何将网络流量可靠地转发到后端的Pod，而不关心流量的具体内容。  Ingress (入口): 是一个API对象，用于管理对集群内Service的外部访问，主要工作在网络模型的第七层（L7 - HTTP&#x2F;S）。Ingress可以提供基于主机名（Host-based）和URL...</div></div></div></a><a class="pagination-related" href="/2025/09/11/k8s_10/" title="k8s_10"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">k8s_10</div></div><div class="info-2"><div class="info-item-1">请描述 Kubernetes 中的 Helm 的作用，并解释其使用场景。Of course. Helm is an indispensable tool in the Kubernetes ecosystem, and understanding its role is crucial for anyone managing applications at scale. Let’s dive into its purpose and common use cases. 🤔 分析过程：此问题旨在考察对Kubernetes应用部署和管理工具——Helm的理解。一个优秀的回答不能仅仅说“它是一个包管理器”，而需要深入解释它解决了什么核心痛点。核心痛点是：Kubernetes原生YAML文件缺乏模板化、版本控制和依赖管理能力，导致在多环境、复杂应用场景下难以管理。因此，回答的重点应围绕Helm如何通过打包（Charts）、模板化（Templating）和版本发布（Releases）来解决这些问题。 💡 答案生成：1. 概念或定义Helm 是Kubernetes的官方包管理器。它可以被...</div></div></div></a><a class="pagination-related" href="/2025/09/11/configmap/" title="configmap"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">configmap</div></div><div class="info-2"><div class="info-item-1">ConfigMap前面我们学习了一些常用的资源对象的使用，但是单纯依靠这些资源对象，还不足以满足我们的日常需求，一个重要的需求就是应用的配置管理、敏感信息的存储和使用（如：密码、Token 等）、容器运行资源的配置、安全管控、身份认证等等。 对于应用的可变配置在 Kubernetes 中是通过一个 ConfigMap 资源对象来实现的，我们知道许多应用经常会有从配置文件、命令行参数或者环境变量中读取一些配置信息的需求，这些配置信息我们肯定不会直接写死到应用程序中去的，比如你一个应用连接一个 redis 服务，下一次想更换一个了的，还得重新去修改代码，重新制作一个镜像，这肯定是不可取的，而 ConfigMap 就给我们提供了向容器中注入配置信息的能力，不仅可以用来保存单个属性，还可以用来保存整个配置文件，比如我们可以用来配置一个 redis 服务的访问地址，也可以用来保存整个 redis 的配置文件。接下来我们就来了解下 ConfigMap 这种资源对象的使用方法。 创建ConfigMap 资源对象使用 key-value 形式的键值对来配置数据，这些数据可以在 Pod 里面使用，...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/" title="数据模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">数据模型</div></div><div class="info-2"><div class="info-item-1">数据模型在开始学习 PromQL 的知识之前，我们先重新来熟悉下 Prometheus 的数据模型  时间序列Prometheus 会将所有采集到的样本数据以时间序列的方式保存在内存数据库中，并且定时保存到硬盘上。时间序列是按照时间戳和值的序列顺序存放的，我们称之为向量(vector)，每条时间序列通过指标名称(metrics name)和一组标签集(labelset)命名。如下所示，可以将时间序列理解为一个以时间为 X 轴的数字矩阵： 1234567^│   . . . . . . . . . . . . . . . . .   . .   node_cpu_seconds_total&#123;cpu=&quot;cpu0&quot;,mode=&quot;idle&quot;&#125;│     . . . . . . . . . . . . . . . . . . .   node_cpu_seconds_total&#123;cpu=&quot;cpu0&quot;,mode=&quot;system&quot;&#125;│     . . . . . . . . ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huiaz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ClusterIP-%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">1. ClusterIP (默认类型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-NodePort"><span class="toc-number">2.</span> <span class="toc-text">2. NodePort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LoadBalancer"><span class="toc-number">3.</span> <span class="toc-text">3. LoadBalancer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ExternalName"><span class="toc-number">4.</span> <span class="toc-text">4. ExternalName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">总结选择指南：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headless-Service-%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">Headless Service 的定义与特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headless-Service-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.</span> <span class="toc-text">Headless Service 的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headless-Service-%E7%9A%84-DNS-%E8%A7%A3%E6%9E%90%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.</span> <span class="toc-text">Headless Service 的 DNS 解析示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YAML-%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.</span> <span class="toc-text">YAML 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>