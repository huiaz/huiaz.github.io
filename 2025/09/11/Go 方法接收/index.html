<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Go 方法接收 | Hui's Blog</title><meta name="author" content="六一"><meta name="copyright" content="六一"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这是一个非常经典的、来自面向对象编程背景的开发人员会问的问题。我会专业而严谨地为您解答。  Go 语言中没有像 C++、Java 或 Python 那样显式的 this 或 self 指针（关键字）。Go 语言使用了一种不同的机制来达到类似的目的：方法接收者（Method Receivers）。 1. 什么是方法接收者？在 Go 中，你可以为任何类型（除了指针类型和接口类型）定义方法。方法是绑定到">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 方法接收">
<meta property="og:url" content="https://huiaz.github.io/2025/09/11/Go%20%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6/index.html">
<meta property="og:site_name" content="Hui&#39;s Blog">
<meta property="og:description" content="这是一个非常经典的、来自面向对象编程背景的开发人员会问的问题。我会专业而严谨地为您解答。  Go 语言中没有像 C++、Java 或 Python 那样显式的 this 或 self 指针（关键字）。Go 语言使用了一种不同的机制来达到类似的目的：方法接收者（Method Receivers）。 1. 什么是方法接收者？在 Go 中，你可以为任何类型（除了指针类型和接口类型）定义方法。方法是绑定到">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huiaz.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-11T12:32:34.000Z">
<meta property="article:modified_time" content="2025-09-11T14:32:27.384Z">
<meta property="article:author" content="六一">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="GO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huiaz.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go 方法接收",
  "url": "https://huiaz.github.io/2025/09/11/Go%20%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6/",
  "image": "https://huiaz.github.io/img/butterfly-icon.png",
  "datePublished": "2025-09-11T12:32:34.000Z",
  "dateModified": "2025-09-11T14:32:27.384Z",
  "author": [
    {
      "@type": "Person",
      "name": "六一",
      "url": "https://huiaz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huiaz.github.io/2025/09/11/Go%20%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go 方法接收',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hui's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Go 方法接收</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Go 方法接收</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T12:32:34.000Z" title="发表于 2025-09-11 20:32:34">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T14:32:27.384Z" title="更新于 2025-09-11 22:32:27">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go/">go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>这是一个非常经典的、来自面向对象编程背景的开发人员会问的问题。我会专业而严谨地为您解答。</p>
<hr>
<p>Go 语言中<strong>没有</strong>像 C++、Java 或 Python 那样显式的 <code>this</code> 或 <code>self</code> 指针（关键字）。Go 语言使用了一种不同的机制来达到类似的目的：<strong>方法接收者（Method Receivers）</strong>。</p>
<h3 id="1-什么是方法接收者？"><a href="#1-什么是方法接收者？" class="headerlink" title="1. 什么是方法接收者？"></a>1. 什么是方法接收者？</h3><p>在 Go 中，你可以为任何类型（除了指针类型和接口类型）定义方法。方法是绑定到特定类型上的函数。当一个函数被定义为属于某个类型时，它就在函数名前面声明一个<strong>接收者</strong>。这个接收者就像其他语言中的 <code>this</code> 或 <code>self</code>，它代表了调用该方法的具体实例。</p>
<p><strong>结构：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiverName ReceiverType)</span></span> MethodName(parameters) (returns) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>receiverName</code>: 一个标识符，用于在方法体内部引用接收者实例。你可以给它起任何名字，但习惯上会用类型名称的第一个字母或几个字母（例如，<code>p</code> for <code>Person</code>，<code>s</code> for <code>StructName</code>）。</li>
<li><code>ReceiverType</code>: 可以是值类型（<code>T</code>）或指针类型（<code>*T</code>）。这非常重要，因为这决定了方法如何访问和修改接收者。</li>
</ul>
<h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><p>让我们通过一个 <code>Person</code> 结构体来演示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 结构体定义</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello 是一个值接收者方法</span></span><br><span class="line"><span class="comment">// 它接收 Person 类型的一个副本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> SayHello() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hello, my name is %s and I am %d years old.\n&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GrowUp 是一个指针接收者方法</span></span><br><span class="line"><span class="comment">// 它接收 Person 类型的指针，因此可以直接修改原始的 Person 实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> GrowUp() &#123;</span><br><span class="line">	p.Age++ <span class="comment">// 直接修改 p 的 Age 字段</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s just grew up! Now %d years old.\n&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChangeName 是一个值接收者方法</span></span><br><span class="line"><span class="comment">// 它接收 Person 类型的一个副本，所以对副本的修改不影响原实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> ChangeName(newName <span class="type">string</span>) &#123;</span><br><span class="line">	p.Name = newName</span><br><span class="line">	fmt.Printf(<span class="string">&quot;[Inside ChangeName VALUE RECEIVER] My name is now %s.\n&quot;</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReallyChangeName 是一个指针接收者方法</span></span><br><span class="line"><span class="comment">// 它可以修改原始实例的名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> ReallyChangeName(newName <span class="type">string</span>) &#123;</span><br><span class="line">	p.Name = newName</span><br><span class="line">	fmt.Printf(<span class="string">&quot;[Inside ReallyChangeName POINTER RECEIVER] My name is now %s.\n&quot;</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个 Person 实例</span></span><br><span class="line">	person1 := Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">30</span>&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用值接收者方法：SayHello</span></span><br><span class="line">	person1.SayHello() <span class="comment">// Output: Hello, my name is Alice and I am 30 years old.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用值接收者方法：ChangeName</span></span><br><span class="line">	<span class="comment">// 注意：虽然方法内部修改了 p.Name，但由于是值接收者，原始的 person1 实例并未改变</span></span><br><span class="line">	person1.ChangeName(<span class="string">&quot;Alicia&quot;</span>) </span><br><span class="line">	fmt.Printf(<span class="string">&quot;After ChangeName (Value Receiver): %s\n&quot;</span>, person1.Name) <span class="comment">// Still Alice</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;---&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用指针接收者方法：GrowUp</span></span><br><span class="line">	<span class="comment">// 这会修改 person1 的 Age 字段</span></span><br><span class="line">	person1.GrowUp() <span class="comment">// Output: Alice just grew up! Now 31 years old.</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;After GrowUp (Pointer Receiver): %s is now %d years old.\n&quot;</span>, person1.Name, person1.Age) <span class="comment">// Alice is now 31 years old.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用指针接收者方法：ReallyChangeName</span></span><br><span class="line">	<span class="comment">// 这会修改 person1 的 Name 字段</span></span><br><span class="line">	person1.ReallyChangeName(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;After ReallyChangeName (Pointer Receiver): %s\n&quot;</span>, person1.Name) <span class="comment">// Bob</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;---&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同样可以通过指针调用方法，Go 会自动解引用</span></span><br><span class="line">	personPtr := &amp;Person&#123;Name: <span class="string">&quot;Charlie&quot;</span>, Age: <span class="number">25</span>&#125;</span><br><span class="line">	personPtr.SayHello() <span class="comment">// Output: Hello, my name is Charlie and I am 25 years old.</span></span><br><span class="line">	<span class="comment">// 尽管 SayHello 是值接收者，但 Go 编译器会自动将 personPtr 解引用为值后，再传递拷贝。</span></span><br><span class="line"></span><br><span class="line">	personPtr.GrowUp() <span class="comment">// Output: Charlie just grew up! Now 26 years old.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-值接收者-vs-指针接收者：核心区别和使用场景"><a href="#3-值接收者-vs-指针接收者：核心区别和使用场景" class="headerlink" title="3. 值接收者 vs. 指针接收者：核心区别和使用场景"></a>3. 值接收者 vs. 指针接收者：核心区别和使用场景</h3><p>这是理解 Go 方法的关键。</p>
<p><strong>a. 值接收者 (<code>(p Person)</code>)</strong></p>
<ul>
<li><strong>特性：</strong> 方法会接收到接收者类型的一个<strong>副本（copy）</strong>。</li>
<li><strong>修改行为：</strong> 在方法内部对接收者字段的任何修改都只会影响这个副本，而不会影响到原始的调用者变量。</li>
<li><strong>何时使用：</strong><ul>
<li>方法不需要修改接收者的数据（只读操作）。</li>
<li>接收者是一个小型的、简单的结构，或者是一个基本类型（如 <code>int</code>, <code>string</code>）。</li>
<li>希望确保方法不能意外地修改原始值。</li>
<li>例如：<code>String()</code>, <code>Error()</code>, <code>Len()</code>, <code>Cap()</code> 等方法通常使用值接收者。</li>
</ul>
</li>
</ul>
<p><strong>b. 指针接收者 (<code>(p *Person)</code>)</strong></p>
<ul>
<li><strong>特性：</strong> 方法会接收到接收者类型的一个<strong>指针</strong>。</li>
<li><strong>修改行为：</strong> 通过指针可以直接访问和修改原始的调用者变量的底层数据。</li>
<li><strong>何时使用：</strong><ul>
<li>方法需要修改接收者的数据。</li>
<li>接收者是一个大型的结构体，避免值拷贝的性能开销。</li>
<li>方法需要实现某个接口，而该接口定义的方法签名要求指针接收者（尽管Go的编译器有时会为值类型自动生成指针方法的实现，但保持一致性是好的）。</li>
<li>当该类型的方法集需要包含指针方法时（例如，当结构体包含 <code>sync.Mutex</code> 等并发原语时，通常需要指针接收者）。</li>
<li><strong>惯例：</strong> 绝大多数情况下，为结构体定义的方法都倾向于使用指针接收者，因为它更灵活（可以修改状态）且避免了大对象的值拷贝开销。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>尽管 Go 语言没有 <code>this</code> 或 <code>self</code> 这样的显式关键字，但其<strong>方法接收者</strong>机制提供了相同的功能。通过选择<strong>值接收者</strong>或<strong>指针接收者</strong>，开发者可以精确控制方法对调用者实例的作用方式，这既保证了灵活性，也提供了对数据修改的清晰控制。在后端开发中，正确选择接收者类型是编写高效、可维护和无 bug 的 Go 代码的关键。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huiaz.github.io">六一</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huiaz.github.io/2025/09/11/Go%20%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6/">https://huiaz.github.io/2025/09/11/Go%20%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huiaz.github.io" target="_blank">Hui's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/GO/">GO</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/Go%20%E7%BC%BA%E7%9C%81%E5%80%BC/" title="Go 缺省值"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Go 缺省值</div></div><div class="info-2"><div class="info-item-1">您好！这个问题非常棒，它触及了 Go 语言设计哲学的一个核心要素——**零值 (Zero Value)**。 在 Go 语言中，无论是局部变量（Local Variables）还是全局变量（Package-level Variables），当它们被声明但没有显式地被赋予初始值时，它们都会被自动初始化为它们类型对应的零值。这与 C&#x2F;C++ 等语言不同，在那些语言中，局部变量如果不初始化可能会包含“垃圾”值。Go 语法的这一特性极大地提高了代码的健壮性和可预测性，避免了许多常见的因未初始化变量导致的 Bug。  Go 语言的零值是什么？“零值”是 Go 语言中每种类型预定义的默认值。 以下是常见数据类型的零值：  数值类型：整数（int, int8, int16, int32, int64, uint, byte 等）和浮点数（float32, float64）的零值都是 **0**。  例如：0, 0.0, (0+0i) (复数)   布尔类型 (bool)：零值是 **false**。  字符串类型 (string)：零值是**空字符串 &quot;&quot;**。 ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Go%20%E7%A9%BA%E5%88%87%E7%89%87%E4%B8%8E%20nil%20%E5%88%87%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Go 空切片与 nil 切片的区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Go 空切片与 nil 切片的区别</div></div><div class="info-2"><div class="info-item-1">核心区别：nil 切片的底层指针是 nil，而空切片的底层指针是一个有效的、指向 0 字节内存区域的地址。 虽然它们在很多操作上表现一致（如 len、cap、for range、append），但这个根本性的指针差异导致了他们在内存表示、JSON 序列化和语义表达上的关键不同。 让我们深入剖析。  1. 结构与定义要理解它们的区别，首先要看切片在 Go 底层的结构 SliceHeader： 12345type SliceHeader struct &#123;    Data uintptr // 指向底层数组的指针    Len  int     // 切片的长度    Cap  int     // 切片的容量&#125; nil 切片和空切片的区别就体现在这个 Data 指针上。 Nil 切片 (Nil Slice)一个 nil 切片是切片类型的零值。它的指针 Data 为 nil，并且 Len 和 Cap 都是 0。  声明方式：仅声明变量而不进行初始化。 12var s []int // 此时 s 就是一个 nil 切片  内部状态： 1234s (SliceHeade...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/" title="访问控制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">访问控制</div></div><div class="info-2"><div class="info-item-1">好的，作为一名运维工程师，我来详细描述在 Nginx 中如何配置访问控制，并提供具体的配置示例。 访问控制是保障 Web 应用安全的重要一环，Nginx 提供了多种灵活的方式来实现对资源的访问限制，包括基于 IP 地址的访问控制、基于用户认证的访问控制以及结合两者使用。 Nginx 访问控制的类型Nginx 主要通过以下两种方式进行访问控制：  基于 IP 地址的访问控制 (Allow&#x2F;Deny)： 根据客户端的 IP 地址判断是否允许访问。 基于用户认证的访问控制 (HTTP Basic Authentication)： 要求用户输入用户名和密码才能访问受保护的资源。  还有一些高级的访问控制，例如基于 JWT 验证（需要 Lua 模块或其他定制开发），或者与第三方认证服务集成，但最常用和基础的就是上述两种。  1. 基于 IP 地址的访问控制 (Allow&#x2F;Deny)这是最直接的访问控制方式，适用于限制特定 IP 地址或 IP 段的访问。 指令：  allow address | CIDR | all;：允许指定的 IP 地址、IP 段或所有 IP 访问。...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Go%20%E8%AF%AD%E8%A8%80%20tag/" title="Go 语言 tag"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Go 语言 tag</div></div><div class="info-2"><div class="info-item-1">结构体标签（Struct Tag）是附加在结构体字段上的、一段可选的元数据（Metadata）字符串。  一、核心原则：为“反射”而生要理解 Tag 的用处，必须先明白一个核心原则： Go 编译器本身会忽略 Tag，它对程序的编译和运行没有任何直接影响。 它的真正威力在于，它为其他程序（尤其是标准库和第三方库）提供了一种在运行时通过反射（Reflection）机制来读取和解析结构体元信息的方式。通过反射，程序可以在运行时检查一个变量的类型、结构和字段，并读取附加在字段上的 Tag。 二、基本语法Tag 是一个写在反引号 ` 之间的字符串，紧跟在字段类型之后。 123type User struct &#123;    FieldName string `key1:&quot;value1&quot; key2:&quot;value2,option&quot;`&#125;   反引号 `: 用于定义原始字符串字面量，允许在字符串中包含特殊字符而无需转义。 key:&quot;value&quot; 格式: Tag 内部通常由一个或多个键值对组成。 空格分隔: 不同的键值对之间用...</div></div></div></a><a class="pagination-related" href="/2025/09/11/RBAC/" title="RBAC"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">RBAC</div></div><div class="info-2"><div class="info-item-1">RBAC 权限控制前面我们已经学习一些常用的资源对象的使用，我们知道对于资源对象的操作都是通过 APIServer 进行的，那么集群是怎样知道我们的请求就是合法的请求呢？这个就需要了解 Kubernetes 中另外一个非常重要的知识点了：RBAC（基于角色的权限控制）。 管理员可以通过 Kubernetes API 动态配置策略来启用RBAC，需要在 kube-apiserver 中添加参数--authorization-mode=RBAC，如果使用的 kubeadm 安装的集群那么是默认开启了 RBAC 的，可以通过查看 Master 节点上 apiserver 的静态 Pod 定义文件： 1234➜  ~ cat /etc/kubernetes/manifests/kube-apiserver.yaml...    - --authorization-mode=Node,RBAC...    如果是二进制的方式搭建的集群，添加这个参数过后，记得要重启 kube-apiserver 服务。 API 对象在学习 RBAC 之前，我们还需要再去理解下 Kubernetes 集群中的...</div></div></div></a><a class="pagination-related" href="/2025/09/11/RocketMQ%20%E4%B8%AD%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="RocketMQ 中关于事务消息的实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">RocketMQ 中关于事务消息的实现</div></div><div class="info-2"><div class="info-item-1">您好！分布式事务是后端系统中非常关键的环节，而 RocketMQ 在这方面提供了强大的事务消息（Transaction Message）机制，旨在解决分布式系统中的数据最终一致性问题。它的实现基于经典的两阶段提交（Two-Phase Commit, 2PC）思想，但对其进行了优化，使其更适合异步消息场景。 我将从以下几个方面专业且逻辑清晰地阐述 RocketMQ 事务消息的实现：  一、 核心思想：两阶段提交（2PC）的优化与异步化RocketMQ 的事务消息旨在确保生产者发送消息和执行本地事务的原子性。它将传统的同步两阶段提交分解为异步的“半消息”和“消息确认&#x2F;回滚”两个阶段，并通过事务消息回查机制来处理异常情况。 其核心流程可以概括为：  第一阶段（准备阶段）：发送半消息 (Half Message)生产者将消息发送到 Broker，但此时消息是“半态”或“预处理”状态，对消费者是不可见的。 第二阶段（执行&#x2F;提交阶段）：执行本地事务并确认生产者执行自己的本地事务。根据本地事务的执行结果（成功或失败），向 Broker 发送 Commit（提交）或 Roll...</div></div></div></a><a class="pagination-related" href="/2025/09/11/jenkins-k8s/" title="jenkins-k8s"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">jenkins-k8s</div></div><div class="info-2"><div class="info-item-1">Jenkins 与 Kubernetes 集成的核心价值 弹性伸缩的构建环境： Jenkins 可以根据构建需求动态创建 Kubernetes Pod 作为 Jenkins Agent，构建完成后自动销毁，节省资源。 构建环境隔离与一致性： 每个构建都在独立的、预定义的 Pod 中运行，确保环境的纯净和一致性，避免“污染”和冲突。 资源利用率最大化： Kubernetes 负责调度 Agent Pod 到可用节点，优化集群资源利用。 云原生部署： 将应用程序打包成 Docker 镜像后，通过 Jenkins Pipeline 直接部署到 Kubernetes 集群。 自动化且可靠的部署： 利用 Kubernetes 的原生部署（Deployment）、服务发现（Service）、配置管理（ConfigMap&#x2F;Secret）等能力，实现声明式、不可变的基础设施部署。 可观测性与回滚： 结合 Kubernetes 的滚动更新和回滚机制，Jenkins Pipeline 可以轻松实现零停机部署和快速回滚。  Jenkins 与 Kubernetes 集成方式Jenkins 与...</div></div></div></a><a class="pagination-related" href="/2025/09/11/Go%20%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%88%87%E7%89%87%E8%BD%AC%E5%AD%97%E8%8A%82%E5%88%87%E7%89%87%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AD%97%E8%8A%82%E5%88%87%E7%89%87%E8%BD%AC%E5%9B%9E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%88%87%E7%89%87/" title="Go 定义类型切片转字节切片，以及字节切片转回自定义类型切片"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">Go 定义类型切片转字节切片，以及字节切片转回自定义类型切片</div></div><div class="info-2"><div class="info-item-1">Go 语言中，如何自定义类型切片转字节切片，以及字节切片转回自定义类型切片？ 这是一个非常贴近后端实际应用的工程问题，涉及到性能、安全性和数据可移植性等多个方面。将自定义类型切片与字节切片进行相互转换，通常有两种截然不同的路径：  不安全但极高性能的方式：通过 unsafe 包直接进行内存层面的指针转换。 安全且通用的方式：通过序列化库（如 encoding/gob、encoding/json）进行编码和解码。  作为专家，我将为您详细解析这两种方法，并给出明确的适用场景和建议。  场景设定我们先定义一个自定义类型 Point，并以此为例。 12345678910111213141516package mainimport (	&quot;bytes&quot;	&quot;encoding/gob&quot;	&quot;fmt&quot;	&quot;reflect&quot;	&quot;unsafe&quot;)// 自定义类型，注意：为了让 unsafe 方法能够工作，// 结构体内部不能包含任何引用类型（如 string, slice, map, pointer）。t...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">六一</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6%E8%80%85%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. 什么是方法接收者？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">2. 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85-vs-%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.</span> <span class="toc-text">3. 值接收者 vs. 指针接收者：核心区别和使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/27/hexo-beautify/" title="Hexo 博客美化笔记：从零搭建高颜值技术博客">Hexo 博客美化笔记：从零搭建高颜值技术博客</a><time datetime="2026-02-27T04:00:00.000Z" title="发表于 2026-02-27 12:00:00">2026-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Jenkens-Blue%20Ocean%20%E6%8F%92%E4%BB%B6/" title="Jenkins Blue Ocean">Jenkins Blue Ocean</a><time datetime="2025-09-11T12:42:57.000Z" title="发表于 2025-09-11 20:42:57">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/jenkins-jenkinsfile/" title="Jenkins Jenkinsfile">Jenkins Jenkinsfile</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-trap/" title="Linux-trap">Linux-trap</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/shell-%E6%95%B0%E7%BB%84/" title="Shell-数组">Shell-数组</a><time datetime="2025-09-11T12:40:44.000Z" title="发表于 2025-09-11 20:40:44">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 六一</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>